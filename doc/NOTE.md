
# 《编译原理》《Principles of Compiler Design》(龙书)笔记

主要包括词法分析、语法分析、语法制导分析、类型检查、运行环境、中间代码生成、代码生成、代码优化等

## 第一章：编译简介

编译器的编写涉及到程序设计语言，计算机体系结构、语言理论、算法和软件工程等学科。

编译器是一个程序，读入某种语言(**源语言**)编写的程序并将其翻译成一个与之等价的另一种语言(**目标语言**)编写的程序。作为这个翻译过程的一个重要部分，编译器能够将用于报告被编译的源程序中出现的错误。

不同的语言需要不同的编译器。根据编译器的构造方法或者要实现的功能，编译器被分为**一遍编译器**、**多遍编译器**、**装入并执行编译器**、**调试编译器**、**优化编译器**等多种类别。实际上，任何编译器所要完成的基本任务都是相同的。通过理解这些任务，可以利用同样的基本技术为各种各样的源语言和目标机器构建编译器。

编译器的早期工作主要集中在如何把算术表达式翻译成机器代码。

编译的组成：

* **分析**-分析部分将源程序切分成一些基本块并形成源程序的中间表示
* **综合**-综合部分把源程序的中间表示转换为所需的目标程序

在分析期间，源程序所蕴含的操作将被确定下来并被表示成一个称为**语法树**的分层结构。语法树的每个节点表示一个操作，该节点的子节点表示这个操作的参数。

首先完成某种类型分析的软件工具

* **结构编辑器**-结构编辑器将一个命令序列作为输入来构造一个源程序。如可以检查输入的格式是否正确，自动地提供关键字，自动匹配括号
* **智能打印机**-智能打印机能够对程序进行分析，打印出结构清晰的程序。
* **静态检查器**-读入一个程序并分析，不运行的情况下发现程序的潜在错误。如可以检查出源程序永远不能被执行的语句，也可以查出变量在被定义前被引用。
* **解释器**-解释器不是通过翻译来产生目标程序，而是直接执行源程序中蕴含的操作。

当然编译器不一定用于编译程序到汇编，还可以用于:

* **文本格式器**-文本格式器输入是一个字符流。输入字符流中的多数字符串是需要排版输出的字符串
* **硅编译器**-输入是一个源程序，输出是一个以适当语言书写的电路设计
* **查询解释器**-查询解释器把含有关系和布尔运算的谓词翻译成数据库命令，在数据库中查询满足该谓词的记录。

### 编译器的前驱和后继

源程序->预处理器->编译器->目标汇编程序->汇编器->可重定位机器代码->装载器->绝对机器代码

预处理器可以将存储在不同文件中的程序模块哦集成为一个完整的源程序，也能够把源程序中称为宏的缩写语句展开为原始语句加入到源程序中。

**源程序的分析过程**

* **线性分析**-从左到右地读构成源程序的字符流，而且把字符流分组为多个**记号(token)**,而记号是具有整体含义的字符序列
* **层次分析**-在层次分析中，字符串或记号在层次上划分为具有一定层次的多个嵌套组，每个嵌套组具有整体的含义
* **语义分析**-进行某些检查，以确保程序各个组成部分确实是有意义的组合在一起的。

1. 词法分析：在编译器中，线性分析被称为词法分析或者扫描。

例如，在词法分析中，一下赋值语句的字符串将被分组为以下记号token组

```
position := initial + rate * 60
```
 
* 标识符 `position`
* 赋值符号 `:=`
* 标识符 `initial` 
* 加号 `+`
* 标识符 `rate`
* 乘号 `*`
* 数字 `60`

2. 语法分析：层次分析被称为**语法分析(parsing或者syntax analysis)**,他把源程序的记号进一步分组，产生被编译器用于生成代码的语法短语。通常，源程序的语法短语用分析树来表示。比如

```
position := initial + rate * 60
```

可以被表达为如下**分析树**

```json
{
"赋值语句 := " : {
    "left" : "标识符 position", 
    "right" : {
        "表达式 + " : {
            "left" : "表达式-标识符 initial",
            "right" : {
                "表达式 * " : {
                    "left" : "表达式-标识符 rate", 
                    "right" : "表达式-数字 60"
                }
            }
        }
    }
}
}
```

程序的层次结构通常是通过**递归规则**来表达的，可能把下述规则作为**表达式定义**的一部分：

* 任何一个标识符(identifier)都是表达式
* 任何一个数(number)都是表达式
* 如果ex1和ex2都是表达式,那么ex1 + ex2; ex1 * ex2; (ex1)也是表达式

类似地，许多序言用下列规则来递归得定义**语句**:

* 如果id1是标识符，ex1是表达式,那么id1 := ex1 是一个语句
* 如果ex1是表达式，state1是一个语句，则下述代码也是语句
```
while (ex1) do state1
if (ex1) then state1
```

*注意：词法分析和语法分析的界限在某种程度上是不确定的。决定词法分析和语法分析的界限的因素是源语言是否具有递归结构，词法结构不要递归，而语法结构常常需要递归*

上下文无关法是递归规则的一种形式化，可以用来指导语法分析

例如:在识别源语言的标识符(由字母开头的字母和数字串)时，不需要递归，只需要简单扫描输入流就可以完成标识符的识别。一般地，直到遇见一个既不是字母也不是数字的字符为止，在这之前扫描到的数字和字母归结为一个**标识符记号(identifier)**,被分组的字符存储到**符号表中**

另一方面，这种线性扫描不具有分析源语言的表达式或语句的能力。

**语法树**是**分析树**的一种压缩表示

```json
{
":=" : {
    "left" : "position", 
    "right" : {
        "+" : {
            "left" : "initial",
            "right" : {
                "*" : {
                    "left" : "rate", 
                    "right" : "toreal 60"
                }
            }
        }
    }
}
}
```

3. 语义分析

语义分析阶段检测源程序的语义错误，并收集代码生成阶段要用到的类型信息。语义分析利用语法分析阶段确定的层次结构来识别表达式和语句中的操作符和操作数

语义分析的一个重要组成部分是类型检查。类型检查负责检验每个操作符的操作数是否满足源语言的说明。例如：很多程序设计语言都要求每当一个实数用于数组的索引时都要报错。程序设计语言可能允许一些操作数的强制类型转换。例如：一个二元算术操作符的操作数可以是一个整数和一个实数。这种情况下，编译器把整数强制转换成实数

4. 文本格式器中的分析

将文本格式器的输入看成是由多个盒子构成的层次结构的说明是有益的。一个盒子是一个用某种位模式填充的矩形区域，填充的位模式表明该区域被输出设备打印成浅黑像素还是黑像素

### 编译器的各阶段

编译器是分阶段执行的，除了部分编译过程，还包括**符号表管理器**和**错误处理器**

符号表是一种数据结构，每个标识符在符号表中都有一条记录，这种数据结构允许我们快速地找到每个标识符的记录

编译的每个阶段都可能遇到错误。在编译过程中遇到错误后，必须以恰当的方式进行错误处理，使编译器能继续运行，以检测出源程序中的更多错误。发现错误即停止运行的编译器不是一个好的编译器。

**语法分析**和**语义分析**阶段通常能够处理编译器所能检测到的大部分错误。词法分析阶段能够检测出输入中不能形成源语言任何记号的错误字符串。语法分析阶段可以确定记号流中违反源语言结构（语法）规则的错误。语义分析阶段试图检测出具有正确的语法结构但对操作无意义的部分。

**源程序->词法分析器->语法分析器->语义分析器->中间代码生成器->代码优化器->代码生成器**

中间代码可以看成某种抽象机的程序。源程序的中间表示应该具有两个重要性质。一是易于产生，而是易于翻译成目标程序。

比如用**三地址码**表示，类似于某种机器的汇编语言，这种机器的每个存储单元的作用类似于寄存器。三地址码由指令序列组成，每个指令最多有三个操作数。

不同编译器产生的代码的优化程度差别很大。

编译的最后一个阶段是目标代码生成，生成可重定位的机器代码或者汇编代码。这一阶段的一个关键问题是变量的寄存器分配。

### 编译器的伙伴：预处理器

预处理产生编译器的输入，一般具有以下功能

* 宏处理：预处理器允许用户在源程序中定义宏。宏是被经常使用的较长结构的缩写。
* 文件包含：预编译器可以把头文件包含到程序正文中。例如：C语言的预处理器能够用`<global.h>`文件的内容替代源程序中的语句 `#include <global.h>`
* \"理性\"预处理器：这些处理器能把现代控制流和数据结构化机制添加到比较老式的语言中。
* 语言扩充：通过大量的内部宏定义来增强语言的能力

有些编译器能够完成汇编器的工作，产生可重定位的机器代码，交给装配器(loader)或者连接编辑器(link-editor)处理。

*汇编代码*：机器代码的容易记忆的形式。汇编代码使用名称而不是二进制代码来表示操作

汇编语言也使用宏工具，汇编语言的宏工具与前面讨论过的那些宏预处理器类似。

**两遍汇编**-最简单的汇编器对输入汇编源程序文件进行两遍扫描，每遍读入文件一次。第一遍扫描中，表示存储单元的所有标识符都被识别出来并存入符号表。在第二遍扫描中，汇编器再一次从头扫描输入文件。这一次将每个操作符翻译成机器语言中代表相应操作的二进制位序列，将代表存储单元的每个标识符翻译成符号表中该标识符的地址。

第二遍扫描的输出是可重定位的机器代码。

汇编器把汇编指令翻译成的机器代码。

装配器完成程序的装入和连接编辑两项功能。

### 编译器各阶段的分组

编译的多个阶段可以分为**前端**和**后端**两个大的阶段。前端包括依赖源语言并在很大程度上独立于目标机器的某些阶段或者某些阶段的某些部分。前端一般包括词法分析、语法分析、符号表的建立、语义分析、中间代码生成以及相关的错误处理。相当一部分代码优化工作也在前端完成。

后端包括编译器中依赖于目标机器的阶段或某些阶段的某些部分。一般来说，后端完成的任务不依赖于源语言而只依赖于中间语言。后端主要包括代码优化、代码生成以及相关的错误处理和符号表的操作。

为不同的机器编写相同源语言的编译器时，通常采用如下方法：首先为所有的机器编写相同的编译器前端或者已有的编译器前端，然后为每个机器编写编译器的后端。

还可以将不同的源语言编译成同一种中间语言，对不同的前端使用相同的后端，从而得到同一机器上的不同编译器。

**编译器的遍**

编译器的若干个阶段通常是以一遍来实现的，每遍读一次输入文件、产生一个输出文件。编译器的阶段组合为遍的方式千差万别，因此我们趋向于按阶段而不是按遍来讨论编译器。

例如词法分析、语法分析、语义分析以及中间代码生成可以被组合为一遍。这样，词法分析形成的记号流可以被直接翻译成中间代码。语法分析器根据读到的记号token识别语法结构，当需要下一个记号时，通过调用词法分析器获得所需的记号。一旦语法结构找出来了，语法分析器就调用中间代码生成器完成语义分析并生成中间代码的一部分。

**减少编译的遍数**

如果编译的遍数越少，读写中间文件的时间开销就小。但是如果将多个阶段组合为一遍，就不得不将这个程序保存在内存中，但是这样消耗的空间就急剧提高。

一般词法分析器和语法分析器之间的接口通常被限制于**单个记号token**

所以在某些情况下，可以为某些尚不知晓的信息留下空白位置，待获得这些信息后再填上这些空白位置。通过**回填**技术，把中间代码和目标代码划归到一遍中。

#### 编译器的构造工具

编译器的编写者使用*调试器*、*版本管理器*、*描述器(profiler)*等软件工具是十分有益的。

当第一批编译器被编写出来不久，用于辅助编译器编写过程的系统就出现了。这些系统常被称为编译器的编译器、编译器生成器或者翻译器编写系统。

所有语言的词法分析器除了对特殊的关键字和符号识别以外基本上都是一样的。

* 分析器生成器：这类工具生成的语法分析器一般都以上下文无关文法为基础
* 扫描器生成器：这类工具一般都根据正规表达式为基础的说明自动生成词法分析器
* 语法制导翻译引擎：产生一系列的翻译程序
* 自动代码生成器：这类工具以一个规则集合为输入。
* 数据流引擎：完成高质量代码优化所需要的很多信息都包含*数据流分析*

## 第二章：简单的一遍编译器

这章是词法分析、语法分析、语法制导翻译、类型检查、运行时环境、中间代码生成章节的内容简介。重点是编译器的前端部分：词法分析、语法分析和中间代码生成。

程序设计语言描述的两方面定义：程序模式(语言的语法)、程序含义(语言的语义)

表示法：**上下文无关**文或者BNF(Backus-Naur范式)。使用现有的表示法描述语言的语义要比描述语言的语法难的多。因此，在定义语言的语义时，使用非形式化方法和启发性实例。

**上下文无关**除了可以用于定义语言的语法之外，还可用于指导源程序的翻译。面向语法的编译技术，如**语法制导翻译技术**，对于组织编译器的前端十分有用

在语法制导翻译技术中，将构造一个把**中缀表达式**转换成**后缀表达式**的编译器

例如中缀表达式`9+5-2`的后缀表达形式为`95-2+`，可以使用一个堆栈把后缀表达式直接转换成计算该表达式的计算机代码

字符流->词法分析器->记号流->语法制导翻译器->中间表示

词法分析将每个输入字符变成一个个包含数字、标识符、关键字等复杂的词法结构

语法制导翻译器有一个语法分析器和一个中间代码生成器构成

### 语法定义

一个语法非常自然地描述了许多程序设计语言结构的层次结构。例如C语言中的if-else语句具有如下形式:

```
if (表达式) 语句 else 语句
```

整个语句是由一个关键字if、一个左括号、一个表达式、一个右括号、一条语句、关键字else和另外一条语句组成的序列。如果使用变量`expr`来标识表达式，使用变量`stmt`来标识一条语句

```
stmt -> if (expr) stmt else stmt
```

这里，箭头可以读作“可以具有形式”。这样的规则称为**产生式(production)**。在一个产生式中，像关键字if和括号这样的词法元素称为**记号(token)**,像expr和stmt这样的变量表示一个记号序列，并称之为**非终结符(nonterminal)**

**上下文无关文法**包含如下四个部分:
* 一个记号集合，称为终结符号
* 一个非终结符集合
* 一个产生式集合：每个产生式具有一个左部和右部，左部和右部由箭头连接，左部是一个非终结符，右部是记号和(或)非终结符序列
* 一个开始符号。开始符号是一个指定的非终结符

约定，定义语法时只需列出文法的产生式，并把以开始符号为左部的产生式列在最前面。数字、类似于<=的符号、类似于**while**的黑体关键字均为终结符，斜体名字表示非终结符，任何非斜体的名字或者符号都是**记号token**。为了表示上的方便，常把具有相同左部的产生式合并，写成一个产生式，其左部为所有产生式共有的那个非终结符，右部为所有产生式右部的组合，每个右部用'|'分隔，'|'读作'或'

对于表达式`9-5+2`,下面的文法描述了这些表达式的语法,产生式为：

```
list -> list + digit
list -> list - digit
list -> digit
digit -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```

左部的非终结符皆为*list*(列表)的按个产生式的右部可以合并为:

```
list -> list + digit | list - digit | digit
```

文法的记号是下列符号

```
+ - 0 1 2 3 4 5 6 7 8 9
```

斜体词*list*和*digit*是非终结符，*list*是开始非终结符，因为它所对应的产生式列在最前面。

如果一个非终结符出现在一个产生式的左部，该产生式称为该非终结符的产生式。记号串是零个或多个记号的序列。一个包含零个记号的记号串称为空串，记为**e**

从开始符号出发，反复代替产生式中的非终结符(用该非终结符的产生式的右部)，一个文法可产生一个串。由一个文法的开始符号产生的记号串形成了该文法定义的语言。

例子：Pascal语言的begin-end语句块(block)是由分号分隔的语句序列。begin-end语句块的文法结构与上述列表的差别仅在于**begin**和**end**之间允许有空语句。
begin-end语句块的文法:

```
block begin opt_stmt end

opt_stmt -> stmt_list | e
stmt_list -> stmt_list ; stmt | stmt
```

### 分析树

分析树描绘了如何从文法的开始符号开始推导出它的语言中的一个语句。如果非终结符A具有一个产生式A->XYZ,则A的一棵分析树如右图所示，内节点标记为A，A的三个子节点从左到右分别标记为X,Y和Z。

形式地说，给定一个上下文无关文法，分析树是具有如下特性的树：

1. 树根标记为开始符号
2. 每个叶节点由**记号token**或者**空串e**标记
3. 每个内节点由一个非终结符标记
4. 如果A是某个内节点的非终结符号标记，X1,X2,...,Xn是该节点从左到右排列的所有子节点的标记，则A->X1X2...Xn是一个产生式。这里，X1,X2,...,Xn是一个终结符或非终结符。对于A->e,分析树中标记为A的节点只有一个标记为e的子节点

```json
{
    "node" : "A", 
    "childrens" : [
        "X", 
        "Y",
        "Z"
    ]
}
```

一棵分析树从左到右的叶节点是这棵分析树生成的结果。分析树生成的结果是由根节点的非终结符生成或导出的串。

任何树的叶节点都满足从左到右都满足从左到右排列的自然顺序，即如果a和b具有相同的父节点，且a在b的左部，则a和a的所有后代都在b和b的所有后代的左部。

一个文法生成的语言是它的某个分析树生成的串的集合。为给定的记号串找到一个分析树的过程称为这个串的**语法分析(parsing)**

### 二义性

一棵分析树读完它的叶节点只能生成唯一的一个串，但是一个文法可能有多棵分析树生成相同的记号串。这样的文法称为具有*二义性*的文法。

判断一个文法是否具有二义性，只需检查是否存在一个具有多棵分析树的记号串。在构造程序设计语言及其编译器时，需要设计无二义性文法，或者使用增加了额外的规则解决二义性问题的二义性文法。

### 操作符operator的结合规则

在大多数的程序设计语言中，加、减、乘、除四种算术操作符都是左结合的。

某些常用操作符是右结合的，如指数操作。C语言中的赋值运算操作符‘=’号也是右结合的。

例如，在C语言中，表达式`a=b=c`等价于`a=(b=c)`

由右结合的操作符构成的串，如a=b=c,可以由如下文法产生:

```
right -> letter = right | letter
```

下述两个树给出了左结合操作符‘-’和右结合操作符‘=’的分析树的比较。可以看到‘-’分析树向左下端延伸，‘=’分析树向右下端延伸

```json
{
    "node" : "list",
    "child" : [
        {
            "node" : "list", 
            "child" : [
                {
                    "node" : "list",
                    "child" : [
                        {
                            "node" : "digit",
                            "child" : [
                                {
                                    "node" : "9",
                                    "child" : "null"
                                }
                            ]
                        }
                    ]
                },
                {
                    "node" : "-",
                    "child" : "null"
                },
                {
                    "node" : "digit",
                    "child" : "null"
                }
            ]
        },
        {
            "node" : "-",
            "child" : "null"
        },
        {
            "node" : "digit",
            "child" : [
                {
                    "node" : "2",
                    "child" : "null"
                }
            ]
        }
    ]
}
```

```json
{
    "node" : "-",
    "child" : [
        {
            "node" : "letter",
            "child" : [
                {
                    "node" : "a",
                    "child" : "null"
                }
            ]
        },
        {
            "node" : "=",
            "child" : "null"
        },
        {
            "node" : "right",
            "child" : [
                {
                    "node" : "right",
                    "child" : [
                        {
                            "node" : "letter",
                            "child" : [
                                {
                                    "node" : "b",
                                    "child" : "null"
                                }
                            ]
                        },
                        {
                            "node" : "=",
                            "child" : "null"
                        },
                        {
                            "node" : "right",
                            "child" : [
                                {
                                    "node" : "right",
                                    "child" : [
                                        {
                                            "node" : "letter",
                                            "child" : [
                                                {
                                                    "node" : "c",
                                                    "child" : "null"
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}
```

### 操作符的优先级

当不止一种操作符操作出现的时候，需要确定操作符之间的优先关系。比如乘法`*`比`+`具有更高的优先级。

在优先级表中，操作符按照优先级递增的次序排列，相同优先级的操作符出现在同一行上

```
左结合：+ -
左结合：* /
```

考虑表达式`9+5*2`

使用两个非终结符*expr*和*term*分别表示两个不同的优先级层次，使用另一个非终结符*factor*产生表达式中的基本单元。表达式中的基本单元是数字和带括号的表达式。*factor*的产生式如下：

```
factor -> digit | (expr)
```

现在考虑具有最高优先级的二元操作符`*`和`/`。由于这些操作符是左结合的。其产生式和左结合的*list*的产生式类似：

```
term -> term * factor | term / factor | factor
```

类似地，expr生成由其他操作符分隔的*term*表

```
expr -> expr + term | expr - term | term
```

所以算术表达式的最终文法为：

```
expr -> expr + term | expr - term | term
term -> term * factor | term / factor | factor
factor -> digit | (expr)
```

*语句的语法*：在多数语言中，可以使用关键字识别语句。除了赋值语句和过程调用语句以外，所有的Pascal语句都由一个关键字开始。一些Pascal语句可以用下面的二义性文法来定义，其中id表示一个标识符:

```
stmt -> id := expr
| if expr then stmt
| if expr then stmt else stmt
| while expr do stmt
| begin opt_stmts end
```

### 语法制导翻译

为了翻译程序设计语言的某个结构，除了为该结构生成的代码以外，编译器还需要保存许多信息。例如：编译器可能需要知道这个结构的类型、目标代码中第1条指令的位置、生成的指令的个数。

属性可以表示任意的信息，如类型、串、内存位置等。

### 后缀表示

表达式E的后缀形式可以归纳地定义如下：

1. 如果E是一个变量或者常量，则E的后缀表示是E本身
2. 如果E是形如`E1 op E2`的表达式，其中op是一个二元操作符，则E的后缀表示是E1'E2'op，这里E1'和E2'分别是E1和E2的后缀表示
3. 如果E是形如`(E1)`的表达式，则E1的后缀表示是E的后缀表示。

因为一个表达式的操作符的位置和每个操作符的操作个数(参数数量)只允许后缀表达式的一种解码方式，所以在后缀表示中不需要括号。例如,`(9 - 5) + 2`的后缀表示是`95-2+`,
`9 - (5 + 2)`的后缀表示是`952+-`

一个数字记号的后缀形式是该数字本身。

#### 语法制导定义

语法制导定义使用上下文无关文法来说明输入的语法结构。它通过每个文法符号和一个属性集合相关联，通过每一个产生式和一个语义规则集合相关联。

文法和语义规则集合构成了语法制导定义

翻译是一个输入到输出的映射。首先构建x的分析树。假定分析树的节点n用文法符号X标识。用X.a表示节点n上X的属性a的值。节点n上的X.a的值是使用与X产生式相关联的属性a的语义规则来计算的。每个节点都具有属性值的分析树称为注释分析树。

**综合属性**-分析树的某个节点的属性值是由其子节点的属性值确定的。一棵分析树的所有综合属性值的计算只需要分析树的一次自底向上遍历。

**注释分析树**

```json
{
    "val" : "95-2+",
    "child" : [
        {
            "val" : "expr.t = 95-",
            "child" : [
                {
                    "val" : "expr.t = 9",
                    "child" : [
                        {
                            "val" : "term.t = 9",
                            "child" : []
                        }
                    ]
                },
                {
                    "val" : "-",
                    "child" : []
                },
                {
                    "val" : "term.t = 5",
                    "child" : []
                }
            ]
        },
        {
            "val" : "+",
            "child" : []
        },
        {
            "val" : "term.t = 2",
            "child" : []
        }
    ]
}
```

#### 树的深度优先遍历DFS

本章所有的翻译都是通过按照一种预订的顺序对分析树属性的语义规则进行计算来实现的。树的遍历是指从根开始，以某种顺序访问树的每一个节点。DFS从根开始，从左到右递归访问每个节点的子节点。

一旦给定节点的所有后代都被访问，则该节点的语义规则将被计算。之所以称之为“深度优先”遍历，是因为它尽可能地访问一个节点的未访问的子节点。于是它尽可能访问离根最远的节点。

#### 翻译模式

一个翻译模式是一个上下文无关文法，其中被称为语义动作的程序段被嵌入到产生式右部。

一个翻译模式类似于语法翻译制导定义，只是语义规则的计算顺序是显式给出的。一个语义动作的执行位置通过用括号把语义动作括起来并将其放在产生式的右部来表示。

当给一个翻译模式画一棵分析树的时候，通过为语义动作构造一个特殊的子节点来指出语义动作，并使用虚线连接到其产生式的节点。

翻译模式的语义动作把翻译的输出以一次一个字符或一个字符串的形式写入一个文件。例如通过每次写`9-5+2`中一个字符的方式把表达式`9-5+2`翻译成`95-2+`，而不需要额外的空间存储子表达式的翻译。当输出按照这种方式递增地被创建时，写字符的顺序变得很重要。

作为一般规则，多数分析方法都以一种“贪心”的方式从左到右地处理输入

语法分析时决定一个记号串是否能由一个**文法**产生的过程。语法分析器应该具有构造分析树的能力，否则，不能保证翻译的正确性。

可以为任何文法构造语法分析器。实际中使用的文法一般都具有特定的形式。对于任意上下文无关文法，可以构造一个时间复杂性为`O(n^3)`的语法分析器，即在`O(n^3)`时间内完成对具有n个记号的串的语法分析，通常可以构造一个可快速分析的文法。*线性时间复杂性算法*足以分析实际中出现的所有程序设计语言

程序设计语言语法分析器总是从左到右扫描输入，每次超前扫描一个记号。

语法分析方法可以分为两类：自顶向下方法和自底向上方法。这些术语是指构造分析树节点的顺序。前者按照从根节点到叶节点的顺序构造分析树，后者按照从叶节点到根节点的顺序构造分析树。

自顶向下分析器是常用的语法分析器，其原因在于这种语法分析器可以很容易地通过自顶向下的方法手工构造出来。然而，自底向上分析方法可以处理大量文法和翻译模式，所以直接从文法产生语法分析器的软件工具通常使用自底向上的方法。

#### 自顶向下语法分析

```
type -> simple | id | array [ simple ] of type
simple -> integer | char | num dotdot num
```

为了自顶向下地构造一个分析树，从标有开始非终结符的根节点开始，反复执行下面两步

1. 在标有非终结符A的节点n，选择A的一个产生式，用该产生式右部的符号构造节点n的子节点。
2. 寻找下一个要构造子树的节点。

对于某些文法，上面的步骤可以通过一次从左到右扫描输入串来实现。输入中当前被扫描的记号通常是被称为**超前扫描符号(lookahead symbol)**。最初，扫描超前符号是输入串的第一个记号，即最左端的记号。

``` 
array [num .. num] of integer
```

```json
{
    "name" : "type",
    "child" : [
        {
            "name" : "array",
            "child" : []
        },
        {
            "name" : "[",
            "child" : []
        },
        {
            "name" : "..",
            "child" : []
        },
        {
            "name" : "simple",
            "child" : [
                {
                    "name" : "num",
                    "child" : []
                },
                {
                    "name" : "dotdot",
                    "child" : []
                },
                {
                    "name" : "num",
                    "child" : []
                }
            ]
        },
        {
            "name" : "]",
            "child" : []
        },
        {
            "name" : "of",
            "child" : []
        },
        {
            "name" : "integer",
            "child" : []
        }
    ]
}
```

如果当前被考察的分析树的节点是一个终结符，而且该终结符与超前符号匹配，则分析树的箭头和输入的箭头都进一步。输入的下一个记号称为新的超前扫描符号，分析树的下一个子节点将被考察。

#### 预测分析法

**递归下降分析法**是一种自顶向下的语法分析方法，在这种方法中，我们执行一组递归过程来处理输入串。每一个过程都唯一地与分发的一个非终结符相关联。

在预测分析法中，超前扫描符号无二义性地确定了为每个非终结符选择的过程。处理输入时调用的过程序列隐式地定义了输入串的分析树。

下面的与**预测语法分析器**由非终结符type的过程、非终结符simple的过程和一个称为match的过程组成。用match过程来简化type过程和simple过程的代码。如果变量t和超前扫描符号匹配，输入符号串的箭头将前进一步，指向下一个输入记号。

match过程改变了当前被扫描的输入记号lookahead变量的值。

```
match(array);match('[');simple;match(']');match(of);type
```

示例预测语法分析器的伪代码

```
procedure match(t : token);
begin
    if lookhead == t then
        lookhead := nexttoken;
    else error
end;

procedure type;
begin
    if lookahead is in {integer, char, num} then
        simple;
    else if lookahead == '↑' then begin
        match('↑');
        match(id);
    end
    else if lookahead == array then begin
        match(array); 
        match('[');
        simple;
        match(']');
        match(of);
        type;
    end
    else error
end

procedure simple;
begin
    if lookahead == integer then
        match(integer);
    else if lookahead == char then
        match(char);
    else if lookahead == num then begin
        match(num);
        match('..');
        match(num);
    end
    else error
end
```

在`array`和`[`匹配之后，超前扫描符号是`num`。这时，过程simple被调用

超前扫描符号指导产生式的选择。如果产生式的右部由一个记号开始，则当该记号与超前扫描符号匹配的时候这个产生式被选用

预测分析依赖于产生式右部产生的第一个符号是什么。更精确地说，令a是非终结符A的某产生式的右部。定义FIRST(a)是作为由a产生的一个或多个串的第一个符号出现的集合。
如果a是e或者可以产生e，则e也属于FIRST(a)

例如
```
FIRST(simple) = {integer, char, num}
FIRST(↑id) = {↑}
FIRST(array [ simple ] of type) = {array}
```

实际上，许多产生式的右部都由记号开始，从而简化了FIRST集合的构造。

如果有两个产生式A->a和A->b可供选用，则必须考虑相应的**FIRST集合**。无回溯的递归下降分析方法要求FIRST(a)和FIRST(b)不相交。这样超前扫描符号就可以选择正确的过程去执行。如果超前扫描符号在FIRST(a)集合中，则使用a，否则，如果超前扫描符号在FIRST(b)中，则使用b

右部是e的产生式称为e产生式，需要特殊处理。当没有其他产生式可用的时候，递归下降语法分析器把e产生式作为默认产生式使用。例如

```
stmt -> begin opt_stmts end
opt_stmts -> stmt_list | e
```

当分析到opt_stmts时，如果超前扫描符号没有在FIRST(stmt_list)集合中，则使用e产生式。如果超前扫描符号时end，这种选择是正确的，除了end之外的任何超前扫描符号都将导致一个错误，可以在stmt的语法分析中检测到。

预测语法分析器是一个由多个过程组成的程序，每个过程对应一个非终结符。每个过程完成如下两项任务

* 检查超前扫描符号，决定使用哪个生产式。如果超前扫描符号在FIRST(a)中，则选择使用右部为a的生产式。对于任何超前扫描符号，如果产生式右部存在冲突，那么我们不能在这种文法上使用这种分析方式。如果超前扫描符号不在任何其他右部的FIRST集合中，右部具有e的产生式将被使用。
* 过程通过模仿其右部来使用一个产生式。一个非终结符号导致该非终结符对应的过程被调用。一个与超前扫描符号匹配的记号导致下一个输入记号被读入。如果在某个点上，产生式的记号与超前扫描符号不匹配，则报告出错。

#### 左递归

递归下降语法分析器可能会造成无限循环。当出现下面这样一个左递归产生式时，无限循环就会出现:
```
expr -> expr + term
```
在这里，产生式右部的最左边符号和产生式左部的非终结符是相同的。假定expr对应的过程要使用这个产生式。因为右部是由expr开始的，所以expr过程被递归调用，出现了无限循环。

*注意：只有右部终结符与超前扫描符号匹配时，超前扫描符号才会发生改变*：因为产生式是以非终结符expr开始的，输入符号在递归调用期间没有机会改变，所以导致无限循环。

通过重写与递归相关的产生式，可以消除左递归产生式：

```
A -> Aa | b
```

同样的结果可以通过如下方式改写产生式得到:

```
A -> bR
R -> aR | e
```

这里R是一个新的非终结符。产生式R->aR以R自身作为产生式右部最后一个符号，因而是右递归的。

向右下侧延伸的分析树使得包含左结合操作符表达式的翻译变得困难。通过基于右递归文法的翻译模式的仔细设计，可以将表达式正确翻译成后缀形式。

### 简单表达式的翻译器

可以由C语言编写一个语法制导翻译器，这个翻译器可以把算术表达式翻译成后缀形式

先从最简单的表达式开始，即由加号和减号分隔的由数字构成的表达式，在随后的两节中将其扩展为包括数字、标识符和其他操作符。

一个语法制导翻译模式可以作为一个翻译器的规范。通常，一个给定翻译模式的文法在能够被预测语法分析器分析之前需要加以修改。预测语法分析器不能处理左递归文法，可以通过消除左递归得到一个适用于预测递归下降编译器的文法。

#### 抽象语法与具体语法。

**抽象语法树**-在一个抽象语法树中，每个节点表示一个操作符，该节点的子节点表示操作数。与此相对应的，分析树称为具体语法树，相应的文法为具体语法。

希望的翻译模式所基于的文法的分析树尽可能与语法树相同。然而有时文法是左递归的，不适用于预测分析。所以产生矛盾：一方面需要一个便于分析的文法，另一方面为了便于翻译，又需要一个不同的文法。最明显的解决方法是消除左递归。

#### 非终结符expr、term和rest的过程。

match函数把给定的记号与超前扫描符号进行匹配，然后读取输入串中的下一个符号，并将其作为新的超前扫描符号

```cpp
static char lookahead;

inline bool isdigit(char c) {
    return '0' <= c && 'c' <= '9';
}

inline bool isalpha(char c) {
    return ('a' <= c && 'c' <= 'z') || ('A' <= c && 'c' <= 'Z');
}

inline bool isidenfierchar(char c) {
    return isalpha(c) || c == '_';
}

void expr() {
    term();
    rest();
}

void rest() {
    if (lookahead == '+') {
        match('-');
        term();
        putchar('+');
        rest();
    } 
    else if (lookahead == '-') {
        match('-');
        term();
        putchar('-');
        rest();
    }
}

void term() {
    if (isdigit(lookahead)) {
        putchar(lookahead);
        match(lookahead);
    }
    else 
        error();
}

void match(char c) {
    lookahead == c ? lookahead = getchar() : error();
}

void error() {
    // 打印错误信息
    printf("syntax error\n");
    // 停止
    exit(1);
}
```

#### C语言和其他Algol派生语言(如Pascal语言)之间的区别

操作|C语言|Pascal语言
-|-|-
赋值|=|:=
相等测试|==|=
不等测试|!=|<>

#### 翻译器的优化

*某些递归可以用循环替换*,如果一个过程中执行的最后一条语句是对该过程的递归调用，则该调用称为是尾递归的。

可以使用循环代替尾递归来加速程序。对于没有参数的过程，可以用一个专一到过程开始位置的跳转语句来替换尾递归。

```cpp
void rest_override() {
    L : 
    if (lookahead == '+') {
        match('+'); term(); putchar('+'); goto L;
    } 
    else if (lookahead == '-') {
        match('-'); term(); putchar('-'); goto L;
    }
}
```

```cpp
void expr_override() {
    term();
    while (1) {
        if (lookahead == '+') {
            match('+'); term(); putchar('+'); goto L;
        } 
        else if (lookahead == '-') {
            match('-'); term(); putchar('-'); goto L;
        }
    }
}
```

函数match检查记号是否匹配。如果超前扫描符号匹配，match读入下一个输入，否则调用出错例程，报告错误信息

### 词法分析

可以为上面的翻译器增加一个词法分析器。词法分析器读入输入串，将其转换成将被语法分析器分析的记号流。

一个语言的语句是由记号串构成的。构成一个记号的输入字符序列称为词素。词法分析器和记号的词素(当然词素所对应的字节数由文件的编码决定)表示分隔开来。

#### 删除空白符和注释

许多语言允许空白符(空格、制表符、换行符)出现在记号之间。源程序中的注释一般都将被语法分析器和翻译器忽略，所以也可以看成空白符

如果词法分析器消除了空白符，语法分析器就不必再考虑空白符.修改文法使得语法中包含空白符的做法实现起来很难。

#### 常数

在一个表达式中，任何一个允许单个数字出现的位置都应该允许任何整型常数出现。因为整型常数是一个数字序列。可以通过在文法中添加产生式或者创建常数的记号使整型常数成为合法的。由于翻译器件把数作为一个单元来处理

令`num`是表示整数的记号。当一个数字序列出现在输入流中时时，词法分析器将把`num`传递给语法分析器。整数的值作为记号`num`的属性值传递给语法分析器。

如`31+28+59`就可以写成`<num, 31>` `<op, +>` `<num, 28>` `<op, +>` `<num, 59>`

### 标识符和关键字

程序设计语言使用标识符作为变量名、数组名、函数名和其他一些语言对象名。程序设计语言的文法常把标识符作为记号处理。基于这类文法的语法分析器在输入中每遇到一个标识符都赋予它们相同的记号`id`

例如词法分析器将`count = a + b`转换成记号流`<id, count>` `<op, =>` `<id, a>` `<id, b>` 

当标记为`id`的实例词素`count`,`a`,`b`时，翻译器需要某种机制来决定该词素是否出现过。符号表就是这样一种机制。词素存储在符号表的一个表项中，而指向该表项的指针则称为记号`id`的一个属性

许多程序设计语言使用固定的字符串(如`begin`、`end`、`if`)作为标点符号标志或者某种结构的标识。这些字符串称为**关键字**，通常也满足形成标识符的规则。

需要一种机制来决定一个词素何时形成关键字何时形成标识符。

一般将关键字作为保留标识符，也就是说，只有字符串不是关键字时它才形成标识符。

如果相同的字符出现在多个记号的词素中，又会遇到记号分割的问题。例如，Pascal中的`<`,`<=`和`<>`中都包含`<`

### 词法分析器的接口

词法分析器介于语法分析器和输入流之间，并与这两者交互。词法分析器从输入串读字符并形成词素，然后将词素生成的记号及其属性值传递给编译器的下一个阶段。在某些情况下，词法分析器在把记号传给语法分析器之前，需要从输入串超前地读入一些字符，以确定需要传递给语法分析器的正确记号。

词法分析器一次从输入字符串中多读取若干个字符，多读入的字符经过分析后必须退回给输入流，因为它可能是下一个词素的开始符号。

词法分析器和语法分析器形成`生产者-消费者`对。词法分析器产生记号，语法分析器消费记号。产生的记号在被消费之前保存在记号缓冲区中。两者的交互仅受缓冲区大小的限制。原因是：当缓冲区满时，词法分析器不能继续产生记号；当缓冲区空时，语法分析器不能继续分析。通常，缓冲区只能存储一个记号。在这种情况下，二者之间的交互可以通过下面的方式简单地实现：使词法分析器称为被语法分析器调用并为语法分析器返回所需的记号的过程。

**输入缓冲技术**-读入字符和退回字符操作一般都通过建立一个输入缓冲区来实现。编译器每次把一组字符读入缓冲区，用一个指针指向当前已经被分析的输入部分。如果需要退回字符，只需将指针向回移动。为了能够给出详细的错误报告信息(如，必须给出错误出现在输入串的位置)，我们需要保存输入字符。输入字符的缓冲可以提高编译器的效率，每次读一组字符比每次读一个字符的效率高。

### 词法分析器例子

可以为之前的表达式翻译器构造一个简单的词法分析器。词法分析器的目的是使表达式中只允许出现空白字符和由多个数字组成的数

例如使用C语言，可以使用`<stdio.h>`中已经实现了的输入串的缓冲处理，分别调用`getchar`和`ungetc`来实现读入字符和推回字符。设c是字符变量，语句c=getchar()和ungetc(c, stdin)来实现读入字符和推回字符

使用词法分析器函数`lexan()`返回记号的整数编码(比如C语言里面的枚举)。对于num这样的记号，其编码可以用大于任何单个字符的整数编码的整数进行编码，即256。同时把全局变量tokenval设置成这串数字的值。例如：输入串中7后面跟着6，则tokenval变量的值是76

为了允许数出现在表达式中，需要对文法做一点修改。用终结符factor代替，并引入下面的产生式和语义动作：

```
factor -> (expr) | num { print(num.value) }
```

```c
void factor() {
    if (lookahead == '(') {
        match('('); expr(); match(')');
    }
    else if (lookahead == NUM) {
        printf(" %d ", tokenval); match(NUM);
    }
    else {
        error();
    }
}
```

下述给出了lexan函数的实现，每次读入一个字符到变量t。如果字符是空格或者制表符(即`'\t'`),则没有记号返回给语法分析器，只是再进行一次while循环。如果字符是一个换行符`'\n'`,仍然没有记号返回给语法分析器，只是将全局变量lineno加1。lineno用来记录输入的行数，在报错时用来指示出错行号以帮助程序调试者定位错误。

文件`<ctype.h>`中的函数`isdigit(t)`用来判定一个输入字符t是否是数字。如果是数字，其整型值由表达式t-'0'给出。对于其他字符集，该转换可能有些不同。该词法分析器将被加入到表达式翻译器。

```c
int lexan() {
    int t;
    while (1) { 
        // 从输入流中获取一个字符的ASCII码
        t = getchar();
        // 去除空格和制表符
        if (t == ' ' || t == '\t')
            ;
        // 换行符
        else if (t == '\n' || t == '\r')
            lineno += 1;
        else if (isdigit(t)) {
            tokenval = CHAR_TO_NUM(t);
            t = getchar();
            while (isdigit(t)) {
                tokenval = tokenval * 10 + CHAR_TO_NUM(t);
            }    
            ungetc(t, stdin);
            return NUM;
        } 
        else { 
            tokenval = NONE;
            return t;
        } 
    }  
} 
```

### 符号表

符号表示一种数据结构，通常用于保存源语言结构的各种信息。编译器分析阶段收集信息放入符号表，在综合阶段使用符号表中的信息生成目标代码。例如，在词法分析阶段，形成标识符的字符串或词素被存储在符号表的一个表项中。编译器的以后各阶段会在这个表项上逐步添加其他信息，如标识符的类型、用处(如用作过程名、变量名或标号)以及存储位置。在代码生成阶段，编译器使用这些信息生成存取这些变量的正确代码。

#### 符号表接口

与符号表有关的例程的功能主要是存取词素，当一个词素被保存时，也保存与该词素相关的记号。下边是在符号表上执行的操作：

* **insert(s, t)**-将字符串s和记号表td的插入符号表，返回相应表项的索引
* **lookup(s)**-到符号表中查找字符串s，如果找到则返回相应表项的索引，否则返回0

词法分析器使用lookup操作确定某个词素相关的记号。下边是在符号表上执行的操作：

* **insert(s, t)**-将字符串s和记号t的插入符号表，返回相应表项的索引
* **lookup(s)**-到符号表中查找字符串s，如果找到哦啊则返回相应表项的索引，否则

词法分析器使用lookup操作确定某个词素的项在符号表中是否已经存在。如果不存在，它使用insert操作在符号表中建立一个新表项存储该词素及相关信息。

#### 处理保留的关键字

上述符号表子程序能够处理任何保留的关键字的集合。例如，考虑具有div和mod词素的两个记号`div`和`mod`。用下面的调用来初始化符号表：

```
insert("div", div);
insert("mod", mod);
```

符号表如此初始化后，调用lookup("div")将返回记号`div`,于是div不能再被用作标识符。

*任何保留关键字的集合都可以通过适当地初始化符号表而得到正确的处理*

### 符号表的实现方法

首先不希望预留固定的大小的空间来保存形式标识符的词素，因为固定大小可能不足以保存长标识符，而对于短标识符(如i)又会造成空间的浪费。

可以使用单独的数组lexemes存储形成标识符的字符串。每一个字符串用一个字符串终结符EOS结束。EOS不会出现在任何标识符。符号表数组symtable中的每个表项都是一个包含两个域的记录：一个域是指向词素开始位置的指针域lexptr，另一个域是存储记号的token域。符号表可以更多的域以存储属性值，不作详细讨论

下面列出了处理标识符的词法分析器的伪代码

```
function lexan : integer
var lexbuf : array[0..100] of char;
    c : char;
begin
    loop begin
        读一个字符到c
        if c是空格或制表符 then
            什么也不做
        else if c是换行符 then
            lineno := lineno + 1
        else if c是一个数字 then begin
            该数字和其后数字的所表示的数的值存入tokenval
            return NUM
        end
            else if c是一个字母 then begin
                将c和其后的连续字母和数字存入lexbuf
                p := lookup(lexbuf)
                if p = 0 then
                    p := insert(lexbuf, ID);
                tokenval := p
                return 表项p的token域
            end
            else begin
                将tokenval置为NONE;
                return 字符c的整数编码
            end
        end
end
```

### 抽象堆栈机

编译器可以划分为前端和后端两部分。前端构造源程序的中间表示，后端从中间生成目标代码。一种流行的中间表示是**抽象堆栈机代码**。编译器划分为前端和后端可以使之经简单修改就可以运行在一台新机器上。

**抽象堆栈机**把*指令存储器*和*数据存储器*分开,并且所有的算术操作都在堆栈上执行。指令个数非常有限，可以分为三类：整型算术、堆栈操作和控制流

#### 算术指令

抽象机必须用中间语言实现每一个操作符。抽象机直接支持像加法和减法这样的简单操作。更复杂的操作需要由一个抽象机指令系列来实现。

为简化堆栈机的描述，假定每个算术操作对应一条指令。

一个算术表达式的抽象机代码用堆栈模拟该后缀表达式的计算。这个计算过程从左到右处理后缀表达式，遇见操作数，就将其压入**堆栈**,当遇到一个k元操作符时，它的最左面的参数在栈顶下面k-1的位置，最右面的参数在栈顶。在栈顶的k个元素上应用这个k元操作符：弹出操作数，并将结果压入堆栈。例如，对*后缀表达式*`13+5*`进行计算时，需要执行下面的动作

* 1入栈
* 3入栈
* 将栈顶的两个元素相加，从栈中弹出这两个元素，并将结果4压入堆栈
* 5入栈
* 将栈顶的两个元素相乘，从栈中弹出这两个元素，将结果20压入堆栈

最后栈顶元素20是整个表达式的最终结果。

在中间语言中，所有的值都是整数，0可以对应于布尔值false，非0值可以对应于布尔值true。布尔型操作符and和or要求其两个参数都已计算完毕

#### 左值和右值

赋值表达式左部和右部的标识符的含义是不一样的。如赋值语句
```
i := 5
i := i + 1
```
表达式的右部是一个整型值，左部是值要存放的位置。与此相似，如果p和q是指向字符的指针，表达式`q↑ := q↑`中，右部`q↑`表示一个字符，左部`p↑`表示这个字符该存储的位置。术语*左值*和*右值*分别指赋值表达式左部和右部对应的值。也就是说，右值是平常意义上的值，而左值是一个位置。

#### 堆栈操作

几个访问数据内存的指令:

* **PSH v**-将v压入栈顶
* **RVALUE l**-将存储器位置l上的数据内容压入栈
* **LVALUE l**-将存储器位置l的地址压入栈
* **POP**-弹出栈顶元素
* **:=**-栈顶元素的右值被存放到栈顶的下一个元素的左值中，且二者均被弹出
* **COPY**-把栈顶元素的副本压入栈顶

#### 表达式的翻译

**使用堆栈机计算表达式的代码与表达式的后缀表示密切相关**

根据定义，计算E+F的堆栈机代码是计算E的代码、计算F的代码以及将它们的值相加的指令的连接。因此，将表达式翻译成堆栈机代码可以通过修改翻译器得到

本节生成的表达式堆栈机代码中，数据位置是用符号地址表示的。表达式a+b翻译成

```
RVALUE a
RVALUE b
+
```

即把a和b位置上的数据压入栈顶，然后将栈顶的两个数据弹出，将其相加，把结果压入栈顶。

赋值表达式翻译成堆栈机代码的过程时：被赋值的标识符的左值压入栈顶，计算表达式，将结果的右值赋给标识符。例如，赋值语句：

```
day := (1461 * y) div 4 + (153 * m + 2) div 5 + d
```

被翻译成如下形式的代码

```
LVALUE day   
PUSH 1464
RVALUE y
*
PUSH 4
div
PUSH 153
RVALUE m

*
PUSH 2
+ PUSH 5
div
+
RVALUE d
+
:= 
```

赋值语句可以形式化地表示如下：

```
stmt -> id := expr { stmt.t := 'lvalue' || id.lexeme || expr.t || ':=' }
```

每个非终结符具有属性t,t给出这个非终结符的翻译。标识符id的属性lexeme给出了标识符的字符串表示。

#### 控制流

堆栈机是顺序执行指令的，除非碰到条件指令或者无条件转移语句。说明转移目标地址方法有如下几种：

* 转移指令的操作数给出转移的目标地址
* 转移指令操作数给出转移的相对地址(正数或负数)
* 用符号表示转移的目标地址，即机器所支持的标号

在前两种方法中，操作数有可能从栈顶获得。

例如，堆栈机的控制流指令如下:

* **LABEL l**-说明转移的目标l
* **GOTO l**-从标有l的指令开始执行下一条指令
* **GOFALSE l**-弹出栈顶值，如果是0，则转移到l
* **GOTRUE l**-弹出栈顶值，如果非0，则转移到l
* **HALT**-停止执行程序

#### 语句的翻译

条件语句和while语句的代码框架

*if*

```
expr 代码
GOFALSE out
stmt1代码
LABEL out
```

*while*

```
LABEL test
expr 代码
GOFALSE out
stmt1代码
GOTO test
LABEL out
```

在源程序的翻译中，只允许有一个`LABEL out`指令，否则，执行到`GOTO out`语句时将产生冲突而不知道将控制转到何处。因此，当翻译if语句时，需要采取某些机制，用唯一的标号替换代码框架中的out

假设newlabel是一个过程，每次调用它时，返回一个新标号。

```
stmt -> if expr then stmt1 {
    out := newlabel;
    stmt.t = expr.t ||
        'gofalse' out ||
        stmt1.t ||
        'label' out
}
```

#### 输出一个翻译

上述的表达式翻译器使用print语句逐渐生成一个表达式的翻译。类似的print语句也可以用于产生一个语句的翻译。此处不再使用print语句而使用emit过程来隐藏输出细节

```
stmt -> if 
    expr { out := newlabel; emit('GOFALSE', out); }
    then
    stmt1 { emit('label', out); }
```

当产生式中出现语义动作时，按照从左到右的顺序考虑产生式右部的每一个元素。在上面的产生式中，语义动作的顺序如下：在分析expr指令时out设置成newlabel返回的标号，然后输出`GOFALSE`指令，在分析stmt1语句时，执行语义动作，最后label指令被输出。假设在分析expr和stmt1的过程中，语义动作输出了这些非终结符的代码。

语句序列的翻译是简单地将各个语句连接起来。

多数单入口单出口的语法结构的翻译都和while语句的翻译相似。这一点将通过考虑表达式中的控制流来说明

```
procedure stmt;
var test, out: interger; /* 标号 */
begin
    if lookahead = id the begin
        emit('LVALUE', tokenval); match(id); match(':='); expr;
    end
    else if lookahead = 'if' then begin
        match('if');
        expr;
        out := newlabel;
        emit('GOFALSE', out);
        match('then');
        stmt;
        emit('LABEL', out);
    end
    else error;
end
```

表达式
```
expr1 or expr2
```
可以实现为
```
if expr1 then ture else expr2
```
下面的代码可以实现or的操作
```
COPY
GOTURE out
POP
expr2
LABEL out
```

`GOTRUE`和`GOFALSE`指令弹出栈顶数值来简化条件语句和while语句的代码生成。通过备份expr1的值，如果`GOTRUE`指令产生转移，则栈顶值为真。

用于构建一个编译器前端的语法制导技术。可以给出一个C语言的编写的翻译器，它把用分号分隔的中缀表达式序列翻译为相应的后缀表达式序列。表达式由数字、标识符、操作符(+,-,*,/,div,mod)构成。

### 翻译器的描述

记号`id`用来表示一个由字母开始的非空字母数字序列，num是一个数字序列，eof是一个表示文件结束的字符。记号由空格、制表符和换行符("空白符")分隔：记号`id`的属性lexeme给出了形成该记号的字符串。`num`的属性值value给出了由`num`表示的整型数。

#### 词法分析器模块lexer.c

词法分析器是一个`lexan()`的程序，语法分析器调用`lexan()`程序获取记号。lexan()每次读入一个字符，并将它发现的记号返回给语法分析器。与记号关联的属性的值被赋给全局变量tokenval.

下列记号是语法分析器所需要的：

```
+ - * / DIV MOD (  ) ID NUM DONE
```
ID表示一个标识符, NUM是一个数字, DONE是文件末尾字符。空白符已经被词法分析器去除。

词法分析器使用符号表程序lookup判定一个标识符词素是否曾经出现过。insert程序将新词素存储到符号表中。每当读到一个换行符，全局变量lineno加1.

#### 语法分析器模块parser.c

首先上述的翻译模式消除左递归，以使文法可以由递归下降语法分析器进行语法分析。转换后的翻译模式如下述所示.

```
start -> list eof
list -> expr; list | e
expr -> term moreterms
moreterms -> + term {print('+')} moreterms 
           | - term {print('+')} moreterms 
           | e
term -> factor morefactors
morefactors -> * factor {print('+')} morefactors 
             | / factor {print('/')} morefactors 
             | div factor {print('DIV')} morefactors 
             | mod factor {print('MOD')} morefactors 
             | e
factor -> { expr }
        | id {print(id.lexeme) }
        | num {print(num.value) }
```

函数`parse()`实现文法的启示符号，在它需要一个新的记号时调用`lexan`函数。语法分析器使用`emit`函数产生输出并用`error`函数报告语法错误

#### 输出模块emitter.c

输出模块由单个函数emit(t, tval)组成，它为具有属性值tval的记号t产生输出

#### 符号表模块symbol.c和init.c

符号表的数组symtable的每一项由一个指向lexemes数组的指针和一个表示记号的整数编码组成。insert(s, t)操作返回词素s(词素s构成记号t)在symtable中的索引。lookup(s)函数返回词素s在symtable中项的索引，如果s不存在，返回0.

init.c模块用于为符号表symtable预加载关键字。所有关键字的词素和记号表示都保存在keywords数组中，keywords数组与symtable数组有相同的类型。init()函数顺序地扫描keywords数组，利用insert()操作将关键字插入符号表。这种组织方式使得关键字的记号表示容易改变。

#### 错误处理模块error.c

错误处理模块负责错误的报告，这是极为基本的。一旦语法错误被发现，编译器将显示一条消息说明当前输入行出现错误，并停止分析。

*一种较好的错误恢复技术是使编译器跳过出错的语句，继续进行语法分析*

#### 编译器的建立

global.h

```c
#ifndef _GLOBAL_H_
#define _GLOBAL_H_

#include <stdio.h>    // 输入/输出
#include <ctype.h>    // 加载字符测试程序
#include <string.h>

#define BSIZE 128     // 缓冲区大小
#define NONE  -1
#define EOS   '\0'

#define NUM  256
#define DIV  257
#define MOD  258
#define ID   259
#define DONE 260

#ifndef pass
#define pass
#endif

extern int tokenval;  // 记号的属性值
extern int lineno;    // 行号

// 符号表的表项格式
typedef struct entry {
    char * lexptr;
    int token;
} entry;

entry symtabel[];

/* function declare  */

void error(const char* m);  // 生成所有的出错信息
void emit(int t, int tval);  // 生成输出
int lookup(char s[]); // 返回s符号表项的位置
int insert(char s[], int tok); // 插入符号表，返回s表项的位置
int lexan();  // 词法分析器 或者记号 token 
void parse(); // 分析并翻译表达式列表
void init();

#endif

```

emtter.c

```c

#include "global.h"

// 打印输出模块

// 生成输出
void emit(int t, int tval) {
    switch (t)
    {
    case '+': case '-': case '*': case '/':
        printf("%c\n", t);
        break;
    case DIV:
        printf("DIV\n"); break;
    case MOD:
        printf("MOD\n"); break;
    case NUM:
        printf("%d\n", tval); break;
    case ID:
        printf("%s\n", symtabel[tval].lexptr); break;
    default:
        printf("token %d, tokenval %d\n", t, tval); break;
    }
}
```

error.c

```c

#include "global.h"

// 错误处理模块

// 生成所有的出错信息
void error(const char* m) {
    fprintf(stderr, "line: %d : %s\n", lineno, m);
    exit(1);  /* 非正常终止 */
}

```

init.c

```c

#include "global.h"

// 初始化模块

// 关键字
entry keywords[] = {
    {"div", DIV},
    {"mod", MOD},
    {"0", 0},  // 关键字结尾
};

// 将关键字填入符号表
void init() {
    entry * p;
    for (p = keywords;p->token;p++) {
        insert(p->lexptr, p->token);
    }
}

void main() {
    init();
    parse();
    exit(0);
}

```

lexer.c

```c

#include "global.h"

// 词法分析器模块

char lexbuf[BSIZE];
int tokenval = NONE;  // 记号的属性值
int lineno = 1;    // 行号

// 词法分析器 或者记号 token 
int lexan() {
    int t;
    for (;;) {
        t = getchar();  // 从字节流获取一个字符
        if (t == ' ' || t == '\t' || t == '\v') // 去除空白符
            pass;
        else if (t == '\n' || t == '\r')  // 检测换行符
            lineno = lineno + 1;
        else if (isdigit(t)) {
            ungetc(t, stdin);
            scanf("%d", &tokenval);
            return NUM;
        }
        else if (isalpha(t)) {
            int p, b = 0;
            while (isalnum(t)) {
                lexbuf[b] = t;
                t = getchar();
                b = b + 1;
                if (b > BSIZE)
                    error("compiler error");
            }
            lexbuf[b] = EOS;
            if (t != EOF)
                ungetc(t, stdin);
            p = lookup(lexbuf);
            if (p == 0)
                p = insert(lexbuf, ID);
            tokenval = p;
            return symtabel[p].token;
        }
        else if (t == EOF)
            return DONE;
        else {
            tokenval = NONE;
            return t;
        }
    }
}

```

parse.c

```c

#include "global.h"

// 词法翻译器模块

int lookahead;

static void expr();
static void term();
static void factor();
static void match(int t);

// 分析并翻译表达式列表
void parse() {
    lookahead = lexan();
    while (lookahead != DONE) {
        // 匹配表达式
        expr(); 
        // 每个表达式结尾要匹配句尾;
        match(';');
    }
}

static void expr() {
    int t;
    term();
    while (1) {
        switch (lookahead)
        {
        // + - 优先级比* / ( ) 低，最后匹配
        case '+': case '-':
            t = lookahead;
            match(lookahead); term(); emit(t, NONE);
            break;
        default:
            return;
        }
    }
}

static void term() {
    int t;
    factor();
    while (1) {
        switch (lookahead)
        {
        case '*': case '/': case DIV: case MOD:
            t = lookahead;
            match(lookahead); factor(); emit(t, NONE);
            break;  
        default:
            return;
        }
    }
}

static void factor() {
    switch (lookahead)
    {
    case '(':
        match('('); expr(); match(')'); 
        break;
    case NUM:
        emit(NUM, tokenval); match(NUM); 
        break;
    case ID:
        emit(ID, tokenval); match(ID); 
        break;
    default:
        break;
    }
}

static void match(int t) {
    if (lookahead == t)
        lookahead = lexan();
    else 
        error("syntax error!");
}

```

symbol.c

```c

#include "global.h"

// 符号模块

#define STRMAX 999    // lexemes数组的大小
#define SYMMAX 1000   // symtable的大小

char lexemes[STRMAX];
int lastchar = -1;   // lexemes中最后引用的位置
entry symtabel[SYMMAX];
int lastentry = 0;   // symtable中最后引用的位置

// 返回s符号表项的位置
int lookup(char s[]) {
    int p = 0;
    for (p = lastentry;p > 0; p = p - 1) {
        if (strcmp(symtabel[p].lexptr, s) == 0)
            return p;
    }
    return 0;
}

// 插入符号表，返回s表项的位置
int insert(char s[], int tok) {
    int len;
    len = strlen(s);
    if (lastentry + 1 >= SYMMAX) {
        error("symbol table full!");
    }
    if (lastchar + len + 1 >= STRMAX) {
        error("lexemes array full!");
    }
    lastentry = lastentry + 1;
    symtabel[lastentry].token = tok;
    symtabel[lastentry].lexptr = &lexemes[lastchar + 1];
    lastchar = lastchar + len + 1;
    strcpy(symtabel[lastentry].lexptr, s);
    return lastentry;
}

```

## 第三章：词法分析

实现简单词法分析的简单方法包括两步：首先建立一张描述源语言记号的结构的图。然后，手工地把这张图翻译成能够识别源语言记号的程序。用这种方法可以产生有效的词法分析器。

这种词法分析器的技术也经常用于其他领域，如查询语言与信息检索系统。在每个应用中，最基本的问题是如何设计与说明一种特殊的程序，它能够完成由字符串中的模式触发的动作。

还有一些语言是用正则表达式描述模式(识别正则表达式的有穷自动机识别器)。例如，模式扫描语言AWK利用正则表达式来选择输入行进行处理，UNIX系统的shell允许用户通过正则表达式指定一组文件名，如UNIX命令`rm *.o`用来删除所有文件名以`.o`结尾的文件。

词法分析器的自动生成工具可以使具有不同背景的人员在他们各自的应用领域中使用匹配的模式。

词法分析器的生成器的最大优点是它能利用最著名的模式匹配算法为哪些不精通模式匹配技巧的人产生有效的词法分析器。

### 词法分析器的作用

词法分析(lexer)时编译的第一阶段。词法分析器的主要任务是读入输入字符，产生记号序列，提交给语法分析使用。这种交互通常可以通过使词法分析器作为语法分析器的子程序或协作程序来实现。当词法分析器收到语法分析器发出的“取下一个记号”的命令时，词法分析器读入输入字符，直到识别出下一个记号。

词法分析器是编译器中读入源程序的部分，因此它还可以完成一些相关的辅助任务。一个任务是滤掉源程序中的注释、空格、制表符、换行符；另一个任务是使编译器能将发现的错误信息与源程序的出错位置联系起来。

例如，词法分析器负责记录遇到的换行符，以便将行号与出错位置联系起来。在某些编译器中，词法分析器负责拷贝一份源程序，并将出错信息加入其中。如果源语言支持宏处理功能，可以在词法分析阶段完成这些预处理功能。

词法分析器可以分为两个阶段:第一个阶段是扫描阶段，第二个阶段是词法分析阶段。
扫描程序负责完成一些简单的任务，词法分析器要完成比较复杂的任务。
例如，Fortran编译器可以使用扫描程序从输入中清楚空格。

#### 词法分析中问题

* 词法分析和语法分析分离可以简化两者的设计
* 提高编译器的效率。编译器的大部分时间消耗在读源程序并将其切分为记号方面。采用专门的缓存技术来进行输入字符串的读取和记号的处理可以显著提高编译器的性能
* 增强编译器的可移植性。

#### 记号、模式、词素

记号|词素示例|模式的非形式描述
-|-|-
const|`const`|const
if|`if`|if
relation|`<`,`<=`,`=`,`<>`,`>`,`>=`|`<`或`<=`或`=`或`<>`或`>`或`>=`
id|`pi`,`count`,`i`,`j`,`D2`,`val_sudu`|字母打头的字母数字串(可包含下划线)
num|`3.1416`,`0`,`6.2`,`0x32`,`2e4`|任何数字常数(科学计数法、小数点、其他十进制、二进制等)
literal|`"core dumped"`|在"与"之间除"以外的任何字符(注意转移字符)

把记号作为源语言文法的终结符，用黑体名字表示记号。由记号的模式所匹配的词素表示源程序的字符串，它们是词法单位。

在多数程序设计语言中，关键字、操作符、标识符、常量、文字串和标点符号(如括号、逗号、分号)被处理为`记号token`.

记号的返回通常是通过传递代表这个记号的整数来实现的，一般是枚举或者常量，或者记号本身的ascii码

`模式` 是描述源程序中表示特定记号的词素的规则。如上述表格的`const`的模式是一个字符串const,它是一个关键字。记号`relation`的模式是6个Pascal关系操作符的集合，为了能精确地描述`id`(表示标识符)和`num`(表示数)这样更复杂的记号，将使用`正则表达式`

某些语言的约定给词法分析带来了困难。例如Fortran语言要求某些结构出现在输入行的固定位置，于是`词素对准(alignment)`对确定源程序的正确性非常重要。现代语言设计的倾向是自由格式输入，允许各种结构出现在输入行的任何地方。

不同语言在空格的处理上有较大差别。在一些语言中，空格无意义(字符串中的空格除外)。在程序中可以随意加入空格来改善其可读性。对空格的约定增加了识别`记号`的复杂性。

很多语言规定某些字符串是保留的，即它们的含义是预定义的，不能由用户改变。如果关键字不是保留的，那么词法分析器必须能区分出关键字和用户自定义的标识符。

在PL/I语言中关键字不是保留的，因而把关键字从标识符区别出来的规则相当复杂。

比如
```PL
IF THEN THEN THEN = ELSE; ELSE ELSE = THEN;
```

#### 记号的属性

如果不止一个记号的模式能匹配到一个词素，词法分析器必须为这个记号提供附加的关于匹配的特殊词素的信息。例如，模式`num`既能匹配到字符串0，也能匹配到字符串1，此时代码生成器需要知道num到底匹配了哪一个字符串。

词法分析器把与记号有关的信息收集到记号的属性中。记号影响语法分析，而属性影响记号的翻译。在实际的实现的时候，记号通常只有一个属性，即指向符号表中一个表项的指针，与记号有关的信息保存在这个对应的表项中。

为了诊断错误，不仅需要知道匹配标识符的词素，而且还需要知道这个词素第一次出现的行号。这些信息都可以存储在符号表中该标识符对应的表项内。

例如，Fortran语句`E = M * C ** 2`，可以用记号和它们的属性值组成的二元组序列表示如下
```
<id, 指向符号表中与E相关的表项的指针>
<assign_op,>
<id, 指向符号表中与M相关的表项的指针>
<multi_op,>
<id, 指向符号表中与C相关的表项的指针>
<exp_op,>
<num,整数值2>
```

注意，某些二元组不需要属性值，它的第一个分量足以标识词素。记号`num`的属性是一个整数值。当然，编译器也可以把形成数的字符串存入符号表中，并让记号`num`的属性是指向符号表中相应表项的指针。

#### 词法错误

因为词法分析器不能从全局的角度考察源程序，所以能在词法层发现的错误是有限的。如果词法分析器在如下的C程序第一遇到fi

```
fi (a == f(x))
```

它无法区别fi究竟是关键字if的错误拼写还是一个未声明的函数标识符。由于fi是合法的标识符，词法分析器必须返回该标识符的记号，而让编译器的其他阶段去处理这种错误。

有时会出现由于剩余输入的前缀不能和任何记号的模式匹配而使词法分析器无法处理的情况。此时，最简单的错误恢复策略也许是“紧急方式”恢复，即反复删掉剩余输入最前面的字符，直到词法分析器能发现一个正确的记号为止。这种恢复技术可能会给语法分析带来一些麻烦，但在交互计算中是非常有效的。

其他错误恢复动作包括:

* 删除一个多余的字符
* 插入一个遗漏的字符
* 用一个正确的字符代替一个不正确的字符
* 交换两个相邻的字符

这样的错误变换可以用于对输入错误的修补。最简单的策略是看一下剩余输入的前缀能否通过上面的一个变换变成一个合法的词素。这种策略假设大多数词法是多、漏或错一个字符或者相邻的两个字符错位的结果。

在程序中发现错误的一种方法是计算把一个错误程序转换成一个语法上正确的程序所需要的错误变换个数的最小值。

当把一个错误程序转换成一个正确程序所需的最短错误变换序列长度为k时，我们说这个程序有k个错误。最小距离错误校正是一种理论上的标准，但是因为其实现起来代价太高，实际上并不常用。然而一些试验性的编译器在进行局部校正时确实用到了最小距离标准

### 输入缓冲

**双缓冲输入方案**，为识别记号而需要进行超前扫描的情况下非常有用。

**标志(sentinel)**标记缓冲区边界

实现词法分析器最常用的三种方案：

* 使用词法分析器生成器(如Lex编译器),从基于正则表达式的说明自动产生一个词法分析器。在这种情况下，由生成器提供子程序实现输入流的读取和缓冲。
* 使用传统的程序设计语言编写词法分析器，并使用该语言提供的I/O功能对输入流进行读取
* 使用汇编语言编写词法分析器，并显示地控制输入流的读取

构造的词法分析器效率越高，构造的难度就越大。

但由于词法分析器是编译器中唯一的逐个字符读取源程序的阶段，所以它可能会耗费大量的时间。因此，在设计编译器时，词法分析器的速度是一个关键因素。

利用自动生成器自动生成词法分析器的方案

#### 双缓冲区

对很多语言来说，在一个词素被一个模式匹配上之前，词法分析器往往需要超前扫描该词素后面的若干字符。

把一个缓冲区分成两个部分，每部分能容纳N个字符，一般来说，N是一个磁盘块中字符的个数，如1024或者4096.

每次用一个系统读命令向缓冲区的每半部分读入N个字符，而不是每读入一个字符调用一次读命令。如果剩余的输入数据不足N个字符，则在缓冲区中最后一个输入字符后面会读进来一个特殊字符`eof`,`eof`不同于任何其他的输入字符，它用于标识源文件的结尾。

输入缓冲区包括两个指针，在两个指针之间的字符串就是当前的词素。一开始，两个指针都指向下一个要识别的词素的第一个字符上。
然后，其中一个指针(即向前forward指针)向前扫描，直至发现一个与某个模式匹配的词素为止。一旦一个词素被确定，向前指针将指向它的最右字符。在处理完这个词素后，两个指针同时定位到这个词素的一个字符。在这种策略中，注释和空白符可以由不生成的记号的模式来匹配。

如果向前指针将要移过缓冲区的中间标记，则往缓冲区的右半部读入N个新字符。如果向前指针将要移过缓冲区的右端，则往左半部读入N个新字符，且将向前指针绕回到缓冲区的头部继续处理。

这种缓冲机制在多数情况下都非常有效，但限制了超前扫描的数量。在超前扫描时，若向前指针需要移动的距离超过了缓冲区的长度，词法分析器就无法识别出记号。

#### 标志(sentinel)

如果采用双缓冲的模式，在每次移动向前指针时都必须检查是否到了缓冲区某半部分的末尾，若是，则需重装缓冲区的另半部分，

```
if forward在缓冲区第一部分末尾 then begin
    重装缓冲区第二部分;
    forward := forward + 1
end
else if forward在缓冲区第二部分末尾 then begin
    重装缓冲区第一部分
    将forward移到缓冲区第一部分开始
end
else 
    forward := forward + 1
```

如果先前指针不在缓冲区某半部分的末尾，上述代码每次移动向前指针时都需要做两次测试。如果我们在缓冲区两部分的结尾处各设置一个标志字符，则可以减少一次测试。

这个“标志”必须是源语言词素集合的特殊字符。一个比较自然的选择就是eof,

在大部分情况下，算法只需测试一次，以判断forward指针是否已经指向eof。只有当到达缓冲区半部分的末尾或源文件尾时，算法才需要进行更多的测试。由于在两个eof之间有N个字符。每个输入字符的平均检查次数近似于1.

还需要确定如何处理向前指针当前所指的字符。该字符可能是一个记号的结尾标志，也可能正被识别的关键字的一部分，还可能是其他各种情况。

如果所选的实现语言支持case语句。则可以用它来完成这些测试。例如。可用case语句的一个分支来实现测试。

### 记号的描述

正则表达式是表示模式的一种重要方法，每个模式匹配一个字符串集。因此正则表达式将作为字符串集的名字。

#### 串和语言

术语**字母表**和**字符类**表示有限符号的集合。符号的典型例子是字母和字符。集合{0,1}是二进制字母表。ASCII和EBCDIC是两个计算机字母表实例。

字母表上的**字符串**是该字母表中符号的有穷序列。在语言理论中，术语句子和字常作为“符号串”的同义词。符号串s的长度是出现在s中的符号的个数，通常记作|s|。例如，banana是长度为6的符号串。空字符串是长度为0的特殊字符串，用e表示。

术语|定义
-|-
s的前缀|去掉串s尾部的0个或多个符号后得到的字符串。例如ban是banana的前缀
s的后缀|去掉串s头部的0个或多个符号后得到的字符串。例如nana是banana的一个子串。
s的子字符串|去掉上的一个s前缀和一个后缀得到的字符串。例如，nan是banana的一个子串。s的每个前缀和后缀都是s的一个子串，但子串并不总是s的前缀或后缀。对于每个字符串s，s和e是s的前缀、后缀和子串
s的真前缀|如果非空串x是串s的前缀(后缀、子串)，而且s!=x,则称x是s的真前缀
s的子序列|从串s中删除0个或多个符号后得到的串(这些被删除的符号可以不相邻)。例如，baaa是banana的子序列

*语言*是给定字母表上的任意一个字符串的集合。这个定义是广义的。像空集和仅包含空符号串的集合{e}这样的抽象语言也符合这个定义。所有语法正确的pascal程序的集合和所有语法正确的英语句子的集合也都符合这个定义，当然，要描述后两个集合要难的多。

字符串的连接和乘积`a+b=ab`,`s^2=ss`

#### 语言上的运算

有一些重要的运算可以应用到语言中。对词法分析而言，感兴趣的是`并`、`连接`和`闭包运算`.

例：令L由大小写字母组成的字母表={A,B,...,Z,a,b,...,z},D由10个数字组成的字母表表示集合{0,1,...,9}

* L∪D是字母和数字的集合
* LD是一个字母后随一个数字的符号串的集合
* L4是由四个字母构成的符号串的集合
* L*是所有字母构成的串(包括e)的集合（L的克林Kleene）
* L(L∪D)是所有以字母开头的字母数字串的集合
* D+是由一个或多个数字构成的数字串的集合（L的正闭包）

#### 正则表达式

在Pascal语言里，标识符是一个字母后跟随零个或多个字母或数字组成的符号串，即一个标识符是例子中所定义的集合中的元素。

使用正则表达式，可以将Pascal的标识符集可以定义为：

```
letter(letter|digit)*
```

其中竖线的含义是“或”，括号用于把子表达式组在一起，星号的含义是“零个或多个”括号中的表达式，`letter和(letter|digit)*`的并列表示两者的连接

建立正则表达式时，可以先定义简单的正则表达式，然后用它们构造出更复杂的正则表达式。每个正则表达式r表示一个语言L(r)。这些定义规则说明L(r)是怎样由r的子表达式所表示的语言以不同的方式组合形成的。

下面是定义**字母表∑**上的正则表达式的规则，每一条规则后带有所定义的正则表达式所表示语言的一个说明：

* **规则1**：e是正则表达式，它表示{e},即包含空串的集合
* **规则2**：如果a是∑上的符号，那么a是正则表达式，表示{a},也就是包含符号串a的集合。虽然，我们使用相同的表示法，但正则表达式a、符号串a和符号a这三者的含义是不同的，可以从上下文中清楚地区分出所谈到的a的具体含义
* **规则3**：假定r和s都是正则表达式，分别表示语言L(r)和L(s),则：
1. `(r)|(s)`是正则表达式，表示`L(r)∪L(s)`
2. `(r)(s)`是正则表达式，表示`L(r)L(s)`
3. `(r)*`是正则表达式，表示`(L(r))*`
4. `(r)`是正则表达式，表示`L(r)`

正则表达式表示的语言叫做`正规集`

正则表达式的说明是一种递归定义。规则1、2是定义的基础。把e和出现在正则表达式中的∑中的符号称为*基本符号*，规则3提供了归纳的步骤.

1. 一元运算符`*`具有最高的优先级，并且是左结合的
2. 连接的优先级次之，也是左结合的
3. `|`的优先级最低，同样是左结合的

那么在正则表达式中可以避免一些不必要的括号。在此约定下,`(a)|((b)*(c))`等价于`a|b*c`。这两个表达式都表示由单个a构成的符号串或者由0个或多个b后面跟着一个c组成的符号串集合。

令`∑={a,b}`

1. 正则表达式`a|b`表示集合`{a,b}`
2. 正则表达式`(a|b)(a|b)`表示`{aa,bb,ba,bb}`,即由a和b组成的长度为2的符号串的集合。表示同样集合的另一正则表达式是`aa|ab|ba|bb`
3. 正则表达式`a*`表示由零个或多个a组成的所有串的集合`{e,a,aa,aaa,...}`
4. 正则表达式`(a|b)*`表示由零个或多个a或b构成的符号串集合，即由a和b构成的所有符号串的集合。这个集合也可用另一个正则表达式`(a*b*)*`来表示
5. 正则表达式`a|a*b`表示串a和零个或多个a后跟随一个b构成的符号串的集合。

如果两个正则表达式r和s表示同样的语言，则称r和s等价，记作`r=s`。例如，`(a|b)=(b|a)`.正则表达式遵循一些代数定律，它们可以用于正则表达式的等价变换。

下表示正则表达式r,s和t遵循的代数定律

公理|描述
-|-
`r|s=s|r`|`|`是可交换的
`r|(s|t)=(r|s)|t`|`|`是可结合的
`(rs)t=r(st)`|连接是可结合的
`r(s|t)=rs|rt`或`(s|t)r=sr|tr`|连接对`|`是可分配的
`er=r`或`re=r`|空串`e`是连接的单位元
`r*=(r|e)*`|`*`和`e`的关系
`r**=r*`|`*`是幂等的

#### 正则定义

为表示方便，希望为正则表达式命名，并用这些名字来定义正则表达式，就如同它们也是符号一样。如果∑是基本符号的字母表，那么正则定义是如下形式的定义序列：
```
d1->r1
d2->r2
...
dn->rn
```
其中，每个di都是一个名字，并且它们各不相同，每个ri是∑∪{d1,d2,...,dn-1}(即基本符号和前面定义的名字)中符号上的正则表达式。由于限制了每个ri中只含∑中的符号和在它之前定义的名字，所以可以通过反复地用名字所代表的正则表达式替代该名字的方法为任何一个ri构造∑上的正则表达式。如果ri用到了dj，并且j>=i,则ri是递归定义的，而且这个替换过程不会中止。

例子：如前面所述，Pascal语言的标识符集合是以字母开头的字母数字串的集合，这个集合的正则定义时

```
letter -> A | B | ... | Z | a | b | ... | z
digit -> 0 | 1 | ... | 9
id -> letter(letter|digit)*
```

Pascal语言中的无符号数是形如`5280`、`39.37`、`6.336e4`、`1.849E-4`这样的符号串，下面的正则表达式定义给出了这类符号串的精确说明
```
digit -> 0|1|···|9
digits -> digit digit*
optional_fraction -> .digtis|e
optional_exponent -> (E(+|-|e)digits)|e
num -> digits optional_fraction optional_exponent
```
在这个定义中，optional_fraction是空串(空缺)或小数点后再上一个或多个数字。注意，小数点后至少要有一个数字，所以num不能匹配1.,但能匹配1.0

#### 缩写表示法

在正则表达式中，某些结构出现频繁，为方便起见，我们可以用缩写形式表示它们。

* **一个或多个实例**-一元后缀操作符*的意思是“一个或过个实例”。如果`r`是表示语言`L(r)`的正则表达式，那么`(r)*`是表示语言`(L(r))*`的正则表达式。正则表达式`a+`表示由一个或多个a构成的所有串的集合。操作符`+`和操作符`*`具有同样的优先级和结合。代数恒等式`r*=r+|e`与`r+=rr*`表达了克林闭包和正闭包`+`这两个操作符间的关系。
* **零个或一个实例**-一元后缀操作符`?`的意思是“零个或者多个实例”。`r?`是`r|e`的缩写式。如果r是正则表达式，则`(r)?`是表示语言`L(r)U{e}`的正则表达式。例如，使用`+`和`?`操作符，可以重写上述的例子
```
digit -> 0|1|···|9
digits -> digit*
optional_fraction -> (.digits)?
optional_exponent -> (E(+|-)?digits)?
num -> digits optional_fraction optional_exponent
```
* **字符类**-`[abc]`(其中a、b和c是字母表中的符号)表示正则表达式`a|b|c`.缩写的字符类`[a-z]`表示正则表达式`a|b|···|z`。使用字符类，可以用下述正则表达式描述标识符：`[A-Za-z][A-Za-z0-9]`

#### 非正规集

某些语言不能用正则表达式描述。
* 正则表达式不能用于描述均衡或者嵌套结构。例如，具有配对括号的符号串集合不能用正则表达式描述，但它们可以用上下文无关文法来描述
* 重复符号串不能用正则表达式表示。集合{wcw|w是a和b组成的串}不能用正则表达式描述，也不能用上下文无关法来说明
* 正则表达式只能表示固定次数的重复或给定结构的没有指定次数的重复。由于正则表达式不能比较任意两个数是否相等，因此不能用正则表达式描述早期Fortran语言中形如nHa1a2...an的Hollerith字符串，因为H后面的字符数目要等于H前面的十进制数

### 记号的识别

考虑下述文法片段
```
stmt -> if expr then stmt
    | if expr then stmt else stmt
    | e
expr -> term relop term
    | term
term -> id
    | num
```

其中，终结符if、then、else、relop、id和num产生由以下正则定义给出的串的集合：
```
if -> if
then -> then
else -> else
relop -> < | <= | = | <> | > | >=
id -> letter(letter|digit)*
num -> digit+(.digit)?(E(+|-)?digit+)?
```
其中，letter和digit的定义与前面相同。

对这个给定的语言，词法分析器将识别关键字if、then、else和由relop(关系操作符)、id(标识符)和num(数)表示的词素。为简单起见，假定关键字是保留的，也就是说，它们不能作为标识符使用。类似于例3.5，这里的num表示Pascal中的无符号整数和实数。

此外，我们还假定词素由空白符分隔。空白符是空格、制表符、换行符组成的非空序列。词法分析器还要完成去掉空白符的任务。这个任务通过把输入串与如下的ws正规定义相比较来完成：
```
delim -> blank | tab | newline
ws -> delim+
```
如果发现了与ws匹配的字符串，则词法分析器不返回记号给语法分析器，继续识别空白符后面的记号，然后把它返回给语法分析器。

记号的正则表达式模式

正则表达式|记号|属性值
-|-|-
`ws`|-|-
`if`|`if`|-
`then`|`then`|-
`else`|`else`|-
`id`|`id`|指向符号表表项的指针
`num`|`num`|指向符号表表项的指针
`<`|`relop`|LT
`<=`|`relop`|LE
`=`|`relop`|EQ
`<>`|`relop`|NE
`>`|`relop`|GT
`>=`|`relop`|GE

目标是构造一个词法分析器，这个词法分析器能利用上表在**输入缓冲区**中识别出下一个记号的词素，产生该词素相应的记号和属性值的二元组。关系操作符的属性值由符号常量`LT`,`LE`,`EQ`,`NE`,`GT`和`GE`给出

#### 状态转移图(状态转移图)

作为构造词法分析器的中间步骤，先构造**状态转移图(transition diagram)**状态转移图描绘语法分析器为得到下一个记号而调用词法分析器时词法分析器要做的动作。

假设输入缓冲区为长度1024，并且词素开始(*lexeme-beginning*)指针指向上次发现的词素后面的字符。当向前指针扫描输入流字符时，用状态转换图来记录所读信息的轨迹，方法是在读字符的过程中不断地在状态转移图的各位置之间移动。

状态转换图的位置用圆圈表示，叫做*状态*,状态间由箭头连接，称为边。由状态s到状态r的边上标记的字符表示使状态r的输入字符。标记`other`表示任意一个未被离开状态s的边所标定字符。

假设状态转换图是*确定的*，即没有一个符号可以同时离开一个状态的两条以上的边的标记匹配。使词法分析器的设计更加简单。如果使用恰当的工具，词法分析器的实现会更加容易。

状态转换图中具有一个状态标记为`start状态`,这个状态称为`初始状态`。识别记号时，将从这个状态开始。有些状态可以具有动作，当控制流到达一个具有动作的状态时，将执行这些动作。当进入一个状态时，需要读入下一个输入字符。若存在一个离开当前状态的边，其标记和读入字符匹配，控制就转到有这条边指向的状态，否则表示失败。

通常可能有多个状态转移图，每个图说明一组记号。如果沿着一个状态转换图识别输入字符串失败，需要把前向指针回退到进入该图开始状态时该指针所指向的输入字符串位置，并启动下一个状态转换图。因为在状态转换图的开始状态，词法分析器的词素开始指针和向前指针都指向同一个位置，所以向前指针被回退到词素开始指针所指向的位置。

*注意：如果在所有状态转换图上都失败了，则意味着输入字符串有词法错误。这时，需要调用错误恢复程序进行错误处理*

例：因为关键字是字母序列，所以它们也符合标识符的规则，即由字母开头的字母和数字的序列。一般来说，不为关键字单独构造状态转换图，而是把关键字看成特殊的标识符。

**把关键字从标识符中分离出来的一种简单技术是适当地初始化符号表**:将关键字再一开始就存入符号表。

对于上表中的记号，需要在开始扫描输入字符之前把字符串if、then和else填入符号表。这些符号的记号也将被记录在符号表中，以便它们在输入字符串中被识别出来，返回它们的记号。使用return语句分别使用gettoken()和install_id()来获得要返回的记号和属性值。过程install_id()访问缓冲区，标识符词素被定位在其中，并用该词素查符号表，如果在符号表找到了该词素，当它被标记为关键字时，install_id()返回0，当它是程序变量时,install_id()返回返回指向相应符号表表项的指针。如果在符号表中没有找到该词素，则把该词素作为变量填入符号表中，并返回指向新建表项的指针。

过程gettoken()也以类似的方式在符号表中查找词素。如果该词素是个关键字，则返回相应的记号，否则返回记号`id`.

**如果有要增加的关键字，无需修改状态转换图，只需将新增关键字对应的字符串和记号填入符号表即可**

如果不把关键字预先放入符号表，一个典型的程序设计语言的词法分析器的状态数会达到几百个。如果使用这种技术，需要的状态数可能不到一百个

```
num -> digit+(.digit)?(E(+|-)?digit+)?
```
一个给定记号的词素必须是最长的。例如，当输入串是`12.3E4时`，词法分析器不应该在发现`12`或`12.3`后就停止。这里假设`12.3E4`后面是一个非数字的字符。

一种避免多余匹配的方法是将这些状态转换图合并成一张图，一般来说这个任务比较艰巨。另一种方法是改变对失败的响应策略。

#### 状态转换图的实现

状态转换图序列可以变换成程序，用来识别该序列所定义的记号。我们将采用对所有状态转换图都适用的系统化方法来构造程序，该程序的大小与图中状态数和边数成正比。

每个状态对应一个代码段。如果一个状态具有出边，该状态的代码便读一个字符并选择应跟随的边。函数nextchar()用来从输入缓冲区中读入下一个字符，每次调用都向前移动指针，并返回读入的字符。如果存在标记为该字符的边，或标记为包含该字符的字符类的边，则控制转给这条边指向的状态所对应的代码。如果不存在这样的边，而且当前状态不是接收状态，调用fail()程序，把向前指针撤回到开始指针指向的位置，气动下一个状态转换图对应的代码继续匹配。如果不存在下一个状态转换图。fail()调用错误恢复程序，进行错误处理。

用全局指针变量lexical_value返回记号。当识别出一个标识符或一个数时，lexical_value被赋值为install_id()和install_num()过程返回的指针。记号类由词法分析器的主过程nexttoken()返回。

使用case语句查找下一个状态转换图的开始状态。在下述的实现中，两个变量state和start分别用来保存当前转换图的当前状态和起始状态。

```c
int state = 0, start = 0;
int lexical_value; /* 返回记号的第二个分量 */
int fail()
{
    forward = token_beginning;
    switch (start) {
        case 0: start = 9; break;
        case 9: start = 12; break;
        case 12: start = 20; break;
        case 20: start = 25; break;
        case 25: recover(); break;
        default: /* 编译错误 */
    }
    return start;
}
```

下述给出了状态0对应的代码,在状态转换图中一条边一条边地往下匹配的过程是通过不断地选择一个状态对应的代码段来执行，以确定出下一个状态，并将控制转到该状态对应的代码段去执行。

```c
token nexttoken()
{
    while(1) {
        switch (state) {
            case 0:
                /* c是超前扫描字符 */ 
                c = nexychar();
                if (c == blank || c == tab || c == newline) {
                    state = 0;
                    lexeme_beginning++;
                    /* 词素开始指针的前移 */
                }
                else if (c == '<') state = 1;
                else if (c == '=') state = 5;
                else if (c == '>') state = 6;
                else state = fail();
                break;
            case 9:
                if (isletter(c)) state = 10;
                else state = fail();
                break;
            case 10:
                if (isletter(c)) state = 10;
                else if (isdigit(c)) state = 10;
                else state = 11;
                break;
            case 11:
                retract(1);
                install_id();
                return gettoken();
            case 25:
                if (isdigit(c)) state = 26;
                else state = fail();
                break;
            case 26:
                c = nextchar();
                if (isdigit(c)) state = 26;
                else state = 27;
                break;
            case 27:
                retract(1);
                install_num();
                return NUM;
        }
    }
}
```

C代码while(1) `stmt` 会不断地重复执行`stmt`，直到遇见一个return为止。由于C语言不允许同时返回记号和属性值，所以`install_id()`和`install_num()`用全局变量来存放对应于**id**和**num**表项的属性值

如果实现状态转换图的语言没有case语句，可以为每个状态创建一个数组，用字符作下标。如果state1是这样的数组，则当超前扫描的字符是c时，`state1[c]`是指向需要执行的程序段的指针。这些代码段一般以转到下一个状态的代码段的goto语句结束。状态s的数组可以看成是s的间接状态转换表

### 词法分析器描述语言

目前有很多基于正则表达式从特定表示法构建词法分析器的工具。可以用正则表达式来描述记号模式，也可把正则表达式转换成模式匹配程序的算法之前。

Lex编译器广泛用于各种语言的词法分析器的描述，Lex编译器的输入称为Lex语言。讨论现有的工具的目的在于说明如何把*正则表达式*描述的模式与行为(如在符号表创建表项，这是词法分析器需要做的动作)结合起来。

Lex的使用方法

* 首先使用Lex语言写一个定义词法分析器的源程序lex.l
* 然后利用Lex编译器将lex.l转换成C语言程序lex.yy.c。它包括从lex.l的正则表达式构造的状态转换图的表格形式以及使用该表格识别词素的标准子程序。与lex.l中正则表达式相关联的动作是C代码段，这些动作可以直接加到lex.yy.c中。
* 最后，lex.yy.c通过C编译器生成目标程序a.out,a.out就是把输入流转换成记号序列的词法分析器

#### Lex说明

一个Lex程序由如下三部分组成:

* **声明部分**
* **转换规则**
* **辅助过程**

声明部分包括变量声明、符号常量声明和正则定义。（符号常量是被声明来表示常数的标识符。）

Lex程序的转换规则是如下形式的语句：

```
p1 {action_1}
p2 {action_2}
...
pn {action_n}
```

其中每个p是一个正则表达式，每个action表示当模式p匹配上一个词素后词法分析器所要执行的程序段。在Lex中，这些action是用C语言编写的，当然也可以用其他语言来实现。

Lex程序的第三部分包含action所需要的辅助过程。这些过程可以单独翻译，并与词法分析器一起装载。

由Lex创建的词法分析器与语法分析器协同工作的方式如下：词法分析器被语法分析器调用后，从尚未扫描的输入字符串读字符，每次读入一个字符，直到发现能与某个正则表达式pi匹配的最长前缀。然后，词法分析器执行action。通常action会将控制返回给语法分析器。然而，如果不讲控制交给语法分析器，词法分析器可以继续发现更多的词素，直到某个操作将控制返回给语法分析器。词法分析器的这种不断查找词素，直到以显式的return调用结束工作的方式，使其可以方便地处理空白符和注释。

词法分析器只返回记号给语法分析器，带有与词素相关信息的属性值是通过全局变量yylval传递的。

Lex的特点：在声明部分，可以看到转换规则所使用的符号常量的声明。这些声明被一对特殊括号%（和%）括在一起。所有出现在括号内的内容都直接复制到词法分析器lex.yy.c中。它们不作为正则定义或转换规则的一部分。对第三部分的辅助过程也进行同样的处理。

在声明部分还包含一些正则定义。每个定义有一个名字和这个名字所代表的正则表达式组成。例如，第一个名字定义为delim，它代表字符类`[\t\n]`,即空格、制表符(由`\t`表示)、换行符(由`\n`表示)三者之一。第二个是关于空白符定义，由名字ws表示。空白符是一个或多个分隔符组成的序列。注意：在Lex中词delim必须由大括号括起来以便与包含delim这五个字符的模式区别开。

在`letter`的正则定义中使用了字符类.`[A-Za-z]`表示大写字母A到Z或小写字母a-z中的任何一个。在id的定义(第5个定义)中使用了圆括号，圆括号是Lex语言的元符号，与通常情况下的含义相同，表示包括。类似，竖也是Lex语言的元符号，表示并。

在number的正则定义中可以看到更多的细节。？是元符号，表示出现过0次或一次。反斜杠被当成转义字符，使得Lex的元符号能表示它的本来意义。在number的定义中，小数点表示成`"\."`,因为在Lex和很多UNIX系统的处理正则表达式的程序中，单独的一个点表示除了换行符以外的所有字符的字符类。在字符类`[+\-]`中，减号前面的反斜杠是为了避免与减号表示范围的用法混淆.如`[A-Z]`

```lex
%{
    /* 符号常量定义
    LT, LE, EQ, NE, GT, GE,
    IF, THEN, ELSE, TD, NUMBER, RELOP  */
%}

/* 正则定义 */
delim    [ \t\n]
ws       [delim]+
letter   [A-Za-z]
digit    [0-9]
id       {letter}({letter}|{digit})*
number   {digit}+(\.{digit}+)?(E[+\-]?{digit}+)?

%%

{ws}     {/* 没有动作和返回值 */}
if       {return(IF);}
then     {return(THEN);}
else     {return(ELSE);}
{id}     {yylval = install_id(); return(ID);}
{number} {yylval = install_num(); return(NUMBER);}
"<"      {yylval = LT; return(RELOP);}
"<="     {yylval = LE; return(RELOP);}
"="      {yylval = EQ; return(RELOP);}
"<>"     {yylval = NE; return(RELOP);}
">"      {yylval = GT; return(RELOP);}
">="     {yylval = GE; return(RELOP);}

install_id() {
    /* 往符号表中填入词素的过程。yy_text 指向词素的第一个字符，yyleng表示词素的长度。将词素填入符号表，返回指向该词素所在表项的指针 */
}

install_num() {
    /* 与填词素的过程类似，只不过词素是一个数 */
}
```

还有一种方法能使字符保持本来的意义，即使他们是Lex的元符号。这种方法就是用引号把字符括起来。在转换规则部分，使用了这种方法来表示六个关系操作符。

现在，在考虑跟在第一个%%后面的转换规则。第一条规则表示如果发现ws(任何由空格、制表符和换行符组成的最长序列)则不做任何动作，控制也不返回给语法分析器，词法分析器继续识别记号，直到与某一个记号关联的动作调用的return语句。

第二条规则表示如果识别出`if`,则返回记号IF,它是表示某个整数的符号常量，语法分析器将这个整数理解为记号**if**。类似地，接下来的两条规则用来识别关键字then和else。

在**id**的规则中，关联动作的有两条语句。第一条语句将过程install_id的返回值赋给变量yylval，该过程的定义在第三部分给出。变量yylval是在Lex的输出lex.yy.c中定义的。语法分析器也可以访问这个变量。使用yylval的目的是保存词素的属性值，因为return (ID)语句(即第二个语句)只能返回记号类。

install_id的详细代码，Lex使用两个变量yytext和yyleng来保证第三部分的程序能够访问匹配的词素。变量yytext就是前面介绍的词素lexeme_beginning(开始指针)，即指向词素的第一个字符位置的指针。变量yyleng存放词素的长度。如果install_id在符号表中没有找到这个词素，则为它创建一个新的表项，输入流中从yytext开始的yyleng个字符被复制到一个字符数组中，并以一个字符串结尾符做结束标记，在符号表的新表项中填入一个指向这个字符起始位置的指针。

接下来的一条规则以类似的方式处理数。在最后的操作符六条规则中，yylval用来返回识别出的关系操作符对应的代码，而实际上对这个六个关系操作符返回的都是记号relop的代码。

一按一个匹配的词素是if。模式if和{id}均匹配这个词素，并且没有能匹配更长串的模式。匹配关键字if的模式先于匹配标识符的模式执行，所以if被匹配为关键字。

**采用将匹配关键字的模式置于匹配标识符的模式之前的策略，可以简单有效地保留关键字**

例子：假设读入的头两个字符是`<=`.模式`<`匹配上第一个字符，但它不是能匹配输入字符串的最长前缀的模式。Lex采用**选择最长匹配前缀的策略**方便地解决了`<`和`<=`之间的冲突。这里，当然`<=`被选择作为下一个记号。

#### 超前扫描操作

对于某些程序设计语言结构，词法分析器需要超前扫描词素后面的若干字符来确定一个记号

词法分析器在输入缓冲区超前地扫描一串字母或数字，接着扫描等号以及后面的一串字母或数字，最后扫描到逗号才能够判断出这不是一个赋值语句。但只有超前扫描符前面的D和O才是与模式匹配的词素的部分。经过成功的匹配，yytext指针指向字符D并且yyleng=2。注意，这个简单的超前扫描模式使得当DO后面跟着一些无意义的符号

在Lex中，可以把模式写成`r1/r2`的形式，其中r1和r2都是正则表达式。它的意思是当一个字符串与r1匹配时，还需其后的字符串与r2匹配，这样才算该字符串与r1匹配成功。在超前扫描操作符`/`，还需要其后的字符串与`r2`匹配，这样才算该字符串与`r1`匹配成功。在超前扫描操作符`/`后面的正则表达式`r2`表示需要进一步匹配的内容，这里它只是匹配模式的一个限制，而不是匹配的一部分。

```
DO/({letter}|{digit})* * ({letter}|{digit})*
```

超前扫描操作符还可以用来解决Fortran词法分析中的另一个难题：区别关键字和标识符。例如：`IF(I, J) = 3`是一个正确的赋值语句，而不是一个逻辑判断if语句。使用Lex描述关键字IF的一种方法是使用超前扫描操作符定义IF右边的正文。

识别关键字IF的模式可以写为(连带匹配其后的括号):

```
IF / \( .* \) {letter}
```

其中的圆点表示除了换行符以外的任何字符，而括号前面的反斜杠表示括号取其本来的意思，而不是正则表达式中的元符号

处理Fortran的if语句问题的另外一种方法是：当看到字符串`IF(`,先确定IF是否被声明为数组。如果是，才去匹配上面给出的整个模式。这样的检查使得由Lex说明自动实现一个`词法分析器`变得很难，而且它们在运行时可能耗费更多的时间，因为要由模拟状态转化图的程序频繁地判断是否要进行这样的检查。

### 有穷自动机

语言的`识别器`是一个程序，它以字符串x作为输入，当x是语言的句子时，回答“是”，否则回答“不是”。可以通过构造有穷自动机把正则表达式翻译成识别器。有穷自动机是更一般化的状态转换图，它可以是确定的或不确定的，其中“不确定”的含义是：对于某个输入符号，在同一个状态上存在不止一种转换。

确定和不确定的有穷自动机都能而且仅能识别正则集，即它们能够识别正则表达式所表示的语言。但是，它们之间有着**时空的权衡**,确定的有穷自动机导出的识别器比不确定的有穷自动机导出的识别器快得多，但确定的有穷自动机可能比与之等价的不确定的有穷自动机的方法。由于变成不确定的自动机更直接一些。

例如，表示所有以`.o`结尾的文件名的正则表达式是(.|o|c)*.o,其中c代表除.和o以外的任何字符。又如，C语言的注释是由开括号`/*`之后以`*/`结尾的任意字符序列组成的，其任何真前缀都不以`*/`结尾

#### 不确定的有穷自动机

不确定的有穷自动机(简写为NFA)是有个有以下几部分组成的数学模型：

* 一个状态的有穷集合S
* 一个输入符号集合∑，即输入符号字母表
* 一个转换函数move，它把由状态和符号组成的二元映射到状态集合
* 状态s0是唯一的*开始*或者*初始*状态
* 状态集合F是接收(或终止)状态集合

NFA可以用带标记的有向图表示，称为**转换图(transtion graph)**,其节点是状态，有标记的边表示转换函数。这种转换图和前面所讲的**状态转换图(transtion diagram)**很类似，但略有区别：同一个字符可以标记始于同一个状态的两个或多个转换，边可以由输入字符符号，也可以由特殊符号e标记。

可以在计算机上使用不同的方法实现NFA的转换函数。最简单的办法是使用转换表。转换表的每个状态占一行，每个输入符号占一列。表中第i行a列对应的表项是当输入为a时从状态i所能到达的状态的集合(实际上它很可能是指向状态集合的指针)

转换表表示的优点是能够快速地确定给定状态在给定字符上的转换。它的缺点是：当输入字母表较大而且大多数转换是空集时，需要耗费大量空间。转换函数的**邻接表表示法**能提供较紧凑的实现，但在确定一个给定的转换时速度较慢。

例：识别语言`(a|b)*abb`的NFA状态转换图，这个NFA的状态集合是{0,1,2,3}

当且仅当对应的转换图存在从开始状态到某个接受状态的路径，使得该路径的边上的标记恰好连城字符串x时，一个NFA接收输入字符串x。上述的NFA可以接受输入串`abb`,`aabb`,`babb`,`aaabb`,...例如，从状态0开始，沿着标记为a的边再回到状态0，然后沿着标记分别为a,b,b的边进入状态1,2,3.

一条路径可以用状态转换序列表示，其中的状态转换叫做移动。

#### 确定的有穷自动机

确定的有穷自动机(DFA)是不确定的有穷自动机的特例，其中：

* 没有一个状态有e换换，即在输入e上的转换
* 对每个状态s和输入符号a，最多只有一个标记为a的边离开s

确定的有穷自动机在任何状态下，对任一输入符号，最多只有一个转换。如果用转换表表示DFA的转换函数，那么表中的每个表项最多只有一个状态。因而，很容易确定DFA是否接受某输入字符串，因为从开始状态起，最多只有一条到达接受状态的路径可由这个符号串标记。

下边的算法说明怎样在一个输入串上模拟DFA的行为。

```
s := s0
c := nextchar
while c != eof do
end
if s is in F then
    return "yes"
else return "no"
```

输入以文件结束符eof结尾的串x，一个DFA D，其开始状态为s0，接受状态集合为F。输出：如果D接受x，则回答“yes”，否则回答“no”。方法：把图3-22的算法应用于输入字符串x。函数move(s, c)给出状态s上遇到的输入字符c时应该转换到的下一个状态。函数nextchar返回输入串x的下一个字符。

#### 从NFA到DFA的转换

多值转换函数使得很难用计算机程序模拟NFA。“接受”的定义仅仅是说必然存在一条从开始状态到某个接受状态的路径，该路径的标记是输入字符串。如果有很多路径其边上的标记都可以连成同样的输入字符串，则在找到一条接受路径或发现没有路径可到达接受状态前，可能不得不考虑所有这些路径

从NFA构造识别同样语言的DFA算法：这个算法通常被称为子集构造算法，有利于使用计算机程序模拟NFA。一个和它紧密相关的算法在下一章构造LR语法分析器时将起到重要作用

在NFA的转换表中，每个表项是一个状态集；而在DFA的转换表中，每个表项只有一个状态。从NFA变换到DFA的基本思想是让DFA的每个状态对应NFA的一个状态集。这个DFA用它的状态去记住NFA在读输入符号后到达的所有状态。这个子集T是从NFA的开始状态沿着那些标有a1a2...an的路径能达到的所有状态的集合。DFA的状态数有可能是NFA状态数的指数。

**子集构造算法**

输入：一个NFA N

输出：一个接受同样语言的DFA D

方法：为D构造转换表Dtram，DFA的每个状态是NFA的状态集，D将“并行”地模拟N对输入串的所有可能的移动

用下表的操作来记录NFA的状态集的轨迹(是代表NFA的状态，T代表NFA的状态集)

在读入一个输入符号前，N可以处于集合e-closure(s0)中的任何状态上，其中s0是N的开始状态。假定从s0出发经过输入字符串上的一系列移动，N到达集合T中的状态。令a是下一个输入符号。遇到a时，N可以移动到集合move(T,a)中的任何状态。由于由于e转换，遇到a以后，N可以处于e-closure(move(T, a))中的任何状态

操作|描述
-|-
e-closure(s)|从NFA状态s只经过e转换可以到达的NFA状态集
e-closure(T)|从T中的状态只经过e转换可以到达的NFA状态集
move(T,a)|从T的状态s

```
初始时，e-closure(s0)是Dstates中唯一的状态且未被标记；
while Dstates中存在一个未标记的状态T do begin
    标记T：
    for 每个输入符号a do begin
        U := e-closure(move(T, a))
        if U 没在Dstates中 then
            将U作为一个未标记的状态添加到Dstate中；
        Dtran[T,a] := U
    end
end
```

```
将T中所有的状态压入栈stack中；
将e-closure(T)初始化为T；
while 栈stack不空 do begin
    将栈顶元素t弹出栈；
    for 每个这样的状态u：从1到u有一条标记为e的边 do
        if u 不在e-closure(T) do begin
            将u添加到e-closure(T);
            将u压入栈stack中
        end
end
```

按上述的方法构造D的状态集合Dstates和D的转换表Dtram。D的每个状态对应于NFA的一个状态集，它是N读了某个输入符号序列后所能到达的全部状态，包括所有的e转换。D的开始状态是e-closure(s0)。使用上述的算法构造D的状态和转换。如果D的某个状态是至少包含一个N的接受状态的NFA的状态集，那么它是D的一个接受状态。

e-closure(T)是一个典型的从给定节点集合出发在转换图上搜索可达节点集的过程。这里，T的状态是给定的节点集合，转换图中只包含NFA中由e标记的边。计算e-closure(T)的简单算法是用栈来保存其边还没有完成e转换检查的状态。

例子：接受语言`(a|b)*abb`的另一个NFA N

这里的输入符号表是{a,b}。图中给出的算法告诉我们要先标记A，然后计算e-closure(move(A,a)).让我们首先计算move(A,a)，即对输入a从A状态可以转换到的N的状态集。在状态0，1，2，4和7中只有2和7有a上的转换，分别到达状态3和8.

e-closure(move({0,1,2,4,7}, a)) = e-closure({3,8}) = {1,2,3,4,6,7,8}

我们称这个集合为B。于是，`Dtran[A, a] = B`

在A中只有状态4对输入b有一个转换(转换到状态5)，所以DFA对输入b有一个从A到C的转换，其中C=e-closure({5}) = {1,2,4,5,6,7}.因此`Dtran[A,b] = C`

对新的没标记过的集合B和C继续这个过程，最终会使得所有的集合(即DFA的状态)都已标记过。因为包含11个状态的集合其不同子集“只有”2^11个，而且一个集合一旦被标记就永远是标记的，所以这个过程肯定能终止。最终，实际构造出的5个不同的状态集合是：
```
A = {0, 1, 2, 4, 7}
B = {1, 2, 3, 4, 6, 7, 8}
C=  {1, 2, 4, 5, 6, 7}
D = {1, 2, 4, 5, 6, 7, 9}
E = {1, 2, 4, 5, 6, 7, 10}
```

### 从正则表达式到NFA

从正则表达式建立其识别器的策略很多，各有优劣。其中有一个策略常用语文本编辑程序，该策略先使用本节将要介绍的算法从正则表达式构造NFA，然后利用算法NFA在输入串上的行为，若想提高运行速度，可以利用子集构造法把NFA变成DFA，

本节介绍一种直接由正则表达式构造DFA而无需建立过渡的NFA的方法。本节还将讨论基于NFA和DFA的识别器的实现在时间与空间复杂性的权衡问题。

#### 从正则表达式构造NFA

语法制导算法，该算法使用正则表达式的语法结构来制导构造过程。算法的分支遵循正则表达式定义的分支。首先构造自动机使其能够识别e和字母表中的任何符号，然后由此构造自动机来识别包含一个交换、一个连接或一个`克林闭包(closure)`运算符的正则表达式。例如，对于正则表达式r|s,可以从r和s的NFA构造出它的NFA。

在构造过程中，每步最多引入两个新的状态，于是，为一个正则表达式构造的最终NFA的状态数最多两倍于该正则表达式中符号和操作符数

算法 **(Thompson构造法)**，从正则表达式构造NFA

输入：字母表∑上的一个正则表达式r

输出：接受L(r)的NFA N

方法：首先，分析r并将其分解成最基本的子表达式，然后使用下面的规则1和规则2为r中的每个基本符号(e或字母表中的符号)构造NFA。基本符号对应正则表达式定义的1和2两部分。请注意，如果符号a在r中出现多次，则要为它的每次出现构造一个NFA。

然后，由正则表达式r的语法结构制导，用下面的规则3逐步地组合前面构造的NFA。直到获得整个正则表达式的NFA为止。在构造过程中所产生的中间NFA（与r的子表达式对应）有几个重要的性质：只有一个终态；开始状态无入边，终态无出边。

1. 对e，构造NFA，其中,i是新的开始状态，f是新的接受状态。很明显这个NFA识别{e}.

2. 对于∑中的每个符号a，构造NFA。同样，i是新的开始状态，f是新的接受状态。

3. 如果N(s)和N(t)是正则表达式s和t的NFA

对于正则表达式s|t,可构造复合的NFA N(s|t)如下：

这里i是新的开始状态，f是新的接收状态。从i到N(s)和N(t)的开始状态有e转换，从N(s)和N(t)的接受状态到f也有e转换。N(s)和N(t)的开始和接受状态不是N(s|t)的开始和接受状态。这样，从i到f的任何路径必须独立完整地通过N(s)或N(t),因此这个复合的NFA识别L(s)∪L(t).

这里，N(s)的开始状态称为复合后的NFA的开始状态，N(t)的接收状态称为复合后的NFA的接受状态。N(s)的接受状态和N(t)的开始状态合并，也就是说N(t)的开始状态上的所有转换现在变成了N(s)的接受状态上的转换。合并后的状态不作为复合后的NFA的接受或开始状态。从i到f的路径必须首先经过N(s)，然后经过N(t),所以路径上的标记是L(s)L(t)中的串。因为没有边进入N(t)的开始状态或离开N(s)的接受状态，所以从i到f的路径不能从N(t)回到N(s)，因此复合的NFA识别L(s)L(t)

(c) 对于正则表达式s*,可构造复合的NFA N(s*)如下：

在此，i和f分别是新的开始状态和接受状态。在这个复合的NFA中，可以沿着一条标记了e边直接从i到达f，这表示e属于(L(s))*。我们还可以从i经过一次或多次N(s)到达f。显然，这个复合的NFA识别(L(s))

(d) 对于括起来的正则表达式(s),使用N(s)本身作为它的NFA

上述算法构造的每一步都产生识别对应语言的NFA。此外，产生的NFA具有下列性质：

* N(r)的状态数最多是r中符号和运算符个数的两倍
* N(r)只有一个开始状态和一个接受状态，接受状态没有出边。作为构成成分的每个自动机也具有这一性质
* N(r)的每个状态或者有一个用∑中的符号标记的出边，或者至多有两个标记为e的出边

#### NFA的双堆栈模拟

算法每次从输入字符串读取一个字符，然后计算自动机N在读入输入字符串的每个前缀后可能进入的所有状态的集合。这个算法利用算法3.3生成的NFA的一些特殊性质，有效地计算非确定的状态集合。这个算法的运行时间与N*x成正比，其中|N|表示N的状态数，|x|表示串x的长度

算法3.4  模拟NFA

```
S := e-closure({s0})
a := nextchar
while a != eof do begin
    S := e-closure(move  )
end
if s ∩ F != ∅ then
else return "no"
```

输入：由算法3.3生成的NFA N和输入串x。假定输入串x由字符eof做结束标记，N以状态s0为开始状态，F是接受状态集

输出：如果N接收x，则返回"yes"，否则返回"no".

方法：把上述算法应用到输入串x。这个算法在运行时执行了*子集构造算法*。它分两步计算从当前的状态集到下一个状态集的转换。第一步，它先求move(S,a),即状态S在输入a(当前输入字符)上经过一个转换能到达的所有状态集合。第二步求出move(S,a)在经过0个或多个e转换后能到达的状态集。算法每次使用函数nextchar从输入字符串x读入下一个字符。当x中的所有字符都读完后，如果接受状态在当前集合S中，则返回“yes”，否则返回“no”。

算法3.4可以使用两个堆栈和由NFA状态做索引的位向量来有效地实现。一个堆栈用于跟踪非确定状态的当前集合的轨迹，另一个堆栈用于计算下一个非确定状态集。

使用位向量可以在常数时间内判断一个非确定状态是否已在堆栈中，以防重复加入。一旦已经在第二个栈求出了下一个状态，则两个栈的角色互换。由于每一个非确定状态至多有两个输出边，因此每个状态在一个转换中至多会增加两个新状态。我们用M表示N的状态数。因为一个栈中至多有|N|个状态，所以计算当前状态集的下一个状态集的时间与|N|成正比。因此，模拟N在输入字符串x上的行为需要的时间正比于|N|*|x|

注意：算法3.4是在运行时执行子集构造算法的。例如，比较上述的转换的NFA苟傲的DFA状态图。开始状态集和读a后可达到的状态集对应着DFA的A和B状态。

#### 时间空间的权衡

给定一个正则表达式r和输入字符串x，算法3.3为r构造一个NFA N。这种构造法的时间复杂性是O(|r|)，其中|r|是r的长度。N至多具有两倍于|r|的状态，每一个状态至多有两个转换，因此N的转换表的空间复杂性是O(|r|).使用算法3.4判断N是否接受字符串x，其时间复杂性是O(|r|*|x|).使用这种方法判断x是否在L(r)中的时间代价正比于r的长度和x长度的乘积。在很多文本编辑器中，当目标字符串x不是很长时，可以用这种方法寻找正则表达式模式。

第二种方法是先用Thompson构造法(算法3.3)从正则表达式r构造其NFA，然后再用子集构造法（算法3.2）构造NFA。我们利用转换表实现状态转换函数，并使用算法3.1模拟DFA在输入串x上的动作。这个算法时间代价与x的长度成正比，但与DFA的状态数无关。这种方法经常用于在文本文件中寻找正则表达式模式的模式匹配程序。一旦有穷自动机创建成功，查找的速度非常快。当目标串非常长时，这种方法是很有利的。

然而，存在一些正则表达式，它们的最小DFA也有很多状态，其状态数是正则表达式大小的指数。例如，若正则表达式`(a|b)*a(a|b)(a|b)...(a|b)`包含n-1个(a|b),则识别该正则表达式的任意DFA的状态数不可能少于2^n。这个正则表达式表示a和b的字符串，这个字符串的倒数第n个字符是a。

另一种方法是使用DFA，但通过利用“惰性转换计算”技术来避免创建整个状态的转换表。转换是在运行时计算的，只有在真正需要的时候才去计算给定状态在给定输入上的转换。计算的转换存储在cache中。每次要进行状态转换时，先检查cache。如果需要的转换步子cache中，我们才去计算它，并将其存入cache。如果cache满了，可以清除一些旧的转换，为新的转换腾出空间。

下标总结了用从NFA和DFA构造的识别器判断输入字符串x是否在由正则表达式r表示的语言中所需的最坏的时间、空间复杂性。“惰性”技术结合了NFA的空间需求小和DFA的时间需求小的特点。它的空间需求是正则表达式的大小加上cache的大小。它的运行时间几乎与DFA识别器相同。在某些应用中，“惰性”技术比DFA方法还要快，因为它没有计算不必要的状态转换。

自动机|空间|时间
-|-|-
NFA|`O(|r|)`|`O(|r|*|x|)`
DFA|`O(2^|r|)`|`O(|x|)`

### 设计词法分析器的生成器

构造一个在输入缓冲区中查找词素的识别器。如果有多个模式匹配成功，识别器将选择与最长词素匹配的模式。如果有多个模式与最长词素匹配，则选择第一个与最长词素匹配的模式。

有穷自动机是一种创建词法分析器的自然模型。由Lex编译器构造出的**词法分析器**由一个**输入缓冲区**，缓冲区有两个指针，其中一个是词素的**开始指针**，另一个是词素的**向前指针**。

Lex编译器根据使用Lex说明书写的正则表达式模式为有穷自动机构造转换表。词法分析器本身包括一个有穷自动机模拟器，这个模拟器使用转换表在输入缓冲区中查找正则表达式模式。

#### 基于NFA的模式匹配

一种基于NFA的模式匹配方法是为模式p1,p2,...,pn的NFA N构造状态转换表。为此，可以先使用算法3.3为每个模式pi构造NFA N(pi)，然后加入一个新的开始状态s0，并用e转换将s0和每个N(pi)的开始状态相连。

NFA修改必须保证该NFA能识别输入字符串中被匹配的最长前缀。在这个NFA中，每一个模式pi都有一个接受状态。当使用算法模拟NFA时，构造一个状态集序列，其中每个状态集都是NFA看到每个输入字符后能够进入的状态集。即使在一个状态集中包括了一个接受状态，但为了实现最长的匹配，仍需继续模拟NFA,穷尽当前输入符上的所有转换，即到达一个终止。

通常，所写的Lex说明总能使某个模式（也可以是错误模式）匹配成功。如果没有一个模式能匹配成功，则意味着没有把错误情况考虑周全，此时词法分析器需要把控制转给某个默认的错误恢复程序。

#### 词法分析器的NFA

从Lex说明构造词法分析器的另一种方法是使用DFA完成模式匹配。这种方法与上面描述的对NFA的模拟完全类似，知识在确定正确的模式匹配时有一些细微的差别。当使用子集构造算法进行NFA到DFA的转换时，在一个非确定状态的子集中可能会有多个接收状态。在这种情况下，在Lex说明中位置靠前的模式对应的接受状态具有优先权。类似于模拟NFA，在穷尽对当前的输入符号的转换之前，还需要继续进行状态转换。为了找到匹配的词素，需要将缓冲区的向前指针返回到DFA最后一次进入道接受状态时的位置上。

#### 实现超前扫描操作

由于在某些情况下表示特定记号的模式可能需要描述实际词素后面的一部分正文，所以需要使用超前扫描操作符`/`。将一个含有`/`的模式转换成NFA时，可以将l看成e，使得不用真正地在输入字符串中查找`/`.然而，当由这样的正则表达式表示的字符串在输入缓冲区被识别出来时，词素的末尾并不在NFA的接受状态的位置上，而是在最后一个在（假想的）`/`上具有转换的状态上

### 基于DFA的模式匹配器的优化

构建算法能小化DFA的状态数，所以可用于减小基于DFA的模式匹配器的大小。这个算法是高效的，其运行时间O(nlgn),n是NFA中的状态数。

#### NFA的重要状态

如果一个NFA状态有一个标记为非e的出边，则称这个状态是重要状态。子集构造在确定e-closure(move(T,a))时只使用了子集合T中的重要状态。仅当状态s是重要的，集合move(s,a)才是非空的。在构造过程中，两个子集可以被认为是等同的，如果它们的重要状态相同并且两者同时包含或不包含NFA的接受状态。

当子集构造法被应用由正则表达式经算法3.3生成的NFA时，可以利用NFA的特殊性质来将两种构造方法合二为一。合并的构造法把NFA的重要状态与出现在正则表达式中的符号相关联。只有字母表上一个符号出现在正则表达式中时，Thompson构造法才创建一个重要状态。例如，对于`(a|b)*abb`,Thompson构造法为每个a和b创建重要状态

结果NFA有且只有一个接受状态，但该接受状态不是重要的，因为它没有出边。通过在正则表达式r右端连接一个唯一的结束符`#`，我们给r的接受状态增加一个`#`上的转换，使它成为NFA的重要状态。换句话说，通过使用扩展的正则表达式`(r)#`，在子集构造过程中可以忽略接受状态。当构造结束时，任何在`#`上有转换的DFA的状态都是接受状态。

用语法树表示扩展的正则表达式。语法树的叶结点表示基本符号，内节点表示操作符。如果一个内节点被标记为连接1或*操作符，则分别称其为cat-节点、or-节点或star-节点。

正则表达式语法树的叶节点由符号表中的符号或e标记。对于每一个非e标记的叶节点，分配一个唯一的整数，这个整数表示叶节点的位置，同时也表示对应符号的位置。一个重复出现的符号会有多个位置。位置标记在符号的下边。NFA中被编号的状态对应着叶节点的位置。这些状态是NFA的重要状态，非重要状态用大写字母来表示

#### 从正则表达式到DFA

从扩展的正则表达式`(r)#`构造DFA。首先为正则表达式`(r)#`构造一个语法树T，然后通过遍历这棵语法树计算*nullable*,*firstops*,*lastops*和*followpos*四个函数。最后由`followpos`构造DFA.函数*nullable*,*firstops*和*lastops*定义在语法树的节点上，用于计算函数followpos，而函数followops定义在位置集合上

利用NFA的重要状态和正则表达式语法树的叶节点的等价性，可以绕过NFA的构造而直接构造一个其装填对应语法树的位置集合的DFA。NFA的e转换表示相当复杂的位置结构。特别地，它包含了这样的信息：什么时候一个位置可以跟随另一个位置，即输入到DFA的字符串中的每一个符号都可以被一个位置匹配。一个输入符号c只能由具有符号c的位置匹配，但不是每一个具有符号c的位置都一定匹配输入字符串中c的一次出现

一个位置匹配一个输入符号的概念将由函数followpos定义。如果i是一个位置，那么followpos(i)是满足如下条件的位置j的集合：对于某个输入字符串...cd...,位置i对应着c的出现，位置j对应着d的出现

算法 从正则表达式r构造DFA

输入：正则表达式r

输出：识别L(r)的DFA D

方法:
* 构造扩展的正则表达式`(r)#`的语法树T、其中#是附加在(r)后面的唯一结束标志
* 通过对T进行深度优先遍历计算函数nullable、firstops、lastpos和followpos的值
* 利用下述过程构造Dstates（D的状态集），生成D的状态转换表Dtran。Dstates中的状态是位置集，初始情况下，每一个状态都是“未标记的”，只有我们开始考虑其出边时，这个状态才变成“标记的”。D的开始状态是firstpos(root),接受状态是包含与结束符`#`相关位置的状态。

```
初始时，Dstates中唯一未标记的节点是firstpos(root),root是(r)#语法树的根节点：
while Dstates 中㛮一个未标记的状态T do begin
    标记T;
    for 每个输入符号a do begin
        令U是followpos(p)中的位置的集合，p是T中的某个位置，位置p的符号为a;
        if U非空而且不在Dstates中 then
            将U作为一个未标记的状态加入到Dstates中；
        Dtran[T,a] := U
    end
end
```

#### 最小化DFA的状态数

理论上的一个重要结论是：每一个正规集都可以由一个状态数最少的DFA识别，这个DFA是唯一的(状态名不同的同构情况除外)。

假定有一个DFA M，其状态合集是S，输入符号表是∑，每个状态对每个输入符号都有转换。如果不是这样，可以引入一个“死状态”d，d在所有输入符号上都转换到d。如果s在符号a上没有转换，加上一个在a上从s到d的转换。

字符串w区别状态s和t，如果：DFA M从状态s出发，对输入串w进行状态转换，最后停在某个接受状态；从t出发，对输入串w进行状态转换，停在一个非接受状态；反之亦然。

极小化DFA的状态数的算法是把DFA状态分成一些不相交的组，同一个组中的状态都是不可区别的，而不同组的状态则可以由某个输入串的区别。把每个状态组合并成一个状态。该算法先把所有状态划分为两个组，然后逐步将这个划分精细化。在一个划分中，如果两个状态处于同一分组，然后逐步将这个划分精细化。在一个划分中，如果两个状态处于同一分组则说明它们还没有被任何串区别出来，反之如果两个状态处于不同分组则说明它们已经被某个串区别出来。

初始划分包含两个组：接受状态组合非接受状态组。算法的基本步骤是从当前划分中取一个状态组。如果这些转换所到达的状态落入当前划分的两个或更多不同的状态组，那么A必须进一步划分，使得划分后的每个子集在a上的转换能落入当前划分的同一个状态组中。在当前划分中重复上述划分组的过程，直到没有任何一组需要再分裂为止。

算法3.6 最小化DFA的状态数

输入：DFA M(其状态集合为S)，输入符号集为∑，转换函数为f：S*∑->S,开始状态为s0，接受状态集为F

输出：一个DFA M，它和M接受同样的语言，且状态数最少。

方法：
* 构造具有两个组的状态集合的初始划分π；接受状态组F，非接受状态组S-F
* 对π采用下述的过程来构造新的划分π
* 如果π_{new} = π,零π_{final} = π，再执行步骤4；否则，令π = π_{new},重复步骤2
* 在划分π_{final}的每个状态组中选一个状态作为该组的代表。这些代表构成了简化后DFA M‘的状态。令s是一个代表状态，而且假设：在DFA M中，在输入a上有从s到t的转换。令t所在组的代表是r(r可能就是t)，那么在M'中有一个从s到r的a上的转换。令包含s0的状态组的代表是M'的开始状态，并令M'的接受状态是那些属于F集的状态所在组的代表。注意，π_{final}的每个组或者仅含F中的状态，或者不含F中的状态。
* 如果M'含有死状态(即一个对所有输入符号都有到自身的转换的非接受状态d)，则从M'中去掉它；删除从开始状态不可到达的状态；取消从任何其他状态的死状态的转换定义

```
for π中的每个组 do begin
    当且仅当对任意输入符号a，状态s和t在a上的转换到达π的同一组中的状态时，才把G划分成小组，以便G的两个状态s和t在同一小组中；
    /* 最坏情况下，一个状态就可能成为一个组 */
    用所有新形成的小组代替π中的G
end
```

#### 词法分析器的状态最小化

开始运行算法3.6，必须对识别不同记号的状态进行分组，以得到一个厨师划分

#### 表压缩方法

可以有多种方法来实现有穷自动机的状态转换函数。因为词法分析器是编译器中唯一逐个处理输入字符流的过程，所以它占用了编译器可观的时间。因此词法分析器需要最小化它对每一个输入字符所执行的操作个数。如果用DFA来实现词法分析器，则需要对状态转换函数进行有效的表示。

一个高度压缩但速度相比比较慢的方案是使用一个链表来存储每个状态的出边所表示的转换。在链表的最后存放一个默认的转换。这个默认的转换应该是最经常用到的转换

*表压缩方法*:既有数组表示法访问速度快的特点，又有链表结构占用空间小的优点。使用4个数组组成的数据结构，这些数组由状态做索引。base数组用于决定存储在next和check数组中的与每个状态相关的表项的基位置。default数组用于确定当前基位置无效情况下可选的基位置。为了计算状态s在遇到字符a后要进入的状态nextstate(s,a)，首先查看next和check这对数组。特别地，要从这两个数组中找到对应于状态s的表项所在位置`l=base[s]+a`,其中a可以看成整数。如果`check[l]=s`,取`next[l]`为s在输入a上的下一个状态。如果`check[l]!=s`,则令`q=default[s]`,然后用q代替s并递归地重复整个过程。该过程描述如下：
```
procedure nextstate(s,a):
    if check[base[s] + a] then
        return next[base[s] + a]
    else
        return nextstate(default[s],a)
```

## 第四章：语法分析

### 语法分析器的作用

语法分析器接收词法分析器提供的记号串，检查它们是否能由源程序语言的文法产生。希望语法分析器能用于易于理解的方式提示语法错误信息，并能从常见的错误中恢复出来，以便后面的输入能继续处理下去。

典型的文法的语法分析器有三类：

* **通用的语法分析方法**：如Cocke-Younger-Kasami算法和Earley算法，这些方法能分析任何文法。然而这些方法在生成编译器效率太低。
* **自顶向下方法**：沿着从顶向底的方向建立分析树
* **自底向上方法**：沿着从叶向根的方向建立分析树

无论哪一种方法，语法分析器都是自左向右地扫描输入字符串，每次读一个符号

最有效的自顶向下和自底向上分析方法智能处理文法的一些子类。然而，这些子类中的某些文法，如LL文法和LR文法，足以描述程序设计语言的大部分语法结构。LL文法的语法分析器常由手工实现

假设语法分析器的输出是对词法分析器产生的记号流的分析树的某种表示。实际上在分析过程中编译器还可以完成许多其他任务。例如，把与各种记号有关的信息收集到符号表中、进行类型检查和其他一些语义分析检查、如产生中间代码等。

语法错误的性质和两种错误恢复策略：**紧急方式恢复策略**和**短语级恢复策略**

#### 语法错误的处理

如果编译器只处理正确程序，它的设计和实现就可以大大简化。好的编译器应该能帮助程序员识别和定位错误。大多数程序设计语言的说明都没有描述编译器应该怎样响应语法错误，而是把它留给了编译器的设计者来处理。

* **词法错误**，如标识符、关键字或操作符的拼写错误
* **语法错误**，如算术表达式的括号不配对
* **语义错误**，如操作符作用于不相容的操作数
* **逻辑错误**，如无限的递归调用

源程序的多数错误诊断和恢复都集中在语法分析阶段。原因之一是多数错误都是语法错误，或者当来自词法分析器的记号流违背定义程序设计语言的文法规则时才暴露出来。另一个原因是现代语法分析方法的准确性使得它们能非常有效地检查出程序中的语法错误。在编译阶段准确地诊断语义和逻辑错误是非常困难的。

语法分析器中出错处理程序的基本目标是：
* 清楚而准确地报告错误的出现
* 迅速地从每个错误中恢复出来，以便能继续检查后面的错误
* 不能过分降低正确程序的处理速度

但是，有些情况下，错误的发生远远先于发现它的位置，而且很难诊断出这种错误的准确性质。更困难的是，出错处理程序可能需要猜测程序员编程时的意图

有些分析方法，如LL方法和LR方法，可以尽快地检查出语法错误。它们具有**萌发前缀性(viable-prefix property)**,即当它们一旦发现一个输入字符串的前缀不是该语言任何字符串的前缀时就能检查出错误。

例：多数错误可以简单地分为以下几类：60%是标点符号错，20%是操作符或运算对象错，15%是关键字错，剩下的5%是其他类型的错误

一种常见的标点错误是在函数说明的参数表中出现的标点，分号错误普遍出现的原因是不同语言在分号的用法上有很大区别。如在Pascal语言中，分号是语句的分隔符；在PL/1和C语言中，分号则是语句的结束符。研究表明，后一种用法较少出错

操作符错误的典型例子是漏写了`:=`中的冒号。关键字拼写错误通常比较少见，其典型的例子是writeln中的i

然而，另一类常见的错误是很难正确修复的，比如漏写了begin或end。多数编译器都不能修复这类错误。

出错处理程序的错误报告：应该报告源程序的错误被检测到的位置，比如显示出错的程序行，用指针指出检测到错误的位置。比如显示“此处遗漏了分号”

通常，一些语法分析器试图将自己恢复到某一状态，以便能够继续分析输入字符串或正确地处理出现的错误。

不充分地恢复程序可能会引起大量令人烦恼的“伪”错误的出现，这些错误不是程序设计人员造成的，而是由于错误恢复时改变了语法分析器的状态而引起的。同样，语法错误的恢复也可能引起语义伪错误，这些错误会在语义分析或代码生成阶段被检查出来。例如，错误恢复时，语法分析器可能跳过某个变量的声明，如变量zap。以后在表达式中碰到变量zap时，虽然语法上没有错，但由于符号表中没有变量zap的表项，会产生“zap没有定义”的出错信息。

编译器的一个保守的策略是：如果在输入流中查到某个错误，并且它离前一个错误非常近，则抑制这个错误信息的出现，即在发现一个语法错误后，编译器应该在成功地分析几个记号之后才报告下一个错误信息。然而，在某些情况下，可能会有太多的错误，以至于编译器无法继续进行合理的处理。

考虑到各种错误情况的出现以及合理处理，错误恢复的策略是一个需要认真考虑的折中。

有些编译器试图猜测程序员编程时的意图并修复错误。

#### 错误恢复策略

* **紧急方式恢复策略**-最容易实现的方法，适用于多数语法分析方法。当发现错误时，语法分析器开始抛弃输入符号，每抛弃一个记号，直到发现某个指定的同步记号(通常是界定符)，如分号或者end。必须恰当地设计选择同步记号，因为这种方法常常跳过大量的输入记号，而不检查是否有其他错误，并不会陷入死循环
* **短语级恢复策略**-发现错误时，对剩余的输入字符串做局部纠正，即用一个能使语法分析器继续工作的字符串来代替剩余输入
* **出错产生式策略**-如果对经常遇到的错误有很清楚的了解，可以扩充语言的文法，增加产生错误结构的产生式。然后用由这些错误产生式扩充的文法构造语法分析器。如果语法分析器
* **全局纠正策略**-有一些算法可以选择最小的修改序列，以获得全局代价最小的错误纠正。如果给定错误输入串x和文法G，这些算法会发现y的一棵分析树，以便使用最少的符号插入、删除和修改操作把x变换成正确的输入字符串y。

**最小代价纠正**的概念已经成为评价错误恢复技术的一种标准，并且已经被用于短语级恢复方法中最优替换字符串的选择

### 上下文无关文法

程序设计语言的许多结构都包含固有的递归结构，这种递归结构可以用上下文无关文法定义。例如

```
如果S1和S2是语句，E是表达式，则“if E then S1 else S2是语句”
```

这种形式的条件语句不能用正则表达式说明。使用**语法变量stmt表示语句类，expr表示表示类**,可以使用下面的文法产生式:

```
stmt -> if expr then stmt else stmt
```

**上下文无关由终结符、非终结符、开始符号和产生式组成**

* **终结符**是组成字符串的基本符号。在讨论设计语言的文法时，“记号”和“终结符”是同义词，在上述例子中，关键字`if`,`then`和`else`都是终结符
* 非终结符是表示字符串集合的语法变量。*stmt*和*expr*是非终结符。非终结符所定义的字符串集合有助于定义该文法所产生的语言。非终结符强加给语言一种层次结构，这种层次结构对语法分析和翻译都非常有用
* 在文法中，有一个非终结符被指定为开始符号。开始符号表示的字符串集合就是文法所定义的语言 
* 文法的产生式说明了终结符和非终结符组合成串的方式。每个产生式由非终结符开始，跟随一个箭头(有时用::=代替箭头)，然后是非终结符和终结符组成的串

```
expr -> expr op expr 
expr -> (expr)
expr -> -expr
expr -> id
op -> +
op -> -
op -> *
op -> /
```

在上述文法中，终结符包括id,+,-,\*,/,非终结符包括expr和op，*expr是开始符号*

#### 文法符号的使用约定

* **终结符**

1. 字母表中比较靠前的小写字母，如a,b,c等
2. 操作符，如+、-等
3. 标点符号，如括号、逗号等
4. 数字0,1,...,9
5. 黑体串，如**id**、**if**等

* **非终结符**

1. 字母表比较靠前的大写字母，如A,B,C等
2. 字母S,它常常代表开始符号
3. 小写斜体名字，如*expr*、*stmt*等

* 字母表中比较靠后的大写字母，如X,Y,Z等，表示文法符号，可以是非终结符也可以是终结符
* 小写希腊字母表示文法符号的串。因此，一个通用产生式可以写作A->α，箭头左边(产生式的左部)是一个非终结符A，箭头右边使文法符号串(产生式右部)
* 如果A—>α1,A->α2,...,A->αk是所有以A为左部的产生式(称为A产生式)，则可以把它们写成A->α1|α2|α3|...|αk,将α1,α2,α3,...,αk称为A的候选式
* 除非另有说明，否则第一个产生式左部的符号是开始符号。

```
E -> E A E | (E) | -E | id
A -> + | - | * | / | ↑
```

#### 推导

可以使用多种方法观察文法定义语言的过程。将该过程看成是分析树的建立过程，但推导也是描述文法定义语言过程的有用方法，其核心思想是把产生式看成重写规则，即用产生式右部的串来代替左部的非终结符。

例如，考虑下面的算术表达式文法:

```
E -> E + E | E * E | (E) | -E | id
```

其中，非终结符E表示一个表达式。产生式E->-E意味着前面带有减号的表达式仍然是表达式。这个产生允许用-E代替出现的任何E,以便从简单的表达式产生更复杂的表达式。如果用-E代替单个E，这个动作可以描述为

```
E -> -E
```

读为`“E推导出-E”`。产生式`E->(E)`表示可用`(E)`代替在文法符号串中出现的任何E。如`E*E=>(E)*E`或者`E*E=>E*(E)`

可以从E开始，不断地(以任何顺序)应用产生式，得到一个替换序列。例如：

```
E -> -E -> -(E) -> -(id)
```

抽象地，有`αAβ->αγβ`，如果`A->γ`是产生式，而且α和β是任意的文法符号的串。如果`α1->α2->...->αm`,则说α1推导出αm,符号->表示“一步推导”。通常用*->表示“零步或多步推导”。因此：
* 对任何串α，α*->α
* 如果α*->β，而且β->γ,则α*->γ

类似地，用+->表示“一步或多步推导”。对于开始符号为S的文法G，可以用+->关系来定义G所产生的语言L(G).L(G)中的字符串只包含G的终结符。当且仅当S+=>w时，说终结符w在L(G)中。终结符串w称为G的句子。由上下文无关文法产生的语言称为上下文无关语言。如果两个文法产生同样的语言，则称这两个文法等价。

对于开始符号为S的文法G，如果S*=>α，则称α为G的句型，其中α可能包含有非终结符。句子是不含非终结符的句型。

字符串`-(id+id)`是文法(4-3)的句子，因为存在如下推导

```
E -> -E -> -(E) -> -(E + E) -> -(id + E) -> -(id + id)  文法(4-3)
```

可以简单地用如下形式表示：
```
E *-> -(id + id)
```

按推导长度进行归纳，可以证明文法(4-3)产生的语言中的每个句子都是由二元操作符`+`和`*`、一元操作符`-`、括号以及运算对象id组成的算术表达式。同样，按算术表达式的长度进行归纳，也可以证明这样的算术表达式都可以由文法(4-3)产生。因此，文法(4-3)正好产生所有包括二元操作符`+`和`*`,一元操作符`-`、括号以及操作数id的算术表达式的集合。

在推导的每一步都有两个选择，首先需要选择被替换的非终结符，然后再选择用于替换该非终结符的候选式。

```
-(E + E) -> -(E + id) -> -(id + id)
```

为了理解语法分析器是怎样工作的，需要考虑每一步都替代最左非终结符的推导。这样的推导叫做**最左推导**,如果`α -> β`是最左推导，可以写成`α lm-> β`

每一步的最左推导都可以写成`wAγ lm-> wδγ`，其中`w`只含终结符，`A -> δ`是推导所用的产生式，`γ`是文法符号的串。为了强调`α`通过最左推导出`β`这一事实。写`α lm*-> β`。

如果`S lm*-> α`,则称`α`是该文法的左句型。

类似地可以定义最右推导，即每步推导都代替最右非终结符的推导。最右推导有时也称为规范推导。

#### 分析树和推导

分析树可以看成的图形表示，但它不能显示出替代顺序的选择。分析树的每个内节点都标以某个非终结符A。A的子节点从左到右分别被用来替换A所使用的产生式右部的各符号标记。分析树的叶节点用非终结符或终结符来标记，它们从左到右构成一个句型，称为树的边界或果实。

考虑任意推导`α1 -> α1 -> ... αn`,其中`α1`是单个非终结符A。对推导中的每个句型`αi`,构造产生`αi`的分析树。该过程是对i的归纳。`αi = A`对应的分析树是标有A的单个节点，是归纳的基础。为了完成这种归纳，假设已经构造了产生`αi = X1X2...Xk`的分析树，假设`αi`是用`β=Y1Y2...Yr`代替`αi-1`中的非终结符`Xj`所产生的，即在推导的第i步中，对`αi-1`应用产生式`Xj->β`，推导出`αi=X1X2...Xj-1βXj+1...Xk`

分析树忽略了句型中符号被代替的顺序。如果只考虑最左推导(或最右推导)，则可以消除推导过程中产生式应用顺序的不一致性。**每棵分析树都有一个与之对应的唯一的最左推导和唯一的最右推导**。可以用产生分析树方法来代替推导。

分析树可以反映一定的运算符优先级。比如`a+b*c`,习惯上*比+具有更高的优先级，因为表达式`a+b*c`被看成`a+(b*c)`而不是`(a+b)*c`

#### 二义性

给定一个文法G，如果L(G)中存在一个具有两棵或者两棵以上分析树的句子,则称G是二义性的。

还可以如下定义二义性文法：如果L(G)中存在一个具有两个或两个以上最左(或最右)推导的句子，则G是二义性文法。很多语法分析器要求所处理的文法是无二义的，否则对具有二义性的句子无法确定应该选择那颗分析树。

某些应用可能要求可以构造适应于二义性文法的语法分析器，不过，这种文法要具有*消除二义性*的规则,以便语法分析器能够“抛弃”不需要的分析树而为每个句子保留唯一一棵分析树。

### 文法的缩写

文法能够描述程序设计语言的大部分语法成分，但不能描述程序设计语言的全部语法成分。当**词法分析器**从输入字符串产生记号序列时，将完成一定量的语法分析工作。对输入字符串的某些限制(如标识符的声明必须先于它们的使用)不能用上下文无法文法来描述。**语法分析器接受的记号序列形成了程序设计语言的超集**。语法分析以后的各编译阶段必须分析语法分析器的输出，以保证输入字符串符合语法分析器无法检查的那些规则。

考虑词法分析器和语法分析器的分工。每种语法分析方法只能处理一种形式的文法。为了适应所选择的分析方法，常常不得不改写初始文法。**适于表达式的文法常常用结合律和优先级信息来构造**

#### 正则表达式和上下文无关文法的比较

正则表达式所描述的每一种结构都可以用上下文无关文法来描述。例如正则表达式`(a|b)*abb`和下述文法描述的语言皆为由a和b组成的以abb结尾的字母串：
```
A0 -> aA0 | bA0 | aA1
A1 -> bA2
A2 -> bA3
A3 -> e
```

可以机械地把一个不确定的**有穷自动机(NFA)**转换成一个等价的上下文无关文法，该文法可以按照下列规则构造:
* 对NFA的每个状态i，创建一个非终结符Ai
* 如果状态i遇见的输入符号a转换到状态j，则引入产生式Ai -> aAj
* 如果状态i遇见的输入符号e转换到状态j，则引入产生式Ai -> Aj
* 如果状态i是接受状态，则引入产生式Ai -> e
* 如果状态i是开始状态，则Ai是文法的开始符号

使用正则表达式而不用上下文无关文法定义语言的词法

* 语言的词法规则通常非常简单，不必用强大的文法来描述
* 对于记号，正则表达式比上下文无关文法提供了更简洁且易于理解的定义
* 从正则表达式可以自动地构造出有效的词法分析器，从任何文法都很难构造词法分析器
* 把语言的语法结构分成词法和非词法两部分为编译器前端的模块划分提供了方便的途径。

*注意：正则表达式对描述标识符、常数和关键字等词法结构时最常用。另一方面，文法在描述括号配对、begin-end配对、if-then-else对应等嵌套结构时最常用。正则表达式不能描述这些嵌套结构*

#### 验证文法所产生的语言

对“文法G产生语言L”的证明包括两个部分：必须证明由G产生的每个字符串都在L中，反之，L中的每个字符串都能由G产生。

如文法G`S->S(S)|e`能而且仅能产生所有配对的括号串，证明略.

#### 消除二义性

有些二义性文法可以通过改写来消除二义性。例子：消除“不匹配else”文法的二义性。

```
stmt -> if expr then stmt
    | if expr then stmt else stmt
    | other            
    (4-7)
```

这里，other代表任何其他语句。复合条件语句

```
if E1 then S1 else if E2 then S2 else S3
```

文法(4-7)具有二义性的，因为串`if E1 then if E2 then S1 else S2`有两棵分析树。而一般规则是，每个else和前面最近的没有配对的then配对，当然这条避免二义性的规则可以直接并入文法中。例如，可以把上述文法改写成下面的无二义性文法，其基本思想是：出现在then和else之间的语句必须是“配对”的，即它不能以一个未配对的then后面跟随任意的非else语句结束，于是else会被迫与这个未配对的then匹配。配对的语句是一个不包含不配对语句的if-then-else语句或者任何非条件语句。因此，按照上述思想改写后的文法如下：

```
stmt -> matched_stmt
    | unmatched_stmt
matched_stmt -> if expr then matched_stmt else matched_stmt
    | other
unmatched_stmt -> if expr then stmt 
    | if expr then matched_stmt else unmatched_stmt
```

#### 消除左递归

如果文法G具有一个非终结符A使得对某个字符串α存在推导`A +-> Aα`,则称G是左递归的。自顶向下语法分析法不能处理左递归文法，因此需要一种消除左递归的变换。

左递归产生式`A -> A α|β`可以由下面的非左递归产生式来代替:

```
A -> βA'    A' -> αA' | e
```

这种变换没有改变从A推导出的字符串集合。这条规则适用于很多文法。

例子：考虑下面的算术表达式文法
```
E -> E + T | T
T -> T * F | F
F -> (E) | id
```
消除E和T的直接左递归(形如`A -> Aα`的产生式)，可以得到
```
E -> TE'
E' -> +TE'| e
T -> FT'
T' -> *FT' | e
F -> (E) | id
```
无论有多少A产生式，都可以用下面的技术来消除直接左递归。首先，把A产生式放在一起：
```
A -> Aα1 | Aα2 | ... | Aαm | β1 | β2 | ... | βm 
```
其中，每个βi都不以A开头。然后用下面的产生式代替A产生式：
```
A  -> β1A' | β2A' | ... | βmA'
A' -> α1A' | α2A' | ... | αmA' | e 
```
变换后的非终结符A与变换前的非终结符A产生同样的字符串集合，但已经没有左递归了。这种方法可以从A产生式和A'产生式(假定αi都不等于e)消除直接左递归，但不能消除包括两步或多步推导的左递归。例如，考虑文法
```
S -> Aa | b
A -> Ac | Sd | e
```
非终结符S是左递归的，因为S -> Aa -> Sda,但不是直接左递归。

下面的算法4.1能够系统地消除文法中的左递归。该算法对于所有无循环推导(`A +-> A`的推导)和e产生式(形如`A -> e`的产生式)的文法都有效。循环推导和e产生式都可以系统地从文法中消除掉

**算法4.1** 消除左递归

```
输入：无循环推导和e产生式的文法G
输出：与G等价的无左递归文法
方法：对文法G应用如下算法。注意：得到的非左递归文法可能含有e产生式
1. 以某种顺序排列非终结符A1,A2,...,An
2. 
for i := 1 to n do begin
    for j := 1 to i - 1 do begin
        用产生式A -> δ1γ|δ2γ|...|δkγ代替每个形如A->Aiγ的产生式
        其中，Ai -> δ1|δ2|...|δk是所有的当前Aj的产生式
    end
    消除Ai产生式中的直接左递归
end
```

*注意：因为有e产生式，算法4.1不一定有效，但在这种情形天产生式A->e是无害的*

令非终结符的次序是S、A。在S产生式中没有直接左递归，对于i=1，什么也没做。i=2时，用S产生式替换A -> Sd中的S，得到下面的A产生式。
```
A -> Ac | Aad | bd | e
```
消除A产生式中的直接左递归，产生下面的文法
```
S  -> Aa | b
A  -> bdA' | A'
A' -> cA' | adA' | e
```

#### 提取左因子

提取左因子是一种对产生适合预测分析的文法非常有用的文法变换。提取左因子的基本思想是：当不清楚应该用两个选择中的哪一个来替换非终结符A时，可改写A产生式来推迟这种决定，制导看见足够多的输入能做出正确的选择为止

例如，有如下两个产生式：

```
stmt -> if expr then stmt else stmt
    | if expr then stmt
```

看到输入记号if时，不能立即立刻决定选择哪个产生式来扩展stmt。一般地，如果`A->αβ1|αβ2`是A的两个产生式，输入字符串从α导出的非空串开始，不知道是用`αβ1`来扩展A还是用`αβ2`。然而，可以通过先将A扩展到`αA'`来推迟这个决定。然后，扫描完由α导出的输入字符串后，再把`A'`扩展成`β1`或`β2`，亦即提取左因子。这样的变换以后，原来的产生式变为：
```
A -> αA'  A' -> β1 | β2
```

**算法4.2** 提取左因子
```
输入：文法G
输出：一个等价的提取了左因子的文法。
方法：对每个非终结符A，找出它的两个或者更多候选式的最长公共前缀α。如果α!=e,即有一个非平凡的公共前缀，则用下面的产生式代替所有A产生式A->αβ1|αβ2|...|αβn|γ,其中γ表示所有不以α开头的候选式:
A  -> αA' | γ
A' -> β1 | β2 | ... | βn
```

其中A'是一个新的非终结符。反复应用这种变换，直到任一非终结符都没有两个候选式具有公共前缀为止

#### 非上下文无关语言的结构

有些语言不能用任何文法产生。

例子：考虑抽象语言`L1 = {wcw|w属于(a|b)*}`。L1是所有由隔开的两个相同a、b串组成的字母串集合，例如`aabcaab`。这个语言是检查程序中标识符的声明应先于其应用的抽象，即wcw中的第一个w表示标识符w的声明，第二个w表示它的引用。可以证明该语言不是上下文无关语言。*因为它们要求标识符的声明先于引用，并且允许标识符任意长*

由于上述原因，描述Algol和Pascal语法的文法并不定义标识符中的字符，而只是用文法中id这样的记号代表所有的标识符。在这类语言的编译器中，语义分析阶段检查标识符的声明是否先于引用。

例子：语言`L2 = {a^nb^mc^nd^m | n >= 1 & m >= 1}`不是上下文无关语言。L2是由正则表达式`a*b*c*d*`所表示的语言的子集合，在它的每个句子中，a和c的个数相等，b和d的个数相等(a^n意味着a被写过n次)。它是“过程声明的形参个数和过程引用的实参个数和过程引用的实参个数应该一致”的抽象，a^n和b^m表示两个过程说明的形参表中分别有n和m个参数,c^n和d^m分别表示调用这两个过程的实参表

注意：过程定义和引用的语法并不涉及到参数的个数。例如，一个类似于Fortran语言的中的CALL语句的文法如下：
```
stmt -> call id (expr_list)
expr_list -> expr_list, expr
    | expr
```
其中带有expr的产生式。通常在语义分析阶段检查call中的实参个数是否正确。

例子：语言`L3 = {a^nb^nc^n | n >= 0}`是`L(a*b*c*)`子集合，每个串包括相等个数的a、b和c。L3不是上下文无关语言。下面是一个与L3相关的问题。设打字时用下划线标记的正文，排版输出时改用斜体。为了把在行式打印机的文本文件转换成适于在照相排版机上输出的文本，需要用斜体代替下划线。在打字机上打印一个用下划线标记的单词时，首先在键盘上敲打一串与这个单词对应的字母键，然后敲打相等数量的退格键，最后敲打相等数量的底线键。如用a表示任意的字母键，b表示退格键，c表示底线键，则L3可以表示所有用下划线标记的单词。但是，如果用`<`字母，退格，底线`>`三元组标识用下划线标记的单词，可以用正则表达式`(abc)*`表示用下划线标记的单词集合。

有些语言类似于L1,L2,L3,但却是上下文无关语言。例如，L1' = {wcw^R | w属于(a|b)*}是上下文无关语言，其中w^R表示w的逆序。
```
S -> aSa | bSb | c
```

### 自顶向下语法分析

无回溯自顶向下语法分析器也称为预测语法分析器。这种文法的预测语言分析器可以自动生成。关于预测语法分析器的讨论之外，只讨论非递归的预测语法分析器。

#### 递归下降语法分析器

自顶向下语法分析的目的是为了输入字符串寻找最左推导，从根节点(文法开始符号)开始，自上而下、从左到右地为输入串建立一棵分析树，并以预先确定的顺序创建分析树的节点。先前讨论了一种不需要回溯的特殊递归下降分析法，称为预测分析法。

考虑自顶向下分析的一般形式，称为**递归下降分析法**。它可能需要回溯，即需要重复地扫描输入。然而，需要回溯的语法分析器是不常见的，其原因是在分析程序设计语言的结构时很少需要回溯。即使在分析自然语言的情况下，回溯也不是非常有效的，并且列表的方法更可取。

下面是一个需要回溯的例子。当需要回溯时，建议使用一种记录输入轨迹的方法，考虑下述文法和输入字符串`w = cad`
```
S -> cAd
A -> ab | a
```
为了自顶向下地为w建立分析树，首先建立只具有标记为S的单个节点的树。输入指针指向w的第一个符号c。

最左边的叶子标记为c，匹配w的第一个符号。现在，将输入指针移到w的第二个符号a。考虑下一个标记为A的叶子。用A的第一个候选式扩展A，当已经匹配到了的哥输入符号a时，再将输入指针移到第三个输入符号d，把它和下一个标记为b的叶节点进行比较，因为b和d不匹配，报告失败，回到A，看是否还有别的候选式可试。

回到A时，必须将输入指针重置到第二个符号，即第一次进入A时的位置。这意味着A的程序必须将输入指针保存在一个局部变量中。现在尝试A的第二种候选式，得到图所示的分析树。叶子a匹配w的第二个符号，叶子d匹配w的第三个符号。因为已经产生了w的分析树，停止分析并宣告分析成功！

虽然递归下降语法分析器带有回溯能力，左递归文法也会使其进入无限循环，也就是说，当试图扩展A时，可能最终会发现：在不断试图扩展A，但输入指针并没有前移

#### 预测语法分析器

在许多情况下，通过仔细地编写文法，消除左递归，提取左因子，可以获得一个有效的文法，这个文法可以用不带回溯的递归下降语法分析器来分析。为了构造预测语法分析器，对给定的当前输入符号a和将要扩展的非终结符A，在A的所有可选产生式A -> α1 | α2 | ... | αn中，哪个候选式是唯一能推导出以a开头的串。预测语法分析器能够通过观察候选式所推导出的第一个符号，确定正确的候选式。这种方法可以检测出多数程序设计语言中具有不同关键字的控制流结构。
```
stmt -> if expr then stmt else stmt
    | while expr do stmt
    | begin stmt_list end
``` 
那么关键字if、while、begin告诉如果想找到一条语句哪个候选式是唯一可能成功的选择。

#### 预测分析器的状态转换图

对于词法分析器的设计者来说，状态转换图(transtion diagram)是非常有用的设计工具。也可以为预测语法分析器创建状态转换图。

词法分析器的状态转换图和预测语法分析器的状态转换图具有明显的区别。对于预测语法分析器，每个非终结符都对应一个状态转换图，边上的标记是记号和非终结符。记号(终结符)上的转换意味着如果该记号是下一个输入符号，就应进行该转换。非终结符A上的转换是对与A对应的过程的调用。

为了由文法构造预测语法分析器的状态转换图，首先需要消除文法中的左递归，然后提取左因子，并对每个非终结符A执行如下操作：
1. 创建一个开始状态和一个终态(返回状态)
2. 对每个产生式A->X1X2X...Xn,创建一条从开始状态到终止状态的路径，边上的标记分别为X1,X2,...,Xn

预测语法分析器以状态转换图为基础完成分析工作，其工作方式如下：开始，语法分析器进入状态图的开始状态，输入指针指向输入符号串的第一个符号。如果经过一些动作后，语法分析器进入状态s，且在状态图上从状态s到状态t的边上标记终结符a，而下一个输入符又正好是a，则语法分析器将输入指针向右移动一位指向下一个符号，语法分析器进入状态t。另一个方面，如果边上标记的是非终结符A，则语法分析器进入A的初始状态，但不移动输入指针。一旦语法分析器到达A的终止状态，则立刻进入状态t。事实上，语法分析器从状态s转移到状态t时，已经从输入符号串"读"了A。最后，如果从s到t有一条标记为e的边，那么语法分析器从状态s直接进入状态t而不移动输入指针。

基于状态转换图的预测分析程序试图进行终结符和输入的匹配，并且，当它经过标记为非终结符的边时，进行潜在的递归过程调用。一种非递归的实现方法是，当在状态s上有一个标记为非终结符的指向其他状态的转换时，则将状态s压入栈中，当到达该非终结符的终止状态时，将状态s弹出栈。下面将更详细地讨论状态转换图的实现。

如果给定的状态转换图是确定的，即一个状态对于一个输入仅有一个转换，则上述方法是有效的。如果出现二义性，就要消除，否则不能不够预测语法分析器。但是可以构造低估一下将语法分析器，用回溯的方法尝试所有可能的情况。

#### 非递归的预测分析

通过显式地维护一个状态栈，而不是通过隐式的递归调用，可以构造非递归的预测语法分析器。预测分析的关键问题就是确定用于扩展非终结符的产生式。

**非递归语法分析器**通过查分析表来选取产生式。表驱动的预测语法分析器有一个输入缓冲区、一个栈、一张分析表和一个输入流。输入缓冲区包含要分析的串，后面跟一个符号`$`,`$`是输入串的结束标记。栈用来存放文法符号序列。栈底符号是`$`。初始时，栈中含有文法符号序列及其下边的`$`。分析表是一个二维数组`M[A,a]`,A是非终结符，a是终结符或`$`

语法分析器由一个按如下方式工作的程序控制：程序根据栈顶当前的符号X和当前输入符号a决定语法分析器的动作：
* 如果`X = a = $`，则语法分析器宣告分析成功并停止
* 如果`X = a != $`，则语法分析器弹出栈顶符号X，并将输入指针移到下一个输入符号上。
* 如果X是非终结符,则程序访问分析表M的`M[X,a]`项。`M[X,a]`项是文法的一个X所产生或者出错信息。例如，如果`M[X,a] = {X -> UVW}`,则语法分析器用WVU(U在栈顶)代替栈顶符号X.

**算法4.3** 非递归的预测分析
```
输入：串w和文法G的分析表M
输出：如果w属于L(G),则输出w的最左推导，否则报告错误。
方法：开始时，语法分析器的格局是$在栈里(其中S是G的开始符号且在栈顶)，w$在输入缓冲区。下述程序是用预测分析表M分析输入串的程序

令ip指向w$的第一个符号；
repeat
    令X是栈顶符号，a是ip指向的符号；
    if X是终结符或者$ then
        if X = a then
            从栈中弹出X，ip指向下一个符号
        else 
            error()
    else
        if M[X,a] = X -> Y1Y2...Yk then begin
            总栈中弹出X;
            将Yk, Yk-1, ..., Y1 压入栈，Y1在栈顶
            输出产生式X -> Y1Y2...Yk
        end
        else 
            error()
until X = $  /* 栈空 */
```

#### FIRST和FOLLOW

构造文法G的分析表需要两个与G有关的函数FIRST和FOLLOW。可以用这两个函数来填写G的分析表的表项。由FOLLOW函数产生的记号集合还可用做紧急方式错误恢复期间的同步记号。

如果α是任意的文法符号串，则定义FIRST(α)是从α推导出的串的开始符号的终结符集合，即`FIRST(α) = {α | α *-> a..., a是终结符}`。如果`a *-> e`,则e也属于`FIRST(α)`

设A是一个非终结符，定义`FOLLOW(A)`是包含所有在句型中紧跟在A后面的终结符a的集合，即`FOLLOW(A) = {a | S *-> αAaβ, a是终结符}`。注意，在推导某一时刻，在A和a之间可能有符号，但如果是这样，它们将推导出e并消失。如果A是某个句型的最右符号，那么$属于FOLLOW(A)

为了计算文法符号X的FIRST(X),可以应用下列规则，直到没有终结符或e可加到某个FIRST集合为止：
* 如果X是终结符，则FIRST(X)是{X}
* 如果X->e是一个产生式，则将e加到FIRST(X)中
* 如果X是非终结符，且X->Y1Y2...Yk是一个产生式，则
1. FIRST(Yi)中的所有符号在FIRST(X)中
2. 若对于某个i，a属于FIRST(Yi)且e属于FIRST(Y1),...,FIRST(Yi-1),即`Y1...Yi-1 *-> e`,则将a加入FIRST(X)中。
3. 若对于所有的j=1,2,...,k,e在FIRST(Yj)中，则将e加到FIRST(X)中。

例如，FIRST(Y1)中的每个元素确实都存在FIRST(X)中，如果Y1不能导出e，则不再往FIRST(X)中增加新符号，如果`Y1*->e`,则将FIRST(Y2)加到FIRST(X)中，依次类推

```
FIRST(E) = FIRST(T) = FIRST(F) = {(, id}
FIRST(E) = {+, e}
FIRST(T) = {*, e}
FOLLOW(E) = FOLLOW(E') = {), $}
FOLLOW(T) = FOLLOW(T') = {+, ), $}
FOLLOW(F) = {+, *, ), $}
```

例如，根据计算FIRST的规则1，FIRST(id) = {id}且FIRST('(') = {(}。根据规则3与i=1,id和左括号被加入FIRST(F)中。再根据规则3与i = 1,产生式T->FT意味着id和左括号也在FIRST(T)中。另外，根据规则2，e属于FIRST(E')。

为计算FOLLOW集，根据计算FOLLOW的规则1将$放入FOLLOW(E)中。把规则2应用到产生式F->(E),右括号也在FOLLOW(E)。把规则3应用到产生式E->TE'意味着FIRST(E')中除e以外的所有字符都应该放入FOLLOW(T)。

#### 预测分析表的构造

**算法4.4** 构造预测分析表
```
输入：文法G
输出：分析表M
方法：
1. 对于文法中的每个产生式A->α，执行第2
2. 对FIRST(α)中每个终结符α，将A->α加入到M[A,a]中
3. 若e在FIRST(α)中，则对FOLLOW(A)的每个终结符b，将A->a加入到M[A,b]中，若e在FIRST(α)中，且$在FOLLOW(A)中，则将A->α加入到M[A,$]
4. 将M中每个没定义的表项均置为error
```

#### LL(1)文法

算法4.4应用于任何文法G可以产生分析表M。然而，对某些文法，M可能含有多重定义的表项。例如，若G是左递归的或二义性的，则M至少包含一个多重定义的表项。分析表项汇总没有多重定义表项的文法叫做LL(1)文法。LL(1)中的第一个L代表从左向右扫描输入，第二个L代表产生最左推导，1代表在决定语法分析器的每步动作时间向前扫描一个输入符。

可以证明：算法4.4可以为任何LL(1)文法G产生分析表。这个分析表能分析G的所有句子，而且只能分析G的句子

LL(1)文法有一些特殊的性质。它不是二义性的，也不含左递归。可以证明，G是LL(1)文法，而且仅当G的任何两个不容的产生式A->α|β满足下面的条件:
1. 不存在这样的终结符a，使得α和β导出的串都以a开始
2. α和β中至多有一个能导出空串
3. 如果`β * ->e`,那么α不能导出以FOLLOW(A)中的终结符开始的任何串。

消除分析表中含有的多重定义的方法：进行文法变换，消除左递归和提取所有可能的左因子，以期产生的新文法的分析表中没有多重定义的表项。不幸的是，有些文法不论怎么变换也不能产生LL(1)文法。一般来说，没有一个普遍适用的规则可以用来删除多重定义的表项，使其成为单值而不影响语法分析器所识别的语言。

使用预测分析的主要困难在于为源语言编写一个能构造出预测语法分析器的文法。虽然消除左递归和提取左因子都非常简单，但它们使得结果文法很难阅读而且不易于翻译。为降低上述难度，编译器中语法分析器常常同时使用两种方法，即使用预测分析方法分析控制结构，使用算符优先分析方法分析表达式。然而，如果LR语法分析器的生成器可用，则可以自动获得预测分析和算符优先分析的一切优点。

#### 预测分析的错误恢复

非递归预测语法分析器的栈使得语法分析器希望同剩余输入串进行匹配的终结符和非终结符变得十分清楚。因此，在下面的讨论中，将引用栈中符号。在预测分析过程中，如果栈顶的终结符和下一个输入符号不匹配或者栈顶是非终结符A，a是下一个输入符号，而`M[A,a]`是空白表项，则检测出一个错误。

**紧急方式错误恢复策略**主要基于以下思想：跳过一些输入符号，直到期望的同步记号中的一种出现为止。它的效果依赖于同步记号集合的选择。这个集合的选择应该使得语法分析器能迅速地从实际可能发生的错误中恢复过来。下面是一些启发式方法：

1. 开始，可以把FOLLOW(A)中的所有符号放入非终结符A的同步记号集合中。如果出现错误时栈顶元素是A，可以跳过一些记号，直到看见FOLLOW(A)中的元素，再把A弹出栈。这样我们就可以进行语法分析；
2. 仅使用FOLLOW(A)作为A的同步集合是不够的。例如，在C语言中分号用于表示语句结束，语句开始的关键字很可能不出现产生表达式的非终结符号的FOLLOW集合中。因此，赋值语句分号的遗漏会导致下一语句的开始关键字被跳过。语言的结构往往具有层次结构，如表达式出现在语句中，语句出现在程序块中，等等。我们可以把高层结构的开始符号加到低层结构的同步集合中。例如，可以把表示语句开始的关键字加入产生表达式的非终结符的同步集合中；
3. 如果FIRST(A)的符号加入非终结符A的同步集合，那么可以恢复关于A的分析，只要FIRST(A)的出现在输入中；
4. 如果非终结符能产生空串，则可以将产生空串的产生式作为默认选择。这样做会延迟某些错误的发现，但不会漏掉，而且这种方法可以减少错误恢复时要考虑的非终结符数
5. 如果栈顶的终结符不能被匹配，那么简单的办法就是弹出该终结符，并给出提示信息，说明输入中插入了该符号，然后继续进行分析。实际上，这种方式等于把所有其他的记号作为该记号的同步集合

如果语法分析器发现表项`M[A,a]`为空，则跳过输入符号a；如果表项是synch，则弹出栈顶的非终结符并试图恢复分析；如果栈顶的记号与输入符号不匹配，则从栈顶弹出该记号。

一般来说，出误信息必须由编译器的设计者提供。通过在预测分析表的空白表填上出错处理程序指针即可实现**短语级恢复**。这些程序可以修改、插入或删除输入符号并给出适当的出错信息。它们也可能弹出栈中的符号。如果允许替换栈顶符号或者将新的符号压入栈顶可能会出问题，因为这样会使得语法分析器执行的步骤跟语言中任何词的推导都不会对应。不管怎样，我们必须确保不会产生无限循环。有一种很好的方法可以防止这种循环，即确认所有的恢复动作最终都将会使剩余输入串缩短(或者，如果到了输入的末端，使栈缩短)

### 自底向上语法分析

比较常用的自底向上分析法，称为移动归约分析法。一种最易于实现的移动归约分析法，称为算符优先分析法。更一般的移动归约分析方法叫做LR分析法。LR分析法可用于许多自动的语法分析器的生成器。

移动归约分析法为输入串构造分析树时从叶节点(底端)开始，向根节点(顶端)前进。可以把该过程看成是把输入串w“归约”成文法开始符号的过程。在每一步归约(reduction)中，如果一个子串和某个产生式的右部匹配，则用该产生式的左部符号代替该子串。如果每一步都能恰当地选择子串，就可以得到最右推导的逆过程。

例子：考虑文法
```
S -> aABe
A -> Abc | b
B -> d
```
句子abbcde可按下述步骤归约到S
```
abbcde
aAbcde
aAde
aABe
S
```
首先扫描abbcde，寻找能够匹配某产生式右部的子串。子串b和d都可以匹配某产生式右部。选择最左边的b，用A代替b(因为A是产生式A->b的左部)，得到aAbcd。现在子串Abc、b和d都能匹配某产生式的右部。虽然b是匹配某产生式右部的最左子串，但我们用A代替子串Abc(因为A是产生式A->Abc的左部)，得到aAde。然后，因为B是产生式B->d的左部，所以用B代替d，得到aABe，再用S代替此串。于是，这四步归约将abbcde归约到S。事实上，这些归约与如下最右推导的逆过程相对应
```
S rm-> aABe rm-> aAde rm-> aAbcde -> abbcde
```

#### 句柄

非形式地，一个符号串的“句柄”是和一个产生式右部匹配的子串，而且把它归约到该产生式左部的非终结符代表了最右推导逆过程的一步。在很多情况下，匹配某个产生式A->β右部的最左输入子串β不是句柄，因为用这个产生式归约产生的串不能归约成开始符号。

形式地说，右句型(最右推导可得到的句型)γ的句柄是一个产生式A->β及γ的一个位置，在该位置可以找到串β，而且用A代替β可以的到γ的最右推导的前一个右句型，即如果`S *rm-> αAw rm->αβw`，那么紧跟在α后面的`A -> β`是`αβw`的句柄。

在上面的例子中，abbcde是右句型，句柄是在位置2的A->b。同样，aAbcde也是右句型，它的句柄是在位置2的A->Abc。如果能清楚地知道β的位置和产生式A -> β，有时也可以直接说"子串β是αβw的句柄"

例子，考虑文法
```
E -> E + E
E -> E * E
E -> (E)
E -> id
```
和最右推导
```
E *rm-> E + E
  *rm-> E + E * E
  *rm-> E + E *id3
  *rm-> E + id2 * id3
  *rm-> id1 + id2 *id3
```

#### 句柄裁剪

通过“句柄裁剪”可以得到最右推导的逆过程。从被分析的终结符串w开始。如果w是文法的一个句子，那么w=γn，其中γn是下面的未知最右推导的第n步右句型。
```
S = γ0 rm-> γ1 rm-> γ2 rm-> ... rm-> γn-1 rm-> γn - w
```
为构造这个推导的逆过程，需要在γn中找到句柄βn，并用产生式An->βn的左部代替βn，得到第n-1步的右句型。

重复此过程，即在γn-1中找到句柄βn-1,并对该句柄进行归约得到右句型γn-2。如果继续此过程将得到只包含开始符号S的右句型，那么就宣告分析成功并停止。在归约过程所用产生式序列的逆序就是输入串的最右推导。

#### 用栈实现移动归纳分析

两个问题：
1. 定位右句型中将要归约的子串，
2. 如果这个子串是多个产生式的右部，如何确定选择哪一个产生式。

**实现移动归约分析的一种简单方法是用栈来保存文法符号，用输入缓冲区来保存要分析的串w，用$来标记栈底，也用它标记输入串的右端。**

初始，栈是空的，串w在输入缓冲区中，如下所示：

栈|输入
-|-
$|w$

语法分析器将零个或多个输入符号压入栈，直到句柄β在栈顶出现为止，语法分析器再把β归约成某个恰当的产生式的右部。语法分析器重复此过程，直到它发现错误或者栈中只有开始符号并且输入串为空：

栈|输入
-|-
$$|$

进入这个格局以后，语法分析器停止并宣告分析成功！移动归约语法分析器的基本动作是移动和归约，但实际上有四种可能的动作：**移动**、**归约**、**接受**、**出错**

1. **移动**：把下一个输入符号移动到栈顶
2. **归纳**：语法分析器知道句柄的右端已在栈顶。它必须在栈中确定句柄的左端，并选择正确的非终结符替代句柄
3. **接受**：语法分析器宣告分析成功
4. **出错**：语法分析器发现了一个语法错误，并调用错误恢复程序进行出错处理

有一个重要的事实说明在移动归约分析中会用栈是有道理的：句柄最终总会出现在栈顶，而不是在栈的里面。如果考察任意最右推导中连续两步的可能形式，这个事实将是显而易见的。这两步可能的形式:
```
(1) S *->rm αAz *->rm αβByz *-> αβγyz
(2) S *->rm αBxAz *-> rm αBxyz *-> αγxyz
```
在(1)中，A被βBy代替，然后最右边的非终结符B由γ代替。在(2)中，A仍然先被替换，但这次只是由终结符串y来代替。下一个最右非终结符B将会在y左边的某个地方出现。

在这两种情况下，在执行了一步归约之后，语法分析器都必须移动零个或多个符号以便使下一个句柄进栈。语法分析器不需要深入到栈中去寻找句柄。由此可知，使用栈来实现移动归约语法分析器是非常有效的

#### 活前缀

出现在移动归纳语法分析器中的右句型的前缀集合称为**活前缀**。等价的定义为：活前缀是右句型的前缀，而且其右端不会超过该句型的最右边句柄的末端。根据该定义，可以把终结符加到活前缀的末尾得到右句型。因此，在给定时刻只要输入串中已分析过的那部分能归约成活前缀，就没有错误

#### 移动归约分析过程的冲突

有些上下文无关文法不能使用移动归约分析。这种文法的每一个移动归约语法分析器会形成这样的局面：根据栈中的内容和下一个输入符号不能决定是移动还是归约(移动-归约冲突),或不能决定按哪一个产生式进行归约(归约-归约冲突)。下面会给出属于这类文法的语法结构的例子。从技术上讲，这些文法不属于LR(k)类文法。称它们为非LR文法。LR(k)中的k代表超前搜索k个输入符号。编译中使用的文法通常都属于LR(1)类，即超前搜索一个输入符号。

例子：二义性文法一定不是LR文法:
```
stmt -> if expr then stmt
    | if expr then stmt else stmt
    | other
```
如果移动归约语法分析器处于格局
```
栈                      输入
...if expr then stmt  else...$
```
无论栈中`if expr then stmt` 下面是什么符号，都不能判断`if expr then stmt`是否为句柄，这里存在移动-归约冲突。根据输入中else后的内容，也许将`if expr then stmt`归约成stmt是正确的。或者也许移动else进栈，然后寻找另一个stmt来完成`if expr then stmt else stmt`的替换是正确的。因此，在这种情况下不能判断应该移动还是归约，所以这个文法不是LR(1)文法。

对移动归约分析方法进行简单的改造即可分析某些二义性文法，如上面的`if then else`文法。当为我们包含上面产生式的文法构造这样的语法分析器时，存在移动-归约冲突；对于else或者移动，或者用`stmt->if expr then stmt`归约。如果我们通过优先使用移动来解决这个冲突，语法分析器就能正常工作。

非LR出现的另一种常见的情况是：制导了句柄，但根据栈里的内容和下一个输入符号不足以判断在归约中使用哪个产生式。

例子：假设词法分析器对任何标识符都返回记号id，而不管它是如何使用的。假设语言通过给出过程的名字及用括号括起来的参数表来调用过程，而且数组元素的引用也采用同样的语法。因为数组引用中的下标和过程调用中的参数的翻译是不一样的，所以，用不同的产生式来产生实参数和下标表。文法应该具有下面一些产生式：
```
(1) stmt -> id(parameter_list) 
(2) stmt -> expr := expr
(3) parameter_list -> parameter_list, parameter
(4) parameter_list -> parameter
(5) parameter -> id
(6) expr -> id(expr_list)
(7) expr -> id
(8) expr_list -> expr_list, expr
(9) expr_list -> expr
```
以A(I,J)开始的语句可能以记号流id(id,id)的形式呈现给语法分析器。把前三个记号移进栈后，移动归约语法分析器的格局是：
```
栈           输入
...id(id      ,id)...
```
显然，必须对栈顶的id进行归约：如果A是过程，应按产生式(5)归约；如果A是数组，应按产生式(7)归约。但栈中的信息不能告诉应该按哪个产生式归约，必须使用符号表中有关A的信息。

解决上述问题的一种方法是把产生式(1)的记号改为procid，并使用更复杂一些的词法分析器，当它识别出作为过程名的标识符时返回记号procid。当然，这样做要求词法分析器在返回记号前要访问符号表。

这样修改后，处理A(i,j)时，语法分析器可能处于格局
```
栈               输入
...procid(id    .id)...
```
或处于前面的格局。前者用产生式(5)归约，后者用产生式(7)归约。注意，栈中的第三个符号用来决定归约的产生式，虽然它本身并不包含在这个归约中。移动归约分析可以利用栈深处的信息来指导分析。

### 算符优先分析法

LR文法是一大类适合移动归约语法分析器的文法。对于一小部分非常重要的文法，可以很容易地手工构造有效的移动归约语法分析器。这些文法具有下面的性质：所有产生式的右部都不是e或两个相邻的非终结符。具有第二个性质的文法称为算符文法。
```
E -> EAE | (E) | -E | id
A -> + | - | * | / | ^
```
它不是算符文法，因为右部EAE有2个（实际上是3个）连续的非终结符。然而，如果用A的每个候选式替代第一个产生式中的A，将得到下面的算符文法:
```
E -> E + E | E - E | E * E | E / E | E ^ E | (E) | -E | id    文法(4-17)
```
算符优先语法分析器最初是一种处理记号的技术，而这些记号不是建立在文法的基础上。实际上，一旦根据一个文法构造了一种算符优先语法分析器，就可以忽略该文法，栈中的非终结符仅仅作为与这些非终结符相关的属性的占位符。

作为通用的语法分析技术，算符优先分析法具有许多缺点。例如，它很难处理像减号这样的记号，因为减号有两个不同的优先级(取决于它是一元操作符`取负`还是二元操作符`减法`)。更糟糕的是，因为要分析的语言的文法和算符优先语法分析器本身的关系不是十分紧密的，所以不能肯定语法分析器接受的就是所期望的语言。

然而，由于算符优先分析技术比较简单，很多编译器的语法分析器经常采用算符优先分析技术对表达式进行分析，对于语句和高级结构的分析则采用**递归下降分析法**。有些编译器的语法分析器甚至对整个语言都采用算符优先技术进行语法分析。

在算符优先分析中，在某些终结符对之间定义如下三种优先关系：`<·`/`·=`/`·>`。这些优先关系可用于制导句柄的选取，它们的含义如右表所示。

关系|含义
-|-
`a <· b`|a的优先级低于b
`a ·= b`|a的优先级等于b
`a ·> b`|a的优先级高于b

注意：这些关系类似于算术关系“小于”、“等于”和“大于”，但优先关系具有不同的性质。例如，对于同一语言，`a <· b`和`a ·> b`可能同时成立，或者对于某两个终结符`a`和`b`，`a <· b`和`a ·= b`以及`a ·> b`均不成立。

有两种常用的方法确定终结符之间的优先关系。第一种方法是直觉主义方法，即基于习惯的操作符间的结合规则和运算优先关系。例如，如果`*`比`+`具有更高的优先级，可以令`+ <· *`和`* ·> +`成立。并且可以使用这种方法的算符优先语法分析器(虽然一元减会有问题)。

确定算符优先关系的第二种方法是首先为语言构造无二义性文法。该文法在分析树上反映了正确的结合规则和优先级。对于表达式来说，这项工作不难。对于二义性的其他来源，如else的不匹配。如果已经获得了无二义性文法，则存在一种从该文法构造算符优先关系的机械方法。这些关系可能是相交的，而且它们可能分析非该文法产生的语言，但是对于标准算术表达式来说，实际上很少遇到问题。

#### 使用算符优先关系

优先关系主要用于界定右句型的句柄。`<·`标记句柄的左端，`·=`出现在句柄的内部，`·>`标记句柄的右端。假设我们有一个算符文法的右句型，那么“没有相邻的非终结符出现在产生式右部”意味着“右句型不会有两个相邻的非终结符”。于是，可以用β0a1β1...anβn表示右句型，这里βi是e(空串)或单个非终结符，ai是单个终结符。

假设ai和ai+1之间只是满足`<·`/`·=`/`·>`中的某一种优先关系，用`$`标记符号串的两端，对所有的终结符b，定义`$ <· b`和`b ·> $`。现在假设我们从符号串移走非终结符，并在每两个终结符之间以及两端的终结符与$之间放上正确的优先关系`<·`/`·=`/`·>`，其中$标记符号串的两端。例如，假设开始时有右句型`id + id * id`和下表所示的优先关系，

\|id|+|*|$
-|-|-|-|-
id||·>|·>|·>
+|<·|·>|<·|·>
*|<·|·>|·>|·>
$|<·|<·|<·|

插入优先关系后的符号串为：
```
$ <· id ·> + <· id ·> * <· id ·> $
```

例如，由于`<·`是优先关系表中行为$列为id的表项，所以`<·`被插入在左端的`$`和`id`之间。应用下面的过程即可发现句柄:

* 从左端开始扫描串，直到遇到第一个`·>`为止。
* 向左扫描，跳过所有的`·=`,直到遇到一个`<·`为止，向左扫描到$
* 句柄包括从第2步遇到的`<·`的右部到一个`·>`的左部之间的所有符号，包括介于其间或者两边的非终结符。包括两边的非终结符是必要的，可以使两个相邻的非终结符不会出现在右句型中

如果正在处理文法(4-17)，就把id归约为E。这时，可以得到右句型E + id * id。按照同样的步骤将剩余的两个id归约为E之后，可以得到右句型E + E * E。现在考虑删除非终结符后的符号串`$+*$`。插入优先关系后，得到：
```
$ <· + <· * ·> $
```
可以看出，句柄的左端位于`+`和`*`之间，右端位于`*`和`$`之间。这些优先关系表明，在右句型`E + E * E`中，句柄是E * E。注意*两边的E也在句柄中。

因为非终结符不会影响语法分析，所以不需要考虑区分它们。可以吧一个标记“非终结符”保存在移动归约栈中，作为属性值的占位符。

为了找到句柄，每步都必须扫描整个右句型。用栈存储已看到的输入符号，并且用优先关系指导移动归约语法分析器的动作，情况就不同了。如果栈顶的终结符和下一个输入符之间的优先关系是`<·`或`·=`，则语法分析器移动，表示还没有发现句柄的右端；如果是`·>`关系，就调用归约。这时语法分析器已找到句柄的右端，而且优先关系还能用来在栈中找到句柄的左端。

如果一对终结符之间没有优先关系成立，则表示检测出了语法错误，须调用错误恢复例程。下面的算符可以形式化描述上述思想：

**算法4.5** 算符优先分析算法

```
输入：输入字符串w和优先关系表
输出：如果w是一个句子，则输出一个分析树架子，它的所有内节点均由占位非终结符E来标注；否则，指出错误。
方法：初始时，栈中放入$,输入缓冲区放入w$。为了进行语法分析。
```

#### 从结合律和优先级获得算符优先关系

可以以合适的方式创建算符优先关系，并希望由它们指导的算符优先分析算法能运行正常。类似于文法(4-17)产生的算术表达式语言，可以用下面的启发式方法产生正确的优先关系。注意：文法(4-17)是二义性的，右句型可能有多个句柄。设计规则是选择恰当的句柄来反映二元操作符的结合律和优先级

1. 如果操作符`o1`比`o2`具有更高的优先级，则`o1 ·> o2`和`o1 <· o2`都成立。例如，如果`*`比`+`具有更高的优先级，那么，`* ·> +`和`+ <· *`都成立。这些关系可以确保形如`E + E * E + E`的表达式，中间的`E * E`是先被归约的句柄。
2. 如果`o1`和`o2`是同优先级的操作符(可以是同一个操作符),那么当它们满足左结合律时,`o1 ·> o2`和`o1 <· o2`成立;当它们满足右结合律时，`o1 ·> o2`和`o1 <· o2`成立。例如,`+`和`-`满足左结合律,`+ ·> +`、`+ ·> -`、`- ·> -`、`- ·> +`同时成立。`^`满足右结合律，这些关系可以确保在`E - E + E`中，`E - E`会被选为句柄；而在`E ^ E ^ E`中，最后的`E ^ E`会被选为句柄
3. 对于所有的操作符o来说，`o <· id`、`id ·> o`、`o <· (`、`( <· o`、`) ·>o`、`o ·> )`、`o ·> $`、`$ <· o`均成立。`( ·= )`、`$ <· id`、`( <· (`、`id ·> $`、`) ·> $`、`( <· id`、`id ·> )`、`) ·> )`

这些规则可以确保`id`和`(E)`都会被归约为`E`,而且只要`$`作为左右两端的标记，就可能会促使在`$`之间找到句柄。

例子：对于算符`+`,`-`,`*`,`/`,`^`,`id`,`(`,`)`,`$`的算符优先关系：

* `^`具有最高优先级，满足右结合律
* `*`和`/``具有次最高优先级，满足左结合律
* `+`和`-`的优先级最低，满足左结合律

#### 处理一元操作符

如果有类似于`~`(逻辑非)的操作符，并且不是二元操作符，那么可以把它合并到上面的构造算符优先关系的方案中。假设`~`是一元前缀操作符，对于任何操作符`o`,无论是一元的还是二元的，均使`o ·< ~`成立。如果`~`比`o`的优先级高，则使`~ ·> o`成立，否则`~ ·< o`成立。例如，设`~`比`&`优先级更高，且`&`满足左结合律，通过这些规则可以看出`E & ~E & E`等价于`(E & (~E)) & E`。一元操作符的规则类似。

对于类似于减号这样的操作符(它既是一元前缀操作符又是二元中缀操作符)情况就不同了。即使给一元和二元的减号赋予同样的优先级，也无法区别一元或者二元。当它看到一元的减号时返回不同的记号。但是词法分析器不能通过超前扫描来区分两者，它必须记住前一个记号。例如，在Fortran中，如果前一个记号是操作符、左括号、逗号或赋值符号，则减号是一元的。

#### 优先函数

使用算符优先语法分析器的编译器不需要存储优先关系表。在大多数情况下，该表可以用两个优先函数f和g来表示。f和g把终结符映射为整数。对于符号a和b，选择f和g满足：

* f(a) < g(b),如果a <· b 
* f(a) = g(b),如果a ·= b 
* f(a) > g(b),如果a ·> b 

这样a和b之间的优先关系就可以通过f(a)和g(b)之间的数值比较来确定。但是，优先矩阵中的空白项是模糊的，因为无论f(a)和g(b)取何值，上面的1、2或3总有1项成立。错误检测的能力损失还没有严重到阻止使用有限函数的程度。如果在调用归约时没有发现句柄。仍然会发现错误。

注意：并不是所有的优先关系表都能用优先函数来表示；但是，在实际应用中，优先函数通常是存在的。

**算法4.6** 优先函数的构造
```
输入：算符优先表
输出：表示输入矩阵的优先函数，或指出它不存在
方法：
1. 为每个终结符a或$创建符号fa和ga
2. 把生成的符号按下面的方式分成尽可能多的组；如果a ·= b，则fa和gb在同一组。注意，即使某些符号之间没有 ·= 关系，也可能不得不把它们放在同一组。例如，如果a ·= b且c ·= b,那么fa和fc必在同一组，因为它们都和gb在同一组。此外，如果c ·= d,那么即使a ·= d不成立，fa和gd也可能在同一组
3. 构造一个以(2)中的符号组为节点的有向图。对任意的a和b，如果a <· b，则从gb所在的组引出一条边指向fa所在的组。如果a >· b,则从fa所在的组引一条边指向gb所在组。注意从fa到gb的边或路径意味着f(a)必超过g(b)，从gb到fa的路意味着g(b)必超过f(a).
4. 如果(3)中构造的图中有环路，则不存在优先函数。如果没有环路，则将f(a)设为从fa所在的组开始的最长路径的长度，g(a)设为从ga所在的组开始的最长路径的长度。
```

#### 算符优先分析中的错误恢复

算符优先分析器在语法分析的过程中，能发现以下两种情况下的语法错误：

* (1) 如果栈顶的终结符和当前输入之间没有优先关系
* (2) 如果发现句柄，但句柄不是任何产生式的右部

算符优先分析算法(算法4.5)似乎只归约由终结符组成的句柄。然而，虽然非终结符是匿名处理的，但它们仍在分析栈中占据位置。

然而，不能因为我们在栈中找到了一个符号序列`a <· b1 ·= b2 ·= ... ·= bk`,就认为b1b2...bk是某个产生式右部的终结符串。事实上，如果希望将语义规则和归约相关联，就必须这么做。以确定归约时哪个产生式是句柄。

##### 归约时的错误处理

可以把错误检测和恢复程序分成几部分。例子：当把符号弹出栈时，没有用于归约的产生式，所以没有语义动作，而只是打印诊断信息。为了确定打印什么诊断信息，处理情况(2)的程序必须确定被弹出的字符串与哪个产生式的右部相像。例如：假设abc被弹出，并且没有哪个产生式的右部由a，b，c和零个或多个非终结符组成，也许可以考虑是否删除a、b和c中的一个就可以产生一个合法的产生式右部(忽略非终结符)。例如，如果有一个右部为aEcE，则可以给出下面的诊断信息：
```
illegal b on line (包含b的行)
```
也可以考虑改变或插入一个终结符。如果abEdc是一个产生式的右部，则可以给出下面的诊断信息：
```
missing d on line (包含c的行)
```
也可能发现对于某个右部，终结符的顺序正确，但非终结符的模式不对。例如，abc被弹出栈并且在它的中间和两边均没有非终结符，而且abc不是某产生式的右部，而aEbc是，则可以给出下面的诊断信息：
```
missing E on line (包含b的行)
```
这里的E代表由非终结符E所表示的一个适当的语法类型。例如，如果a、b或c是操作符，则可能代表“表达式”；如果a是类似if这样的关键字，则可能代表“条件”。

*注意：在使用优先函数表示优先关系表的编译器中，这种错误源的检测可能不可用*

一般地，当没有发现的句柄不是任何产生式的右部时，要给出合适的诊断信息，其困难在于是否弹出有限或无限数目的字符串。相邻符号之间必须满足`·=`关系。如果算符优先表告诉仅由有限数目的终结符序列满足`·=`关系，则可以用枚举法处理这些串。对于每个这样的串x，可以事先确定一个具有最小距离的字符串y，y是某个产生式的右部，并给出诊断信息来暗示希望找到y时却找到了x。

确定上述过程能够弹出所有字符串是很容易的，其方法是构造一个有向图，图的节点表示终结符，当且仅当`a ·= b`时，从a到b有一条边。沿着图上各路径的节点标记所形成的字符串就是能够弹出的字符串。路径可能包含单个节点。然而，对某个输入，为了能够弹出`b1b2...bk`,必须有一个符号a(可能是$)使得`a <· b1`,`b1`称为起点；同时也必须有一个符号c(可能是$)使得`bk ·> c`，`bk`称为终点。只有这时才能调用归约，使`b1b2...bk`称为被弹出的符号序列。如果从起点到终点的路径中有环路存在，则有可能弹出无限个串，否则只能弹出有限个串。

例子：重新考虑文法(4-17)
```
E -> E + E | E - E | E * E | E / E | E ^ E | (E) | -E | id    文法(4-17)
```

检查程序进行如下检查：

* 1. 如果`+`、`-`、`*`、`/`或`^`被归约，则检查两边是否有非终结符出现。如果没有，输出诊断信息“missing operand”
* 2. 如果`id`被归约，检查两边是否有非终结符出现。如果有，输出警告“missing operator”
* 3. 如果`()`被归约，检查两个括号中间是否有非终结符出现。如果没有，输出警告“no expression between parentheses”

除此之外，还要检查是否有非终结符出现在括号对的任何一边，如果是，给出和(2)一样的信息。如果能够弹出无限个字符串，则错误信息不能用枚举法列出。可以使用通用程序来确定是否有某个产生式的右部与弹出的字符串接近(即距离是1或2，此处的距离根据插入、删除或修改的记号数而不是字符数来计算的)。如果有，则在“这个产生式是欲寻找的产生式”的假设下，给出一个特定诊断信息。如果没有产生式的右部与弹出的字符串接近，则给出一条一般的诊断信息“当前行有错误”。

##### 处理移动归约错误

下面讨论算符优先语法分析器检测错误的其他方法。如果根据优先矩阵决定符号移动还是归约，有时会发现栈顶符号和第一个输入符号间没有优先级关系。例如，假设a和b是两个相邻栈顶符号，b在栈顶，c和d是接下来的两个输入符号，且b和c之间没有优先关系。为恢复错误，必须修改栈、输入或者两者都修改。可以改变符号、在输入或栈中插入符号或者从输入或栈中删除符号。如果改变或插入符号，*注意：可以免陷入死循环*。例如，在输入的前端不断地插入符号而不能归约或移动任何插入的符号，就可能会造成死循环。

一种不会陷入死循环的方法是确保在恢复后能够把当前输入符号移动进栈(如果当前符号是$,确保不会往输入中插入符号，且栈最终会被缩短)。例如，假设ab在栈里，cd是输入，如果`a <=· c^2`,把b从栈里弹出。另一种选择方案是：如果`b <=· d`,从输入中删除c。第三种选择方案是找到某个符号e，使得`b <=· e <=· c`,在输入字符串中把e插到c的前面。更一般地，如果找不到单个符号插入，可以插入符合如下条件的一串符号：
```
b <=· e1 <=· e2 <=· ... <=· en <=· c
```

对于优先矩阵中的每个空白项，必须指定一个错误恢复程序，而且同一程序可用在多个地方。这样，当语法分析器在步骤(6)发现a和b之间没有优先关系时，就可以找到指向相应错误恢复程序的指针。

例子，错误处理机制如何处理错误输入字符串`id+`。语法分析器的第一个动作是把id移动进栈，并将其归约为E(还是用E作为栈中的匿名非终结符)，然后移进`+`,现在的格局是：
```
栈    输入
$E+    )$
```
因为`+·>)`,调用归约，句柄是`+`。错误检查程序将进行归约时的错误检测，检查`+`的左右是否有`E`,发现右边缺少`E`,给出诊断信息"missing operand",并进行归约，现在的格局为：
```
栈    输入
$E    )$
```
`$`和`)`之间没有优先关系，而且图中与这对符号对应的项是e2。程序e2被调用并给出诊断信息"unbalanced right parenthesis",然后从输入中删掉右括号，语法分析器最后的格局为
```
栈    输入
$E    $
```

### LR语法分析器

一种自底向上语法分析技术，它适用于一大类上下文无关文法的语法分析。这种技术叫做LR(k)分析法，L指的是从左向右扫描输入字符串，R指的是构造最右推导的逆过程，k指的是在决定语法分析动作时需要向前看的符号个数。(k)省略时，假设k是1。LR分析富有吸引力的原因有以下几点：

* LR语法分析器能识别几乎所有能用上下文无关文法描述的程序设计语言的结构
* LR分析法是已知的最一般的无回溯移动归约语法分析法，而且可以和其他移动归约分析法一样被有效地实现
* LR分析法分析的文本类是预测分析法能分析的文法类的真超集。
* 在自左向右扫描输入符号串时，LR语法分析器能及时发现语法错误。

这种分析方法的主要缺点是，对典型的程序设计语言文法，手工构造LR语法分析器的工作量太大，因而需要专门的工具，即LR语法分析器的生成器。

幸好有许多这样的生成器是可用的。比如Yacc的设计和使用。有了这种生成器，只要写出上下文无关文法，就可以用它自动生成该文法的语法分析器。如果文法有二义性或有其他难以自左向右分析的结构，这种生成器能够识别这些结构，并向编译器设计者报告。

在讨论完LR语法分析器的操作后，将给出三种构造LR分析表的方法。第一种方法称为简单LR方法(简称SLR)，它最容易实现，但功能也最弱。对某些文法，另外两种方法能成功地产生语法分析表，但用它却会失败。第二种方法称为规范的LR方法，它的功能最强，代价也最高。第三种方法叫做向前看的LR方法(简称LALR)，其功能和代价介于前两者之间。LALR方法可用于大多数程序设计语言的文法，并且可以高效地实现。以及还有LR语法分析表的压缩技术。

#### LR语法分析算法

LR语法分析器的模型如图所示，它是由输入、输出、栈、驱动程序以及包含动作(action)和转移(goto)两部分的语法分析表构成的。驱动程序对所有的LR语法分析器都是一样的，不同的语法分析器只是语法分析表有所不同。分析程序每次从输入缓冲区读入一个符号，并使用栈来存储形如`s0X1s1X2s2...Xmsm`的串，其中`sm`在栈顶,`Xi`是文法符号，`si`是称为状态的符号，每个状态符号概括了栈中位于它下面的信息。栈顶的状态符号和当前的输入符号用来检索语法分析表，以决定移动归约分析的动作。在实际实现中，文法符号不必出现在栈里。

**语法分析表由动作函数action和转移函数goto两部分组成**。驱动LR语法分析器的程序工作如下：它根据栈顶状态sm和当前输入符号ai访问`action[sm, ai]`,即sm和ai所对应的语法分析表项的动作部分，可能的动作如下：

* 移动状态s进栈 
* 按文法产生A->β归约
* 接收
* 出错

函数goto以状态和文法符号为参数，产生一个状态。将会看到，用SLR、规范的LR或LALR方法从文法G构造的语法分析表的goto函数是识别G的活前缀的确定有穷自动机的转换函数。回想一下，文法G的活前缀是右句型的前缀，并且它不会超过句柄的最右端，所以它可以出现在移动归约语法分析器的栈顶。这个确定有穷自动机的初始状态是初始时置于LR语法分析器栈中的状态。

LR语法分析器的格局是一个如下形式的二元组，它的第一个分量是栈的内容，第二个分量是尚未处理的输入：
```
(s0 X1 s1 X2 s2 ... Xm sm ai ai+1 ... an $)
```
这个格局代表下面的右句型:
```
X1 X2 ... Xm ai ai+1 ... an
```
由此可以看出，它本质上和一般的移动-归约分析器相同，只是栈中新加了一些状态。

语法分析器的下一个动作是用当前输入符号ai和栈顶状态sm查询语法分析表的表项`action[sm,ai]`。四种不同的移动所引起的格局变化如下：

* 1. 如果`action[sm,ai]=`"移动状态s进栈",语法分析器执行移动操作，进入下面的格局：
```
(s0 X1 s1 X2 s2 ... Xm sm ai ai+1 ... an $)
```
这里，语法分析器把当前输入符号ai和下一个状态s(它在`action[sm,ai]`中给出)都移动进栈；`ai+1`成为当前输入符号。
* 2. 如果`action[sm,ai]=`"按文法产生式`A->β`归约"，语法分析器执行归约操作，进入下面的格局：
其中，`s=goto[sm-r,A]`,r是产生式右部β的长度，在此，语法分析器首先从栈中弹出`2r`个符号，分别为r个状态符号和r个文法符号(这些文法符号刚好匹配产生式的右部β)，栈顶为状态`sm=r`。然后，语法分析器把产生式左边的符号A和`goto[sm-r,A] = s`压入栈。执行归约操作时，当前输入符号没有变化。对于要构造的LR语法分析器，从栈中弹出的文法符号序列`Xm-r,+1...Xm`总是能匹配归约式的右部β。LR语法分析器的输出由归约时执行的与归纳产生式有关的语义动作产生，现在，我们暂且认为输出就是打印归约中使用的产生式。
* 3. 如果`action[sm,ai]=`“接受”，分析完成。
* 4. 如果`action[sm,ai]=`“出错”，语法分析器发现错误，调用错误恢复程序。

所有的LR语法分析器都以这种方式工作，只是语法分析表的action和goto域的信息有所不同。

**算法4.7** LR分析算法
```
输入：文法G的LR语法分析表和输入串w
输出：如果w属于L(G),则输出w的自底向上分析，否则报错
方法：首先，把初始状态s0放在语法分析器栈顶，把w$放在输入缓冲区；然后，语法分析器执行下图的程序，直到遇见接受或出错动作为止.

令ip指向w$的第一个符号;
repeat forever begin
    令s是栈顶的状态，a是ip所指向的符号；
    if action[s, a] = "移动状态s'进栈" then begin
        把a和s'依次压入栈顶；
        让ip指向下一个输入符号
    end
    else if action[s,a] = "按文法产生式A->β归约" then begin
        从栈顶弹出2 * |β|个符号；
        令s'是现在的栈顶状态；
        把A和goto[s',A]依次压入栈；
        输出产生式A->β
    end
    end if action[s, a] = "接受" then
        return
    else error()
end
```

例子：下面是含二元操作符+和*的算术表达式的文法:

```
(1) E -> E + T
(2) E -> T
(3) T -> T * F
(4) T -> F
(5) F -> (E)
(6) F -> id
```

G的LR语法分析表，包括动作函数和转移函数。各个动作的编码的含义是：
* 1. si表示把当前输入符号和状态i压进栈
* 2. rj表示按第j个产生式归约
* 3. acc表示接受
* 4. 空白表示出错

注意：对于终结符a，状态转移动作`goto[s, a]`可以在表的动作表项`action[s, a]`中找到，所以转移域中仅给出非终结符A的`goto[s, A]`。

给定输入字符串`id * id + id`,栈和输入内容的变化序列。在第一行，LR语法分析器处于状态0，id是第一个输入符号。第0行和第id列对应的动作域是s5,其含义是id进栈，并把状态5压入栈顶。第二行给出了执行动作s5后的格局：第一输入记号id和状态5进栈，把id从输入字符串删除。

然后，`*`成为当前输入符号，状态5遇见输入`*`的动作是按`F->id`归约:弹出栈顶的两个符号(一个状态符号和一个文法符号)，栈顶为状态0。因为`goto[0, F]`是3，语法分析器把F和3压入栈顶，到达第3行所示的格局。

#### LR文法

给定文法G,如果我们能为G构造出LR语法分析表，则称G是LR文法。很多上下文无关文法不是LR文法。但是，典型的程序设计的结构一般都可以避免非LR文法。直观地，为了使一个文法是LR文法，只要保证在句柄出现在栈顶时，自左向右扫描的移动分析归约分析器能够及时地识别它。

LR语法分析器不需要扫描整个栈就可以知道什么时候句柄出现在栈顶。栈顶的状态符号包含了所需要的一切信息。一个非常重要的事实是：如果仅知道栈中的文法符号就可以识别句柄，则存在一个有穷动机，通过自顶向下读栈中的文法符号自动机就能确定栈顶的句柄(如果有的话)。LR语法分析表的goto函数实质上就是这样的有穷自动机。不过，这个有穷自动机不需要每次移动都读栈。如果识别句柄的有穷自动机自底向上读栈中的文法符号，栈顶所存的状态符号正好是这个自动机所进入的状态。于是，LR语法分析器从栈顶的状态即可确定它需要从栈中了解的一切。

能够用来帮助LR语法分析器作出移动归约决定的另一个信息源是下k个输入符号。实际上感兴趣的是k=0或k=1时的情况。每步需要向前看k个符号的LR语法分析器所分析的文法叫做LR(k)文法。

LL文法和LR文法之间有明显的区别。对于LR(k)文法，必须通过向前看k个输入符号就能够知道一个产生式的右部所能推导出的所有字符串，进而识别出这个产生式右部的出现。这个要求远不如LL(k)那么严格。LL(k)文法要求只要看到了产生式右部推出的前k个符号后就能是被出用于归约的产生式。所以LR文法比LL文法描述的语言更多。

#### 构造SLR语法分析表

由文法构造LR分析表的三种方法：其中一种是**简单LR**即SLR。SLR的功能最弱，但最容易实现。根据这种方法构造的语法分析表叫做SLR语法分析表。使用SLR语法分析表的LR语法分析器叫做SLR语法分析器。能够为之构造SLR语法分析器的文法叫做SLR文法。另外两种通过向前看信息增强了SLR语法。所以SLR方法是研究LR语法分析的理想起点。

文法G的LR(0)项目是在G的产生式右部的某处加点的产生式。例如，产生式`A->XYZ`可以生成如下四个项目：
```
A -> ·XYZ
A -> X·YZ
A -> XY·Z
A -> XYZ·
```

产生式`A->e`只生成一个项目`A->·`。项目可以用一对整数来表示：第一个数表示产生式的号码，第二个数表示点的位置。直观地，项目表示：在语法分析过程中的某一时刻，已经看见了一个产生式所能退出的字符串的多大部分。

SLR方法的主要思想是首先从文法构造识别活前缀的确定有穷自动机。我们把项目划分成一组集合，这些集合对应SLR语法分析器的状态。项目可以看成是识别活前缀的NFA的状态，而“项目分组”就是**子集构造法**。

被称为规范LR(0)项目集族的LR(0)项目集合族是构造SLR语法分析表的基础。为了构造文法规范LR(0)项目集族，需要定义拓广文法的概念，并引入闭包(closure)运算和转移函数(goto)

如果文法G的开始符号是S，那么G的拓广文法G'是在G的基础上增加一个新的开始符号S'和产生式`S'->S`。新产生式的目的使用来指示语法分析器什么时候应该停止分析并宣布接受输入，即当且仅当语法分析器执行归约S'->S时，分析成功。

##### 闭包运算closure

如果I是文法G的项目集，那么closure(I)是从I出发下面两条规则构造的项目集：

* 1. 初始时，把I的每个项目都加入到closure(I)中；
* 2. 如果`A->α·Bβ`在closure(I)中，且存在产生式`B->γ`不在closure(I)中，则将其加入closure(I)。反复运用这条规则，直到没有更过的项目可加入closure(I)为止。

`A->α·Bβ`在closure(I)中表示语法分析过程的某一时刻，下一步应该从输入中看见的是由Bβ推出的串。如果`B->γ`是一个产生式，希望在这个时刻，也应该从输入串中看见从γ推出的子串。基于这个原因，把`B->γ`加入到closure(I).

如果I是一个项目集合`{[E'->E]}`，那么closure(I)包含下列项目：

```
E' -> ·E
E -> ·E + T
E -> ·T
T -> ·T * F
T -> ·F
F -> ·(E)
F -> ·id
```

按规则(1),把`E'->·E`加入到closure(I)。因为E紧挨在点的右边，由规则(2)，把点在左端的E产生式，即`E->·E+T`和`E->·T`都加入到closure(I)。同样，把`T->·T*F`和`T·->F`也加入进去。最后,`T->·F`导致了`F->·(E)`和`F->·(id)`的加入。

计算函数closure的算法如下式所示。一种简单的实现方法是使用一个由G的非终结符作为索引的布尔数组added。当为每个`B->γ`产生式增加项目`B->·γ`时，将`added[B]`置为`true`。

注意，如果一个点在左端的B产生式被加入closure(I),则所有B产生式都将类似地加入closure(I)。事实上，并不需要列出如此加入项目`B->·γ`，而只要列出这样的非终结符B就足够了。因此，可以把感兴趣的项目分成两类：

```
function closure(I)
begin
    j := I
    repeat
        for J的每个项目A->α·Bβ和G的每个产生式
            B->γ，若B->·γ不在J中do
                把B->·γ加入J;
        until 没有新项目可加入J;
    return J
end
```

* 1. 核心项目：初始项`S'->S`和所有点不在左端的项目
* 2. 非核心项目：点在左端的非初始项目

感兴趣的每个项目集都可以通过求核心项目集的闭包得到。当然，加入闭包的项目绝不会是核心项目。这样，如果扔掉所有非核心项目，可以用较少存储空间来表示需要的项目集合，因为非核心项目可以通过求闭包来重新生成。

##### goto函数

第二个非常有用的函数goto(I, X),其中I是项目集，X是文法符号。goto(I,X)定义为所有项目集`[A->αX·β]`（`[A->αX·β]`在I中）的闭包。如果I是对某个活前缀γ的有效项目集，那么goto(I,X)第对活前缀`γX`有效的项目集。

例子：若I是两个项目的集合`|[E'->E·],[E->E·+T]|`，则`goto(I,+)`包含以下项目：
```
E -> E + ·T
T -> ·T * F
T -> ·F
F -> ·(E)
F -> ·id
```

通过考察I的项目，找到+紧挨在点右侧的项目来计算`goto(I,+)`.`E'->E·`不是这样的项目，但`E->E·+T`是这样的项目。把`E->E·+T`中的点移过`+`得到`|E->E+·T|`,然后取它的闭包。

##### 项目集的构造

给出拓广文法`·G'`的规范`LR(0)`项目集族(下面用C表示)的构造算法，如下式所示。

```
procedure items(G')
begin
    C := {closure({[S'->S]})};
    repeat
        for C的每个项目集I和每个文法符号X，
            若goto(I,X)非空且不再C中 do
                把goto(I,X)加入C中
    until 没有更多的项目可以加入C
end
```

如果D的每个状态都是终态且I0是初始状态，那么D识别的刚好是文法的活前缀。这不是偶然的。对每个文法G，规范项目集族的goto函数定义了一个确定的有穷自动机，识别G的活前缀。事实上，也可以想象一个识别活前缀的不确定的有穷自动机N，其状态就是项目本身。从`A->α·Xβ`到`A->αX·β`有一个标记为X的转换，从`A->α·Bβ`到`B->·γ`有一个标记为e的转换。于是，由N的状态集组成的项目集I的closure(I)恰好是之前定义的NFA的一个状态集的e闭包。在由N用子集构造法构造的DFA中，goto(I,X)定义了状态I遇见符号X时的转换。

**有效项目**-如果存在一个推导`S rm*-> αAw rm*-> αβ1β2w`，则说项目`A -> β1 · β2`对活前缀`αβ1`是有效的。一般而言，同一项目可能对多个活前缀有效。`A -> β1 · β2`对活前缀`αβ1`有效这个事实告诉我们，在发现`αβ1`在分析栈时是移进还是归约，特别是，如果`β2 != e`,它暗示句柄还没有完全进栈，动作应该是移进。如果`β2 = e`,那么`A -> β1`是句柄，应该用这个产生式归约。当然，同一个活前缀的两个有效项目可能告诉做不同的事情，有些这样的冲突可以通过向前看下一个输入符号来解决，其他一些冲突可以用下一节的方法解决。当LR方法用于构造任意文法的语法分析表时，不能保证所有语法分析动作的冲突都能被解决。

例：考虑文法(4-19)。它的项目集和goto函数为转换函数的DFA，串`E+T*`是(4-19)的活前缀。自动机读完`E+T*`之后。进入状态I7,状态I7包含下列项目:
```
T -> T *· F
F -> ·(E)
F -> ·id
```

##### SLR语法分析表

现在来说明怎样从识别活前缀的确定有穷自动机构造SLR语法分析表的动作(action)函数和转移(goto)函数。算法不能为所有的文法都产生唯一确定的分析动作表，但是可以成功地应用在许多程序设计语言的文法上。给定文法G,首先把G拓广到G',然后构造G',然后构造G'的规范项目集族C，最后使用下面的算法从C构造语法分析表的action函数和goto函数。

**算法4.8** SLR语法分析表的构造

```
输入：拓广文法G'
输出：G'的SLR语法分析表函数action和goto
方法：
1. 构造C = {I0,I1,...,In}
2. 从Ii构造状态i，它的分析动作确定如下：
a) 如果 [A->α·aβ]在Ii中，并且goto(Ii, a) = Ij,则置action[i,a]为“移动j进栈”，这里的a必须是终结符。
b) 如果 [A->α·]在Ii中，则对FOLLOW(A)中的所有a，置action[i, a]为“归约A->α”。这里的A不能是S'
c) 如果 [S''->S·]在Ii中，则置action[i,$]为“接受”
如果由上面的规则产生的动作有冲突，那么文法G就不是SLR(1)文法。在这种情况下，该算法构造不出G的语法分析器
3. 对所有的非终结符A，使用下面的规划构造状态i的goto函数；如果goto(Ii, A) = Ij,则goto[i, A] = j
4. 不能由规则(2)和规则(3)定义的表项都置为"出错"
5. 语法分析器的初始状态是从包含[S'->S]的项目集构造出的状态。

由算符4.8所确定的由action和goto函数组成的语法分析表叫做文法G的SLR(1)表。使用G的SLR(1)表的LR语法分析器。存在SLR(1)语法分析表的文法叫做SLR(1)文法。通常，省略SLR后面的(1)，因为不讨论向前看多个符号的分析器
```

例子：为文法(4-19)构造SLR表。它的规范LR(0)项目集族已在上图中给出，首先考虑项目集I0；
```
E' -> ·E
E -> ·E + T
E -> ·T
T -> ·T * F
T -> ·F
F -> ·(E)
F -> ·id
```

项目F->·(E)使得`action[0,(]`="移动4进栈"，项目`F->·id`使得`action[0,id]`=“移动5进栈”。I0中的其他项目不产生动作。现在考虑I1：
```
E' -> E·
E -> E·+T
```
第一项导致`action[1,$]`="接受"，第二项使得`action[1,+]`="移动5进栈"，I0中的其他项目不产生动作。现在考虑I1:
```
E' -> E·
E -> E·+T
```
第一个项导致`action[1,$]`="接受"，第二项使得`action[1,+]`="移动6进栈"。接下来考虑I2：
```
E -> T·
T -> T·*F
```
因为FOLLOW(E)={$,+,)},第一项使得`action[2,$]=action[2,+]=action[2,)]=`“归约E->T”，第二项使得`action[2,*]`="移动7进栈"。以这种方法继续下去即可得到图中的动作(action)表和转移(goto)表。归约动作中的产生式序号和它在原文法中出现的顺序是相同的，即`E->E+T`的序号是1,`E->T`的序号是2.

例：每个SLR(1)文法都不是二义的，但有很多非二义的文法不是SLR(1)文法。考虑其右下列产生式的文法:
```
S -> L = R
S -> R
L -> * R
L -> id
R -> L
文法(4-20)
```

可以把L和R想象成分别代表左值和右值，而*代表一个“取单元内容”的操作符。文法(4-20)的规范LR(0)项目集族。

考虑项目集I2。该集合的第一项使得`action[2, =]`为“移动6进栈”。因为FOLLOW(R)包含=（这里因为`S=>L=R=>*R=R`）,第二项使得`action[2,=]`为“归约R->L”。于是，`action[2,=]`有多重定义。因为其中既有移动进栈又有归约，所以状态2在输入符号为"="时存在移动-归约冲突。

文法(4-20)不是二义性的。移动-归约冲突的出现，说明SLR语法分析器的构造方法没有强制记住足够多的上下文，以决定在已经看见了可归约到L又面临=时，语法分析器应该采取什么动作。

但是，存在一些非二义文法，每种LR语法分析器构造方法都会为其产生包含冲突分析动作的语法分析动作表。程序设计语言中通常可以避免使用这样的文法。

#### 构造规范LR语法分析表

在SLR方法中，如果项目集Ii包含项目`[A->α·]`并且a在FOLLOW(A)中，则状态i调用`A->α`归约。然而，在某些情况下，当状态i出现在栈顶时，栈内的活前缀βα使得在任何右句型中，βA不能跟随a。因此，在这种情况下，用`A->α`进行归约时无效的。

可以令该状态蕴含更过的信息，使之能够剔除上述那些用A->α进行的无效归约。必要时，可以通过分裂状态，使LR语法分析器的每个状态能确切地支出句柄α后紧跟哪些终结符时才能把α归约为A。

通过重新定义项目，使之包含一个终结符作为第二个分量，可以把更多的信息并入状态中。项目的一般形式也就变成了`[A->α·β,a]`，其中`A->αβ`是产生式，a是终结符或$。这样的对象叫做LR(1)项目。1是第二个分量的长度，这个分量叫做项目的**搜索符**。**搜索符**对于β为非e的项目`[A->α·β,a]`没有影响。对于形如`[A->α·,a]`的项目，搜索符则表示只有下一个输入符号是a时该项目才能调用`A->α`归约。于是，只有`[A->α·,a]`是栈顶状态的LR(1)项目而且输入符号为a时，才能使用`A->α`进行归约。这样的a的集合总是FOLLOW(A)的一个子集，可能是真子集。

形式地，LR(1)项目`[A->α·β,a]`对话前缀γ有效，如果存在推导`S rm*-> δAw rm-> δαβw`,其中：

* 1. `γ=δα`
* 2. a是w的一个符号，或者w是e且a是$

规范构造有效的LR(1)项目集族的方法本质上和构造规范LR(0)项目集族的方法是一样的，只需要修改closure和goto两个过程。

为了理解closure运算的新定义，考虑对话前缀γ有效的项目集中的项目`[A->α·β,a]`,必定存在一个最右推导`S rm*-> δAax rm-> δaBβax`，其中`γ=δα`。假设`βax`能退出终结符串by，那么对每个形如`B->n`的产生式，存在推导`S *->rm γBby rm-> γnBy`，于是`[B->n，b]`对γ有效。注意，b可能是从β推出的一个终结符，或者在推导`βax *-> by`中，β推出e，b就成了a。总结这两种可能性，可以说b是FIRST(βax)中的任何终结符，其中FIRST的定义。注意，x不可能包含by的第一个终结符，所以FIRST(βax)=FIRST(βa)。

LR(1)项目集的构造算法：

**算法4.9** LR(1)项目的构造

```
输入：拓广文法G’
输出：LR(1)项目集，它们是对G'的一个或者多个活前缀有效的项目集
方法：构造项目集的过程closure和goto及主例程items

function closure(I);
begin
    repeat
        for I中的每个项目[A->α·Bβ,a],G'中的每个产生式B->γ和FIRST(βa)的每个终结符b，如果[B->·γ,b]不在I中do
            把[B->·γ,b]加入到I中；
    until 再没有项目可加到I中；
    return I
end

fuction goto(I,X)
begin
    对于I中的项目[A->α·Xβ,a],令J是项目[A->α·Xβ,a]的集合;
    return closure(J)
end

procedure items{G'};
begin
    C := {closure({[S' -> ·S, $]})};
    repeat 
        for C的每个项目I和每个文法符号X，若goto(I,X)
            非空且不在C中 do
                把goto(I,X)加入C中
    until 再没有项目集可以加入C中
end
```

首先计算`{[S'->S·,$]}`的闭包。为计算闭包，用项目`[S'->S·,$]`来匹配过程closure中的项目`[A->αB·β,a]`,即令`A=S'`,`α=e`,`B=S`,`β=e`,`a=$`.在函数closure中，要求对每个产生式`B->γ`只能是`S->CC`,而且因为`β=e`,`a=$`,`b`也只能是`$`,因此将`[S->·CC,$]`加入到闭包中。

接下来，对于FIRST(C$)中的b，将项目`[C->·γ,b]`加入闭包。也就是说，用项目`[S->·CC,$]`匹配项目`[A->αB·β,a]`,其中`A=S`,`a=e`,`B=C`,`β=C`,`a=$`。因为C不会推导出空串，所以FIRST(C$)=FIRST(C)。又因为FIRST(C)包含终结符c和d，所以将以下项目加入闭包：`[C->·cC,c]`,`[C->·cC,d]`,`[C->·d,c]`,`[C->·d,d]`

**算法4.10** 规范LR语法分析表的构造

```
输入：拓广文法G'
输出：文法G'的规范LR语法分析表action和goto
方法：
1. 构造G'的LR(1)项目集规范族C = {I0, I1, ..., In}
2. 从Ii构造语法分析器的状态i，状态i的分析动作确定如下：
a) 如果 [A->α·aβ,a]
b) 如果 [A->α·,a]在Ii中且goto(Ii,a)=Ij,则置action[i,a]为sj,即“移动j进栈”，这里要求a必须是终结符
c) 如果[S'->S·,$]在Ii中，则置action[i,$]=acc,表示接受。
如果用上面的规则构造语法分析表时出现冲突，那么该文法就是LR(1)的，该算法对此文法失败。
3. 状态i的转移按下面的方法确定：如果goto(Ii, A) = Ij,那么goto[i,A] = j
4. 用规则(2)和规则(3)中未能定义的所有表项都置为"出错"
5. 语法分析器的初始状态是由包含[S'->S,$]的项目集构造出的状态
```

由算符4.10产生的动作函数和转移函数所构成的表叫做规范LR(1)语法分析表，使用这种表的LR语法分析器叫做规范LR(1)分析器。如果动作函数没有多重定义的表项，那么这个文法叫做LR(1)文法。

#### 构造LALR语法分析表

LALR(lookahead-LR)技术。在实践中经常使用这种方法，因为由它产生的语法分析表比规范LR语法分析表要小得多，而大多数普通的程序设计语言的结构又都可以方便用LALR文法来表示。同样的结论对SLR文法几乎也是对的，但是有少数结构不能方便地用SLR技术进行处理。

就语法分析器的大小而言，SLR表和LALR表对同一个文法具有同样多的状态，而同样大小的语言的规范LR表则有几千个状态，所以构造SLR表和LALR表比构造规范LR表要经济的多。

考虑文法(4-21),取一对看起来类似的状态，如I4和I7，它们都只有一个项目，并且第一分量都是C->d,I4搜索符是c或d，I7中搜索符是$。

来看一下语法分析器中I4和I7的不同作用。注意，文法(4-21)产生的是正则集`c*dc*d`.当读入串`cc...cdcc..cd`时，语法分析器把第一组c及其后面的d移进栈中，进入状态4。如果下一个输入符号是c或d，语法分析器将按产生式`C->d`归约。要求c或d跟随是合乎情理的，因为它们属于串`c*d`的开始符号。如果跟在第一个d后的下一个输入符号`$`,例如，输入符号串`ccd`,因为该符号串不在此正则集内，因此分析器将报错(由状态4正确的指出错误)。

语法分析器在读入第二个d之后进入状态7。下一个输入符号必须是`$`，否则输入串就不是`c*dc*d`的形式。所以合理的做法是，面临`$`时状态7应按`C->d`归约，面临c或d时报告错误。

现在，让我们把状态I4和I7合并为I47，把它们的搜索符合起来，成为`[C->d·,c/d/$]`。从I0,I2,I3和I6到达I4或I7的在d上的转移现在都进入I47,状态I47的动作是对任何输入符号都进行归约。修改后的语法分析器的行为本质上和原来的一样，但它会把某些情况下的d归约成C，而原来的语法分析器对这些情况是报错的，如输入为ccd或cdcdc时。值得庆幸的是，这些错误最终会被捕获，而且是在移进下一个输入符号前被捕获。

更一般地讲，可以寻找同心的(即第一分量相同)LR(1)项目集，并把这些同心的项目集合并成一个项目集。一般而言，心是相应文法的一个LR(0)项目集；另外,LR(1)文法可能产生多个同心的项目集合。

因为goto(I,X)的心只依赖于I的心，所以LR(1)项目集合合并后的转移函数可以通过goto(I,X)自身的合并而得到，这样，在合并项目集时不必同时考虑修改转移函数的问题。动作函数应作相应修改，使得它能反映各个被合并集合的既定动作。

假设有一个LR(1)文法，即它的LR(1)项目集中不存在分析动作冲突。如果把通信的项目集合并为一，就可能导致冲突，但是这种冲突不会是移动-归约冲突。因为如果存在这种冲突。如果把同心的项目集合并为一，就可能导致冲突，但是这种冲突不会是移动-归约冲突。因为如果存在这种冲突，则意味着对当前输入符号a，有一个项目`[A->α·,a]`要求以`A->α`进行归约，同时又有另一个项目`[B->β·αγ,b]`要求把a移进。这两个项目既然同处于合并之后的项目集中，则意味着在合并前，必有某个c使得`[A->α·,a]`和`[B->β·αγ,c]`同处于合并前的某一集合中。然而，这又意味着原来的LR(1)项目集就已经存在着移动-归约冲突。从而文法不是LR(1)的，这与假设不符。事实上移动-归约冲突不依赖于搜索符号而只依赖于其心，因此，同心集的合并不会引起新的移动-归约冲突。

*注意：同心集的合并有可能产生新的归约-归约冲突。*

如下文法

```
S' -> S
S -> aAd | bBd | aBe | bAe
A -> c
B -> c
```

它只产生四个串：`acd`,`ace`,`bcd`和`bce`。通过构造该文法的LR(1)项目集，可以看出没有冲突，它是LR(1)文法。在它的项目集中，对活前缀`ac`有效的项目集为`{[A->c·,d],[B->c·,e]}`，对`bc`有效的项目集`{A->c·,e],[B->c·,d]}`,这两个集合都没有产生冲突且是同心的。然而，它们合并后
```
A -> c·, d/e
B -> c·, d/e
```
产生归约-归约冲突。因为当面临输入符号d或e时，不知道应该用哪个产生式进行归约。

**算法4.11** 一个简易但耗空间的LALR表构造法

```
输入：拓广文法G'
输出：G'的LALR语法分析表的action函数和goto函数
方法：
1. 构造文法的LR(1)项目集规范族C={I0,I1,...,In}
2. 对出现在LR(1)项目集中的每个心，找出所有与之同心的项目集，用它们的并集代替它们。
3. 令C'={J0,J1,...,Jm}是合并后的LR(1)项目集族。按照算法4.10中的方式从Ji来构造状态i的动作。如果分析动作出现冲突，算法无法产生分析表，说明该文法不是LALR(1)文法。 
4.goto表的构造如下：如果J是一个或多个LR(1)项目集的并，即J=I1∪I2∪...∪Ik,那么goto(I1,X),goto(I2,X),...,goto(Ik,X)也是同心，因为I1,I2,...,Ik都同心。记K为所有与goto(I1,X)同心的项目集的并，则goto(J,X)=K
```

由算法4.11产生的表称为G的LALR分析表。如果分析动作没有冲突，则该文法称为LALR(1)文法。在第(3)步构造的项目集族叫做LALR(1)项目集族。

当输入串为`c*dc*d`时，无论是哪种LR语法分析器，都给出了同样的移动归约序列。其差别只是状态名不同而已，即如果LR语法分析器把I3或I6压进栈，LALR语法分析器就把I36压进栈。对于正确的输入串，LR语法分析器和LALR语法分析器就非常相像。

但是，当输入串存在错误时，LALR语法分析器可能比LR语法分析器多做了一些不必要的归约，而LR语法分析器则能立即报错。但LALR语法分析器在LR语法分析器报错之后绝不会移进更多的符号。例如，若输入串是ccd并跟随以`$`时，LR语法分析器将把
```
0 c 3 c 3 d 4
```
压入栈，并在状态4发现错误，因为状态4面临$的动作是“出错”。对于同一输入串，LALR语法分析器将产生相应的动作，即把
```
0 c 36 c 36 d 47
```
压入栈，但状态47面临$的动作是归约C->d,栈的内容成为:
```
0 c 36 c 36 C 89
```
现在状态89面临$的动作是归约`C->cC`,这时栈的内容改为：
```
0 c 36 C 89
```
再经一次类似的归纳，获得的栈为：
```
0 C 2
```
最后，状态2面临$的动作是“出错”，语法分析器这时发现错误。

#### LALR语法分析表的有效构造方法

可以对算法4.11进行一些修改，以避免在创建LALR(1)语法分析表时包含全部的LR(1)项目集族，首先，注意到可以用项目集I的核来表示I，可以用初态项目`[S'->·S,$]`或那些圆点不在右部最左端的项目来表示I。

其次，只需要利用项目集I的核就能计算I所产生的动作。除非`a=e`,否则任何调用`A->α`进行归约的项目都在该核中。当且仅当存在核项目`[B->γ·Cδ,b]`,使得对某些η及FIRST(ηδb)中的a有`C rm*-> Aη`时，对输入a才可以用`A->e`进行归约。对每个非终结符C，满足`C rm*-> Aη`的所有非终结符A都可以预先计算出来。

由I产生的移进动作可以通过下列方法由I的核来确定。如果存在核项目`[B->γ·Cδ,b]`,其中`C *rm-> ax`,且这个推导的最后一步不使用e产生式，则可以将输入符号a移进。对于每个C，满足`C *rm-> ax`的所有终结符a也是可以预先计算出来的。

下面来看如何通过核来计算goto转换。如果`[B->γ·Xδ,b]`也在`goto(I,X)`的核中。如果`[B->γ·Cδ,b]`在I的核中，并且对于某个η有`C *rm-> Aη`,那么`[A->X·β,a]`也在`goto(I,X)`的核中。如果对每对非终结符C和A都能预先确定对某个η而言是否有关系`C *rm-> Aη`,那么，从核计算项目集这一工作仅比从闭包计算项目集的工作在效率上稍差一点而已。

为了计算拓广文法G'的LALR(1)项目集，先从初态项目集I0的核S'->S开始，然后，按上述方法计算出从I0出发的转移转换的核。继续计算出每一个新生成的核转移转换直到拥有全部LR(0)项目集的核为止。

例子：考虑下面的拓广文法：

```
S' -> S
S -> L = R | R
L -> * R | id
R -> L
```
该文法的LR(0)项目集的核如下式所示：
```
I0: S' -> S
I1: S' -> S
I2: S -> L· = R
    R -> L·
I3: S -> R·
I4: L -> *·R
I5: L -> id·
I6: S -> L =·R
I7: L -> *R·
I8: R -> L·
I9: S -> L=R·
文法(4-20)的LR(0)的项目集的核
```
现在为LR(0)项目集的核的每一个项目都配上适当的搜索符(第二个分量)。为了了解搜索符是如何从一个项目集I传播到`goto(I,X)`

假设计算的LR(1)项目而不是LR(0)项目，并且`[B->γ·Cδ,b]`属于I，那么对于哪些a的值，`[A->X·β,a]`将在`goto(I,X)`中呢？当然，如果a属于`FIRST(ηδ)`，那么由推导`C *->rm Aη`可知`[A->X·β,a]`一定在goto(I,X)之中。在这种情况下，b的值是无关的，称a(作为A->X·β的一个搜索符)是自生的。由此定义可知，作为初态项目集中的项目`S'->·S`的一个搜索符，$是自生的。

但是项目`A->X·β`的搜索符的产生还有另一种途径。如果`ηδ *-> e`,那么`[A->X·β,b]`也将在`goto(I,X)`中，这时称搜索符从`B->γ·Cδ`传播到`A->X·β`。下面的算法用来确定上述两种方式所产生的搜索符。

**算法4.12** 确定搜索符

```
输入：一个LR(0)项目集I的核K和一个文法符号X。
输出：对于`goto(I,X)`中的核项目，由I中的项目自生的搜索符，以及对于I中的项目，搜索符从这些项目将会传播到goto(I,X)中核项目中。
方法：算法如下所示，使用一个哑搜索符#来检测出超前扫描符号传播的情形。

for K中每一项B -> γ·δ do begin
    J := closure({[B -> γ·δ, #]});
    if [A -> αX·β,a]∈J' 其中a不是# then
        对于goto(I,X)中的核项目A -> aX·β,搜索符a是自生的；
    if [A -> αX·β,#]∈J' then
        搜索符从I中的B -> γ·δ传播到goto(I,X)中的A->αX·β
end
```

现在来考虑如何找到与LR(0)项目集的核中的每个项目相关的搜索符。$是LR(0)初态项目集的项目`S'->·S`的搜索符,用算法4.12可以为每个核的所有项目列出其全部自生搜索符。然后，让这些自生搜索符进行传播，直到不能再传播为止。有许多不同的传播方法，这些方法在某种意义上记录已经传播到一个项目的“新”搜索符，但这些“新”的搜索符没有再继续传播出去，下面的算法描述了一种将搜索符传播到全部项目的技术。

**算法4.13** 计算LALR(1)项目集族的核。

```
输入：拓广文法G'
输出：文法G'的LALR(1)项目集族的核
方法：
1. 利用上述方法，构造G的LR(0)项目集的核
2. 对每个LR(0)项目集的核和文法符号X应用算法4.12，确定出哪些搜索符对于goto(I,X)中的核项目是自生的，并确定出从哪些I中的项目出发搜索符可以传播到在goto(I,X)中的核项目中
3. 对于每个项目集的每个核项目，初始化一个表，使之给出与之相联系的各个搜索符。开始时，与每一个项目相联系的搜索符仅是那些在(2)中确定的自生搜索符
4. 反复遍历所有集合中的核项目。当访问一个项目i时，利用(2)中所建立的信息来查看i能将它的搜索符传播到哪些核项目。把i的当前搜索符集合附加到已经与i相关联的各个项目中去，即附加到i已将其搜索符传播到达的那些项目中去。继续遍历核项目，直到没有新的搜索符被传播为止。
```

例：下面为上例中的文法构造LALR(1)项目集的核，该文法的LR(0)项目集的核是文法(4-20)的LR(0)的项目集的核时，计算`{[S'->·S,#]}`的闭包，结果是：
```
S' -> ·S, #
S -> ·L = R, #
S -> ·R, #
L -> ·*R, #/=
L -> ·id, #/=
R -> ·L, # 
```
在该闭包中有两项可导致搜索符的自生，项目`[L->·*R, =]`使得`=`是I4中的核项目`L->*·R`的自生搜索符，而项目`[L->id, =]`使得`=`是I5中的核项目`L->id·`的自生搜索符。

标有“初始”的每一列给出了每个核项目的自主搜索符。在第1遍，搜索符$有I0的S'->·S传播列出的6个项目。搜索符由I4中的L->*R·和I8中的R->L·。但这些搜索符已经出现过了。在2遍和第3遍，仅有的可被传播的新搜索是$，这是在第2遍的I2和I4的后继和第3遍的I6的后续中发现的。在第4遍就没有新的搜索符可传播了，所以搜索符的最后集合最右一列所示。

*注意：利用SLR方法所出现的移动-归约冲突在这里运用LALR技术时已经不存在了，原因是只有搜索符$与I2中的S->L·相关，所以，对I2中的项目S->L·=R产生的=执行移进时不会产生冲突*

#### LR语法分析表的压缩

一个典型程序设计语言的文法有50-100个终结符和100个产生式，它的LALR语法分析表可能有几百个状态，它的action函数或许有20000个输入项，每项至少需要8位进行编码。显然，寻找一种比二维数组更有效的编码非常重要，简要介绍几种用于压缩LR语法分析表的action域和goto域的技术。

压缩action域的一种有用技术是基于这样一点，即action表中经常有许多行是相同的。状态0和状态3就具有相同的action表项，状态2和6也是，于是就能节省很大的空间，时间开销也很少。如果对每个状态建立一个指向一维数组的指针，则相同表项的指针指向同一个位置。为存取这个数组的信息，给每个终结符分配一个从0到终结符总数减1的整数，并把这个数作为对于每个状态的指针值的偏移量。给定一个状态，第i个终结符的分析动作保存在那个状态指针值下的第i个位置上。

为每个状态的动作创建一个列表可进一步提高空间的利用效率，但要以轻微降低语法分析器的速度为代价。列表由(终结符，动作)对组成。频繁发生的动作放在列表的尾部，并可用符号`any`代替一个终结符。这意味着如果当前输入符号没有在列表中发现，则不管输入是什么都将执行这个动作。此外，对一行上的错误表项可用归约动作安全取代。以后在移进之前，错误将会被检测到。

例子：考虑上述的语法分析表，首先注意到状态0，4，6和7的动作相同，因此可以用如下列表描述它们：
```
符号   动作
id     s5
(      s4
any   error
```
状态1也有一个类似的列表：
```
符号   动作
+      s6
$      acc
any    error
```
在状态2，可以用r2替代error(错误)表项，故对任一除*以外的输入，都将用产生2进行归约，所以状态2的列表是：
```
符号   动作
*      s7
any    r2
```
状态3只有error表项和r4，可以用后者代替前者，所以状态3的列表仅由(any,r4)组成，状态5，10，11可以类似地进行处理。状态8的列表是：
```
符号   动作
+      s6
)      s11
any    error
```
而状态9的列表为：
```
符号   动作
*      s7
any    r1
```
通过列表也可以对goto表进行编码，但在此为每个非终结符A构造序对列表看起来效率更高。A的列表中序对的格式为(current_state,next_state),含义为：
```
goto[current_state,A] = next_state
```
因为goto表的任一列只有很少的状态，所以这个方法很有用。原因是非终结符A的goto项只能从这样的项目集导出的状态，在这些项目集的项中，A在点的左边。如果`X!=Y`,则点左边为X和Y的项不会出现在同一个项目集中。因此每个状态最多出现在一个goto列中。要进一步节省空间，注意到在goto表中的错误表项从来没有被考虑过，因而，可以用最常用的非错误表项替换这些错误表项，使该常用表项称为默认值，并把当前的状态替换为`any`.

例子：F列对应状态7的表项为10，其他表项或者是3，或者是error。可以用3替换error表项从而为F列创建如下列表：
```
current_state     next_state
7                 10
any               3
```
同样，T列相应的列表为：
```
current_state   next_state
6               9
any             2
```

对E列可以选择1或8作为默认值，不管哪种情况都需要两个表项。例如，可以为E列创建下述列表:
```
current_state    next_state
4                8
any              1
```

*对有穷自动机的表压缩方法也可以用于LR语法分析表*

### 二义文法的应用

任何二义文法都不是LR文法，因而不属于前一节所讨论的任何一类文法，这是一条定理。但是，正如在本节将要看到的，某些二义文法对语言的说明和实现非常有用。对于像表达式这样的语言结构，二义文法比任何等价的非二义文法提供的说明都要更短、更自然。另外，为了便于对一些特例语法结构进行优化，需要将它们从一般语法结构中分离出来。通过使用二义文法，往文法中增加新的产生式，就能标识这些特例结构，这是二义文法的另一种应用。

虽然使用的文法是二义性的，但在所有情况下都说明了消除二义的规则，以保证对每个句子只有一棵分析树。这样，整个语言的说明仍然是二义性的。另外，应该慎用二义结构，并在严格控制的方式下使用。否则不能保证语法分析器将识别什么样的语言。

#### 使用优先级和结合规则来解决分析动作的冲突

考虑程序设计语言中的表达式。下面包含操作符`+`和`*`的算术表达式文法是二义的，因为它没有指出操作符`+`和`*`的结合规则和优先级：

```
E -> E + E | E * E | (E) | id
```
下面的无二义文法产生同样的语言，但赋予了`+`一个比`*`低的优先级，并且两个操作符都是左结合的。
```
E -> E + T | T
T -> T * F | F
F -> (E) | id
```
正如将要看到的那样，可以方便地改变操作符`+`和`*`的结合规则及优先级而无需修改文法中的产生式及结果及结果与语法分析器中的状态数。其次，文法的语法分析器要花一部分时间来完成产生式E->T和T->F的归约，它们的作用只是突出结合规则和优先级。文法的语法分析器不会将时间消耗在归约这样的单产生式(右部只有一个非终结符的产生)上。

用`E->E'`拓广后的文法的LR(0)项目集，因为文法是二义的，如果试图从这些项目集生成LR语法分析表，语法分析动作会有冲突。与项目集I7和I8对应的状态会产生这些冲突。假设我们用SLR方法来构造分析动作表，I7产生的归约E->`E+E`与面临`+`和`*`进行移进之间的冲突不能解决，因为`+`和`*`都在FOLLOW(E)中；令一个由I8产生的冲突在归约`E->E*E`与面临`+`和`*`进行移进之间。事实上，用任何一种LR语法分析表的构造方法都会产生这些冲突。

但是,这些问题可以用`+`和`*`的优先级和结合信息来解决。考虑输入`id=id*id`，它使得形成如下格局:
```
栈              输入
0 E 1 + 4 E 7  * id $
```

如果`*`的优先级高于`+`,语法分析器应该把*移进栈，准备将`*`和它两边的id归约成一个表达式。这正是识别相同语言的SLR语法分析器要做的。另一方面，如果`+`的优先级高于`*`，语法分析器应该将`E+E`归约成E。这样，根据`+`和`*`的相关优先级就可以解决状态7中用`E->E+E`归约和面临`*`进行移进之间的冲突。

如果输入是`id+id+id`的话，语法分析器处理完`id+id`后仍将到达栈内容为`0e1+4E7`的格局。在状态7面临`+`时仍有移动`-`归约冲突，现在是由操作符`+`的结合规则来决定应如何解决冲突。如果`+`是左结合的，正确的动作是用`E->E+E`归约，即第一个+前后的id应看成一组。

总之，假如`+`是左结合的，在状态7面临`+`时应该用`E->E+E`归约；如果`*`的优先级高于`+`,在状态7面临`*`时应该移进。可以类似地讨论状态8，最后得出如下结果：如果*是左结合的且优先级高于`+`,那么不论面临`+`还是面临`*`，语法分析器在状态8的动作都是用`E->E*E`进行归约。原因是面临`+`时,`*`的优先级高于`+`,面临`*`时，`*`是左结合的。

#### 悬空的else二义性

考虑下面的条件语句文法：
```
stmt -> if expr then stmt else stmt
    | if expr then stmt
    | other
```
这个文法是二义的，因为它没有解决悬空else的二义性。为了简化讨论，考虑上述文法的抽象,用i代表`if expr then`，用e代表else，并用a代表所有其他产生式，然后加上拓广的产生式`S'->S`,重写文法如下:
```
S'->S
S->iSeS | iS | a
文法 (4-24)
```

当`if expr then stmt`在栈顶并且else是第一个输入符号时，究竟是移进else(移进e)还是将`if expr then stmt`归约成`stmt`(按S->iS归约)呢？答案是移进else。因为它要和前面一个then配对。用文法(4-24)的术语，输入为e(代表else)时，智能让它成为以栈顶的iS开始的右部的一部分。如果e后面的输入不能分析成S而形成右部iSeS，那么，分析将无法继续。

结论：要解决I4中的移动归约冲突，应该首先移进e。按照这个解决办法，由图4-84的项目集构造的SLR语法分析表。产生式1~3分别是`S->iSeS`,`S->iS`和`S->a`。

例如，若输入是`iiaea`,它正确地解决了悬空else问题，面临e时，状态4选择移进；面临$时，状态4按`S->iS`进行归约。

#### 特例产生式引起的二义性

二义文法最后一个用途：即引入一个额外的产生式来标识语法结构的特例，这比用其余的产生式来标识更自然一些，但如果加入这个额外的产生式就会引起分析动作的冲突。这种冲突的解决需要消除二义性规则，这个规则指出，如果出现归约-归约冲突，按特例产生式归约。这样，和特例产生式相联的语义动作允许用更专门的措施来处理这些特例。

#### LR语法分析中的错误恢复

LR语法分析器在访问动作表时若遇到出错表项，就检测出一个错误，但它在访问转移表时决不会检测出出错。与算符优先语法分析器不同的是，LR语法分析器只要发现已扫描的输入出现一个不正确的后继就会立即报告错误。规范LR语法分析器在报告错误之前不会进行任何无效归约。SLR语法分析器和LALR语法分析器在报告错误前可能执行几步归约，但它们绝不会把出错点的输入符号移进栈。

在LR分析中，可以采用下面的方法实现紧急方式的错误恢复：从栈顶开始退栈，直至发现在特定非终结符A上具有转移的状态s为止；然后丢弃零个或多个输入符号，直至找到符号a为止，它是A的合法后随符号；接着，语法分析器把状态`goto[s, A]`压进栈，并恢复正常分析。A的选择可能不唯一，一般A应是代表主要程序结构的非终结符，如表达式、语句或程序块。例如，若A是非终结符stmt,那么a可以是分号或end。

这种恢复方法实质是试图将含有语法错误的短语分离出来。语法分析器认为由A推导出的串含有一个错误，该串的一部分已经处理过，处理的结果是处于栈顶的状态序列，该串的剩余部分仍在输入中。语法分析器试图跳过该串的剩余部分，在输入中找到一个符号，它是A的合法后随符号。通过从栈中移出一些状态，跳过若干输入符号，并把`goto[s, A]`推进栈，语法分析器加装已发现了A的一个实例，并恢复正常分析。

短语级恢复的实现是通过检查LR分析表的每个出错表项，并根据语言的使用情况确定最可能引起该错误的最容易犯的错误，然后为该表项编一个适当的错误恢复例程。该例程大概会采用一种适合于相应出错表项的方式来修改栈顶符号和(或)第一个输入符号。

与算符优先语法分析器相比，设计LR语法分析器的专门错误处理例程要容易一些。尤其是，不必担心不正确的归约，LR语法分析器所执行的归约保证是正确的。于是，可以在语法分析表动作域的每个空白项上填上一个指针，它指向编译器设计者为之设计的出错处理例程。该例程的动作可能包括从栈顶和(或)输入中插入或删除符号，改变或变换输入符号，就像算符优先语法分析器那样，所做的选择不应使LR语法分析器陷入死循环。保证至少有一个输入符号被移走或最终被移进，或者保证在到达输入的末尾时保证栈最终会缩短，这样的策略足以防止上述问题的发生。要避免从栈中弹出覆盖一个非终结符的状态，因为这种修改从栈中删除掉了已经成功分析的一个结构。

### 语法分析器的生成器

#### 语法分析器的生成器Yacc

一个翻译器可用Yacc的方式构造出来。首先，准备一个包含翻译器的Yacc说明的文件，如`translate.y`。UNIX系统的命令
```cmd
yacc translate.y
```
把文件translate.y翻译成名为y.tab.c的C程序，使用的是算法4.13中描述的LALR方法。程序y.tab.c中包含用C语言编写的LALR语法分析器和其他用户准备的C语言例程。为节省空间，用之前的方法对LALR语法分析表进行了压缩.命令
```cmd
cc y.tab.c -ly
```
对y.tab.c进行编译，其中，ly表示使用LR分析程序的库。编译后得到目标程序a.out，它完成Yacc源程序指定的翻译。如果需要其他过程，它们可以和y.tab.c一起编译或装入，就像使用普通的C程序一样。

Yacc源程序由3部分组成:
```y
声明
%% 
翻译规则
%%
用C语言编写的支持例程
```

例子：构造一个简单的台式计算器，读入一个算术表达式，计算并打印它的值。计算器的算术表达式文法:
```
E -> E + T | T
T -> T * F | F
F -> (E) | digit
```
记号digit是0~9的单个数字。由该文法得到的Yacc台式计算器程序如下式所示：
```y
%{
#include <ctype.h>
%}

% token DIGIT

%%
line  :  expr  '\n'  {printf("%d\n", $1); }
      ;  
expr  :  expr  '+'  term { $$ = $1 + $3; }
      :  term
      ;
term  :  term  '+'  factor  { $$ = $1 + $3; }
      :  factor
      ;
%% 
yylex() {
    int c;
    c = getchar();
    if (isdigit(c)) {
        yylval = c - '0';
        return DIGIT;
    }
    return c;
}
```
* **(1) 声明部分**-Yacc程序的声明部分由可任选的两节组成。第一节处于分界符%{和%}之间，它是一些普通的C语言声明。第二部分和第三部分的翻译规则或过程所使用的所有临时声明都放在这里。
```y
#include <ctype.h>
```
它使得C的预处理程序包含标准头文件`<ctype.h>`,该文件含有谓词`isdigit`。声明部分的第二节是文法记号的声明，语句：

```y
%token DIGIT
```

* **(2) 翻译规则部分**-这一部分位于第一个%%后面，用于放置翻译规则，每条规则由一个文法产生式和有关的语义动作组成。产生式集合:
```
<left side> -> <alt 1> | <alt 2> | ... | <alt n>
```
在Yacc中写成:
``` 
<left side>  :  <alt 1>  ;语义动作1}
             :  <alt 2>  ;语义动作2}
             ...
             :  <alt n>  ;语义动作n}
             ;
```
在Yacc产生式中，单引号括起来的字符`c`是由终结符号c组成的记号；没有引号的字母数字串若没有声明为记号，则是非终结符。右部的各个选择之间用竖线隔开，最后一个右部的后面用分号，表示该产生式集合的结束。第一个左部非终结符是开始符号。

Yacc的语义动作是C语句序列。在语义动作中，符号`$$`表示左部非终结符的属性值，而`$i`表示右部第i个文法符号(终结符或非终结符)的值。每当归约一个产生式时，就执行与之相关联的语义动作，所以语义动作一般是根据`$i`的值计算`$$`的值。在这个Yacc说明中，两个E产生式.
```
E -> E + T | T
```
及与它们有关的语义动作写成:
```
expr  :  expr  '+'  term  { $$ = $1 + $3; }
      :  term
      ;
```

注意：第一个产生式的非终结符term是右部的第三个文法符号，`+`是第二个文法符号。第一个产生式的语义动作把右部的expr和term的值相加，把结果赋给左部的非终结符expr作为它的值。省略了第二个产生式的语义动作，因为右部只有一个文法符号时，值的复写是默认的语义动作，即它的语义动作是 { $$ = $1; }

注意，将一个新的开始产生式:
```
line  :  expr '\n'  {printf("%d\n", $1); }
```
加到了这个Yacc说明中。该产生式的意思是，这个台式计算器的输入是一个表达式后面跟一个换行字符，它的语义动作是打印表达式的十进制值并且换行。

* **(3) 支持例程部分**-Yacc说明的第三部分是一些用C语言编写的支持例程。必须提供名字为`yylex()`的词法分析器。其他的过程，如错误恢复例程，如果需要的话，也可以加上。

词法分析器`yylex()`返回二元组(记号，属性值)。返回的记号，如`DIGIT`，必须在Yacc说明的第一部分声明。属性值必须通过Yacc定义的变量yylval传给语法分析器。

#### 用Yacc处理二义文法

改进上一节的Yacc说明。首先，允许台式计算器计算表达式序列，每行一个，还允许表达式之间有空白行。为做到这一点，将第一条规则改为：
```
lines  :  lines  expr  '\n'  {printf("%g\n", $2);}
    :   lines  '\n'
    :
    ;
```

其次，扩大表达式的类，使之包含由多个数字组成的数字，包括操作符`+`，`-`(一元和二元)，`*`，`/`。说明这类表达式的最简单的方法是使用下面的二义文法：
```
E -> E + E | E - E | E * E | E / E | (E) | -E | number
```
LALR算法将产生语法分析动作冲突。Yacc会报告产生的语法分析动作冲突的数目。
项目集合语法分析动作冲突的描述可以通过在调用Yacc时加-v选项来获得。该选项
产生一个附加的文件`y.output`,它包含语法分析时发现的项目集的核、由LALR算法
产生的语法分析动作冲突的描述以及LR语法分析表的可读表示，该可读表示显示出语法
分析动作冲突是怎样解决的。当Yacc报告它发现语法分析动作冲突时，明智的做法
是建立和查阅文法`y.output`,以了解为什么出现分析动作冲突以及它们是否
已经被正确解决。

* 1. 归约-归约冲突的解决是从冲突产生式中选择在Yacc说明中最先出现的那个产生式。因此，只要把产生式放在产生式前面就足够了。
* 2. 移动-归约冲突的解决是移进优先。这条规则正确地解决了悬空else二义所带来的移动-归约冲突

更高级的台式计算器的Yacc说明
```
%{
#include <ctype.h>
#include <stdio.h>
#define YYSTYPE double
%}

%token NUMBER
%left '+' '-'
%left '*' '/'
%right UMINUS

%%
lines   :   lines  expr  '\n'   {printf("%g\n", 2$); }
    : lines '\n'
    : /* e */
    ;
expr    :   expr  '+'  expr  { $$ = $1 + $3; }
        :   expr  '+'  expr  { $$ = $1 - $3; }
        :   expr  '+'  expr  { $$ = $1 * $3; }
        :   expr  '+'  expr  { $$ = $1 / $3; }
        :   '('  expr  ')'   { $$ = $2;  }
        :   '-'  expr  %prec UMINUS  { $$ = - $2; }
        :   NUMBER
        ;
%%
yylex() {
    int c;
    while ( (c = getchar()) == '' );
    if ( (c == '.') || (isdigit(c)) ) {
        ungetc(c, stdin);
        scanf("%1f", &yylval);
        return NUMBER;
    } 
    return c;
}
```

Yacc提供了解决移动-归约冲突的一般方法。在声明部分，可以为终结符指定优先级和结合规则。声明:
```
%left '+'  '-'
```
使得`+`和`-`具有同样的优先级和左结合规则。声明：
```
%right '^'
```
使得操作符`^`为右结合的。还可以用声明限制二元操作符为不可结合的(即该操作符的两个相邻出现根本不能组合)，如
```
%nonassoc  '<'
```
记号的优先级按它们在声明部分出现的次序来确定，先出现的记号的优先级低，同一声明中的记号有相同的优先级。
```
%right UMINUS
```
使得`UNIMUS`的优先级高于前面5个终结符。

Yacc通过为与冲突有关的每个产生式赋予优先级和结合规则来解决移动-归约冲突。如果Yacc必须在移进输入符号a和按产生式`A->α`归约这两个动作之间进行选择，那么，当这个产生式的优先级高于a，或者优先级相同但产生式是左结合的时，执行归约动作，否则选择移进。

通常，产生式的优先级和它最右边的终结符号的优先级一致。给定产生式
```
E -> E + E | E * E
```
若搜索符是`+`,归约产生式是`E->E+E`,那么归约优先，因为右部的+和搜索符具有同样的优先级，而+是左结合的；但如果搜索符是`*`,那么选择移进，因为搜索符的优先级高于这个产生式中+的优先级。

如果最右终结符不能给产生式以适当的优先级，可以通过给产生式附加标记
```
%prec <terminal>
```
来强制它的优先级，它的优先级，它的优先级和结合规则同这个标记的终结符一样。该终结符大概需在声明部分定义。Yacc不会报告用优先级和结合规则解决了的移动-归约冲突。

该终结符可以是一个占位符，如`UMINUS`那样，它不由词法分析器返回，只是用来决定一个产生式的优先级。声明:
```
%right UMINUS
```
给记号`UMINUS`指定高于`*`和`/`的优先级。在翻译规则部分，标记
```
%prec UNIMUS
```
出现在产生式
```
expr    :  '-'  expr
```
的后面，这使得该产生式中的一元减操作符的优先级高于其他任何操作符

#### 用Lex建立Yacc的词法分析器

Lex产生的词法分析器可以用于Yacc。Lex库将提供名为`yylex()`的驱动程序，这个名字就是Yacc所需要的词法分析器的名字。如果用Lex产生词法分析器，那么Yacc说明中的第三部分的例程`yylex()`应由语句
```c
#incldue "lex.yy.c"
```
来代替。使用这条语句，程序`yylex()`可以访问Yacc中记号的名字，因为Lex的输出文件是作为Yacc输出文件的一部分被编译的，所以每个Lex动作都返回Yacc知道的终结符。

在UNIX系统中，如果Lex说明在文件`first.l`中，Yacc说明在`second.y`中，可以用命令
```
lex first.l
yacc second.y
cc y.tab.c -ly -ll
```
来获得所需的编译器。最后一个模式`\n|`，因为在Lex中匹配除换行以外任何字符。

#### Yacc的错误恢复

在Yacc中，可以通过使用出错产生式的形式进行错误恢复。首先，用用户决定哪些“主要的”非终结符会与错误恢复有关，典型的选择是用于产生表达式、语句、程序块和过程的那些非终结符。然后用户把形如`A->error α`的出错产生式加到文法中，其中A是主要非终结符，α是文法符号串，也可能是空串，error是Yacc保留字。Yacc将从这样的说明产生语法分析器，并把出错产生式当做普通产生式来处理。

但是，当Yacc产生的语法分析器遇到错误时，会用一种特定的方式来处理项目集中含有出错产生式的状态。遇到错误时，Yacc从栈中弹出状态，直到发现一个能恢复正常处理的输入符号为止。

如果α为e时，立即归约为A并执行产生式`A->error`的语义动作(可能是用户说明的错误恢复例程)，然后语法分析器丢弃若干输入符号，直到发现一个能恢复正常处理的输入符号为止。

如果α非空，Yacc在输入串上向前寻找能够归约为α的子串。如果α包含的都是终结符，那么它在输入上寻找这样的终结符串，并把它们移进栈，这时，语法分析器的栈顶为error α，语法分析器把error α归约成A，并恢复正常语法分析。

例如，出错产生式
```
stmt -> error;
```
要求衣服啊分析器看见错误时跳过下一个分号，好像该语句已经被看完一样。这个出错产生式的语义例程不需要处理输入，只需产生诊断信息并设置禁止生成目标代码的标记。

例子：带有下列出错产生式的Yacc台式计算器：
```
lines :  error  '\n'
```
当输入行有语法错误时，语法分析器从栈中弹出符号，直至碰到一个含有移进记号error动作的状态为止。该例中，状态0是唯一的这种状态，因为它的项目包含：
```
lines -> ·error '\n'
```
而且状态0总是在栈顶。语法分析器把记号error移进栈，并跳过输入符号，直至发现换行符为止。这时语法分析器把换行符移进栈，把error '\n'归约成lines，输出诊断信息“reenter last line：”。专门的Yacc例程yyerrok用于将语法分析器恢复正常操作模式。

## 第五章：语法制导翻译

主要研究上下文无关文法所产生的语言的翻译。通过把属性附加到代表语法结构的文法符号上，可以将语义信息和程序设计语言的结构联系起来。属性的值是用与文法产生式相关联的"语义规则"来计算的。

把语义规则同产生式联系起来要涉及两个概念，即**语法制导定义**和**翻译模式(translation scheme)**。语法制导定义是关于语言翻译的高层次规格说明，它隐蔽了许多具体实现细节，使用户不必显式地说明翻译发生的顺序。翻译模式则指明了语义规则的计算顺序，以便说明某些实现细节。

从概念上讲，不论是语法制导定义还是翻译模式，都要首先对输入符号串进行语法分析，建立分析树，然后根据需要遍历分析树，并在分析树的节点处计算语义规则。语义规则的计算可以生成代码、在符号表中保存信息、发出错误信息或完成其他活动。这样，对输入符号串的翻译过程就是对语义规则求值的过程。

```
输入符号串->分析树->依赖图->语义规则的计算顺序
```

在某些情况下，语法制导定义可以在单遍扫描中实现，即在语法分析期间计算语义规则，而不用显式地构造分析树或属性间的依赖图。因为单遍扫描的实现方式对提高编译的效率非常重要，所以本章主要致力于研究这种情况。有一个重要的子类称为“L-属性”定义，实际上它包含了所有不必显式构造分析树即可完成的翻译。

#### 语法制导定义(Syntax-Directed Definition, SDD)

语法制导定义是对上下文无法文法的推广，其中每个文法符号都有一个相关的属性集。属性分为两个子集，分别称为该文法符号的综合属性和继承属性。如果把分析树中对应该文法符号的节点看成是一条记录，其中包含若干存储信息的域，那么属性就相当于一个域的名字。

属性可以代表任何对象：字符串、数字、类型、内存单元或其他对象。分析树节点上属性的值由该节点所用产生式的语义规则来定义。节点的综合属性值是通过分析树中其子节点的属性值计算出来的。

语义规则建立了属性间的依赖关系，可以用图来表示。从依赖图中可以得到语义规则的计算顺序。语义规则的计算定义了输入符号串在分析树节点上的属性值。语义规则还可能具有副作用，如打印一个值或修改全局变量等。当然，具体实现时可能不必显式地构造分析树或依赖图，只需对每个输入串产生相同的输出即可。

将每个节点都带有属性值的分析树称为注释分析树，而计算节点属性值的过程则称为注释或装饰分析树。

#### 语法制导定义的形式

在语法制导定义中，每个产生式`A->α`都有一个形如`b:=f(c1,c2,...,ck)`的语义规则集合与之相关联，其中f是函数，并且满足下面两种情况之一：

* 1. b是A的一个综合属性，且c1,c2,...,ck是该产生式文法符号的属性；
* 2. b是产生式右部某个文法符号的一个继承属性，且c1,c2,...,ck也是该产生式文法符号的属性。

对这两种情况都称为属性b依赖于属性c1,c2,...,ck.。**属性文法**是一个语法制导定义，其中语义规则中的函数不能有副作用。

语义规则中的函数通常被写成表达式的形式。有时，语法制导定义中某个规则的目的就是为了产生幅作用。这种语义规则一般被写成过程调用或程序段。在这种情况下，可以把它看作是定义产生式左部非终结符的虚综合属性值，但这种语义规则中的虚属性和符号`:=`都不给出来。

例5.1 下述是一个台式计算器程序的语法制导定义。该定义将一个整数值综合属性val与每个非终结符E,T和F联系起来。对每个以E,T和F联系起来。对每个以E,T和F为左部的产生式，语义规则从产生式右部非终结符的val值计算出产生式左部非终结符的val值。

记号`digit`具有综合属性lexval，其值由词法分析器提供，而产生式L->En（其中L是文法开始符号）所对应的语义规则只是一个打印E所产生的算术表达式的值的过程，可以认为该规则为非终结符L定义了一个虚属性

在语法制导定义中，假设终结符只具有综合属性，因为定义没有为终结符提供任何语义规则。终结符的属性值通常由词法分析器提供。此外，假设开始符号不具有任何继承属性，除非另有说明。

#### 综合属性

综合属性在实践中具有广泛的应用。将仅仅使用综合属性的语法制导定义称为**S属性定义**。在S属性定义的分析树中，可以自底向上地在每个节点用语义规则来计算综合属性值，即从叶节点到根节点进行计算。

S属性定义详细说明了一个台式计算器，它读入包含数字、括号、运算符`+`和`*`的算术表达式(表达式后面跟有换行符n)，并打印表达式的值。例如，输入表达式`3*5+4`，后跟一个换行符n,该程序将打印出值19。下面是输入`3*5+4n`的注释分析树，树根结点输出的是第一个子节点的E.val值。

为弄清楚属性值是如何计算的，先考虑最左边最底层的内部节点，它所对应的产生式是`F->digit`。相应的语义规则为`F.val := digit.lexval`。因为其子节点的digit.lexval值是3，所以该节点的属性F.val的值也为3。同样地，F节点的父节点的属性T.val的值也为3。

现在考虑产生式`T->T * F`所对应的节点，其属性值T.val的值由产生式`T->T1 * F`的语义规则T.val := T1.val * F.val来定义。对此节点应用语义规则：从左子节点可以得到T1.val的值为3，从右子节点可以得到F.val的值为5，故求得在这一节点T.val的值为15。

与产生式`L->En`相关联的语义规则打印由E生成的表达式的值。

#### 继承属性

在分析树中，一个节点的继承属性值是由该节点的父节点和(或)兄弟节点的属性决定的。用继承属性来表示程序设计语言上下文结构的依赖性是很方便的。例如，可以使用继承属性来跟踪一个标识符，看它是出现在赋值号的左边还是右边来确定是需要它的地址还是它的值。虽然总是可以只用综合属性来改写语法制导定义，但是使用带有继承属性的语法制导定义会更为自然。

例：在下表所示的语法制导定义中，非终结符D所产生的声明由关键字`int`或`real`后跟一个标识符表所组成的。非终结符T有一个综合属性type，其值由声明中的关键字来确定。与产生式`D->TL`相关联的语义规则`L.in := T.type`用来将继承属性`L.in`置为
所声明的类型。语义规则适用继承属性`L.in`把该类型信息沿分析树向下传递。与L产生相关联的语义规则调用过程addtype，该过程将各标识符的类型填加到符号表的相应表项中(由属性entry指向)

产生式|语义规则
-|-
D -> T L | L.in := T.type
T -> Int | T.type := integer
T -> real | T.type := real
L -> L1, id | L1.in := L.in   addtype(id.entry, L.in)
L -> id | addtype(id.entry, L.in)

下面给出了语句real id1,id2,id3的**注释分析树**。3个L节点的L.in值分别给出了标识符id1,id2和id3的类型。这些值是按下面的方法确定的：首先计算根的左子节点的属性值T.type，然后在根的右子树中自上而下计算3个L节点的L.in值。在每个L节点处，还调用过程addtype，它在符号表中记下相应的标识符类型(即该结点的右子节点上的标识符类型为real)

```json
{
    "value" : "D",
    "child" : [
        {
            "value" : "T.type = real",
            "child" : [
                {
                    "value" : "D",
                    "child" : null
                }
            ]
        },
        {
            "value" : "L.in = real",
            "child" : [
                {
                    "value" : "L.in = real",
                    "child" : [
                        {
                            "value" : "L.in = real",
                            "child" : [
                                {
                                    "value" : "id1",
                                    "child" : null
                                }
                            ]
                        },
                        {
                            "value" : ",",
                            "child" : null
                        },
                        {
                            "value" : "id2",
                            "child" : null
                        }
                    ]
                },
                {
                    "value" : ",",
                    "child" : null
                },
                {
                    "value" : "id3",
                    "child" : null
                }
            ]
        }
    ]
}
```

#### 依赖图

如果分析树中某个节点的属性b依赖于属性c，那么在该节点处b的语义规则必须在c的语义规则之后计算。分析树中各节点的继承属性和综合属性问的依赖关系可以用有向图来描述，这种有向图称为依赖图。

在构造分析树的依赖图之前，为每个包含过程调用的语义规则引入一个虚综合属性b，以便把每条语义规则都变成`b:=f(c1,c2,...,ck)`的形式。依赖图的每个节点表示一个属性，边表示属性间的依赖关系，如果属性b依赖于属性c，那么从c到b就有一条有向边。更详细地说，给定一棵分析树，其依赖图是按照下面的步骤构造出来的。

```
for 分析树的每个节点n do
    for 与节点n对应的文法符号的每个属性a do
        在依赖图中为a构造一个节点
for 分析树的每个节点n do
    for 节点n所用产生式对应的每条语义规则b:=f(c1,c2,...,ck)do
        for i:= 1 to k do
            从节点ci到结点b构造一条有向边
```

例如，假设`A.a:=f(X.x,Y,y)`是产生式`A->XY`的一条语义规则，该规则定义了一个依赖于属性X.x和Y.y的综合属性A.a。如果分析树中含有该产生式，那么在依赖图中将有3个节点A.a,X.x和Y.y，而且由于A.a依赖于X.x,所以从X.x到A.a的有向边，由于A.a也依赖于Y.y，所以还有一条从Y.y到A.a的边。

如果产生式A->XY所关联的语义规则还有X.i:=g(A.a,Y.y),那么图中还应有一条从A.a到X.i的边，以及一条从Y.y到X.i的边，因为X.i依赖于A.a和Y.y

#### 计算顺序

无环有向图的拓扑排序是图中节点m1,m2,...,mk的这样一种排序：若mi->mj是从mi到mj的边，那么在此排序中mi先于mj。依赖图的任何拓扑排序都给出了一个分析树各节点语义规则计算的正确顺序，即在计算f之前，语义规则b:=f(c1,c2,...,ck)中依赖属性c1,c2,...,ck都是已知的。

语法制导定义所说明的翻译可以像下面这样精确给出。最基本的文法用于构造输入串的分析树；依赖图像上面所讨论的那样建立；从依赖图的拓扑排序可以得到语义规则的计算顺序；按该顺序计算语义规则即可得到输入串的翻译。

计算语义规则的方法：

* **分析树法**-在编译时，这种方法从分析树所构成的依赖图的拓扑排序中得到语义规则的计算顺序。若所考虑的特定的分析树的依赖图中含有环路，则这种方法将会失败。
* **基于规则的方法**-基于规则的方法。在编译器构造时，与产生式相关联的语义规则是用手工或专门的工具来分析的。对于每一个产生式，计算该产生式所关联的属性的顺序在编译器构造时已经预先确定好了。
* **忽略规则的方法**-这种方法选择计算顺序时不考虑语义规则。例如，如果翻译是在语法分析过程中进行的，那么计算顺序的选择就由语法分析方法来确定，而跟语义规则无关。这种方法限制了能被实现的语法制导定义的种类。

基于规则的方法和忽略规则的方法在编译时都不必显式地构造依赖图，因此它们使编译的时空效率更高。

如果某个文法所产生的某些分析树的依赖图中存在环路，则其语法制导定义是循环的。

### 语法树的构造

将说明如何应有语法制导定义来完成语法树的构造以及语言结构的其他图形表示。

用语法树作为中间表示，可以把翻译从语法分析中分离出来。在语法分析期间完成翻译固然有很多优点，但也存在一些问题。如在分析期间调用翻译子程序受到两个限制。首先，适于语法分析的文法可能并不反映语言成分的自然层次结构。例如，Fortran的文法可能把子程序看成只是简单地由语句序列组成的，没有反映出DO循环的嵌套。如果能够反映DO循环嵌套的树形表示，那么子程序的语法分析将会更容易一些。其次，语法分析方法限制了分析树中各节点的考察顺序，该顺序可能和各语法成分的信息变为可用的顺序不匹配。

#### 语法树

（抽象）语法树是分析树的压缩形式，它对表示语言的结构很有用。如产生式`S->if B then S1 else S2`在语法树中可能出现为：

```json
{
    "value" : "if-then-else",
    "child" : [
        {
            "value" : "B",
            "child" : null
        },
        {
            "value" : "S1",
            "child" : null
        },
        {
            "value" : "S2",
            "child" : null
        }
    ]
}
```

在语法树中，运算符和关键字不再是叶节点，而是作为内部节点称为分析树中叶节点的父节点。语法树的另一个简化是单产生式(形如A->B)链可能消失，分析树将变成下面的语法树:

```json
{
    "value" : "+",
    "child" : [
        {
            "value" : "*",
            "child" : [
                {
                    "value" : "3",
                    "child" : null
                },
                {
                    "value" : "5",
                    "child" : null
                }
            ]
        },
        {
            "value" : "4",
            "child" : null
        }
    ]
}
```

语法制导翻译可以基于语法树，也可以基于分析树，其方法都是一样的。就像在分析树中那样，也可以给语法树的节点附加属性。

#### 构造表达式的语法树

构造表示式的语法树类似于把表达式翻译成后缀表示。通过为每个运算符和运算对象建立节点来为子表达式构造子树。运算符节点的子节点分别是表示运算符各运算对象的子表达式组成的子树的根。

语法树的每个节点都是可以用带有几个域的记录来表示。对于运算符节点，记录中的一个域用来标识该运算符。其余的域包含指向运算符对象的指针。常常将运算符称为该节点的标记(label)。在翻译时，语法树的节点可能还有一些其他域用来保存附加在该节点上的属性值(或指向属性值的指针)。在本节中，用下列函数建立带有二元运算符的表达式的语法树节点，每个函数都返回一个指向新建节点的指针：

* **mknode(op, left, right)**。它建立一个标记为op的运算符节点，其两个域left和right是指向其左右运算符对象的指针。
* **mkleaf(id, entry)**。它建立标记为id的标识符节点，其域entry是指向该标识符在符号表中相应表项指针。
* **mkleaf(num, val)**。它建立标记为num的数节点，域val保存该数的值。

例：下面的函数调用序列用来建立图5-8中表达式`a-4+c`的语法树。在该序列中p1,p2,...,p5是指向节点的指针，entrya和entryc分别指向符号表中标识符a和c对应的表项。

* (1) p1 := mkleaf(id, entrya);
* (2) p2 := maleaf(num, 4);
* (3) p3 := mknode('-', p1, p2);
* (4) p4 := mkleaf(id, entryc);
* (5) p5 := mknode('+', p3, p4);

该树是自底向上构造的，函数调用meleaf(id, entrya)和mkleaf(num, 4)分别为a和4建立叶子节点，指向这两个节点的指针保存在p1和p2中；然后，函数调用mknode('-', p1,p2)构造一个内部节点，其子节点为叶节点a和4；再经过两步即可建立起语法树，p5指向根节点。

#### 构造语法树的语法制导定义

为包含+和-的表达式的构造语法树的S属性定义。它通过为文法的基本产生式安排函数mknode和mkleaf的调用来构造语法树。E和T的综合属性nptr用来记住函数调用返回的指针。

产生式`T->id`和`T->num`所对应的语义规则将属性T.nptr定义为指向标识符和数的新建叶节点的指针。属性id.entry和num.val是词法值，假设词法分析器将这些值连同记号id和num一起返回。

在图中，当表达式E是一个单个项时，即使用产生式E->T时,属性E.nptr得到T.nptr的值。当使用产生式`E->E1-T`所对应的语义规则`E.nptr:=mknode('-', E1.nptr, T.nptr)`时，先前的规则已经把`E1.nptr`和`T.nptr`分别置成指向叶节点a和4的指针。

对图的解释关键要认识到，由记录形成的底层树才是构成输出的“真正的”语法树，而上层虚线形成的树分析树，在此处只具有象征意义。

#### 表达式的无环有向图

表达式的**无环有向图(diected acyclic gragh，简称dag)**可以识别表达式中的公共子表达式。和语法树一样，在dag中，表达式中的每一个子表达式都有一个节点与之对应。内部节点代表运算符，子节点代表其运算对象。不同的是，在dag中，代表公共子表达式的节点具有多个“父节点”，而在语法树中，公共子表达式由重复的子树表示，所以它只有一个父节点。

表示式`a+a*(b-c)+(b-c)*d`的dag。其叶节点a具有两个父节点，因为a是两个子表达式a和`a*(b-c)`的公共子表达式。类似地，公共子表达式`b-c`的两次出现也由同一个节点表示，相应地亦拥两个父节点。

如果修改构造节点的函数，语法制导定义即可用于构造dag而不是语法树：只要在构造节点之前先检查是否存在相同节点，就可以得到dag。例如，在以标记op和指向left和right的指针的域构造新节点之前。mknode(op,left,right)先检查是否已经存在这样的节点。如果存在的话，mknode(op,left,right)可以返回一个指向先前已经构造好了的节点的指针，叶节点构造函数mkleaf可以采用类似的修改。

例子：如果mknode和mkleaf仅在必要时才建立新节点，而且尽量返回指向具有正确标记和子节点的现存节点的指针。a，b，c和d分别指向符号表中标识符a,b,c和d的表项。

```
(1) p1 := mkleaf(id, a);
(2) p2 := mkleaf(id, a);
(3) p3 := mkleaf(id, b);
(4) p4 := mkleaf(id, c);
(5) p5 := mknode('-', p3, p4);
(6) p6 := mknode('+', p2, p5);
(7) p7 := mknode('+', p1, p6);
(8) p8 := mkleaf(id, b);
(9) p9 := mkleaf(id, c);
(10) p10 := mknode('-', p8, p9);
(11) p11 := mknode(id, d);
(12) p12 := mknode('*', p10, p11);
(13) p13 := mknode('+', p7, p12);
```

在第(2)行重复调用mkleaf(id, a)时，前一个mkleaf(id, a)调用所构造的节点将被返回，所以p1=p2。类似地，第8行和第9行返回的节点分别与第(3)行和第4行返回的节点相同。因此，第(10)行返回的节点和第(5)行调用mknode所构造的节点是相同的。

如图5-13所示，在许多应用中节点都被实现为记录保存在数组中。图中每个记录都有一个标记域，它决定节点的性质。可以通过节点在数组中的下标或者位置来引用节点。由于历史原因，节点的整数索引通常被称为值编号(value number)。例如，使用值编号，可以说节点3的标记为+，其左子节点为节点1，右节点为节点2。下面的算法可用来为表达式的dag表示创建节点。

算法5.1 构造dag节点的值编号法

假设节点保存在一个数组中，而且每个节点通过其值编号来引用。令运算符节点的签名(signature)为一个三元组`<op, l, r>`，其中op为标记，l为左子节点，r为右子节点。

```
输入：标记op、节点l及节点r。
输出：带有签名`<op, l, r>`的节点
方法：搜索数组，寻找具有标志op，且左子节点为l，右子节点为r的节点m。如果存在，则返回m；否则，创建一个新节点n。将其标记域置为op，左子节点置为r，并返回n。
```

确定节点m是否已经存在于数组中的一个简单方法是将前面建立的所有节点保存在列表中，然后依次查看列表中的每个节点，看其是否具有所要求的签名。使用k个称为桶的列表可以提高查找节点m的效率，而散列函数h用来确定要搜索的桶。

散列函数h根据op，l和r值来计算散列桶的序号。给定相同的参数，总是返回相同的桶号。如果节点m不在散列桶h(op,l,r)中，就创建一个新节点n，并将其加入该散列桶中，所以接下来的搜索将会发现它已经在该桶中了。不同的签名可能会被散列到同一个散列桶中，但实际上希望每个桶只包含少数节点。

可以用链表实现每个散列桶。链表中的每个单元代表一个节点。散列桶的首部是指向链表中第一个单元的指针，将其保存在数组中。由散列函数h(op,l,r)返回桶序号是该数组的一个下标。

对于非顺序存储的节点，可以修改此算法。在许多编译器中，为避免预分配一个大部分时间保存太多节点而有时又没有保存足够节点的数组，节点是按照需要进行分配的。在这种情况下，就不能假定节点是顺序存放的了，此时必须用指针来访问节点。如果可以设计一个能根据标记值和指向子节点的指针来计算散列桶号的散列函数，那么可以使用指向节点的指针而不是值编号。否则，可以以任何方式对节点进行编号并用这些编号作为节点的值编号。

由于dag可以有多个根节点，因此dag可以用来表示表达式的集合。

#### S属性定义

给定一个SDD，很难判定是否存在一棵其依赖图包含环的语法分析树。在实践中，翻译过程可以使用某些特定类型的SDD来实现。这些类型的SDD通常有一个特定的求值顺序，因为它们不允许产生带有环的依赖图

第一种类型的S属性的定义：如果一个SDD的每个属性都是综合属性，它就是S属性的，那么可以按照语法分析树结点的任何自底向上顺序来计算它的各个属性值。对语法分析树进行后序遍历并对属性求值常常会非常简单，当遍历最后一次离开某个结点N时计算出N的各个属性值。也就是说，可以把下面定义的postorder函数应用到语法分析树的根上：

```
postorder(N)
{
    for (从左边开始，对N的每个子结点C) postorder(C);
    对N关联的各个属性求值；
}
```

S属性的定义可以在自底向上语法分析的过程中实现，因为一个自底向上的语法分析过程对应一次后序遍历。特别地，后序顺序精确地对应于一个LR分析器将一个产生式规约成为它的头的过程。这个性质将在LR语法分析过程中的综合属性求值工作，这些值将存放在分析栈中。这个过程不会显式地创建语法分析树的结点。

#### L属性的定义

第2种SSD称为L属性定义，这类SSD的思想是是在一个产生式体所产生的关联的各个属性之间，依赖图的边总是从左到右，而不能从右到左(因此被称为L属性)。更准确地讲，每个属性只能是以下两个属性中的一种：

* 综合属性，
* 继承属性，但是规则有如下限制。假设存在一个产生式`A->X1X2...Xn`,并且有一个通过这个产生式所关联的规则计算得到的继承属性`Xi.a`,那么这个规则只能使用：

1. 和产生式头`A`相关联的继承属性
2. 位于`Xi`左边的文法符号实例X1,X2,...,Xi-1相关的继承属性或者综合属性
3. 和这个Xi本身实例相关的的继承属性或者综合属性，但是在由这个Xi的全部属性组成的依赖图中不存在环

#### 具有受控副作用的语义规则

实践中，翻译过程通常会出现一些副作用。对于SDD，在属性文法和翻译方案之间找到一个平衡点。属性文法没有副作用，并支持任何与依赖图一致的求值顺序。翻译方案要求要求按从左到右的顺序求值，并允许语义动作包含任何程序片段。

按照如下方法之一控制SDD中的副作用：

* 支持那些不会对属性求值产生约束的附带副作用
* 对允许的求值顺序添加约束

### 语法制导翻译的应用

主要应用是抽象语法树(AST)的构造。因为一些编译器使用抽象语法树作为一种中间表示形式，所以一种常见的SDD形式将它的输入串转换成一棵树。完成到中间代码的翻译，编译器接下来可能使用一种规则来编译这棵语法树。这些规则实际上是建立于语法树之上的SDD。

考虑两个为表达式构造语法树的SDD。第一个是一个S属性定义，它适合在自底向上语法分析过程中使用。第二个是一个L属性定义，它适合在自顶向下的的语法分析过程中使用。

#### 抽象语法树AST的构造

一棵语法树中的每个结点代表一个程序构造，这个结点的子结点代表这个构造的有意义的组成部分。表示表达式`E1+E2`的语法树结点的标号为`+`,且两个子结点分别代表表达式`E1`和`E2`。

将使用具有适当数量的字段的对象来实现一棵语法树的各个结点。每个对象将有一个`op`字段，也就是这个结点的标号。这些对象将具有如下所述的其他字段：

* 如果结点是一个叶子，那么对象将有一个附加的域来存放这个叶子结点的词法值。构造函数`Leaf(op,val)`创建一个叶子结点对象。也可以把结点看作记录，那么Leaf就会返回一个指向于与叶子结点对应的新记录的指针。
* 如果结点是内部结点，那么它的附加字段的个数和该结点在语法树中的子结点的个数相同。构造函数`Node`带有两个或多个参数：`Node(op,c1,c2,...,ck)`,该函数创建一个对象，第一个字段的值为`op`,其余k个字段为`c1`到`ck`。

例：下述表格的S属性定义为一个简单的表达式文法构造出语法树。这个文法只包含二目运算符`+`和`-`。通常，这两个运算符都具有相同的优先级，并且都是左结合的。所有的非终结符号都有一个综合属性`node`,该属性表示相应的抽象语法树结点。

每当使用第一个产生式`E->E1+T`,它的语义规则就创建出一个结点，创建时使用`+`作为`op`,使用`E1.node`和`T.node`作为代表子表达式的两个子结点。第二个产生式也有类似的规则。

产生式|语义规则
-|-
1) E->E1+T|E.node = new Node('+', E1.node, T.node)
2) E->E1-T|E.node = new Node('-', E1.node, T.node)
3) E->T|E.node = T.node
4) T->(E)|T.node = E.node
5) T->id|T.node = new Leaf(id, id.entry)
6) T->num|T.node = new Leaf(num, num.val)

产生式3，即`E->T`,没有创建任何结点，因为E.node和T.node是一样的。类似地，产生式4，即`T->(E)`,也没有创建任何结点。T.node的值和E.node的值是相同的，因为括号仅仅用于分组。它们会影响语法分析树和抽象语法树的构造，但是一旦分组完成，就不需要在抽象语法树中保留这些括号了。

最后两个T产生式的右部是一个终结符号。使用构造函数Leaf来创建合适的结点。这些结点就成为T.node的值。

如果这些规则是在对语法分析树的后序遍历过程中求值的，或者是在自底向上分析过程中和归约动作一起求值的，那么当一系列步骤结束时，指针指向构造得到的AST的根结点。

如果使用一个自顶向下语法分析而设计的文法，那么得到的AST仍然相同，其构造的步骤也相同，虽然语法分析树的结构和抽象语法树的结构有着极大的不同。

#### 类型的结构

当语法分析树的结构和输入的抽象语法树结构不同时，继承属性是很有用的。这种情况下，继承属性可以用来将信息从语法分析树的一部分传递到另一部分。下一个例子显示了这种结构上的不匹配可能是由语言设计引起的，而不是由语法分析的方法的约束引起的。

例：C语言中，类型`int[2][3]`可以读作“由两个数组组成的数组，子数组中有三个整数”。相应的类型表达式`array(2, array(3, integer))`可以使用如下的树表示。运算符array有两个参数，一个数字，另一个是类型。如果使用树来表示类型，那么这个运算符返回一个标号为array的结点，该结点具有两个子结点，分别表示数字和类型。

```json
{
    "node" : "array",
    "child" : [
        {
            "node" : "2",
            "child" : "null"
        },
        {
            "node" : "array",
            "child" : [
                {
                    "node" : "3",
                    "child" : "null"
                },
                {
                    "node" : "integer",
                    "child" : "null"
                }
            ]
        }
    ]
}
```

使用如下的SDD，非终结符号T生成的是一个基本类型int和float之一。当T推导出BC且C推导出e时，T生成一个基本类型。否则，C就生成一个由整数序列组成的数组描述分量，其中的每个整数用方括号括起。

产生式｜语义规则
-|-
T -> B C|T.t = C.t, C.b = B.t
B -> int|B.t = integer
B -> float|B.t = float
C -> `[num]`C1|C.t = array(num.val, C1.t), C1.b = c.b
C -> e|C.t = C.b

非终结符号B和T有一个表示类型的综合属性t。非终结符号C有两个属性：一个继承属性b和一个综合属性t。继承属性b将一个基本类型沿着树向下传播，而综合属性t则收集最终得到的结果。

输入串`int[2][3]`的注释语法分析树如下述所示，相应表达式的构造过程如下：首先类型integer从B开始，沿着C组成的链通过继承属性b向下传递。最后的数组类型是沿着C组成的链,通过属性t不断向上传递并综合得到的。

更详细地讲，在产生式`T->BC`对应的根结点上，非终结符号C使用继承属性C.b从B那里继承类型。在最右边的C结点上的产生式是C->e,因此C.t等于C.b。产生式`C->[num]C1`的语义规则将运算符array作用到运算分量num.val和C1.t上，得到C.t的值。

### 语法制导的翻译方案

语法制导的翻译方案是语法制导定义的一种补充。

**语法制导翻译方案(syntax directed translation scheme, SDT)**是在其产生式中嵌入了程序片段的一个上下文无关文法。这些程序片段称为语义动作，它们可以出现在产生式中的任何地方。按照惯例，我们这些动作两边加上花括号。如果花括号要作为文法符号出现，则要给它们加上引号。

任何SDT都可以通过下面的方法实现：首先建立一棵语法分析树，然后按照从左到右的深度优先顺序来执行这些动作，也就是说在一个前序遍历过程中执行。

SDT是在语法分析过程中实现的，不会真的构造一棵语法分析树。在本节中，主要关注如何使用SDT来实现两类重要的SDD：

* 基本文法可以用LR技术分析，且SDD是S属性的。
* 基本文法可以用LL技术分析，且SDD是L属性的。

在这两种情况下，一个SDD中的语义规则是如何被转换成一个带有语义动作的SDT的。这些动作将在适当的时候执行。在语法分析过程中，产生式体中的一个动作在它左边的所有文法符号都被匹配之后立即执行。

可以在语法分析过程中实现的SDT可以按照如下的方式识别：将每个内嵌的语义动作替换为一个独有的标记非终结符号(marker nonterminal)。每个标记非终结符M只有一个产生式`M->e`。如果带有标记非终结符号的文法可以使用某个方法进行语法分析，那么这个SDT就可以在语法分析过程中实现。

#### 后缀翻译方案

至今为止，最简单的实现SDD的情况是文法可以用自底向上方法来分析且该SDD是S属性定义。在这种情况下，可以构造出一个SDT，其中的每个动作都放在产生式的最后，并且在按照这个产生式将产生式体规约为产生式头的时候执行这个动作。所有动作都在产生式最右端的SDT称为后缀翻译方案。

#### 后缀SDT的语法分析栈实现

后缀SDT的语法可以在LR语法分析过程中实现，当规约发生时执行相应的语义动作。各个文法符号的属性值可以放到栈中某个位置，使得执行归约的时候可以找到它们。最好的方法是将属性和文法符号(或者表示文法符号的LR状态)一起放在栈中的记录里。

语法分析栈包含的记录中有一个字段，该字段用于存放文法符号(或语法分析器的状态)，并且在这个字段之下有一个字段用于存放属性。三个文法符号X Y Z位于栈的顶部，可能它们即将按照这一个产生式，比如A->X Y Z，进行规约。这里，用X.x表示X的一个属性，等等。一般来说，可以支持多个属性，方法是使记录变的足够大，或者在栈中的记录里放上指针。对于小型的属性，将记录变得足够大可能是比较简单的方法，即使有些时候有些字段不会被用到也没有太大关系。然而，如果一个或多个属性的大小没有限制，比如它们是字符串，那么最好把一个指针放到栈记录的属性值中，并把实际的值存放在栈之外的某个比较大的共享存储区域中。

如果所有属性都是综合属性，并且所有动作都位于产生式的末端，那么可以把产生式体归约成产生式头的时候计算各个属性的值。如果我们使用`A->XYZ`这样的产生式进行归约。此时X，Y和Z的所有属性值都是可用的，并且都位于已知的位置上，在这个动作之后，A和它的属性都位于栈的顶部，即现在存放X记录的位置上。

例：重写桌上计算器SDT的动作，使它们显示地操作语法分析栈。这样的栈操作通常是由语法分析器自动完成的

假设语法分析栈存放在一个被称为`stack`的记录数组中，而`top`是指向栈顶的游标。这样，`stack[top]`指向这个栈的栈顶记录，`stack[top-1]`指向栈顶记录的下一个记录，依次类推。还可以假设每个记录有一个被称为`val`的字段，该字段存放了这个记录所代表的文法符号的属性值。这样，可以使用`stack[top-2].val`来指向出现在栈中第三个位置上的属性`E.val`。完整的SDT如下所示。

产生式|语义动作
-|-
L -> E n|print(stack[top - 1].val);top = top - 1;
E -> E1 + T|stack[top - 2].val = stack[top - 2].val + stack[ top ].val;top = top - 2;
E -> T|
T -> T1 * F|stack[top - 2].val = stack[top - 2].val * stack[ top ].val;top = top - 2;
T -> F|
F -> (E)|stack[top - 2].val = stack[top - 1].val;top = top - 2
F -> digit|

#### 产生式内部带有语义动作的SDT

动作可以放置在产生式体中的任何位置上。当一个动作的左边的所有符号都被处理过后，该动作立即执行。因此，如果有一个产生式`B->X{a}Y`，当识别到X（如果X是终结符号）或者从X推导出的终结符号（如果X是非终结符号）之后，动作a就会执行。更准确地讲

* 如果语法分析过程是自底向上的，那么在X的此次出现位于语法分析栈的栈顶时，立刻执行动作a；
* 如果语法分析过程是自顶向下的，那么试图展开Y的本次出现（如果Y是非终结符号）之前执行语义动作a。

可以在语法分析过程中实现的SDT包括后缀SDT和即将实现的一类SDT，这类SDT实现了L属性定义。不是所有的SDT都可以在语法分析过程中实现。

任何SDT都可以按照下列方式实现

1. 忽略语义动作，对输入进行语法分析，并产生一个语法分析树；
2. 然后检查每个内部结点N，假设它的产生式是`A->α`，将α中的各个动作当作Nde附加子结点加入，使得N的子结点从左到右和α中的符号和动作完全一致；
3. 对这棵语法树进行前序遍历，并且当访问到一个以某动作为标点de结点时立刻执行这个动作。

#### 从SDT中消除左递归

因为带有左递归的文法不能按照自顶向下的方式确定进行语法分析，所以有时需要消除左递归。

首先考虑简单的情况，即只需要关心一个SDT中的动作的执行顺序的情况。比如，如果每个动作只打印一个字符串，就只关心这些字符串的打印顺序。在这种情况下，可以应用下面的原则完成这个转化

* 当转换文法的时候，将动作当成终结符号处理。

消除左递归的“技巧”是对两个产生式`A->Aa|b`进行替换。这两个产生式生成的串包含一个b和任意数量的a。它们将被替换为下面的产生式。新的产生式使用了一个新非终结符号R（代表“其余部分”）来生成同样的串。

```
A->bR
R->aR | e
```

如果b不以A，那么A就不再有左递归的产生式。按照正则定义的表示法，在两组产生式中A都被定义为b（α）*

如果对E应用标准的左递归消除转换，左递归产生式的余部为`a=+T{print('+');}`

而b（即另一个产生式的体）是T。如果引入R来表示E的余部，就得到如下的产生式集合

```
E -> T R
R -> +T {print('+');} R
R -> e
```

当一个SDD的动作是计算属性的值，而不是仅仅是打印输出时，必须更加小心地考虑如何消除文法中的左递归。然而，如果这个SDD属性是S属性的，那么我们总是可以通过将计算属性的值的动作放在新产生式中的适当位置上来构造出一个SDT。

将给出一个通用的解决方案，以解决只有单个递归产生式，单个非递归产生式并且该左递归非终结符号只有单个属性的情况。将这个方案推广到多个递归/非递归产生式的情况并不困难，但是写起来非常麻烦。假设这两个产生式分别为
```
A -> A1Y {A.a = g(A1.a,Y.y)}
A -> X {A.a = f(X,x)}
```
这里A.a是左递归非终结符号A的综合属性，而X和Y是单个文法符号，分别有综合属性X.x和Y.y。因为这个方案在递归的产生式中用任意的函数g来计算A.a，而在第二个产生式中用任意的函数f来计算A.a的值，所以这两个符号可以代表由多个文法符号组成的串，每个符号都有自己的属性。在每种情况下，f和g可以把它们能够访问的属性当作它们的参数，只要这个SDD是S属性的。

要把基础文法改成
```
A -> X R
R -> Y R | e
```

为了完成这个翻译，使用下列SDT：
```
A -> X {R.i = f(X,x)}  R {A.a = R.s}
R -> Y {R1.i = g(R.i,Y.y)}  R1 {R.s = R1.s}
R -> e {R.s = R.i}
```

*注意：继承属性R.i在产生式体中R的一次使用之前完成求值，而综合属性A.a和R.s在产生式的结尾完成求值。因此，计算这些属性时需要de任何值都已经在左边计算完成，变成了可用的值*

#### L属性定义的SDT

只要基础文法是LR的，后缀SDT就可以按照自底向上的方式进行语法分析和翻译。

考虑更一般化的请情况，即L属性的SDD。假设基础文法将以自顶向下的方式进行语法分析，因为如果不是这样，那么翻译过程常常无法和一个LL或者LR语法分析器一起完成。对于任何文法，只需将动作附加到一棵语法分析树中，并在对这棵树进行前序遍历时执行这些动作，便可以实现下面的技术。

将一个L属性的SDD转换为一个SDT的规则如下：

* 把计算某个非终结符A的继承属性的动作插入到产生式体中紧靠在A的本次出现之前的位置上
* 将计算一个产生式头的综合属性的动作放置在这个产生式体的最右端

例：一个产生式`S -> while(C)S1`。这里，S是生成各种语句的非终结符号，假设这些语句包括if语句，赋值语句和其他类型的语句；C表示一个条件表达式（一个值为真或假的布尔表达式）

在这个关于语句控制流的例子中，只需要生成多个标号。假设其他的中间代码指令都由这个SDT的未显示部分生成。更明确地讲，生成显示的形如`label L`的指令，其中`L`是一个标示符。这个指令表明后一条指令的标号是L。假设中间代码和之前的类似

这个while语句的含义是首先对条件表达式C求值。如果它为真，控制就转向S1的代码的开始处。如果C的值为假，那么控制就转向跟这个while代码之后的代码。必须设计S1的代码，使得它在结束的时候能够跳转到这个代码的开始处。使用下面的属性来正确地生成中间代码：

1. 继承属性`S.next`是必须在S执行结束之后执行的代码的开始处的标号；
2. 综合属性`S.node`是中间代码的序列，实现了语句S，并且最后有一条跳转到`S.next`的指令；
3. 继承属性`C.true`是必须在C为真时执行的代码开始处的标号；
4. 继承属性`C.false`是必须在C为假时执行的代码开始处的标号；
5. 综合属性`C.node`是一个中间代码序列，它实现了条件表达式C，并根据C的值为真或假跳转到`C.true`或`C.false`

计算while语句的这些属性的SDD显示在下述代码中：

```
S -> while(C)S1  L1 = new();
                 L2 = new();
                 S1.next = L1;
                 C.false = S.next;
                 C.true = L2;
                 S.code = label || L1 || c.code || label || L2 || S1.code 
```

*注意：使用`||`作为连接各个中间代码片段的符号。因此，S.node的值以标号L1开始，然后是条件表达式C的代码，然后是另一个标号L2，然后是S1的代码*

这个SDD是L属性的。当我们把它转换为SDT时，还需要考虑如何处理标号L1和L2L2，它们是变量而不是属性。如果我们把语义动作当作哑非终结符号来处理，那么这样的变量可以当作哑非终结符号的综合属性来处理。因为L1和L2L2不依赖于其他属性，它们可以被分配到产生式的第一个语义动作中。实现这个L属性定义带有内嵌语义动作的SDT显示在下面：

```
S -> while ( { L1 = new(); L2 = new(); C.false = S.next; C.true = L2; }
    C )  { S1.next = L1;}
    S1   { S.code = label || L1 || C.code || label || L2 || S1.code; }
```

### 实现L属性的SDD

因为很多翻译应用可以用L属性定义来解决，所以将在这一节中详细地考虑它们的实现。下面的方法通过遍历语法分析树来完成翻译工作。

* **建立语法分析树并注释**-这个方法对于任何非循环定义的SDD都有效；
* **构造语法分析树，加入动作，并按照前序顺序执行这些动作**-这个方法可以处理任何L属性定义。在之前的章节中讨论了如何把一个L属性SDD转变为SDT，还特别讨论了如何根据这样的SDD语义规则把语义动作嵌入到产生式中；
* **使用一个递归下降的语法分析器**-它为每个非终结符号都建立一个函数。对应于非终结符号A的函数以参数的方式接受A的继承属性，并返回A的综合属性；
* **使用一个递归下降的语法分析器**-以边扫描边生成的方式生成中间代码
* **与LL语法分析器结合，实现一个SDT**-属性的值存放在语法分析栈中，而各个规则从栈中的已知位置获取需要的属性值
* **与LR语法分析器结合，实现一个SDT**-这个方法会让人觉得惊讶，因为一个L属性SDD的SDT通常有一些动作位于产生式的中间，而在一个LR语法分析过程中，只有在构造出一个产生式体的全部符号之后才能肯定确实可以使用这个产生式。然而，如果基础文法是LL的，总是可以按照自底向上的方式来处理语法分析和翻译过程。

#### 在递归下降语法分析过程中进行翻译

一个递归下降的语法分析器对每个非终结符号A都有一个函数A。可以按照如下方法把这个语法分析器扩展为一个翻译器：

* 函数A的参数是非终结符号A的继承属性。
* 函数A的返回值是非终结符号A的综合属性的集合。

在函数A的函数体中，要进行语法分析并处理属性：

* 决定用哪个产生式来展开A
* 当需要读入一个终结符号时，在输入中检查这些符号是否出现。假设分析过程不需要进行回溯，但是只要出现在语法错误时恢复输入位置，就可以把这个方法扩展到带回溯的递归下降语法分析技术
* 在局部变量中保存所有必要的属性，这些值将用于计算产生式体中非终结符号的继承属性，或者产生式头部的非终结符号的综合属性
* 调用对应于被选定产生式体中的非终结符号的函数，向它们提供正确的参数。因为基础的SDD是L属性的，所以必然已经计算出了这些属性并且把它们存放到了局部变量中。

例：考虑上一个例子中while语句的SDD和SDT。下述代码显示了S函数相关部分的伪代码。

显示的这个函数S需要存储并返回很长的字符串。在实践中，更有效率的做法是让像S和C这样的函数返回一个指针，指向表示这些字符串的记录。那么函数S中的返回语句将不会真的把各个组成部分连接起来，而是构造出一个记录或记录树。这个记录或记录树表示了将Scode，Ccode，标号L1和标号L2以及文字串“label”的两次出现全部连接起来而得到的串。

```cpp
string S(label next) {
    string Scode, Ccode; /* 存放代码片段的局部变量 */
    label L1, L2;  /* 局部标号 */
    if (当前输入 == 词法单元while) {
        读取输入;
        检查‘(’是下一个输入符号，并读取输入；
        L1 = new();
        L2 = new();
        Ccode = C(next, L2);
        检查‘)’是下一个输入符号，并读取输入；
        Scode = S(L1);
        return ("label" || L1 || Ccode || "label" || L2 || Scode);
    }
    else {
        /* 其他语句类型 */
    }
}
```

#### 边扫描边生成代码

使用属性来表示代码并构造出很长的串不能满足我们的要求，原因是多方面的，比如拷贝和移动这些串字符时需要很长的时间。在通常情况下，比如在我们的代码生成例子中，可以通过执行一个SDT中的语义动作，逐步把各个代码片段添加到一个数组或输出文件中。要保证这项技术能够正确应用，下列要素必不可少：

* 存在一个（一个或多个非终结符号的）主属性。为方便起见，假设主属性都以字符串为值。在上述例子中，属性`S.code`和`C.code`是主属性，而其他属性不是主属性；
* 主属性是综合属性；
* 对主属性求值的规则保证；

1. 主属性是将相关产生式体中的非终结符号的主属性值连接起来得到的。连接时也可能包括其他非主属性的元素，比如字符串label和标号L1及L2的值
2. 各个非终结符号的主属性值在连接运算中出现的顺序和这些非终结符号在产生式体中的出现顺序相同。

上面这些条件使得在构造主属性时只需要在适当的时候发出这个连接运算中的非主属性元素。可以依靠对一个产生式体中的非终结符号的对应函数的递归调用，以增量方式生成它们的主属性。
d
可以修改S函数，使得它生成主属性`S.code`的各个元素，而不是把它们保存起来，再连接得到`S.code`的一个返回值。经过修改的函数S显示在下面：

```cpp
void S(label next) {
    label L1, L2;  /* 局部标号 */
    if (当前输入 == 词法单元while) {
        读取输入;
        检查‘(’是下一个输入符号，并读取输入；
        L1 = new();
        L2 = new();
        print("lable", L1);
        C(next, L2);
        检查‘)’是下一个输入符号，并读取输入；
        print("lable", L2);
        Scode = S(L1);
    }
    else {
        /* 其他语句类型 */
    }
}
```

#### L属性的SDD和LL语法分析

假设一个L属性SDD的基础文法是一个LL文法，并且我们已经按照上述描述的方法把它转换成一个SDT，其语义动作被嵌入到各个产生式中。然后，就可以在LL语法分析过程中完成翻译过程，其中的语法分析栈需要进行扩展，以存放语义动作和属性求值所需的某些数据项。一般来说，这些数据项是属性值的拷贝。

除了那些代表终结符号和非终结符号的记录之外，语法分析栈中还保存**动作记录(action-record)**和**综合记录(synthesize-record)**，其中动作记录表示即将被执行的语义动作，而综合记录保存非终结符号的综合属性值。使用下列两个原则来管理栈中的属性：

* 非终结符号A的继承属性放在表示这个非终结符号的栈记录中。对这些属性求值的代码通常使用紧靠在A的栈记录之上的动作记录来表示。实际上，从L属性的SDD到SDT的转换方法保证了动作记录将紧靠在A的上面。
* 非终结符号A的综合属性放在一个单独的综合记录中，它在栈中紧靠在A的记录之下。

这个策略在语法分析栈中放置了多种类型的记录，这些不同的记录类型将被当作“栈记录”的子类进行正确管理。在实践中，可能把几个记录组合成一个记录，但是如果要解释这个方法的基本思想，最好还是把用于不同目的的数据分别存放在不同的记录中。

动作记录包含指向将被执行的动作代码的指针。动作可能出现在综合记录中，这些动作通常把其他记录中的综合属性拷贝到栈中更低的地方。在这个综合属性所在的记录被弹出栈之后，语法分析程序需要在这个较低的位置上找到该属性的值。

一个通过分析表驱动的LL语法分析器模拟了一个最左推导过程。如果w是至今为止已经匹配完成的输入，那么栈中就包含了一个文法符号序列a，使得`S lm*-> wa`，其中S是开始符号。当语法分析器按照一个产生式`A -> B C`展开的时候，它把栈顶的`A`替换为`B C`。

假设非终结符号C有一个继承属性`C.i`。对于产生式`A -> B C`，继承属性`C.i`可能不仅仅依赖于`A`的继承属性，还可能依赖于B的所有属性。因此，可能需要在计算`C.i`之前完成对B的处理。因此，需要计算`C.i`所需的所有属性值的临时拷贝存放到计算`C.i`的动作记录之中。否则，当语法分析器把栈顶的A替换为BC的时候，A的继承属性就和它的栈记录一起消失了。

因为基础SDD是L属性的。可以肯定当A位于栈顶时，A的继承属性的值是可用的。因此当需要把这些值拷贝到对C的继承属性求值的动作记录中时，这些值也是可用的。不仅如此，用于存放A的综合属性的空间也不成问题，因为这个空间位于A的综合记录中，而这个记录在语法分析器使用`A -> B C`进行展开时还保持在分析栈中（位于B和C之下）。

当处理B时，如果需要，可以执行一个动作，将它的继承属性拷贝给C使用。在处理完B之后，如果需要，B的综合记录也可以拷贝它的综合属性供C使用。类似地，也可能需要一些临时变量来计算A的综合属性的值。这些值可以在先后处理B和C的时候被拷贝到A的综合记录中。所有这些属性的拷贝工作能够正确进行原理是：

* 所有拷贝都发生在对某个非终结符号的一次展开时创建的不同记录之间。因此，这些记录中的每一个都知道其他各个记录在栈中离它有多远，因此可以安全地把值写到它下面的记录中。

#### L属性的SDD的自底向上语法分析 

可以使用自底向上的方法来完成任何可以用自底向下方式完成的翻译过程。更准确地说，给定一个以LL文法为基础的L属性SDD，可以修改这个文法，并在LR语法分析过程中计算这个新文法之上的SDD。这个“技巧”包括三个部分：

* 先得到SDT的起点。这样的SDT在各个非终结符号之前放置语义动作来计算它的继承属性，并且在产生式后端放置一个动作来计算综合属性；
* 对每个内嵌的语义动作，向这个文法中引入一个标记非终结符号来替换掉它，每个这样的位置都有一个不同的标记，并且对于任意一个标记M都有一个产生式`M -> e`；
* 如果标记非终结符号M在某个产生式`A -> a{a}b`中替换了语义动作a，对a进行修改得到a‘，并且将a'关联到`M -> e`上。这个动作a‘：

1. 将动作a需要的A或a中符号的任何属性作为M的继承属性进行拷贝
2. 按照a中的方法计算各个属性，但是将计算得到的这些属性作为M的综合属性

这个变换看起来是非法的，因为通常和产生式`M -> e`相关的动作将不得不访问某些没有出现在这个产生式中的文法符号的属性。然而，将在LR语法分析栈上实现各个语义动作。因此必要的属性总是可用的，它们位于栈顶之下的已知属性上。

例：假设一个LL文法中存在一个产生式`A -> B C`,而继承属性`B.i`是根据继承属性`A.i`按照某个公式`B.i = f(A.i)`计算得到的。也就是说，关心的SDT片段是`A -> {B.i = f(A.i)} B C`

引入标记M，M有继承属性M.i和综合属性M.s。前者是A.i的一个拷贝，而后者将成为B.i。这个SDT将被写作

```
A -> M B C
M -> {M.i = A.i; M.s = f(M.i);}
```

*注意：M的规则中不可以使用A.i*，但是实际上将设法安排分析栈，使得如果即将执行一个到A的归约，那么A的每个继承属性都将出现在栈中这个执行归约的位置下方，从该处就可以读到这些继承属性。因此，当我们将e归约为M时，直接在它的下方找到A.i,在那里读取到它的值。另外，当我们将e规约为M时，直接在它的下方找到A.i，在那里读取到它的值。

例：把之前的while SDT修改成基于经过修改的LR文法的SDT，新的SDT可以和LR语法分析器一起完成翻译。在C之前引入标记M，在S1之前引入标记N，因此基础文法变成

```
S -> while (M C) N S1
M -> e
N -> e
```

现在跟踪一个while语句的语法分析过程。假设一个保存S.next的记录出现在栈顶，并且下一个输入是终结符号while，把这个终结符号移入栈中。此时识别出的产生式肯定是while产生式，因此LR语法分析器可以移入`(`并确定下一步把e归约为M。此时的栈显示在下式中。创建出L1和L2的值，它们被存放在M的记录的域中，同处这个记录还有`C.true`和`C.false`的域。这些属性必定在这个记录的第二个域或第三个域中。这是为了和可能在不同上下文出现于C之下，且需要为C提供这些属性的其他栈记录保持一致。这个动作最后把两个值赋给C.true和C.false。其中de第一个值来自于刚刚生成的L2，另一个从栈下方存放S.next的地方获取。

继续识别while语句，语法分析器下一步将在输入中发现`)`，把它放在该符号自己的记录中，并压入栈中。因为文法是LL的，因此语法分析器在该点上已经知道它在处理一个while语句。语法分析器将把e归约为N。和N相关联的唯一数据是继承属性S1.next。请注意，需要将这个属性存放在此记录中的原因是这个记录将恰好位于S1的记录之下。计算S1.next的值代码时

```
S1.next = stack[top - 3].L1
```

这个动作从N之下三个记录的地方获取了L1的值。当这个代码执行的时候，N的记录位于栈顶。

接下来，语法分析器将其余输入的某个前缀规约为S。一直把它称为S1，以便和产生式头的S区分开。S1.node的值计算完成并放在S1的栈记录中。

此时，语法分析器将把从while到S1的全部内容归约为S。在这一次的归约为S。在这一次归约中，执行的代码是

```
tempCode = label || stack[top - 4].L1 || stack[top - 3].code || label || stack[top - 4].L2 || stack[top].code;
top = top - 6;
stack[top].code = tempCode;
```

也就是说，在变量tempCode中构造出S.code的值。该代码也是由两个标号L1和L2，C的代码和S1的代码组成。这个栈执行了一些弹出操作，因此S出现在while原来出现的地方。S的代码值存放在该记录的code字段中。它在那里被解释为综合属性S.code。请注意，在这次讨论中没有显示对LR状态的操作，实际上这些状态必须出现在栈中，其所在的字段就是存放文法符号的字段。

### 第五章总结

* **继承属性和综合属性**-语法制导定义可以使用两种属性。一棵语法分析树结点上的综合属性根据该结点的子结点的属性计算得到。一个结点上的继承属性根据它的父结点和/或兄弟结点的属性计算得到。
* **依赖图**-给定一棵语法分析树和一个SDD，在各个语法分析树结点所关联的属性实例上面画上边，以指明位于边的头部属性值要根据位于边的尾部的属性值计算得到。
* **循环定义**-在一个有问题的SDD中，发现存在一些语法分析树，无法找到一个顺序来计算所有结点上的所有属性的值。这些语法分析树关联的依赖图中存在环。确定一个SDD是否存在这种带环的依赖图是非常困难的。
* **S属性定义**-在一个S属性的SDD中，所有的属性都是综合的。
* **L属性定义**-在一个L属性的SDD中，属性可能是继承的，也可能是综合的。然而，一个语法分析树结点上的继承属性和位于它左边的兄弟结点的（任意）属性。
* **抽象语法树**-一棵抽象语法树中的每个结点代表一个构造；某个结点的子结点表示该结点所对应的构造的有意义的组成部分。
* **实现S属性定义的SDD**-一个S属性定义可以通过一个动作都在产生式尾部的SDT（后缀SDT）来实现。这些动作通过产生式体中的各个符号的综合属性来计算产生式头的综合属性。如果基础文法是LR的，那么这个SDT可以在一个LR语法分析栈上实现。
* **从SDT中消除左递归**-如果一个SDT只有副作用（即不计算属性值），那么消除文法左递归的标准方法允许把语义动作当作终结符号移动到新文法当中。计算属性时，如果这个SDT是后缀SDT，那么仍然可以消除左递归。
* **用递归下降语法分析实现L属性的SDD**-如果有一个L属性定义，且其基础文法可以用自顶向下方法进行语法分析。就可以构造出一个不带回溯的递归下降语法分析器来实现这个翻译。继承属性变成了非终结符号对应函数的参数，而综合属性由该函数返回。
* **实现LL文法之上的L属性的SDD**-每个以LL文法为基础文法的L属性定义可以在语法分析过程中实现。用于存放一个非终结符号的综合属性的记录被放在栈中这个非终结符号之下，而一个非终结符号的继承属性和这个非终结符号存放在一起。栈中还放置了动作记录，以便在适当的时候计算属性值。
* **以自底向上的方式实现一个在LL文法之上的L属性SDD**-一个以LL文法为基础文法的L属性定义可以转换成一个以LR文法为基础文法的翻译方案，且这个翻译可以和自底向上的语法分析过程一起执行。文法的转换过程中引入了“标记”的非终结符号。这些符号出现在自底向上语法分析栈中，并保存了栈中位于它上方的非终结符号的继承属性。在栈中，综合属性和它的非终结符号放在一起。

## 第六章：中间代码生成

在编译器的分析-综合模型中，前端对源程序进行分析并产生中间表示，后端在此基础上生成目标代码。理想情况下，和源语言相关的细节在前端分析中处理，而关于目标机器的细节则在后端处理。基于一个适当定义的中间表示形式，可以把针对源语言i的前端和针对目标机器j的后端组合起来，构造得到源语言i在目标机器j上的编译器。这种创建编译器组合的方法可以大大减少工作量：只要写出m种前端和n中后端处理程序就可以得到m*n种编译程序。

假设一个编译程序的前端顺序地进行语法分析，静态类型检查和中间代码生成，有时候这几个过程也可以组合起来，在语法分析中一并完成。使用之前章节的语法制导定义来描述类型检查和翻译过程。大部分的翻译方案可以基于自顶向下或自底向上的语法分析技术来实现。所有的的方案都可以通过生成并遍历抽象语法树来实现。

静态检查包括**类型检查（type checking）**，类型检查运算符被应用到兼容的运算分量。静态检查还包括在语法分析之后进行的所有语法检查。例如，静态检查可以保证C语言中的一条break指令必然位于一个while/for/switch语句之内。如果不存在这样的语句，静态检查将报告一个错误。

本章介绍的方法可以用于多种中间表示，包括抽象语法树和三地址码。三地址代码是因为这些指令的一般形式`x = y op z`具有三个地址：两个运算分量y和z，和一个结果变量x。

在将给定源语言的一个程序翻译成特定的目标机器代码的过程中，一个编译器可能构造出一系列中间表示。高层表示接近于源语言，而低层的表示接近于目标机器。语法树是高层的表示，它刻画了源程序的自然层次性结构，并且适用于静态类型检查这样的处理。

低层的表示形式适用于机器相关的处理任务，比如寄存器分配，指令选择等。通过选择不同的运算符，三地址代码既可以是高层的表示方式，也可以是低层的表示方式。对表达式而言，语法树和三地址代码只是在表面上有所不同。对于循环语句，语法树表示了语句的各个组成部分，而三地址码包含标号和跳转指令，用来表示目标语言的控制流。

### 语法树的变体

语法树中的各个结点代表了源程序中的构造，一个结点的所有子结点反映了该结点对应构造的有意义的组成成分。为表达式构建的无环有向图（Directed Acyclic Graph, DAG）指出了表达式中的公共子表达式（多次出现的子表达式）。可以用构造语法树的技术构造DAG。

#### 表达式的有向无环图

和表达式的语法树类似，一个DAG的叶子结点对应于原子运算分量，而内部结点对应于运算符。与语法树不同的是，如果DAG中的一个结点N表示一个公共子表达式，则N可能有多个父结点。在语法树中，公共子表达式每出现一次，代表该公共子表达式的子树就会被复制一次。因此，DAG不仅更简洁地表示了表达式，而且可以为最终生成表达式的高效代码提供重要的信息。

例：表达式`a + a * (b - c) + (b - c) * d`。叶子结点a在表达式中出现了两次，因此a有两个父结点。值得注意的是，结点“-”代表公共子表达式`b - c`的两次出现。该结点同样有两个父结点，表明该子表达式在子表达式`a * (b - c)`和`(b - c) * d`中两次被使用。尽管b和c在整个表达式中出现了两次。但它们对应的结点只有一个父结点，因为对它们的使用都出现在同样的公共子表达式`b - c`中。

下表给出的SDD（语法制导定义）既可以用来构造语法树，也可以用来构造DAG。

产生式|语义规则
-|-
1) E->E1+T|E.node = new Node('+', E1.node, T.node)
2) E->E1-T|E.node = new Node('-', E1.node, T.node)
3) E->T|E.node = T.node
4) T->(E)|T.node = E.node
5) T->id|T.node = new Leaf(id, id.entry)
6) T->num|T.node = new Leaf(num, num.val)

#### 构造DAG结点的值编码方法

语法树或DAG中的结点通常存放在一个记录数组中，数组的每一行表示一个记录，也就是一个结点。在每个记录中，第一个字段是一个运算符代码，也是该结点的标号。各个叶子结点还有一个附加的字段，它存放了标识符的词法值（是一个指向符号的指针或一个常量）。内部结点则有两个附加的字段，分别指明其左右子结点。

在这个数组中，只需要给出一个结点对应的记录在此数组中的整数下标就可以引用该结点。在历史上，这个整数称为相应结点或该结点所表示的表达式的**值编码(value number)**。

算法6.3 构造DAG的结点的值编码方法

输入：标号op，结点l和结点r。
输出：数组中具有三元组`<op, l, r>`形式的结点的值编码
方法：在数组中搜索标号为op，左子结点为l且右子结点为r的结点M。如果存在这样的结点，则返回M结点的值编码。若不存在这样的结点，则在数组中添加一个结点N，其标号为op，左右子结点分别为l和r，返回新建结点对应的值编码。

但是算法6.3每次定位一个结点都要搜索整个数组，这个开销是很大的，当数组中存放了整个程序的所有表达式时尤其如此。更高效的方法是使用散列表，将结点放入若干个“桶”中，每个桶通常只包含少量结点。桶可以通过链表来实现。桶可以通过链表来实现

### 三地址代码

在三地址代码中，一条指令的右侧最多有一个运算符。也就是说，不允许出现组合的算术表达式。因此，像`x + y * z`这样源语言表达式要被翻译成如下的三地址指令序列

```
t1 = y * z
t2 = x + t1
```

其中t1和t2是编译器产生的临时名字。因为三地址代码拆分了多运算符算术表达式以及控制流语句的嵌套结构，所以适用于目标代码的生成和优化。因为可以用名字来表示程序计算得到的中间结果，所以三地址代码可以方便地进行重组。

#### 地址和指令

三地址代码基于两个基本概念：地址和指令。按照面向对象的说法，和两个概念对应于两个类，而各种类型的地址和指令对应于相应的子类。另一种方法是用记录的方式来实现三地址代码，记录中的字段用来保存地址。

地址可以具有如下形式之一：

* **名字**-允许源程序的名字作为三地址代码中的地址。在实现中，源程序名字被替换为指向符号表条目的指针。关于该名字的所有信息均存放在该条目中。
* **常量**-在实践中，编译器往往要处理很多不同类型的常量和变量。
* **编译器生成的临时变量**-在每次需要临时变量时产生一个新名字是必要的，在优化编译器中更是如此。当为变量分配寄存器的时候，可以尽可能地合并这些临时变量。

改变控制流的指令将使用符号化标号。每个符号化标号表示指令序列中一条三地址指令的序号。通过一次扫描，或者通过回填技术就可以把符号化标号替换为实际的指令位置。回填技术将在今后讨论

1. 形如`x op y`的赋值指令，其中op是一个双目运算符或逻辑运算符。x，y，z是地址。
2. 形如`x = op y`的赋值指令，其中op是单目运算符。基本的单目运算符包括单目减，逻辑非和转换运算。将整数转换成浮点数的运算就是转换运算的一个例子。
3. 形如`x = y`的复制指令，它把y的值赋给x。
4. 无条件转移指令`goto L`，下一步要执行的指令是带有标号L的三地址指令。
5. 形如`if x goto L`或`if False x goto L`的条件转移指令。分别当x为真或为假时，这两个指令的下一步将执行带有标号L的指令。否则下一步将照常执行序列中的最后一条指令。
6. 形如`if x relop y goto L`的条件转移指令。它对x和y应用一个关系运算符(<=, ==, >=等)。如果x和y之间满足relop关系，那么下一步将执行带有标号L的指令，否则将执行指令序列中跟在指令之后的指令。
7. 过程调用和返回值通过下列指令来实现：param x进行参数传递，`call p, n`和`y = call p, n`分别进行过程调用和函数调用；return y是返回指令，其中y表示返回值，该指令是可选的。这些三地址指令的常见用法见下面的三地址指令序列
8. 带下标的复制指令`x = y[i]`和`x[i] = y`。
9. 形如`x = &y`,`x = *y`或`*x = y`的地址及指针赋值指令。

例：考虑语句`do i = i + 1; while (a[i] < v);`。下面给出了这个语句的两种可能的翻译。在第一种翻译中，第一条指令加上了一个符号化标号L。在第二种翻译中，显示了每条指令的位置号，选择以100作为开始位置。在两种翻译中，最后一条指令都是目标为第一条指令的条件转移指令。

```
L : t1 = i + 1
    i = t1
    t2 = i * 8
    t3 = a[t2]
    if t3 < v goto L
```

```
100: t1 = i + 1
101: i = t1
102: t2 = i * 8
103: t3 = a[t2]
104: if t3 < v goto 100
```

选择使用哪些运算符是中间表示形式设计的一个重要问题。显然，这个运算符集合中的运算符要足够丰富，以便实现源语言中的所有运算。接近机器指令的运算符可以使在目标机器实现中间表示形式更加容易。然而，如果前端必须为某些源语言运算生成很长的指令序列，那么优化器和代码生成器就需要花费更多的时间去发现程序的结构，然后才能为这些运算生成高质量的目标代码。

#### 四元式表示

上面的指令没有描述这些指令在某个数据结构中的表示方法。在编译器中，这些指令可以实现为对象，或者是带有运算符字段和运算分量字段的记录。四元式，三元式和间接三元式是三种这样的描述方式。

一个四元式（quadrupe）有四个字段，分别称为op，arg1，arg2，result。字段op包含一个运算符的内部编码。举例来说，在三地址指令`x = y + z`相应的四元式中，op字段中存放`+`,arg1中为y，arg2中为z，result中为x。下面是这个规则的一些特例。

* 形如`x = minus y`的单目运算符指令和赋值指令`x = y`不使用arg2。注意，对于像`x = y`这样的赋值语句，op是`=`，而对大部分其他运算而言，赋值运算符是隐含表示的。
* 像`param`这样的运算符既不使用arg2，也不使用result。
* 条件或非条件转移指令将目标标号放入result字段。

例：赋值语句`a = b * -c + b * -c`的三地址代码入下式所示。这里使用特殊的`minus`运算符来表示`-c`中的单目减运算符`-`。以区别于`b - c`中的双目减运算符`-`。*注意：单目减的三地址语句中只有两个地址，复制语句`a = t5`也是如此*

三地址代码如下

```
t1 = minus c
t2 = b * t1
t3 = minus c
t4 = b * t3
t5 = t2 + t4
a = t5
```

四元式如下

-|op|arg1|arg2|result
-|-|-|-|-
0|minus|c||t1
1|*|b|t1|t2
2|minus|c||t3
3|*|b|t3|t4
4|+|t2|t4|t5
5|=|t5||a

#### 三元式表示

一个三元式（triple）只有三个字段，分别称之为op，arg1和arg2。三元式基本上和算法6.3中的结点范型等价。因此表达式的DAG表示和三元式表示是等价的。当然这种等价关系仅对表达式成立，因为语法树的变体和三地址码分别以完全不同的方式来表示控制流。

**为什么需要复制指令**

一个简单的翻译表达式的算法往往会为赋值运算生成复制指令。将t5复制给a，而不是直接将`t2 + t4`赋给`a`。通常，每个子表达式都会有一个它自己的的新临时变量来存放运算结果。只有当处理赋值运算符`=`时，才知道将把整个表达式的结果赋到哪里。一个代码优化过程将会发现`t5`可以被替换为`a`，这个优化过程可能使用DAG作为中间表示。

在优化编译器中，由于指令的位置常常会发生变化。四元式相对于三元式的优势就体现出来了。使用四元式时，如果移动了一个计算临时变量t的指令，那些使用t的指令不需要做任何改变。而使用三元式时，对于运算结果的引用是通过位置完成的，因此如果改变一条指令的位置，则引用该指令的结果的所有指令都要做相应的修改。使用下面将要介绍的间接三元式时就不会出现这个问题。

间接三元式（indirect triple）包含了一个指向三元式指针的列表，而不是列出三元式序列本身。例如，可以使用数组instructions按照适当的顺序列出指向三元式的指针。

使用间接三元式表示方法，优化编译器可以通过对`instruction`列表的重新排序来移动指令的位置，但不影响三元式本身。使用Java实现时，一个指令对象的数组和间接三元式表示类似，因为Java将数组元素作为对象引用来处理。

#### 静态单赋值形式

**静态单赋值形式(SSA)**是另一种中间表示形式，它有利于实现某些类型的代码优化。SSA和三地址代码的区别主要体现在两个方面。首先SSA中的所有赋值都是针对具有不同名字的变量的。

### 类型和声明

可以把类型的应用划分为类型检查和翻译：

* **类型检查（type checking）**-类型检查利用一组逻辑规则来推理一个程序在运行时刻的行为。更明确地讲，类型检查保证运算分量的类型和运算符的预期类型相匹配。例如，Java要求&&运算符两个运算分量必须是boolean型。如果满足这个条件，结果也具有boolean类型。
* **翻译时的应用（translation application）**-根据一个名字的类型，编译器可以确定这个名字在运行时刻需要多大的存储空间。类型信息还会在其他很多地方被用到，包括计算一个数组引用所指示的地址，插入显式的类型转换，选择正确版本的算术运算符，等等。

这一节会考虑在某个过程或类中声明的名字的类型及存储空间布局问题。一个过程调用或对象的实际存储空间是在运行时刻（当该过程被调用或该对象被创建时）进行分配的。当然，在编译时刻检查布局声明时，可以进行相对地址（relative address）的布局，一个名字或某个数据结构分量的相对地址是指它相对于数据区域开始位置的偏移量。

#### 类型表达式

类型自身也有结构，使用**类型表达式(type expression)**来表示这种结构：类型表达式可能是基本类型，也可能通过把称为类型构造算子的运算符作用于类型表达式而得到。基本类型的集合和类型构造算子根据被检查的具体语言而定。

例：数组类型`int[2][3]`表示“由两个数组组成的数组，其中的每个数组包含3个整数”。它的类型表达式可以写成`array(2, array(3, integer))`。该类型可以用树来表示。array运算符有两个参数：一个数字和一个类型。

**类型表达式的定义**

* 基本类型是一个类型表达式。一种语言的基本类型通常包括boolean，char，integer，float和void。最后一个类型表示“没有值”
* 类名是一个类型表达式
* 将类型构造算子array作用于一个数字和一个类型表达式可以得到一个类型表达式
* 一个记录是包含有名字段的数据结构。将record类型构造算子应用于字段名和相应的类型可以构造得到一个类型表达式。
* 使用类型构造算子`->`可以构造得到函数类型的类型表达式。把“类型s到类型t的函数”写成s->t。
* 如果s和t是类型表达式，则其笛卡尔积`s*t`也是类型表达式。引入笛卡尔积主要是为了保证定义的完整性。可以用于描述类型的列表或元组（例如，用于表示函数参数）。假定*具有左结合性，并且优先级高于`->`
* 类型表达式可以包含取值为类型表达式的变量。

图是表示类型表达式的一种比较方便的方法。可以修改值编码方法，以构造一个类型表达式的DAG。图的内部结点表示类型构造算子，而叶子结点是基本类型，类型名或类型变量。

**类型名和递归类型**-在C++和Java中，类一旦被定义，其名字就可以被用来表示类型名。例如，考虑如下程序片段中的Node类。

```java
public class Node {}
...
public Node n;
```

类型名还可以用来定义递归类型，在像链表这样的数据结构中要用到递归类型一个列表元素的伪代码如下：

```java
class Cell {int info; Cell next; ...}
```

它定义了一个递归类型Cell。这个类包括一个info字段和另一个Cell类型的字段next。在C中可以通过记录和指针来定义类似的递归类型。

#### 类型等价

两个类型表达式什么时候等价呢？很多类型检查规则具有这样的形式，“如果两个类型表达式相等，那么返回某种类型，否则出错”。当给一些类型表达式命名，并且这些名字在之后的其他类型表达式中使用时就会产生歧义。关键问题在于一个类型表达式中的名字是代表它自身呢，还是被看作另一个类型表达式的缩写形式。

当用图来表示类型表达式的时候，两种类型之间结构等价（structurally equivalent）当且仅当下面某个条件为真：

* 它们是相同的基本类型
* 它们是将相同的类型构造算子应用于结构等价的类型而构造得到的
* 一个类型是另一个类型表达式的名字

如果类型名仅仅代表它自身，那么上述定义中的前两个条件定义了类型表达式的名等价（name equivalent）关系。

#### 声明

在研究类型及其声明时将使用一个经过简化的文法，在这个文法中一次只声明一个名字。一次声明多个名字的情况可以像之前讨论的例子那样进行处理。使用的文法如下：

```
D -> T id; D | e
T -> B C | record '{' D '}'
B -> int | float
C -> e | [num] C
```

非终结符号D的一些列声明。非终结符号T生成基本类型，数组类型或记录类型。非终结符号C（表示“分量”）产生零个或多个整数。每个整数用方括号括起来。一个数组类型包含一个由B指定的基本类型，后面跟一个由非终结符号C指定的数组分量。一个记录类型（T的第二个产生式）由各个记录字段的声明序列构成，并被花括号括起来。

#### 局部变量名的存储布局

从变量类型可以知道该变量在运行时刻需要的内存数量。在编译时刻，可以使用这些数量为每个名字分配一个相对地址。名字的类型和相对地址信息保存在相应的符号表条目中。对于字符串这样的变长数据，以及动态数组这样的只有在运行时刻才能够确定其大小的数据，处理的方法是为指向这些数据的指针保留一个已知的固定大小的存储区域。另外还存在运行时刻的存储管理问题。

**地址对齐**-数据对象的存储布局受目标机器的寻址约束的影响。比如，将整数相加的指令往往希望整数能够对齐（aligned），也就是说，希望它们被放在内存中的特定位置上，比如地址能够被4整数的位置上。虽然一个有10个字符的数组只需要足以存放10个字符的字节空间。但编译器常常会给它分配12个字节，即下一个4的倍，这样会有2个字节没有使用。因为对齐的要求而分配的无用空间被称为“补白（padding）”。当空间比较宝贵时，编译器需要对数据进行“压缩”（pack），此时不存在“补白”空间，但可能需要在运行时刻执行额外的指令把被压缩的数据重新定位，以便这些数据看上去仍然是对齐的，从而进行相关的运算。

假设存储区域是连续的字节块，其中字节是可寻址的最小内存单位。一个字节通常有8个二进制位，若干字节组成一个机器字。多字节数据对象往往被存储在一段连续的字节中，并以初始字节的地址作为该数据对象的地址。

类型的宽度（width）是该类型的一个对象所需的存储单元的数量。一个基本类型，比如字符型，整形和浮点型，需要整数多个字节。为方便访问，为数组和类这样的组合类型数据分配的内存是一个连续的存储字节块。

下面给出的翻译方案(SDT)计算了基本类型和数组类型以及它们的宽度。**记录类型**将在之后讨论。这个SDT为每个非终结符号使用综合属性`type`和`width`。它还使用了两个变量t和w，变量的用途是将类型和宽度信息从语法分析树中的B结点传递到对应于产生式`C->e`的结点。在语法分析制导定义中，t和w将是C的继承属性。

```
T -> B   {t = B.type; w = B.width;}
     C   {T.type = C.type; T.width = C.width;}
B -> int {B.type = integer; B.width = 4;}
B -> float {B.type = float; B.width = 8;}
C -> e   {C.type = t;C.width = w;}
C -> [num] C1 {C.type = array(num.value, C1.type);
               C.width = num.value * C1.width;}
```

T产生式的产生式包含一个非终结符号B，一个动作和一个非终结符号C，其中C显示在下一行上。B和C之间的动作是将t设置为B.type，并将w设置为B.width。如果B->int，则B.type和C.width分别被设置为float和8，即宽度为一个浮点数的宽度。

C的产生式决定了T生成的是一个基本类型还是一个数据类型。如果C->e，则t变成C.type，且w变成C.width。

否则，C就描述了一个数组分量。`C->[num]C1`的动作类型构造算子array应用于运算分量`num.value`和`C1.type`，构造得到`C.type`。例如，应用array的结果可能是树型结构。

数组的宽度将是数组元素个数乘以单个数组元素的宽度而得到的。如果连续存放的整数的地址之间的差距为4，那么一个整数数组的地址计算将包含乘4运算。这样的乘法运算为优化提供了机会，因此让前端程序在其输出中明确描述这些运算符将有助于优化。在这一章中，将忽略其他与机器相关特性，比如数据对象的地址必须和机器字的边界对齐。

#### 声明的序列

像C和Java这样的语言支持将单个过程中的所有声明作为一个组进行处理。这些声明可能分布在一个Java过程中，但是仍然能够在分析过程时处理它们。因此，可以使用一个变量，比如offset，来跟踪下一个可用的相对地址。

下面显示的翻译方案处理形如`T id`的声明序列，其中的T如上面所示产生一个类型。在考虑第一个声明之前，offset被设置为0。每处理一个一个变量x时，x被加入到符号表，它的相对地址被设置为offset的当前值。随后，x的类型的宽度被加到offset上。

```
P ->       {offset = 0;}
     D
D -> T id; {top.put(id.lexme,T.type,offset);
            offset = offset + T.width;}
     D1
D -> e;
```

产生式`D -> T id`;D1的语义动作首先执行`top.put(id.lexme, T.type, offset)`,创建一个符号表条目。这里的top指向当前的符号表条目，该条目的数据区中存放了类型T.type和相对地址offset。

如果把第一个产生式写在同一行中：
```
P -> {offset = 0;} D
```

则上述产生式中对offset的初始化处理就变得容易理解。生成e的非终结符号称为标记非终结符号，其作用是重写产生式，使得所有的语义动作都出现在产生式右部的尾端，具体方法使用标记非终结符号M，上述产生式可以被写为

```
P -> M D
M -> e {offset = 0;}
```

#### 记录和类中的字段

上述产生式对声明的翻译方案还可以用于处理记录和类中的字段。要把记录类型加入到上述文法中，只需要加上下面的产生式

```
T -> record '{' D '}'
```

这个记录类型中的字段由D生成的声明序列描述。注意⚠️：

* 一个记录中各个字段的名字必须是互不相同的。也就是说，在由D生成的声明中，同一个名字最多出现一次
* 字段名的偏移量，或者说相对地址，是相对于该记录的数据区字段而言的

为方便起见，记录类型将使用一个专用的符号表，对它们的各个字段的类型和相对地址进行编码。记录类型形如`record(t)`,其中record是类型构造算子，t是一个符号表对象。它保存了有关该记录类型的各个字段的信息。

下述翻译方案包含一个产生式，该产生式将加入到上述文法中关于T的产生式中。这个产生式有两个语义动作。在D之前嵌入的动作首先保存top指向的已有符号表，然后让top指向新的符号表。该动作还保存了当前的offset值，并将offset重制为0，D生成的声明会使类型和相对地址被保存到新的符号表中，D之后的语义动作使用top创建一个记录类型。然后恢复早先保存好的符号表和偏移值。

```
T -> record '{'  {Env.push(top); top = new Env();
                  Stack.push(offset); offset = 0;}
     D '}'       {T.type = record(top);T.width = offset;
                  top = Env.pop(); offset = Stack.pop();}
```

为了使翻译方案更加具体，上述中的动作给出了某个实现的伪代码。令Env类实现符号表。对Env.push(top)的调用将top所指的当前符号表压入一个栈中。然后，变量top被设置为指向一个新的符号表。类似地，offset被推入名为Stack的栈中，offset变量被重制为零。

在D中的声明被翻译之后，符号表top保存了这个记录中所有字段的类型和相对地址。而且，offset还给出了存放所有字段所需的存储空间。第二个动作将T.type设为record(top),并将T.width设为offset。然后，变量top和offset将被恢复为原先被压入栈中的值，以完成这个记录类型的翻译。

### 表达式的翻译

首先考虑三地址码的翻译。一个带有多个运算符的表达式(比如a + b + c)将被翻译成每条指令最多包含一个运算符的指令序列。

#### 表达式中的运算

上述文法中的SDT使用的S属性code以及表达式E的属性addr和code，为一个赋值的语句S生成三地址代码，一个地址可以是变量名字，常量或者编译器产生的临时变量.

产生式|语义规则
-|-
`S -> id = E;`|`S.code = E.code || gen(top.get(id.lexme) '=' E.addr)`
`E -> E1 + E2;` | `E.addr = new Temp()` `E1.code || E2.code || gen(E.addr '=' E1.addr '+' E2.addr)`
`| -E1`|`E.addr = new Temp()` `E.code = E1.code || gen(E.addr '=' 'minus' E1.addr)`
`| (E1)`|`E.addr = E1.addr` `E.code = E1.code`
`| id`|`E.addr = top.get(id.lexme)`  `E.code = ''`

考虑上述语法制导定义的最后一个产生式`E -> id`。若表达式只是一个标识符，比如说x，那么x本身就保存了这个表达式的值。这个产生式对应的语义规则把E.addr定义为指向该id的实例对应的符号条目指针。令top表示当前的符号表。当函数top.get被应用于id的这个实例的字符串表示id.lexme时，它返回对应的符号表条目。E.code被设置为空串。

当规则为`E->(E1)`时，对E的翻译与对子表达式E1的翻译相同。因此，E.addr等于E1.addr,E.code等于E1.code。

上述语法制导定义中的运算符`+`和单目`-`是典型语言中的运算符的代表。`E -> E1 + E2`的语义规则生成了根据E1和E2的值计算E的值代码。计算得到的值存放在新生成的临时变量中。如果E1的值计算后被放入E1.addr，E2的值被放到E2.addr中，那么E1+E2就可以被翻译为`t = E1.addr + E2.addr`，其中t是一个新的临时变量。E.addr被设为t，连续执行`new Temp()`会产生一系列互不相同的临时变量t1,t2,...。

为方便起见，使用记号`gen(x '=' y '+' z)`来表示三地址指令`x = y + z`。当被传递给gen时，变量x，y，z的位置上出现的表达式将首先被求值，而像`=`这样的引号内的字符串则按照字面值传递。其他的三地址指令的生成方法类似，也是将gen作用于表达式和字符串的组合。

当翻译产生式`E->E1 + E2`时，上述语法制导定义的语义规则首先将`E1.code`和`E2.code`连接起来，然后再加上一条将E1和E2的值相加的指令。从而生成E.code。新增加的的这条指令将求和的结果放入一个为E生成的临时变量中，用E.addr表示。

产生式`E -> -E1`的翻译过程与此类似。这个规则首先为E创建一个新的临时变量，并生成的一条指令来执行单目-运算。

最终，产生式`S->id = E;`所生成的的指令表达式E的值赋给标识符id和规则`E->id`中一样，这个产生式的语义规则使用函数top.get来确定id所代表的标识符的地址。S.code包含的指令首先计算E的值并将其保存到由E.addr指定的地址中，然后再将这个值赋给这个id实例的地址top.get(id.lexeme)

#### 增量翻译

code的属性可能是很长的字符串，通常是用增量的方式生成的。因此，在增量方式中，gen不仅要构造出一个新的三地址指令，还要将它添加到至今为止已生成的指令序列之后。指令序列可以暂时放在内存中以便进一步处理，也可以增量地输出。

采用增量方式时不再用到code属性，因为对gen的连续调用将生成一个指令序列。增量方法也可以用来构造语法树，对应于`E = E1 + E2`的语义动作使用构造算子生成新的结点，规则如下：

```
E -> E1 + E2 {E.addr = new Node('+', E1.addr, E2.addr);}
```

这里，属性addr表示的是一个结点，而不是某个变量或常量。

#### 数组元素的寻址

将数组元素存储在一块连续的存储空间里就可以快速地访问它们。在C和Java中，一个具有n个元素的数组中的元素是按照0,1,...,n-1编号的。假设每个数组元素的宽度是w，那么数组A的第i个元素的开始地址为`base + i * w`。

其中base是分配给数组A的内存块的相对地址。也就是说，base是`A[0]`的相对地址。地址可以被推广到二维和多维数组上。对应二维数组上，在C中用`A[i1][i2]`来表示第i1行的第i2个元素。假设一行的宽度是w1,同一行中的每个元素的宽度是w2,那么`A[i1][i2]`的相对地址为`base + i1 * w1 + i2 * w2`。

对于k维数组，相应的公式为`base + i1 * w1 + i2 * w2 + ...+ ik * wk`。

其中，wj(1<= j <=k)是对w1和w2的推广。另一种计算数组引用的相对地址的方法是根据第j维上的数组元素的个数nj和该数组的每个元素的宽度`w = wk`进行计算。在二维数组中（即k = 2, w = w2），`A[i1][i2]`的地址为`base + (i1 * n2 + i2) * w`

在更一般的情况下，数组元素下标不一定是从0开始的。在一个一维数组中，数组元素的编号方式如下：low，low + 1,...,high,而base是`A[i]`的相对地址。

编译时刻的预先计算同样可以应用于多维数组元素的地址计算。然而，有一种情况下不能使用编译时刻预先计算的技术；当数组大小是动态变化的时候。如果在编译时刻无法知道low和high的值，我们就无法提前计算出像c这样的常量。因此在程序运行时，数组大小就需要按照公式`base + (i - low) * w`计算。

一般的数组存放方式都是按行存放，C语言都使用这种数据布局存放方式。一个二维数组通常有两种存储方式，按行存放和按列存放。

#### 数组引用的翻译

为数组引用生成代码时要解决的主要问题是将上节提到地址计算公式和数组引用的文法关联起来。令非终结符号L生成一个数组名字再加上一个下标表达式的序列：

```
L -> L[E] | id [E]
```

与C和Java中一样，假定数组元素的最小编号是0。基于宽度计算相对地址，处理引用的语义动作如下

产生式|语义规则
-|-
`S -> id = E;` | `gen(top.get(id.lexeme) '=' E.addr )`
`| L = E;` | `gen(L.array.base '[' L.addr ']' '=' E.addr)`
`E = E1 + E2` | `E.addr = new Temp(); gen(E.addr '=' E1.addr '+' E2.addr )`
`| id` | `{E.addr = top.get(id.lexeme)}`
`| L` | `{E.addr = new Temp(); gen(E.addr '=' L.array.base '[' L.addr ']' )}`
`L -> id [E]` | `{L.addr = top.get(id.lexeme); L.type = L.array.type.elem; L.addr = new Temp(); gen(L.addr '=' E.addr '*' L.type.width; )}`
`| L1 [E]` | `{L.array = L1.array; L.type = L1.type.elem; t = new Temp(); gen(t '=' E.addr '*' L.type.width); gen(L.addr '=' L1.addr '+' t ); }`

非终结符号L有三个综合属性：

* L.addr指示一个临时变量。这个临时变量将被用于累加公式中的ij * wj项，从而计算数组引用的偏移量；
* L.array是一个指向数组名字对应的符号表条目的指针。在分析了所有的下标表达式之后，该数组的基地址，也就是L.array.base，被用于确定一个数组引用的实际左值；
* L.type是L生成的子数组的类型。对于任何类型t，假定其宽度由t.width给出。把类型（而不是宽度）作为属性，是因为无论如何类型检查总是需要这个类型信息。对于任何数组类型t，假设L.elem给出了其数组元素的类型。

产生式`S -> id = E;`，代表一个对非数组变量的赋值语句。它按照通常的方法进行处理。`S -> L E;`的语义动作产生了一个带下标的复制指令，它将表达式E的值存放到数组引用L所指的内存位置。属性`L.array`给出了数组的符号表条目。数组的基地址（即0号元素的地址）由`L.array.base`给出。属性`L.addr`表示一个临时变量，它保存了了L生成的数组引用的偏移量。因此，这个数组引用的位置是`L.array.base[L.addr]`。这个指令将地址E.addr中的右值放入L的内存位置中。

产生式`E -> E1 + E2`和`E -> id`与以前相同。新的产生式`E -> L`的语义动作生成的代码将L所指的位置上的值复制到一个新的临时变量中。和前面对产生式`S -> L = E;`的讨论一样，L所指的地址就是`L.array.base[L.addr]`。其中，属性L.array仍然给出数组名，L.array.base给出了数组的基地址。属性L.addr表示保存偏移量的临时变量。数组引用的代码将存放在由基地址和偏移量给出的位置中的右值放入E.addr所指的临时变量中。

**符号化表示的类型宽度**-中间代码应该相对独立于目标机器，这样当代码生成器被替换为对应于另一台机器的代码生成器时，优化器不需要作出太大的改变。然而，正如刚刚描述的类型宽度计算方法所示。关于基本类型的信息被融合到了这个翻译方案中。例如，假定每个整数数组的元素占4个字节。一些中间代码，如Pascal和P-code，让代码生成器来填写数组元素的大小，因此中间代码独立于机器的字长，只要用一个符号常量来代替翻译方案中的（作为整数类型宽度的）4，就可以在翻译方案中做到这一点。

### 类型检查

为了进行**类型检查(type checking)**，编译器需要给源程序的每一个组成部分赋予一个类型表达式。然后，编译器要确定这些类型表达式是否能满足一定的逻辑规则。这些规则称为源语言的**类型系统(type system)**。

类型检查具有发现程序中错误的潜能。原则上，如果目标代码在保存元素值的同时保存了元素类型的信息，那么任何检查都可以动态地进行。一个健全(sound)的类型系统可以消除对动态类型检查错误的需要，因为它可以帮助静态地确定这些错误不会在目标程序运行的时候发生。如果编译器可以保证它接受的程序在运行时刻不会发生类型错误，那么该语言的这个实现就被称为强类型的。

除了用于编译，类型检查的思想还可以用于提高系统的安全性，使得人们安全地导入和执行软件模块。Java程序被编译为与机器无关的字节码，在字节码中包含了有关字节码中运算的详细类型信息。导入的代码在被执行之前首先要进行类型检查，防止疏忽或者恶意攻击。

#### 类型检查规则

类型检查有两种形式：综合和推导。**类型综合(type synthesis)**根据子表达式的类型构造出表达式的类型。它要求名字先声明在使用。表达式`E1 + E2`的类型根据`E1`和`E2`的类型定义的。一个典型的类型综合规则具有如下的形式

```
if f的类型为 s -> t 且x的类型为s。
then 表达式 f(x) 的类型为 t
```

这里，f和x表示表达式，而s -> t 表示从s到t的函数。这个针对单参数函数的规则可以推广到带有多个参数的函数。只要稍作修改，上述规则就可以用于`E1 + E2`，只需要把它看作一个函数应用`add(E1, E2)`就可以了。

**类型推导(type inference)**根据一个语言结构的使用方式来确定该结构的类型。令null是一个测试列表是否为空的函数。那么，根据这个函数的使用null(x)，可以指出x必须是一个列表类型。列表x中的元素类型是未知的，所知道的全部信息是：x是一个列表类型，其元素类型当前未知。

使用a和b作为类型表达式中的类型变量，一个典型的类型推导规则具有下面的形式

```
if f(x)是一个表达式
then 对某些a和b，f的类型为a->b且x的类型为a
```

把条件语句`if (E) S;`看作是对E和S应用if函数。令特殊类型void表示没有值的类型，那么if函数将被应用在一个布尔型和一个void型的对象上。此函数的结果类型是void。

#### 类型转换

考虑类似于`x + i`的表达式，其中x是浮点数，而i是整型。因为整数和浮点数在计算机中有不同的表现形式，而且使用不同的机器指令来完成整数和浮点数的运算。编译器需要把+的某个运算分量进行转换，以保证在进行加法运算时两个运算分量具有相同的类型。

假定必要的时候可以使用一个单目运算符(float)将整数转换成浮点数。例如，整数2在表达式`2 * 3.14`中被转换为浮点数。

```
t1 = (float) 2;
t2 = t1 * 3.14;
```

使用类型综合对表达式翻译进行扩展，如`E -> E1 + E2`，引入另外一个属性E.type，该属性的值可以是integer或float.

```
if (E1.type = integer and E2.type = integer) E1.type = integer;
else if (E1.type == float and E2.type == integer) ...
```

随着需要转换类型的增多，需要处理的不同情况也急剧增多。因此，在处理大量的类型时，精心组织用于类型转换的语义动作就变得非常重要。

不同语言具有不同的转换规则，如果类型转换由编译器完成，那么这样的转换就称为隐式转换。隐式转换也称为自动类型转换(coercion)。在很多语言中，自动类型转换仅仅限于拓宽转换。如果必须写出代码来完成类型转换，那么这个转换就称为显式转换。显示转换也称为强制类型转换(cast)。

检查`E = E1 + E2`的语义动作使用了两个函数：

1) max(t1, t2)接受t1和t2两个类型的参数，并返回拓宽层次结构中这两个类型中的最大者（或者最小上界）。如果t1或t2之一没有出现在这个层次结构中,比如有个类型是数组类型或者指针类型，那么函数返回一个错误信息。

2）如果需要将类型为t的地址a中的内容转换成w类型的值，则函数widen(a,t,w)将生成的类型转换的代码。如果t和w是相同的类型，则该函数返回a本身。否则，它会生成一条指令来完成转换工作并将转换结果放置到临时变量temp中。这个临时变量将作为结果返回。函数widen的伪代码如下式所示，这里假设只有integer和float两种类型。

```
Addr widen(Addr a, Type t, Type w)
    if (t == w)  return a;
    else if (t == integer and w == float) {
        temp = new Temp();
        gen(temp '=' '(float)' a);
        return temp;
    }
    else error;
```

在表达式求值中引入类型转换

```
E -> E1 + E2
{ E.type = max(E1.type, E2.type);
a1 = widen(E1.addr, E1.type, E.type);
a2 = widen(E2.addr, E2.type, E.type);
E.addr = new Temp();
gen(E.addr '=' a1 '+' a2); }
```

#### 函数和运算符的重载

依据符号所在的上下文不同，被重载(overloaded)的符号会有不同的意义。如果能够为一个名字的每次出现确定其唯一的含义。该名字的重载问题就得到了解决。在本节中，仅考虑那些只需要查看函数参数就能解决的函数重载。

重载函数的类型综合规则

```
if f可能的类型为 si->ti (1 <= i <= n)，其中，si != sj (i != j)
and x的类型为sk (1 <= k <= n)
then 表达式 f(x) 的类型为 tk
```

之前所述的值编码方法同样可以用于类型表达式，以便根据参数类型高效地解决重载问题。在表示类型表达式的一个DAG上，给每个结点赋予一个被称为值编码的整数序号。使用算法6.3，可以构造出每个结点的范型，该范型由该结点的标号及其从左到右的子结点的编码组成。一个函数的范围由其函数名和它的参数的类型组成。根据函数的参数类型解决重载的问题就等价于基于范型解决重载的问题。

仅仅通过查看一个函数的参数类型不一定能够解决重载的问题。在Ada中，一个子表达式会有一组可能的类型，而不是只有一个确定的类型。它所在的上下文必须提供足够的信息来缩小可选范围，最终得到唯一的可选类型。

#### 类型推导和多态函数

类推推导常常用于像ML这样的语言。ML是一个强类型语言，但是它不要求名字在使用前先进行声明。类推推导保证了名字使用的一致性。

术语“多态”指的是任何可以在不同的参数类型上运行的代码片段，首先考虑**参数多态(parametric polymorphism)**，这种多态通过参数和类型变量来刻划。该程序定义了一个函数length。函数length的类型可以描述为：对于任何类型a，length函数将元素类型为a的列表映射为整型。

```
fun length(x) = if null(x) then 0 else length(tl(x)) + 1;
```

在多态函数的各次应用中，函数的受限的类型变量可以表示成不同的类型。在类型检查中，每次使用多态类型时，将受限变量替换为新的变量。

例子：可以使用AST表示定义的length函数。这棵树根的标号为`fun`，它表示函数的定义。其他的非叶子结点可以看作是函数应用。标号为+的结点表示对两个子结点应用运算符+。类似地，标号为if的结点表示将运算符if应用于它的三个子结点组成的三元组上（对于类型检查，究竟是then分支还是else分支被求值并不是问题，不会被同时计算）。

可以根据函数length的函数体推导出它的类型。从左到右考虑标号为if的结点的子结点。因为null要被应用在列表上，所以x必须是一个列表。使用变量a作为列表元素类型的占位符，也就是说，x的类型为a的列表。

如果null(x)为真，则length(x)为0。因此，length的类型一定是“从a的列表到整型的函数”。这个推导得到的类型和在else分支length(tl(x))中对length的使用是一致的。

因为在类型表达式中可能出现变量，所以必须重新审视下一个类型等价的概念。设想将类型`s -> s'`的E1应用到类型为t的E2上。不能简单地确定s和t是否等价，而是必须将这两种类型“合一”。非正式地讲，将确定是否可以将类型变量s和t替换为特定的类型表达式，从而使得s和t在结构上等价。

**置换(subsititution)**是一个从类型变量到类型表达式的映射。把对类型表达式t中的变量应用置换S后得到结果写作S(t)。两个类型表达式t1和t2可以**合一(unify)**的条件是存在某个置换S使`S(t1) = S(t2)`。在实践中，感兴趣的是一般化的合一置换，这种合一置换对表达式中的变量施加的约束最少。

**置换，实例和合一**-如果t是一个类型表达式，且S是一个置换（即从一个类型变量到类型表达式的映射），那么用S(t)来表示将t中的每个类型变量a的所有出现替换为S(a)后得到的结果。S(t)被称为t的一个实例(instance)。例如，list(integer)是list(a)的一个实例，因为它是将list(a)中的a替换为integer后的结果。然而，请注意integer->float不是a->a的实例，因为置换必须将a的所有出现替换为相同的类型表达式。

对于类型表达式t1和t2，如果`S(t1) = S(t2)`，那么置换S就是一个**合一替换(unifier)**。如果对于t1和t2的任何合一替换，比如说S‘，下面的条件成立：对于任意的t，S‘(t)是S(t)的一个实例，那么就说S是t1和t2的**最一般化的合一替换(most general unifier)**。换句话说，S'对t施加的限制比S施加的限制更多。

算法6.10 多态函数的类型推导

```
输入：一个由一系列函数定义以及紧跟其后的待求值表达式组成的程序。一个表达式由多个函数应用和名字组成。这些名字具有预定义的多态类型。
输出：推导出的程序名中名字的类型。
方法：为简单起见，只考虑一元函数。对于带有两个参数的函数f(x1,x2)，可以将其类型表示为s1 * s2 -> t,其中s1和s2分别是x1和x2的类型，而t是函数f(x1,x2)的结果类型。通过检查s1是否和a的类型匹配，s2是否和b的类型匹配，就可以检查表达式f(a,b)的类型
```

检查输入序列中的函数定义和表达式。当一个函数在其后的表达式中被使用时，就使用推导得到的该函数的类型。

* 对一个函数定义`fun id1 (id2) = E`，创建一个新的类型变量a和b。将函数id1与类型a->b相关联，参数id2和类型a相关联。然后，推导出表达式E的类型。假设在对E进行类型推导之后，a表示类型s而b表示类型t。推导得到的函数id1的类型就是`s->t`。
* 对于函数应用E1(E2)，推导出E1和E2的类型。因为E1被用作一个函数，它的类型一定具有`s -> s'`的形式（从技术上来说，E1的类型必须和b->y合一，其中b和y是新的类型变量）。假定推导得到的E2的类型为
* 对一个多态函数的每次出现，将它的类型表达式中的受限变量替换为互不相同的新变量，并移除量词。替换得到的类型表达式就是这个多态函数的本次出现所对应的类型推导。
* 对于第一次碰到的变量，引入一个新的类型变量来表示它的类型。

#### 一个合一算法

非正式地讲，合一就是判断能否通过将两个表达式s和t中的变量替换为某些表达式，使得s和t相同。测试表达式是否等价是合一的一种特殊情况。如果s和t只有常量没有变量，则s和t合一当且仅当它们完全相同。

将实现一种基于图论表示方法的合一算法，其中类型被表示成图的形式。类型变量用叶子结点表示，类型构造算子用内部结点表示。结点被分成若干等价类。如果两个结点在同一个等价类中，那么它们代表的类型表达式就必须合一。因此，同一个等价类中的内部结点必须具有同样的类型构造算子，且它们的对应子结点必须等价。

例：考虑下列两个类型表达式

```
((a1 - a2) * list(a3) ) -> list(a2)
((a3 - a4) * list(a3) ) -> a5
```

下列的置换S是这两个表达式的最一般化的合一替换：

x|S(x)
-|-
a1|a1
a2|a2
a3|a1
a4|a2
a5|list(a2)

这个置换将上述两个类型表达式映射成如下的表达式`((a1 - a2) * list(a3) ) -> list(a2)`。

算法6.19 类型图中的一对结点的合一处理

```
输入：一个表示类型的图，以及需要进行合一处理的结点对m和n。
输出：如果结点m和n表示的表达式可以合一，返回布尔值。反之，返回false。
方法：结点用一个记录实现，记录中的字段用于存放一个二元运算符和分别选作这个类的唯一代表，它的set字段包含一个空指针。等价类中其他结点的set字段（可能通过该集合中的其他结点间接地)指向该等价类的代表结点。在初始时刻，每个结点n自身组成一个等价类，n是它自己的代表结点
```

如下面所示的合一算法在结点上进行如下两种操作：

* `find(n)`返回当前包含结点n的等价类的代表结点。
* `union(m, n)`将包含结点m和n的等价类合并。

```
boolean unify(Node m, Node n) {
    s = find(m); t = find(n);
    if (s == t) return true;
    else if (结点s和t表示相同的基本类型) return true;
    else if (s是一个带有子结点s1和s2的op-结点 and 
                t是一个带有子结点t1和t2的op-结点) {
        union(s, t);
        return unify(s1, t1) and unify(s2, t2);
    }
    else if (s 或者 t表示一个变量) {
        union(s, t);
        return true;
    }
    else return false;
}
```

集合的union操作的实现很简单，只需要改变一个等价类的代表结点的set字段，使之指向另一个等价类的代表结点即可。为了找到一个结点所属的等价类，沿着各个结点的set字段中的指针前进，直到到达代表结点(即set字段指针为空指针的结点)为止。

*注意：上述算法分别使用s = find(m) 和 s = find(n)，而不是直接使用m和n*。如果m和n在同一个等价类中，那么代表结点s和t相等。如果s和t表示相同的基本类型，则调用unify(m, n)返回true，如果s和t都是代表某个二目类型构造算子的内部结点，那么尝试合并它们的等价类，并递归地检查它们的各个子结点是否等价。因为首先进行合并操作，在递归地检查子结点之前减少了等价类的个数，因此算法终止。

将一个变量置换为一个表达式的实现方式如下：把代表该变量叶子结点加入到代表该表达式的结点所在的等价类。假设m和n表示一个一个变量的叶子结点，同时假设这个结点已经放入满足下面条件的等价类中，即这个等价类中的一个结点代表的表达式或者带有一个类型构造算子，或者是一个基本类型。那么，find将会返回一个反映该类型构造算子或基本类型的代表结点，使一个变量不会和两个不同的表达式合一。

### 控制流

if-else语句，while语句这类语句的翻译和对布尔表达式的翻译是结合在一起的。在程序设计语言中，布尔表达式经常被用来：

* **改变控制流**-布尔表达式被用作语句中改变控制流的条件表达式。这些布尔表达式的值由程序到达的某个位置隐含地指出。例如，在`if(E) S`中，如果运行到语句S，就意味着表达式E的取值为真
* **计算逻辑值**-一个布尔表达式的值可以表示为true或false。这样的布尔表达式也可以像算术表达式一样，使用带有逻辑运算符的三地址指令进行求值。

布尔表达式的使用意图要根据其语法上下文来确定。例如，跟在关键字if后面的布尔表达式用来改变控制流，而一个赋值语句右部的表达式用来表示一个逻辑值。有多种方式可以描述这样的上下文，可以使用两个不同的非终结符号，也可以使用继承属性，还可以在语法分析过程中设置一个标记。此外，还可以建立一棵语法分析树并调用不同的过程来处理布尔表达式的两种不同的使用。

#### 布尔表达式

布尔表达式是将由作用于布尔变量或关系表达式的布尔运算符而构成的。使用C语言的方法，用&&,||,!分别表示AND,OR,NOT运算符。关系表达式的形式为`E1 rel E2`。其中，E1和E2为算术表达式。在本节中，考虑的是由如下文法生成的布尔表达式：

```
B -> B || B | B && B | !B | (B) | E rel E | true | false
```

通过属性rel.op来指明rel究竟表示6种比较运算符<, <=, =, !=, >, >=中的哪一种。按照惯例，假设||和&&是左结合的，||和&&是左结合的，||的优先级最低，其次为&&，再其次为!。 

给定表达式`B1 || B2`，如果已经确定B1为真。那么不用再计算B2就可以断定整个表达式为真。同样地，给定`B1 && B2`，如果B1为假，则整个表达式为假。

程序设计语言的语义决定了是否需要对一个布尔表达式的各个部分求值。如果语言的定义允许(或要求)不对布尔表达式的某个部分求值，那么编译器就可以优化布尔表达式的求值过程，只要已经求值的部分足以确定整个表达式的值就可以了。因此，在表达式`B1 || B2`中，B1和B2都不一定完全地求值。如果B1或B2是具有副作用的表达式(比如它包含了改变一个全局变量的函数)，那么这么做就可能会得到意料之外的结果。

#### 短路代码

在短路(跳转)代码中，布尔运算符&&,||和!被翻译成跳转指令。运算符本身不出现在代码中，布尔表达式的值是通过代码序列中的位置来表示的。

语句`if (x < 100 || x > 200 && x != y)`被翻译为下面的代码

```
if x < 100 goto L2
if False x > 200 goto L1
if False x != y goto L1
L2: x = 0
L1:  
```

#### 控制流语句

现在考虑在按下列文法生成的语句的上下文中，如何把布尔表达式翻译成为如下三地址代码。

```
S -> if (B) S1
S -> if (B) S1 else S2
S -> while (B) S1
```

在这些产生式中，非终结符号B表示一个布尔表达式，非终结符号S表示一个语句。

这个文法将while表达式的连续使用的例子进行了推广。B和S有综合属性code，该属性给出了翻译得到了三地址指令。为简单起见，使用语法制导定义来构造得到的翻译结果B.code和S.code，结果值是字符串。定义了code属性的语义规则还可以按照下面的方法实现：首先构造语法树，并在遍历树的过程中产生目标代码。

对`if (B) S1`的翻译结果中包含了B.code，其后是S1.code。B.code中存在基于B值的跳转。如果B为真，控制流转向S1.code的第一条指令；如果B为假，控制流立即转向紧跟在S1.code之后的指令。

#### 布尔表达式的控制流翻译

一个布尔表达式B被翻译为一个三地址指令，它将使用条件或无条件跳转指令来对B求值。这些跳转指令的目标是两个标号之一：当B为真时是B.true;当B为假时是B.false

#### 避免生成冗余的goto指令

`if False`指令利用了控制流在指令序列中会从一个指令自然流动到下一个指令的性质，因此当x > 200时，控制流直接“穿越“到标号L4，从而减少了一个跳转指令。

*注意：在C和Java中，表达式中可能包含赋值语句，因此即使B.true和B.false都为full，也必须为子表达式E1和E2生成代码。如果必要，无用代码可以在优化阶段被清除*

#### 布尔值和跳转代码

本节讨论的重点是用于改变语句中控制流的布尔表达式。一个布尔表达式的目的可能就是要求出的它的值，如x=true；或x = a < b；的语句中的布尔表达式就是这样。

处理布尔表达式的这两种角色的一种简单思路首先建立表达式的抽象语法树，可以使用下面的两种方法之一：

* 使用两趟处理的方法。为输入构造出完整的抽象语法树AST，然后可以以深度优先顺序遍历这棵抽象语法树，依据语义规则的描述计算得到翻译结果
* 对语句进行一趟处理，但对表达式进行两趟处理。使用这种方法时，将首先翻译语句`while(E) S1`中的E，然后再处理S1。然而，要对E进行翻译，需要首先建立它的AST，然后才遍历它。

在下列文法中，使用单个非终结符E来代表表达式

```
S -> id = E; | if (E) S | while(E) S | S S
E -> E || E | E && E | E rel E | E + E | (E) | id | true | false
```

可以使用不同的代码生成函数处理表达式的这两种角色。假定属性E.n表示对应于表达式E的AST结点，并且AST中的结点都是对象。令方法jump产生一个表达式结点的跳转代码，并令方法rvalue产生计算结点的值的代码，该代码还把得到的值存储在一个临时变量中。

对于出现在`S -> while (E) S1`中的E，在结点E.n上调用方法jump。方法jump的实现是基于之前给出的关于布尔表达式的语义规则。确切地说，跳转代码是通过调用E.n.jump(t,f)生成的，其中t是指向S1.code的第一条指令的新标号，而f就是标号S.next。

对于出现在`S -> id = E`中的E，在结点E.n上调用方法rvalue。如果E形如`E1 + E2`，方法调用E
.n.rvalue()按照中讨论的方法生成代码。如果E形如`E1 && E2`，首先为E生成跳转代码，然后在跳转代码的真假出口分别将true和false赋给一个新的临时变量t。

例如，赋值语句`x = a < b && c < d`

```
ifFalse a < b goto L1
ifFalse c < d goto L1
t = true
goto L2
L1 : t = false
L2 : x = t
```

### 回填

为布尔表达式和控制流语句生成目标代码时，关键问题之一是将一个跳转指令和该指令的目标匹配起来。例如，对`if (B) S`中的布尔表达式B的翻译结果中包含一条跳转指令。当B为假时，该指令将跳转到紧跟在S的代码之后的指令处。在一趟式的翻译中，B必须在处理S之前就翻译完毕。那么跳过S的goto指令的目标是什么呢？在上一节中，解决这个问题的方法是将标号作为继承属性传递到生成相关跳转指令的地方。但是，这样的做法要求再进行一趟处理，将标号和具体地址绑定起来。

**回填**-把一个由跳转指令组成的列表以综合属性的形式进行传递。明确地讲，生成一个跳转指令时暂时不指定该跳转指令的目标。这样的指令都被放入一个由跳转指令组成的列表中。等到能够确定正确的目标标号时才去填充这些指令的目标标号。同一个列表中的所有跳转指令具有相同的目标标号。

#### 使用回填技术的一趟时式目标代码生成

回填技术可以用来在一趟扫描中完成对布尔表达式或控制流语句的目标代码生成。

非终结符号B的综合属性truelist和falselist将用来管理布尔表达式的跳转代码中的标号。特别地，B.truelist将是一个包含跳转或条件跳转指令的列表，必须向这些指令中插入适当的标号，也就是当B为真时控制流应该转向的标号。类似地，B.falselist也是一个包含跳转指令的列表，这些指令最终获得的标号就是当B为假时，控制流应该转向的标号。在生成B的代码时，跳转到真或者假出口的跳转指令是不完整的，标号字段尚未填写。这些不完整的跳转指令被保存在B.truelist和B.falselist所指的列表中。类似地，语句S的综合属性S.nextlist也是一个跳转指令列表，这些指令应该跳到紧跟在S的代码之后的指令。

更明确地讲，将生成的指令放入一个指令数组中，而标号就是这个数组的下标。为了处理跳转指令列表，使用下面三个函数：

* makelist(i)创建一个只包含i的列表。这里i是指令数组的下标。函数makelist返回一个指向新创建的列表的指针。
* merge(p1,p2)将p1和p2指向的列表进行合并，它返回的指针指向合并后列表。
* backpatch(p, i)将i作为目标标号插入到p所指列表中的各指令。

#### 布尔表达式的回填

现在构造一个可以在自底向上语法分析过程中为布尔表达式生成目标代码的翻译方案。这个文法中有一个标记非终结符号M。它引发的语义动作在适当的时刻获取将要生成的下一条指令的下标。该文法如下：

```
B -> B1 || M B2 | B1 && M B2 || B1 | (B1) | E1 rel E2 | true | false
M -> e
```

翻译方案

```
1) B -> B1 || M B2 {backpatch(B1.falselist.M.instr);
                    B.truelist = merge(B1.truelist, B2.truelist);
                    B.falselist = B2.falselist;}

2) B -> B1 && M B2 {backpatch(B1.truelist, M.instr);
                    B.truelist = B2.truelist;
                    B.falselist = merge(B1.falselist,B2.falselist);}

3) B -> !B1  {B.truelist = B1.falselist;
              B.falselist = B1.truelist;}

4) B -> (B1) {B.truelist = B1.falselist;
              B.falselist = B1.falselist;}

5) B -> E1 rel E2 {B.truelist = makelist(nextinstr);
                   B.falselist = makelist(nextinstr + 1);
                   gen('if', E1.addr rel.op E2.addr 'goto _');
                   gen('goto _')}

6) B -> true {B.truelist = makelist(nextinstr);
              gen('goto _');}

7) B -> false {B.falselist = makelist(nextinstr);
               gen('goto _');}

8) M -> e    {M.instr = nextinstr;}
```

考虑上述文法中对应于规则`B -> B1 || MB2`的语义动作(1)。如果B1为真，那么B也为真，这样B1.truelist中的跳转指令就成为B.truelist的一部分。然而，如果B1为假。下一步必须测试B2。因此，B1.falselist中的跳转指令的目标必定是B2的代码的起始位置。这个位置使用标记非终结符号M获得。在即将生成B2代码之前，M生成了下一条指令的序号，存放在综合属性M.instr中。

为了获得指令序号，将产生式`M -> e`和语义动作

```
M.instr = nextinstr;
```

关联起来。变量nextinstr保存了紧跟着的下一条指令的序号。当看到了产生式`B -> B1 || M B2`的余下部分时，这个值将被回填到B1.falselist中的指令上（即B1.falselist中的每条指令都把M.instr当作目标标号）。

`B -> B1 && M B2`的语义动作(2)和动作(1)类似。`B -> !B`的语义动作(3)的对换真假列表。动作(4)只是忽略括号

为简单起见，语义动作(5)生成了两条指令：一个条件转移指令goto和一个无条件转移指令。它们的目标标号都未填写。这两个指令被放入新的分别由B.truelist和B.falselist指向的列表中。

#### 控制转移语句

使用回填技术在一趟扫描中完成控制流语句的翻译。考虑由下列文法产生的语句

```
S -> if (B) S | if (B) S else S | while(B) S | {L} | A;
L -> L S | S
```

这里S表示一个语句，L是一个语句的列表，A是一个赋值语句，B是一个布尔表达式。请注意，一定还存在一些其他的产生式，比如那些关于赋值语句的产生式。然而，这里给出的这些产生式已经足以用来说明来控制流语语句的翻译中用到的技术。

语句if，if-else和while代码布局和之前描述的那样，给出一个隐含的假设，即指令数组中的代码顺序反映了控制流的自然流动，即控制从一条语句到达下一条语句。加入如果没有这个假设，那么就必须明确插入跳转指令来实现自然的顺序控制流。

下述的翻译方案保留了多个跳转指令列表，当确定了这些跳转指令的目标序号后就会回填列表。由非终结符号B生成的布尔表达式有两个跳转指令列表：B.truelist和B.falselist。它们分别对应于B的代码的真假出口。由非终结符号S和L生成的语句也有一个待回填的跳转指令列表，由属性nextlist表示。列表S.nextlist中包含了所有跳转按照运行顺序紧跟在S代码之后的指令的条件或无条件转移指令。L.nextlist的定义与此类似。

#### break语句，continue语句和goto语句

用于改变程序控制流的最基本的程序设计语言结构是goto语句。在C语言中，像goto L这样的语句将控制流跳转到标号为L的指令----在相应作用域内必须恰好存在一条标号为L的指令----在相应作用域内必须恰好存在一条标号为L的语句。

在实现goto语句时，可以为每个标号维护一个未完成跳转指令列表，然后在知道这些指令的目标之后进行回填。

Java废除了goto语句。但是Java支持一种规范化的跳转语句，即break语句。它使控制流跳出外围的语言结构。Java中还可以使用continue语句。这个语句的作用是触发外围循环的下一轮迭代。下面的摘自一个语法分析器，它说明了简单的break语句和continue语句。

```cpp
for (;;readch()) {
    if (peek == ' ' || peek == '\t') continue;
    else if (peek == '\n') line = line + 1;
    else break;
}
```

如果S表示外围的循环结构，那么一条break语句就是跳转到S代码之后的第一条指令处的跳转指令。可以按照下面的步骤为break生成代码：

* 跟踪外围循环语句S；
* 为该break语句生成未完成的跳转指令；
* 将这些指令放到S.nextlist中

是一个通过两趟扫描构建AST的编译器的前端中，S.nextlist可以被实现为对应于语句S的结点的一个字段，可以在符号表中将一个特殊的标识符break映射为表示外围循环语句S的结点，以此来跟踪S。这种方法同样可以处理java中带标号的break语句，因为同样可以用符号表来将这个标号映射为对应于标号所指的结构的语法树结点。

如果不使用符号表来访问S的结点，还可以在符号表中设置一个指向S.nextlist的指针。现在当遇到一个break语句时，生成一个未完成的跳转指令，并通过符号表查找到nextlist，然后把这个跳转指令加入到这个列表中。这个nextlist按照上节的方法进行回填。

continue语句的处理方法和break语句的处理方法类似。两者的主要区别在于生成的跳转指令的目标不同。

### switch语句

switch语句中包含一个待求值的选择表达式E，后面是该表达式可能取的n个常量值。语句中也可能默认包含一个默认值，当其他值都不和选择表达式值匹配时，就用这个默认值匹配。

#### switch语句的翻译

一个switch语句的预期翻译成果是完成如下工作的代码：

* 计算表达式的E的值
* 在case列表中寻找与表达式值相同的值Vj。回顾一下，当在case列表中明确列出的值都不和表达式匹配时，就用默认值和表达式匹配
* 执行和匹配值相关联的语句Sj

步骤2是一个n路分支，它可以采取多种方法实现。如果case的数目较少，比如不多于10个，那么可以使用一个条件跳转指令序列来实现。每一个条件跳转指令都测试一个常量值，并跳转到这个值对应的语句代码。

实现了这个跳转指令序列的一个简单的方法是创建一个对照关系表。表中的每一个关系都包含了一个常量值和相应语句代码的标号。在运行时刻，表达式自身的值以及默认语句的标号被放在对照表的末端。编译器生成一个简单循环，把表达式的值和表中的每个值进行比较。已经保证了当找不到其他匹配时，最后一个条目(默认值条目)一定会匹配。

如果值的个数超过10个或者更多，那么更高效的方式是为这些值构造一个散列表。这个表的条目是各个分支语句的标号。如果没有找到对应于switch表达式值的条目，就会有一条跳转指令转到默认语句。

还有一种常见的特殊情况，它的实现可以比n路分支更加高效。如果表达式的值位于某个较小的范围内，比如从min到max，并且不同常量值的总数接近max-min。那么可以构造一个包含max-min个“桶”的数组，其中桶j-min包含了了对应于值j的语句的标号，任何没有被填入对应标号的“桶”中包含了默认标号。

执行switch语句时，首先计算表达式并获得值j；检查它是否在min到max的范围之内。如是则间接跳转到偏移量为j-min的条目中的标号。例如，如果表达式的类型是字符型，可以创建一个包含128个条目（根据具体的字符集，条目个数可有不同）的表，并且不进行范围检查直接进行控制流跳转。

#### switch语句的语法制导翻译

下述代码是上述switch语句的一个近似翻译结果。所有测试都出现在代码的末端，因此一个简单的代码生成器就可以识别出多路分支。

```
     code to evaluate E into t
     goto test
L1 : code for S1
     goto next
L2 : code for S2
     goto next
     ...
Ln : code for Sn
     goto next
test:if t == V1 goto L1
     if t == V2 goto L2
     ...
     if t == Vn-1 goto Ln-1
     goto Ln
next:
```

下面显示了一个更直接的代码序列。它要求编译器进行更加深入的分析，才能找到最高效的实现。值得注意的是，在一趟式编译器中，将分支语句放在开始的位置会造成不便，因为编译器此时还没有碰到各个语句Si，无法生辰转向各个语句的代码。

```
     code to evaluate E into t
     if t != V1 goto L1
     code for S1
     goto next
L1 : if t != V2 goto L2
     code for S2
     goto next
L2 : 
     ...
Ln-1:code for Sn
next:
```

当编译器到达switch语句的末端时，已经可以生成n路分支代码了。读取值-标号对的队列，就可以生成形如下面的三地址语句序列。其中t是一个保存选择表达式E的值的临时变量，Ln为默认语句的标号。

指令case t Vi Li和之前的if t == Vi goto Li含义相同，但是case指令更加容易被最终的代码生成器探测到，从而对这些指令进行某种特殊处理。在代码生成阶段，根据分支的个数以及这些值是否在一个较小的范围内，这些case语句的序列可以被翻译成最高效的n路分支。

### 过程的中间代码

使用术语“函数”来表示带有返回值的过程，将简单讨论函数声明以及函数调用的三地址代码。在三地址代码中，函数调用被拆分为准备进行调用的参数求值，然后是调用本身。为简单起见，假定参数使用值传递的方式。

例：假定a是一个整数数组，并且f是一个从整数到整数的函数，那么赋值语句`n = f(a[i]);`可以被翻译成如下的三地址代码：

```
1) t1 = i * 4
2) t2 = a[t1]
3) param t2
4) t3 = call f, 1
5) n = t3
```

前两行计算表达式`a[i]`的值，并将结果存放到临时变量t2中，第3行将t2作为实在参数用于第4行对f的调用。这个调用只带有一个参数。第4行中函数的调用的返回值被赋值为t。第5行将返回值赋给n。

下面的产生式可以生成函数定义和函数调用。非终结符号D和T分别生成声明和类型。由D生成的函数定义包含了关键字define，返回类型，函数名，括号中的形式参数以及由一个位于花括号中语句组成的函数体。非终结符号F生成0个或多个形式参数，每个形式参数包括一个类型和一个标识符。非终结符号S和E分别生成语句和表达式。S的产生式增加了一条返回表达式值的语句。E的产生式中增加了函数调用，调用中的实在参数由A生成。一个实在参数就是一个表达式。

```
D -> define T id  (F) {S}
F -> e  | T id, F
S -> return E;
E -> id (A)
A -> e | E, A
```

函数定义和调用可以用已经介绍过的概念进行翻译。

* **函数类型**-一个函数类型必须包含它的返回值类型和形式参数类型。令void是一个表示没有参数或没有返回值的特殊类型。因此，返回一个整数的函数pop()的类型是“从void到integer的函数”。函数类型可以在返回值类型和有序的参数类型列表上应用构造算子fun来表示。
* **符号表**-设编译器处理到一个函数定义时，最上层的符号表为s。函数名被放入s，以便在程序的其他部分使用。函数的形式参数可以用于类似记录字段名的方式来处理。在D的产生式中，在看到关键字define和函数名后，将s压入栈并建立新的符号表。
* **类型检查**-在表达式中，一个函数和运算符的处理方法相同。
* **函数调用**-当为一个函数调用id(E, E,..., E)生成三地址指令时，只需要对生成对各个参数E求值的三地址指令，或者生成各个参数E归约为地址的三地址指令，然后再为每个参数生成一条param指令即可。

### 第六章总结

* **选择一个中间表达式形式**-中间形式的表达形式通常是一个图形表示方法和三地址代码的组合。比如在语法树中，图中的结点表示一个程序构造；而各个子结点表示其子构造。三地址代码的名字源于它的`x = y op z`的形式。每条指令至多有一个运算符。另外还有一些用于控制流的三地址指令。
* **翻译表达式**-通过在各个形如`E -> E1 op E2`的产生式中加入语义动作，带有复杂运算的表达式可以被分解成一个由单一运算组成的序列。这些动作或者创建一个E的结点，此结点的子结点为E1和E2；或者生成一条三地址指令，该指令对E1和E2的地址应用运算符op，并将其运算结果放入一个临时变量中。这个临时变量就成了E的地址。
* **检查类型**-一个表达式`E1 op E2`的类型是由运算符`op`以及`E1`和`E2`的类型决定的。自动类型转换(coercion)是指隐式的类型转换，例如从integer转换到float。中间代码中还包含了显式的类型转换，以保证运算分量的类型和运算符的期待类型精确匹配。
* **使用符号表来实现声明**-一个声明指定一个名字的类型。一个类型的宽度是指存放该类型的变量所需要的存储空间。使用宽度，一个变量在运行时刻的相对地址可以计算为相对于某个数据区域的开始地址的偏移量。每个声明都会将一个名字的类型和相对地址放入符号表，这样当这个名字后来出现在一个表达式中时，翻译器就可以获取这些信息。
* **将数组扁平化**-为实现快速访问，数组元素被存放在一段连续的空间内，数组的数组可以被偏平化，当作各元素一维数组进行处理。数组的类型用于计算一个数组元素相对于数组基地址的偏移量。
* **为布尔表达式产生跳转代码**-在短路（或者说跳转）代码中，布尔表达式的值被隐含在代码所到达的位置中。因为布尔表达式B常常被用于决定控制流，例如在if(B) S中就是这样，因为跳转指令是有用的。只使得程序正确地跳转到代码`t = true`或`t = false`处，就可以计算出布尔值，其中的t是一个临时变量。使用跳转标号，通过继承对应于一个布尔表达式的真假出口的标号，就可以对布尔表达式进行翻译。常量true和false分别被翻译成跳转到真值出口和假值出口的指令。
* **用控制流实现语句**-通过继承next标号就可以实现语句的翻译，其中next标记了这个语句的代码之后的第一条指令。翻译条件语句`S->if (B) S1`时，只需要将一个标记了S1的代码起始位置的新标号和S.next分别作为B的真值出口和假值出口传递给其他处理程序。
* **可以选择使用回填技术**-回填是一种为布尔表达式和语句进行一趟式代码生成的技术。其基本思想是维护多个由不太完整跳转指令组成的列表，在同一列表中的指令具有同样的跳转目标。当目标位置已知时，将为相应列表中的所有指令填入这个目标。
* **实现记录**-记录或类中的字段名可以当作声明序列进行处理。一个记录类型包含了关于它的各个域类型和相对地址的信息。可以使用一个符号表对象来实现这个目的。

## 第七章：运行时环境

编译器必须准确地实现源程序语言中包含的各个抽象概念，包括名字，作用域，绑定，数据类型，运算符，过程，参数以及控制流构造。编译器还必须和操作系统以及其他系统软件协作，在目标机上支持这些抽象概念。

为了完成上述功能，编译器创建并管理一个运行时刻环境(run-time environment)，它编译得到的目标程序就运行在这个环境中。这个环境处理很多事物，包括为在源程序中命名的对象分配和安排存储位置，确定目标程序的访问变量时使用的机制，过程间的连续，参数传递机制，以及与操作系统，输入输出设备及其他程序的接口。

### 存储组织

对于编译器而言，正在执行的目标程序在它自己的逻辑地址空间内运行，其中每个程序值都在这个空间有一个地址。对这个逻辑地址空间的管理和组织是由**编译器**，**操作系统**和**目标机**共同完成。操作系统将逻辑地址映射为物理地址，而物理地址对整个内存空间。

一个目标程序在逻辑地址空间的运行时刻映像包含数据区和代码区。另外还包括堆区，栈区以及空闲内存。假定运行时刻存储是以多个连续字节块的方式出现的，其中字节是内存的最小编址单元。一个字节包含8个二进制位，4个字节构成一个机器字。多字节数据对象总是存储在一段连续的字节中，并把第一个字节作为它的地址。

一个名字所需要的存储空间大小是由它的类型决定的。基本数据类型，比如字符，整数或浮点数，可以存储在整数个字节中。聚合类型（比如数组或结构）的存储空间大小必须足以存放这个类型的所有分量。

数据对象的存储布局受目标机的寻址约束影响很大。在很多机器中，执行整数加法的指令可能要求整数是对齐的，也就是说这些数必须被放在一个能够被4整除的地址上。尽管在C语言或者类似的语言中一个有10个字符的数组只需要能够存放10个字符的空间，但是编译器可能为了对齐而给它分配的12个字节，其中的两个字节未使用。因为对齐的原因而产生的闲置空间称为补白。如果空间比较紧张，编译器可能会压缩数据以消除补白。但是在运行时刻可能需要额外的指令来定位被压缩数据，使得机器在操作这些数据时就好好像是对齐的。

生成的目标代码的大小在编译时刻就已经确定下来了，因此编译器可以将执行目标代码放在一个静态确定的区域：代码区，这个区通常位于存储的低端。类似地，程序的某些数据对象的大小可以在编译时刻知道，它们可以被放置在另一个称为静态区的区域中，该区域可以被静态确定。放置在这个区域的数据对象包括全局常量和编译器产生的数据，比如用于支持垃圾回收的信息等。之所以要将尽可能多的数据对象进行静态分配，是因为这些对象的地址可以被编译到目标代码中。

为了将运行时刻的空间利用率最大化，另外两个区域----栈和堆被放在剩余地址空间的相对两端。这些区域是动态的，它们的大小会随着程序运行而改变。这两个区域根据需要向对方增长。栈区用来存放称为活动记录的数据结构，这些活动记录在函数调用过程中生成。

在实践中，栈向较低地址方向增长，而堆向较高地址方向增长。然而，将假定栈向较高地址方向增长，以便能够在所有例子中方便地使用正的偏移量。

一个活动记录用于在一个过程中调用发生时记录有关机器状态的信息，例如程序计数器和机器寄存器的值。当控制从该次调用返回时，相关寄存器的值被恢复，程序计数器被设置成指向紧跟在这次调用之后的点，然后调用过程的活动就可以重新开始。如果一个数据对象的生命周期包含在一次活动的生命期中，那么该对象可以和其他关于该活动的信息一起被分配到栈区上。

C语言中的malloc和free函数可以用来获取及释放任意存储块。堆区被用来管理这种具有长生命周期的数据。

**静态和动态存储分配**

数据在运行时刻中的内存位置的布局及分配是存储管理的关键问题。这些问题需要谨慎对待，因为程序文本中的同一个名字可能在运行时刻指向不同的存储位置。两个形容词静态(static)和动态(dynamic)分别表示编译时刻和运行时刻。如果编译器只需要通过观察程序文本即可作出某个存储分配决定，而不需要观察该程序在运行时刻做了什么，就认为这个存储分配决定是静态的。反过来，如果只有在程序运行时才能作出决定，那么这个决定就是动态的。很多编译器使用下列两种策略的某种组合进行动态存储分配。

* **栈式存储**-一个过程的局部名字在栈中分配空间，
* **堆存储**-有些数据的生命周期要比创造它的某次过程调用更长，这些数据通常被分配在一个可复存储的“堆”中。堆是虚拟内存的一个区域，它允许对象或其他数据元素在被创建时获得存储空间，并在数据变得无效时释放该存储空间。

为了支持堆区管理，通过“垃圾回收”使得运行时刻系统能够检测出无用的数据元素，即使程序员没有显式地释放它们的空间，运行时刻系统也能够复用这些存储。尽管自动垃圾回收机制是一个难以高效完成的操作，但是它仍是很多现代程序设计语言的一个重要特征。对于某些语言来说，垃圾回收机制甚至是不可能完成的。

### 空间的栈式分配

有些语言使用过程，函数或方法作为用户自定义动作的单元，几乎所有针对这些语言的编译器都把它们的(至少一部分)运行时刻存储按照一个栈进行管理。每当一个过程被调用时，用于存放该过程的局部变量的空间被压入栈；当这个过程结束时，该空间被弹出这个栈。这种安排不仅允许活跃时段不交叠的多个过程调用之间的共享空间，而且允许以如下方式为一个过程编译一个代码：它的非局部变量的相对地址总是固定的，和过程调用的序列无关。

#### 活动树

假如过程调用(或者说过程的活动)在时间上不是嵌套的，那么栈式分配就不可行了，比如快速排序的例子。

在活动树和程序行为之间存在下列多种有用的对应关系，正是因为这些关系使我们可以使用运行时刻栈：

* 过程调用的序列和活动树的前序遍历相对应。
* 过程返回的序列和活动树的后序遍历相对应。
* 假定控制流位于某个过程的特定活动中，且该过程活动对应于树上的某个结点N。那么当前尚未结束的(即活跃的)活动就是结点N及其祖先结点对应的活动。这些活动被调用的顺序就是它们在从根结点到N的路径上的出现顺序。这些活动将按照这个顺序的反序返回。

#### 活动记录

过程调用和返回通常由一个称为**控制栈(control stack)**的运行时刻栈进行管理。每个活跃的活动都有一个位于这个控制栈的**活动记录(activation record)**，有时也称为**帧(frame)**，活动树的根位于栈底，栈中全部活动记录的序列对应于在活动树中到达当前控制所在的结点的路径，程序控制所在的活动记录位于栈顶。

一个概括性的活动记录

```
实在参数
返回值
控制链
访问链
保存的机器状态
局部数据
临时变量
```

#### 调用代码序列

实现过程调用的代码被称为**调用代码序列(calling sequence)**。这个代码序列为一个活动记录在栈中分配空间，并在此记录的字段中填写信息。**返回代码序列(return sequence)**是一段类似的代码，它恢复机器状态，使得调用过程能够在调用结束之后继续执行。

即使对于同一种语言，不同实现中的调用代码序列和活动记录的布局也可能千差万别。一个调用代码序列中的代码通常被分割到调用过程(调用者)和被调用过程(被调用者)中。在分割运行时刻任务时，调用者和被调用者不存在明确分别界限。源语言，目标机器，操作系统会提出某些要求，使得能够选择出一种较好的分割方案。总的来说，

在设计调用代码序列和活动记录的布局时，可以使用下列的原则：

* 在调用者和被调用者之间传递的值一般被放在调用者的活动记录的开始位置，因此它们尽可能地靠近调用者的活动记录。
* 固定长度的项被放在中间位置
* 那些早期不知道大小的项将被放置在活动记录的尾部。
* 必须小心地确定栈顶指针所指的位置。

例：调用者和被调用者如何合作管理调用栈。寄存器`top_sp`指向当前的顶层活动记录中的机器状态字段的末端。调用者知道这个位于被调用者的活动记录中的位置。因此，调用者可以负责在控制转向被调用者之前设定的`top_sp`值。这个调用代码序列，以及在它调用者和被调用者之间的划分描述如下：

* 调用者计算实在参数的值
* 调用者将返回地址和原来的`top_sp`值存放到被调用者的活动记录中。然后调用者增加`top_sp`的值。也就是说，`top_sp`越过了调用者的局部数据和临时变量以及被调用者的参数和机器状态字段
* 被调用者保存寄存器值和其他状态信息
* 被调用者初始化其局部数据并开始执行

#### 栈中的变长数据

运行时刻存储管理系统必须频繁地处理某些数据对象的空间分配，这些数据对象的大小在编译时刻未知，但是它们是这个过程的局部对象，因而可以被分配在运行时刻栈中。在现代程序语言中，在编译时刻不能决定大小的对象将被分配在堆区。不过也可以将未知大小的对象，数组以及结构分配在栈中。

尽可能将对象放置在栈区的原因是我们可以避免对它们的空间进行垃圾回收，也就减少了相应的开销。注意，只有一个数据对象局限于某个过程，当且此过程结束时它变得不可访问，才可以使用栈为这个对象分配空间。

为变长数组(及其大小依赖于被调用过程的一个或多个参数值的数组)分配空间的一个常用策略。同样的方案可以用于任何类型的对象分配，只要它们对被调用的过程而言是局部的，并且其大小依赖于该次调用的参数即可。

策略：过程p有三个局部数组，假设它们的大小无法在编译时刻确定。尽管这些数组的存储出现在栈中，它们并不是p的活动记录的一部分。只有指向各个数组的开始位置的指针存放在活动记录中。因此当p执行时，这些指针的位置相对于栈顶指针的偏移量是已知的，因而目标代码可以通过这些指针访问数组元素。策略中还给出了一个被p调用的过程q的活动记录。q的这个活动记录从p的数组之后开始，q的所有变长数组被分配在q的活动记录之外。

对栈中数据的访问通过指针`top`和`top_sp`完成。这里，top标记了实际的栈顶位置，它指向下一个活动记录将开始的位置，第二个指针`top_sp`用来找到栈顶活动记录的局部字长字段。将假定`top_sp`指向机器状态字段的末端。`top_sp`指向q的活动记录的机器状态字的末端。可以找到q的控制链字段，根据这个字段可以知道当p位于栈顶时，top_sp所指的p的活动记录中的位置。

重新设置`top`和`top_sp`所指向位置的代码可以在编译时刻生成。这些代码根据将根据在运行时刻获知的记录大小来计算`top`和`top_sp`的新值。当q返回时，可以根据q的活动记录中被保存的控制链来恢复`top_sp`的值。`top`的新值等于（未经恢复的原来的）`top_sp`值减去q的活动记录中的机器状态，控制链，访问链，访问值，参数字段的总长度。调用者可以在编译时刻知道这个长度，尽管当调用参数的个数可变时，它仍取决于调用者(如果调用q的参数个数可变)。

### 栈中非局部数据的访问

尤其重要的的是要找到在过程p中被使用但又不属于p的数据的机制。对于那些在过程中声明其他过程的语言，这种访问将变得更加复杂。因此，首先从C函数这种简单情况开始，然后介绍另一种语言ML，该语言支持嵌套的函数声明，并支持将函数看成是“一阶对象”。也就是说，函数可以将函数作为参数，并把函数当做值返回。通过修改运行时刻栈的实现方法就可以支持这种能力。

#### 没有嵌套过程时的数据访问

在C系列语言中，各个变量要么在某个函数内定义，要么在所有函数之外(全局地)定义。最重要的是，不可能声明一个过程使其作用域完全位于另一个过程之内。反过来，一个全局变量v的作用域包含了在该变量声明之后出现的所有函数，但那些存在标识符v的局部定义的地方除外。在一个函数内部声明的变量的作用域就是这个函数。如果该函数具有嵌套的语句块，这个变量的作用域可能是该函数的部分区域。

对于不允许声明嵌套过程的语言而言，变量的存储分配和访问这些变量是比较简单的：

* 全局变量被分配在静态区。这些变量的位置保持不变，并且在编译时刻可知。因此要访问当前正在运行的过程的非局部变量时，可以直接使用这些静态确定的地址。
* 其他变量一定是栈顶活动的局部变量。可以通过运行时刻栈的`top_sp`指针来访问这些变量。

对于全局变量进行静态分配的一个好处是，被声明的的过程可以作为参数传递，也可以作为结果返回，实现这样的传递不需要对数据访问策略做出本质的改变。使用C语言的静态作用域规则且不允许使用嵌套过程声明时，一个过程的任何非局部变量也是所有过程的非局部变量，不管这些过程是如何被激活的。类似地，如果一个过程作为结果返回，那么任何非局部的变量都指向为该变量静态分配的存储位置。

#### 和嵌套过程相关的问题

当一种语言允许嵌套地声明过程并且仍然遵循通常的静态作用域规则时，数据访问变得比较复杂。也就是说，根据描述的针对语句块的嵌套作用域规则，一个过程能够访问另一个变量，只要最后一个过程的声明包含了前一过程的声明即可。其原因在于，即使在编译时刻知道p的声明直接嵌套在q之内，并不能由此确定它们的活动记录在运行时刻的相对位置。实际上，因为p或q或者两者都可能是递归的，在栈中可能有多个p和/或q的活动记录。

作为一个内嵌过程p中的一个非局部名字x找出对应的声明是一个静态的决定过程，将块结构的静态作用域进行扩展就可以解决这个问题。假定x在一个外围过程q中声明。根据p的一个活动找到相关q的活动则是一个动态的决定过程，它需要额外的有关活动的运行时刻信息。这个问题的可能解决方案之一是使用“访问链”。

#### 一个支持嵌套过程声明的语言

在C语言系列中，还有很多常见的语言不支持嵌套的过程，因此介绍一种支持嵌套的过程的语言。在语言中支持嵌套过程的历史比较长。Alogl 60 就具备这种能力。Alogl 60的后继Pascal(一个一度很流行的数学语言)也支持嵌套过程。在较晚的支持嵌套的过程语言中，最有影响力的语言之一是ML。将通过这个语言的语法和语义进行相关介绍。

* ML是一种函数式语言(functional language)，这意味者变量一旦被声明并初始化就不会再改变。其中只有少数几个例外，比如数组的元素可以通过特殊的函数调用改变。
* 定义变量并设定它们不可更改的初始值的语句具有如下形式`val <name> = <expression>`
* 函数使用如下语法定义`fun <name> (<arguments>) = <body>`
* 使用下列形式的let语句来定义整个函数体`let <list of definitions> in <statements> end`

其中，定义(definition)通常是val或fun语句。每个这样的定义的作用域包括从该定义之后直到in为止的所有定义，以及直到end为止的所有语句。最重要的是，函数可以嵌套的定义。例如，函数p的函数体可能包括一个let语句，而该语句又包含了另一个(嵌套的)函数q定义。类似地，q自身的函数体中也可能有函数定义，这就形成了任意深度的函数嵌套。

#### 嵌套深度

对于不内嵌在任何其他过程中的过程，设定其**嵌套深度(nesting depth)**为1。例如，所有的C函数的嵌套深度为1。然而，如果一个过程p在一个嵌套深度为i的过程中定义，那么设定p的嵌套深度为i+1。

ML的更多特性(ML几乎是纯函数式的语言)

* ML支持高阶函数(high-order function)。也就是说，一个函数可以将函数作为参数，并且能够构造并返回其他函数。而这些函数又可以将函数作为参数。从而构造出任何层次的函数
* ML本质上没有像C中for和while语句那样的迭代语句，而是通过递归来达到的循环的效果。这种方法在一个函数式语言中是非常重要的，因为不能改变迭代过程中的值
* ML将列表和带标号的树结构作为其基本数据类型
* ML不需要声明变量的类型。准确地说，在编译时刻推导出类型，并且当它不能推导出结果时就将其作为错误处理。例如，`val x = 1`显然使得x具有整数类型，并且如果还看到`val y = 2 * x`，就知道y也是一个整数

#### 访问链

针对嵌套函数的通常的静态作用域规则的一个直接方法是在每个活动记录中增加一个被称为**访问链(access link)**的指针。如果过程p在源代码中直接嵌套在过程q中，那么p的任何活动中的访问链形成了一条链路，它从栈顶活动记录开始，经过嵌套深度逐步递减的活动序列。沿着这条链路找到的活动就是其数据和对应过程可以被当前正在运行的过程访问的所有活动。

假定栈顶的过程p的嵌套深度是n且p需要访问x，而x是在某个包围p的嵌套深度为n的过程q中定义的一个元素。为了找到x，从位于栈顶的p活动记录开始，沿着访问链进行n次从一个活动记录到另一个活动记录的查找，最终找到q的活动记录。这一定是当前出现在在中的最近(即最高)的q活动记录。这个活动记录中包含了要找的元素x。因为编译器知道活动记录的布局，所以我们可以根据最后一个访问链找到q的活动记录中的某个位置，而x就位于和这个位置具有某个固定偏移量的位置上。

#### 处理访问链

当一个过程调用另一个特定的过程时，而被调用过程的名字在此次调用中明确给出，那么处理方法就很简单。更复杂的情况是调用的对象是一个过程型参数的时候。在那种情况下，要在运行时刻才能知道被调用的是哪个过程，因此在这个调用的不同执行中，被调用过程de嵌套深度可能有所不同。

* 过程p的嵌套深度大于q的嵌套深度，那么p一定是直接在q中定义的，否则q调用p的位置就不可能位于过程名p的作用域内。
* 这个调用是递归的，也就是说p=q。那么，新的活动记录的访问链和它下面的活动记录的访问链是相同的。
* p的嵌套深度np小于nq的嵌套深度nq。为了使q中的调用位于名字p的作用域中，过程q必定嵌套在某个过程中r，而p是一个直接在r中定义的过程。

#### 过程型参数的访问链

当一个过程p作为参数传递给另一个过程q，并且q随后调用了这个参数（因此也就在q的这个活动调用了p），有可能q并不知道p在程序中出现时的上下文。如果是这样，q就不可能知道如何为p设定访问链。这个问题的解决方案如下，当过程调用作为参数的时候，调用者除了传递过程参数的名字，同时还需要传递这个参数对应的正确的访问链。

调用者总是知道这个访问链，因为如果p被过程r当作一个实在参数传递，那么p必然是一个被r访问的名字。因此，r可以像直接调用p那样为p确定访问链条。

#### 显示表

使用访问链的方法来访问非局部数据的问题之一是，如果嵌套的深度变大，就必须沿着一段很长的访问链路才能找到需要的数据。一个更高效的实现方法是使用一个称为显示表(display)的辅助数组d，为每个嵌套深度保存了一个指针，设法使得在任何时刻，指针`d[i]`指向栈中最高的对应于某个嵌套深度为i的过程的活动记录。

使用显示表的优势在于如果过程p正在运行，且它需要访问某个属于过程q的元素x，那么只需要查看`d[i]`即可。其中，i是q的嵌套深度。沿着指针`d[i]`找到q的活动记录，根据已知的偏移量就可以在这个活动记录中找到x。编译器知道i的值，因此它可以产生代码，该代码根据`d[i]`和x相对于q的活动记录顶部的偏移量来访问x。因此，该代码不需要经过一段很长的访问链路。

### 堆管理

堆是存储空间的一部分，被用来存储那些声明周期不确定，或者即将到生存到被程序显式删除为止的数据。虽然局部变量通常在它们所属的过程结束之后就变得不可访问，但很多语言支持创建某种对象或者其他数据，它们的存在与否和创建它们的过程无关。例如C++和Java语言都为程序员提供了new语句。该语句创建的对象可以在过程之间进行传递，因此这样的对象在创建它们的过程结束之后仍然可以长期存在，这样的对象被放在堆区。

**存储管理器(memory manager)**，即分配和回收堆区空间的子系统。它是应用程序和操作系统之间的一个接口。对于C或是C++这样的手动回收存储块的语言（即通过程序中的显式语句，比如free或者delete进行回收）。存储管理器还负责实现空间的回收。

**垃圾回收**，即在堆区中找到那些不再被程序使用，因此可以被重新分配以便存放其他数据项的空间的过程。对于Java这样的语言，内存的回收是由垃圾回收器完成的。在需要进行垃圾回收时，垃圾回收器是存储管理器的一个重要子系统。

#### 存储管理器

存储管理器总是根据堆区中的空闲时间。它具有两个基本的功能：

* **分配**-当程序为一个变量或对象请求内存时，存储管理器产生一段连续的具有被请求大小的堆空间。如果有可能，使用堆中的空闲空间来满足分配请求；如果没有被请求大小的空间块可供分配，试图从操作系统中获得连续的虚拟内存来增加堆区的存储空间。如果空间已经用完，存储管理器将空间耗尽的信息传回给应用程序。
* **回收**-存储管理器把被回收的空间返还到空闲空间的缓冲池中，这样它可以复用该空间来满足其他的分配请求。存储管理通常不会将内存返回给操作系统，即使当这个程序不再需要那么多的堆空间时也不会归还给操作系统。

如果下面的(a),(b)两个条件都成立，内存的管理就会简单：(a) 所有分配请求都要求相同大小的存储块，(b) 存储空间按照可预见的方式被释放，比如先分配先回收。对于有些语言而言条件a成立。纯的Lisp语言只使用一种数据元素----一个双指针单元，所有的数据结构都在该元素的基础上构建。条件b在某些情况下也可能成立，最常见的情况是可以在运行时刻栈中分配的数据。然而，对于大部分的语言而言，这两个条件一般都不成立。相反地，需要为不同大小的数据元素分配空间，并且没有好的方法可以预测所有已分配对象的声明周期。

因此，存储管理器必须准备以任何顺序来处理任何大小的空间分配和回收请求。这些请求小到一个字节，大到该程序的整个地址空间：

下面是期望存储管理器具有的特性：

* **空间效率**-存储管理器应该能够使一个程序所需的堆区空间的总量达到最小。
* **程序效率**-存储管理器应该充分利用存储子系统，使程序可以更快。
* **低开销**-因为存储分配和回收在很多程序中是常用的操作，因此使得这些操作尽可能地高效是非常重要的。

#### 一台计算机的存储层次结构

存储管理和编译器优化必须在充分了解存储行为的基础上完成的。现代机器的设计使得程序员不需要考虑内存子系统的细节就能写出正确的程序。然而，程序的效率不仅取决于被执行指令的数量，还取决于每条被执行指令所花的时间。

内存访问时间上的巨大差异源于硬件技术的根本性局限，可以制造出一个小而快的存储器件或大而慢的存储器件，但是无法制造出既快又大的存储器件。现代计算机都以**存储层次结构(memory hierarchy)**的方式安排他们的存储。

一个处理器通常具有少量存储器，寄存器中的内容由软件控制。它具有一层或多层高速缓存，这些高速缓存通常使用静态RAM制造，其大小从几千字节到几兆字节不等。层次结构中的下一层是物理(主)内存，由数百兆到几千兆的动态RAM构成。物理内存由下一层的虚拟内存提供支持，虚拟内存由几千兆字节的磁盘实现。在一次内存访问中，机器首先在最近(最底层)的存储中寻找数据，如果数据不在那里则到上一层中寻找。以此类推。

寄存器个数很少，因此寄存器的使用会根据特定应用进行裁剪，并由编译器生成的代码进行管理。存储层次结构中的所有其他层都是自动管理的。这样做不仅简化了编程任务，并且相同的程序可以在不同存储配置的机器上高效工作。对于每次存储访问，机器从最底层开始逐层搜索每一层存储，直到找到数据为止。高速缓存是完全通过硬件进行管理的，这么做是为了能够跟上较快的RAM访问时间。因为磁盘访问速度较慢，虚拟内存是由操作系统进行管理的，辅以一个称为“转换旁视缓冲”的硬件结构。

数据以连续存储块的方式进行传输。为了分摊访问的开销，内存层次结构中较慢的层次通常使用较大的块。在主存和高速缓存之间的数据是按照被称为**高速缓存栈(cache line)**的块进行传输的，高速缓存栈的长度通常在32~256字节之间。在虚拟内存(硬盘)和主内存之间的数据是以被称为“页(page)”的内存块进行传输的，页的大小通常在4~64KB之间。

#### 程序中的局部性

大部分程序表现出高度的**局部性(locality)**，也就是说，程序的大部分运行时间花费在相对较小的一部分代码中，此时他们只涉及少部分数据，如果一个程序访问的存储位置很可能将在一个很短的时间段内被再次访问，就说这个程序具有**时间局部性(temporal locality)**。如果被访问过的存储位置的临近位置很可能在一个很短的时间段内被访问，就说这个程序具有**空间局部性(spatial locality)**

通常认为程序把90%的时间用来执行10%的代码，原因如下：

* 程序经常包含很多从来不会执行的指令
* 在程序的一次典型运行中，可能被调用的代码中只有很小一部分会被实际执行
* 通常的的程序往往将大部分时间花费在执行程序中的最内存循环和最紧凑的递归上

**静态的和动态的RAM**

大部分随机访问的内存是**动态的(dynamic)**，这意味着它们由简单的电子电路构成的。这些电路会在短时间内丢失电位。这些电路需要刷新，既读出然后重新写入它们的比特。另一方面，在**静态(static)**RAM的设计中，每个比特都需要一个复杂的电路，结果是存储在其中的比特可以保持任意长的时间，直到它们被改写为止。一个芯片使用动态RAM电路可以比使用静态RAM电路存储更多的比特。因此通常会看到动态RAM类型的大容量主存，而像高速缓存这样的较小存储则使用静态电路构造。

局部性使得我们可以充分利用现代计算机的存储结构。将最常用的指令数据放在快而小的存储中，而将其余部分放入慢而大的存储中，就可以显著降低一个程序的平均存储访问时间。

和数据的访问上既表现出时间局部性，又表现出空间局部性。然而，数据访问模式通常比指令访问模式表现出更大的多样性。将最近使用的数据存放在最快的存储层次中的策略可以在普通程序中发挥很好的作用，但是在某些数据密集型程序中的作用并不明显，比如循环遍历非常大的数组。

**高速缓存体系结构**

逐个检查高速缓存中的每一条高速缓存线过于费时，因此在实践中常常会限制一条高速缓存线在高速缓存中存放的位置。这个约束称为**成组相关性(set associativity)**。如果在一个高速缓存中，一条缓存线只能被放在k个位置上，那么这个高速缓存就称为**k路成组相关的(k-way set associative)**。最简单的高速缓存是1路相关高速缓存，它也称为**直接映射高速缓存**，存储地址为n的数据只能够放在缓存地址`n mod s`上，其中s是这个高速缓存的大小。类似地，一个k路成组相关高速缓存被分为k个集合，而一个地址为n的数据只能映射到各个集合中的位置`n mod (s/k)`上。大部分指令和数据高速缓存的相关性在1～8之间。如果一条缓存线被掉入高速缓存，并且所有可能存放这个高速缓存线的位置都已经被占用，那么通常情况下会将最近最少使用的缓存线清除出高速缓存。

#### 碎片整理

在程序开始执行的时候，堆区就是一个连续空闲的存储单元。随着这个程序分配和回收内存的进行，空间被分割成若干个空闲存储块和已用存储块，而空闲块不一定位于堆区的某个连续区域中。将空闲存储块称为**窗口(hole)**。对于分配请求存储管理器必须将请求的存储块放入放入足够大的一个“窗口”中。除非找到一个大小正好相等的窗口，那么就得切分某个窗口。对于某个回收请求也是，把连续的窗口合并为大窗口，如果不小心，那么空闲存储就会变成碎片，即大量的细小且不连续的窗口。

**best-fit和next-fit对象放置**

通过控制存储管理器在堆区中放置新对象的方法来减少碎片。经验表明，使现实中的程序碎片最少的一个良好策略是将请求的存储分配在满足最小可用窗口中。best-fit算法趋向于将大的窗口保留下来满足后续的更大请求。另一种策略被称为first-fit。在这个策略中，对象被放置到第一个(即地址最低的)能够容纳请求对象的窗口中，这种策略在放置对象时花费的时间较少，但是人们发现它在总体性能上要比best-fit策略最差。

为了更有效地实现best-fit放置策略，可以根据空闲空间块的大小，将它们分在若干个容器中。一个实际可行的想法是为较小的尺寸设置较多的容器，因为小对象的个数通常比较多。容器机制使得寻找best-fit块变得容易。

* 如果被请求的尺寸有一个专有容器，即该容器只包含该尺寸的存储块，可以从该容器中任意取出一个存储块。
* 如果被请求的尺寸没有专有的容器，可以找出一个能够包含该尺寸的存储块的容器。在这个容器中，可以使用first-fit或者best-fit策略。也就是说，既可以找到并选择第一个足够大的存储块，也可以花更多时间去寻找最小的满足需求的存储块。
* 目标容器可能为空，或者这个容器中的所有存储块都太小，不能满足空间请求。在这种情况下，只需要使用对应下一个较大尺寸容器重新进行搜索。最后要么找到可以使用的存储块，要么到达“荒野块”。从这个荒野块中一定可以获得需要的空间，但有可能需要请求操作系统为堆区增加更多的内存页。

虽然best-fit算法可以提高空间利用率，但是不一定是最好的。对best-fit算法的改进之一是找不到恰好等于请求尺寸的存储块时，使用另一种对象放置方法。在这种情况下，使用next-fit策略，只要刚刚分割过的存储块中还有足够的空间来容纳这个对象，就把这个对象放置在这个存储块中。next-fit算法还可以提高分配的操作速度。

**管理和接合空闲尺寸**

当一个对象通过手工方式回收时，存储管理器必须将该存储块设置为空闲的，以便它可以被再次分配。在某些情况下，还可以将这个块和堆中的相邻块合并(接合)起来，构成一个更大的块。

如果为所有具有固定尺寸的存储块保留一个容器，那么尽可能倾向于不把相邻的该尺寸的块合并为双倍大小的块。比较简单的做法是将所有同样大小的块全部按照需要放在多个页中，而不必接合。那么一个简单的分配/回收方案是维护一个位映射，其中的每个比特对应于容器中的一个块。1代表占用，0代表空闲。

有两种数据结构可以用于支持相邻空闲块的接合：

* **边界标记**-在每个(不管是分配还是空闲)存储块的高低两端，都存放了重要的信息。在块的两端都设置了一个free/used位，用来标识当前该块是已用的(used)还是空闲的(free)，在与每一个free/used位相邻的位置上存放了该块的字节总数。
* **一个双重链接的，嵌入式的空闲列表**-各个空闲块(不是已分配的块)还使用一个双重链表进行链接。这个链表的指针就存放在这些块中，比如存放在一个紧挨着某一端边界标记的位置上。因此，不需要额外的空间来存放这个空闲块列表，尽管它的存在为块的大小设置了一个下界。即使数据对象只有一个字节，存储块也必须提供存放两个边界标记和两个指针的空间。空闲列表中的存储块的顺序没有确定。

如果自动垃圾回收过程将所有的已分配的的存储块移动到一段连续的存储中，同时还可以消除所有碎片。

#### 人工回收请求

在理想情况下，任何不会再被访问的存储都应该删除。反过来，任何可能还会被引用的空间都不能删除。遗憾的是，这两个性质都很难保证。除了考虑人工回收的困难之处以外，还将描述一些被程序员用于处理这些难点的技术。

**人工回收带来的问题**

人工存储管理很容易出错。常见的错误有两种形式：一直未能删除不能引用的数据，这称为**内存泄漏(memory link)**错误；引用已经被删除的数据，这称为**悬空指针引用(dangling-pointer-dereference)**错误。

程序员不能保证一个程序是否永远不会在将来引用某块存储，因此第一个常见的错误是没有删除那些不会被再次引用的数据。请注意，尽管内存泄漏可能由于占用的存储增多而降低程序运行的速度，但是只要机器没有用完全部的存储，它们就不会影响程序的正确性。很多程序可以容忍内存泄漏，当泄漏比较慢时尤其如此。然而，对于长期运行的程序，特别是像操作系统和服务器代码这样不间断运行的程序，保证它们没有内存泄漏是非常关键的。

自动垃圾回收通过回收所有的垃圾而消除了内存泄漏问题。但是即使使用垃圾回收机制，程序仍然可能耗费了过多的内存。有时尽管在某处还存在着某个对象的引用，但程序员可能知道该对象不会再被引用，因此程序员可以主动删除那些不会再被引用的对象的引用，使得这些对象可以被自动回收

过度热衷于删除对象可能引起比内存泄漏更严重的问题。第二个常见的错误是删除了某个存储空间，然后又试图去引用这个已回收空间中的数据。指向已回收空间的指针称为**悬空指针(dangling pointer)**，一旦这个已释放的空间被重新分配给另一个变量，通过该悬空指针进行的任何阅读，写或者回收操作都可能产生看起来不可琢磨的结果。把诸如读，写，回收等沿着一个指针试图使用该指针所指对象的所有操作称为对这个指针的“解引用”

注意，一个通过悬空指针读取数据可能会返回不确定的值。通过一个悬空指针读取数据可能会返回不确定的值。通过一个悬空指针进行写操作则可能不确定地改变新变量的值。回收一个悬空指针的存储空间意味着这个新变量的存储空间可能被分配给另一个变量。新旧变量上的动作可能会互相冲突。

和内存泄漏不一样，在释放的空间被重新分配之后再对相应的悬空指针进行解引用总是会带来难以调试的程序错误。因而，当程序员不能确定一个变量是否还会被引用时，倾向于不回收该变量。

另一个相关的编程错误形式是访问非法地址。这种错误的常见例子包括对空指针的解引用和访问一个数组界限之外的元素。探测出这种错误要好过任由程序产生错误结果。

**编程规范和工具**

* 当一个对象的生命周期能够被静态推导出来时，**对象所有者**的概念是有用的。基本思想是在任何时候都给每个对象关联上一个所有者(owner)。这个所有者是指向该对象的一个指针，通常属于某个函数调用。
* 当一个对象的生命周期需要动态确定时，**引用计数(reference counting)**会有所帮助。它的基本思想是给每个动态内存分配的对象附上一个计数。在指向这个对象的引用被创建时，将此对象的引用计数加1.当一个引用被删除时，将引用计数减一。当计数变成0时，这个对象就不会被再引用，因此可以被删除。
* 对于其生命周期局限于计算过程中的某个特定阶段的一组对象，可以使用**基于区域的分配(region-based allocation)**方法。当被创建的对象只在一个计算过程的某个步骤中使用时，可以把这些对象分配在同一个区域中。一旦这个计算步骤完成，就删除整个区域。

### 垃圾回收概述

不能被引用的数据通常称为**垃圾(garbage)**，垃圾回收最早在Lisp中实现。

#### 垃圾回收器的设计目标

垃圾回收是重新收回那些存放不能再被程序访问的对象的存储块。假定这些对象的类型可以由**垃圾回收器**在运行时刻确定。基于这个类型信息，可以知道该对象有多大，以及该对象的哪些分量包含指向其他对象的引用(指针)。还假定对象的引用总是指向该对象的起始位置，而不会指向该对象中间的位置。因此，对同一个对象的所有引用具有相同的值，可以很容易被识别。

把一个用户程序称为**增变者(mutator)**，它会修改堆区的对象集合。增变者从存储管理器处获取空间，创建对象，还可以引入和消除已有对象的引用。当增变者程序不能“到达”某些对象时，这些对象就变为了垃圾。垃圾回收器找到这些不可达对象，并将这些对象交给跟踪空闲空间的存储管理器，收回它们所占的空间。

**一个基本要求，类型安全**

不是所有的语言都适合进行自动垃圾回收，为了使垃圾回收器能够工作，它必须知道任何给定的数据元素或一个数据元素的分量是否为（或可否被用作）一个指向某块已分配存储空间的指针。在一种语言中，如果任何数据分量的类型都是可确定的，那么这种语言就被称为类型安全的。另外一种类型安全的语言，比如Java，其类型不能在编译时刻确定，但是可以在运行时刻确定，后者称为动态类型的语言。有些最重要的语言却不是类型安全的，比如C和C++，因为存储地址可以任意操作，任何整数都可以被称为指针。

**性能度量**

* **总体运行时间**-
* **空间使用**-
* **停顿时间**-
* **程序局部性**-

一般来说，在基于跟踪的回收器中，等待垃圾回收的时间越长，可回收对象的比例就越大。相比之下，一个使用引用计数的回收器给增变者的每次运算引入一个常量开销，从而明显地降低程序的整体运行速度。但是引用计数不会产生长时间的停顿，并且能够有效地利用内存，因为它可以在垃圾产生时立刻发现他们。

语言的设计同样会影响内存的使用特性。如函数式编程语言为了避免改变已存在的对象，会创建出更多的对象。但是在Java中，除了整型和引用这样的基本类型，所有的对象都被分配在堆区而不是栈区，即使这些对象的生命周期被限制在一次函数调用的生命周期内，它们仍然被分配到堆区中。这种设计不需要程序员关注变量的生命周期，但是其代价是产生更多的垃圾，有一些编译器优化技术可以分析变量的生命周期，并尽可能地将它们分配到栈区。

#### 可达性

把所有不需要对任何指针解引用都可以被程序直接访问的数据称为**根集(root set)**。例如在Java中，一个程序的根集由所有的静态字段和栈中的所有变量成员组成。显然，程序可以在任何时候访问根集中的所有成员。递归地，对于任意一个对象，如果指向它的一个引用被保存在任何可达对象的字段成员或数组元素中，那么这个对象本身也是可达的。

当程序被编译器优化后，可达性问题会变得更加复杂。首先编译器可能会把引用变量放在寄存器中，这些引用也必须看作是根集的一部分。为了使垃圾回收器能够找到正确的根集，优化编译器可以做如下的处理：

* 编译器可以限制垃圾回机制只能在程序的某些代码点上被激活。在这些点上没有“隐藏”的引用。
* 编译器可以写出一些信息供垃圾回收器恢复所有的引用。比如，指出哪些寄存器中包含了引用，或者如何根据给定的某个对象的内部地址来计算该对象的基地址。
* 编译器可以确保当垃圾回收器被激活时每个可达对象都有一个引用指向它的基地址。

可达对象的集合随着程序的变化而变化。当新对象被创建时该集合会增长，当某些对象变得不可达使该集合就缩小。并且一旦某个对象变的不可达，它就不可能再次变的可达。下面是一个赠变者程序改变可达对象集合的四种基本操作：

* **对象分配**-这些操作由存储管理器完成。
* **参数传递和返回值**-对象引用从实在输入参数传递到相应的形式参数，也可以从返回结果传回给调用者。
* **引用赋值**-对于引用u和v，形如`u = v`的赋值语句有两个效果。首先，u现在是v所指对象的一个引用。只要u是可达的，那么它所指对象当然也是可达的。其次，u中原来的引用丢失了。如果这个引用是指向某一可达对象的最后一个引用，那么那个对象就变成不可达的。当某个对象变得不可达时，所有只能通过这个对象中的引用到达的对象都会变成不可达的。
* **过程返回**-当一个过程退出时，保存其局部变量的活动记录将被弹出栈。如果这个活动记录中保存了某个对象的唯一引用，那个对象就变得不可达。同样，如果这个刚刚这个不可达的对象变得不可达，以此类推。

新的对象通过对象分配被引入。参数传递和赋值可以传递可达性；赋值和过程结束可能结束对象的可达性。当一个对象变得不可达时，可能会导致更多的对象变得不可达。

有两种寻找不可达对象的基本方法。可以捕获可达对象变得不可达的转变时刻，也可以周期性地定位出所有可达对象，然后推出所有其他对象都是不可达的。**引用计数**技术是一种著名的近似实现第一种方法的技术。在增变者执行可能改变可达对象集合的动作时，维护了指向各个对象的引用计数。当计数器变为0时，相应的对象变得不可达。

第二种方法传递地跟踪所有的引用，从而计算可达性。一个基于跟踪的垃圾回收器首先为根集中的所有对象加上“可达的”标号，然后重复地检查可达对象中的所有引用，然后才能决定哪些对象是不可达的。

#### 引用计数垃圾回收器

现在考虑一个简单的引用计数的垃圾回收器，当一个对象从可达的变为不可达的时候，该回收器就可以将该对象认为是垃圾；当一个对象的引用计数为0时，该对象就会被删除。使用引用计数的垃圾回收器，每个对象必须有一个用于存放引用计数的字段。引用计数可以按照下面的方法进行维护。

* **对象分配**-新对象的引用计数被设置为1。
* **参数传递**-被传递给一个过程的每个对象的引用计数加一。
* **引用赋值**-如果u和v的引用，对于语句`u = v`，v指向的对象的引用计数加1，u本来指向的原对象的引用计数减1
* **过程返回**-当一个过程退出时，该过程活动记录的局部变量中所指向的对象引用计数都要减1。
* **可达性的传递关系**-当一个对象的引用计数变成0时，必须将该对象中的各个引用所指向的对象的引用计数减1。

引用计数有两个主要的缺点：他不能回收不可达的循环数据结构，并且它的开销较大。循环数据结构的出现都是有理由的：数据结构常常会指回到他们的父结点，也可能互相指向对方，从而形成交叉引用。

引用计数的开销比较大，因为每一次引用赋值，以及在每个过程的入口和出口处，都会增加一个额外运算。这个开销和程序中的计算量成正比，而不仅仅和系统中的对象数目相关。需要特别考虑的是一对程序的根集中的引用更新。局部栈访问会引起引用计数的更新，为了消除因这种更新而引起的时间开销，提出了**延期引用计数**的概念。也就是说，引用计数不包括来自程序根集的引用，除非扫描整个根集仍没有找到指向某一对象的引用。否则这个对象不会被当作垃圾。

另一方面，引用计数的优势在于垃圾回收是以增量方式完成的。尽管总的开销可能很大，但这些运算分布在增变者的整个计算过程中。尽管删除一个引用可能可能致使大量对象变得不可达，但是可以很容易地延期执行递归地修改引用计数的计算，并且在不同的时间点上逐步完成修改

### 基于跟踪的回收的介绍

基于跟踪的回收器并不在垃圾产生的时候回收，而是回周期性地运行，寻找不可达对象并收回它们的空间。通常的做法是在空闲空间被耗尽或者空间数量低于某个阈值时启动垃圾回收器。

#### 基本的标记-清扫式回收器

**标记-清扫式(mark-and-sweep)**垃圾回收算法是一种直接的全面停顿的算法。找出所有不可达的对象，并将它们放入空闲空间列表。然后“清扫”整个堆区并释放不可达对象。

**算法7.12 标记清扫式垃圾回收**

输入：一个由对象组成的根集，一个堆和一个被称为Free的包含了子堆中所有未分配存储块的**空闲空间列表(free list)**。所有空间块都有边界标记进行标识，指明它们的空闲/已用状态和大小。
输出：在删除了所有垃圾之后的经过修改的Free列表。
方法：下面示出的算法使用了几个简单的数据结构。列表Free保存了已知的空闲对象。一个名为Unscanned的列表保存了已经确定可达的对象，但是还没有考虑这些对象的后继对象的可达性。也就是说，还没有扫描这些对象来确定通过它们能够到达哪些对象。列表Unscanned最初为空。另外，每个对象包括一个比特，用来指明该对象是否可达。在算法开始之前，所有已分配的对象reached位都被设定为0。

伪代码为

```c
/* 标记阶段 */
/* 把被根集引用的每个对象的reached位设置位1，并把它加入到Unscanned列表中； */
while (Unscanned != 0) {
    从Unscanned列表中删除某个对象o;
    for (在o中引用每个对象o') {
        if (在o中引用每个对象o') {
            将o'的reached位设置为1;
            将o'放到Unscanned中;
        }
    }
}
/* 清扫阶段 */
Free = 0;
for (堆区中的每个内存块o) {
    if (o未被访问到，即它的reached位为0)
        将o加入到Free中;
    else
        将o的reached位设置位0;
}
```

可能从o到达的三种对象

* 之前扫描过的对象，不需要被再次扫描
* 当前在Unscanned列表中的对象
* 一个可达的数据项，但是之前它被认为是未被访问的

#### 基本抽象

所有基于跟踪的算法都计算可达对象集合，然后取这个集合的补集。因此，内存是按照下列方式循环使用的：

* 程序（或者说增变者）运行并发出分配请求
* 垃圾回收器通过跟踪揭示可达性
* 垃圾回收器收回不可达对象的存储空间

一个存储块的状态可以存储块内部，也可以使用垃圾回收器的某个数据结构隐含地表示。

虽然不同的基于跟踪的算法可能在实现上有所不同，但是它们都可以通过下列状态进行描述：

* **空闲的**-存储块处于空闲状态表示它可以被分配。因此，一个空闲块内不会存放任何可达对象。
* **未被访问的**-除非通过跟踪证明存储块可达，否则它被认为是不可达的。
* **待扫描**-已知可达的存储块要么处于待扫描状态，要么处于已扫描状态。
* **已扫描的**-每个待扫描对象最终都将被扫描并转移到已扫描状态。

当不再有对象处于待扫描状态时，可达性的计算就完成了。到最后仍处于未被访问状态的对象确实是不可达的。垃圾回收器收回它们占用的空间，并将这些存储块置于空闲的状态。

#### 标记-清扫式算法的优化

基本的标记-清扫式算法的最后一步代价很大，因为没有一个容易方法可以不用检查堆区就找到所有不可达对象。一个优化算法是用一个列表记录所有已分配的对象。必须将不可达对象的存储返回给空闲空间。为了找出不可达对象的集合，可以求已分配对象和可达对象的差集。

**算法7.14 Baker标记-清扫式回收器**

输入：一个由对象组成的根集，一个堆区，一个空闲列表Free，一个名为Unreached的已分配对象的列表。
输出：经过修改的Free列表和Unreached列表。Unreached列表保存了被分配的对象。
方法：算法中用于垃圾回收的数据结构是名字分别为Free，Unreached，Unscanned，Scanned的四个列表。这些列表分别保存了处于空闲的，未被访问，待扫描和已扫描状态上的所有对象。

这些列表可以通过嵌入式的的双重列表来实现，对象中的reached位没有被使用，但是假定每个对象中都包含了一些二进制位，指明该对象处于上述四个状态的哪一个。

```c
Scanned = 0;
Unscanned = 在根集中引用的对象的集合，并将这些对象从Unreached中删除;
while (Unscanned != 0) {
    将对象从Unscanned移动到Scanned;
    for (在o中引用的每个对象o') {
        if (o'在Unreached中)
            将o'从Unreached移动到Unscanned中;
    }
}
Free = Free U Unreached;
Unreached = Scanned;
```

#### 标记并压缩的垃圾回收器

进行**重新定位(relocating)**的垃圾回收器会在堆区内移动可达对象以消除存储碎片，通常，可达对象占用的空间要大大小于空闲空间。因此，在标记出所有的“窗口”之后并不一定要逐个释放这些空间。另一个有吸引力的做法是将所有可达对象重新定位到堆区的一端，使得堆区的所有空闲空间成为一个块。毕竟垃圾回收器已经分析了可达对象中的每个引用，因此更新这些引用使之指向新的存储位置并不需要增加很多工作量，需要改变的全部引用包括可达对象中的引用和根集中的引用。

将所有可达对象放在一段连续的位置上可以减少内存空间的碎片，使得它更容易存储较大的对象。同时，通过使数据占用更少的的缓存栈和内存页，重新定位可以提高程序的时间局部性和空间局部性，因为几乎同时创建的对象将被分配在相邻的存储块中。

**算法7.15 一个标记并压缩的垃圾回收器**

输入：一个由对象组成的根集，一个堆，以及一个标记空闲空间的起始位置的指针free。
输出：输出free的新值。

```c
/* 标记 */
Unscanned = 根集引用的对象的集合
while (Unscanned != 0) {
    从Unscanned中移除对象o;
    for (在o中引用每个对象o') {
        if (o'是未被访问的) {
            将o'标记为访问的;
            将o'加入到列表Unscanned中;
        }
    }
}
/* 计算新的位置 */
free = 堆区开始的位置;
for (从低端开始，遍历堆区中的每个存储块o) {
    if (o是被访问的) {
        NewLocation(o) = free;
        free = free + sizeof(o);
    }
}

/* 重新设置引用目标并移动已被访问的对象 */
for (从低端开始，堆区中的每个存储块o) {
    if (o是被访问的) {
        for (o中的每个引用o.r) {
            o.r = NewLocation(o.r);
        }
        将o拷贝到NewLocation(o);
    }
}

for (根集中的每个引用r) {
    r = NewLocation(r);
}
```

#### 拷贝回收器

拷贝回收器预先保留了可以将对象移入的空间。因而解除了跟踪和发现空闲空间之间的依赖关系。整个存储空间被划分为两个半空间(semispace)A和B。增变者在半空间之一(比如A)内分配内存，直到它被填满。此时增变者停止，垃圾回收器将可达对象拷贝到另一个半空间，比如B。当垃圾回收完成时，两个半空间的角色进行兑对换，增变者可以继续运行。并在半空间B中分配对象。下一轮垃圾回收器将把可达对象移动到A。

**算法7.16 Cheney的拷贝回收器**

输入：一个对象组成的根集，一个包含了From半空间和To半空间的堆区，其中From半空间包含了已分配对象，To半空间全部是空闲的。
输出：最后，To半空间保存已分配的对象。free指针指明了To半空间中剩余空闲空间的开始位置。From半空间此时全部空闲。
方法：Cheney算法在From半空间中找出可达对象，并且访问到它们时立刻把它们拷贝到To半空间。这种放置方法将相关对象放在一起，从而提高空间局部性

```c
CopyingCollector () {
    for (From空间中的所有对象o)
        NewLocation(o) = NULL;
    Unscanned = free = To空间的开始地址;
    for (根集中的每个引用r)
        将r替换为LookupNewLocation(r);
    while (unscaned != free) {
        o = 在unscanned所指位置上的对象
        for (o中的每个引用o.r)
            o.r = LookupNewLocation(o.r);
        unscanned = unscanned + sizeof(o);
    }
}

/* 如果一个对象已经被移动过了，查找这个对象的新位置 */
/* 否则将对象设置为待扫描状态 */
LookupNewLocation(o) {
    if (NewLocation(o) == NULL) {
        NewLocation(o) = free;
        free = free + sizeof(o);
        将对象拷贝到NewLocation(o);
    }
    return NewLocation(o);
}
```

*注意：在一个典型的数据结构中(如散列表)，如果o没有被赋值于一个位置，那么在这个结构中就没有相关的信息*

#### 开销的比较

Cheney算法的优势在于它不会涉及任何不可达对象。另一方面，拷贝垃圾回收器必须移动所有的可达对象的内容。对于大型对象，或者那些经历了多轮垃圾收集过程的生命周期长的对象而言，这个过程开销特别高。

4种垃圾回收算法的时间比较

* **基本的标记-清除算法(算法7.12)**-与堆区的存储块的数目成正比
* **Baker的标记-清除算法(算法7.14)**-与可达对象的数目成正比
* **基本的标记并压缩算法(算法7.15)**-与堆区存储块的数目和可达对象的总大小成正比
* **Cheney的拷贝回收器(算法7.16)**-与可达对象的总大小成正比

### 短停顿垃圾回收

简单的基于跟踪的回收器是以全面停顿的方式进行垃圾回收的，它可能造成用户程序的运行的长时间停顿。可以每次只做垃圾部分回收的工作，从而减少一次停顿的长度。可以按照时间来分割工作任务，使垃圾回收和增变者的运行交错进行。也可以按照空间来分割任务，每次只完成一部分垃圾的回收。前者称为**增量式回收(incremental collection)**，后者称为部分回收(partial collection)。

增量式回收器将可达性分析任务分割称为若干个较小单元，并允许增变者和这些任务单元交错运行。可达集合会随着增变者的运行发生变化，因此增量式回收是很复杂的。

最有名的部分垃圾回收算法是**世代垃圾回收(generational garbage collection)**。它根据对象分配时间的长短来划分对象，并且较频繁地回收新创建的对象，因为这些对象的生命周期往往比较短。另一种可选的算法是**列车算法(train algorithm)**，也是每次只回收一部分垃圾。它最适合回收较成熟的对象。

#### 增量式垃圾回收

增量式回收器是保守的，虽然垃圾回收器一定不能回收不是垃圾的对象，但是它并不一定要在每一轮回收中回收所有的垃圾。将每次回收之后留下的垃圾称为**漂浮垃圾(floating garbage)**，当然期望漂浮垃圾越少越好，明确地说，增量式回收器不应该遗漏那些在回收周期开始时就已经不可达的垃圾。如果能够保证做到这一点，那么在某一轮中没有被回收的垃圾一定会在下一轮中被回收。因此不会因为这个垃圾回收方法而产生内存泄漏问题。

换句话说，增量式垃圾回收器会过多地估算可达对象的集合，从而保证安全性。首先以不可中断的方式处理程序的根集，此时没有来自增变者的干扰。在找到了待扫描对象的初始集合之后，增变者的动作与跟踪步骤交错进行。在这个阶段，任何可能改变可达性的增变者动作都被简洁的记录在一个副表中，使得回收器可以在继续执行时做出必要的调整。如果在跟踪完成之前空间就被耗尽，那么回收器将不再允许增变者执行，并完成全部跟踪过程。在任何情况下，当跟踪完成后，空间回收以原语的方式完成。

**增量回收的准确性**

一旦对象成为不可达的，该对象就不可能再变成可达的。因此，在垃圾回收和增变者运行时，可达对象的集合只可能：

* 因为垃圾回收开始之后的某个新对象的分配而增长
* 因为失去了指向已分配对象的引用而缩小

#### 增量式可达性分析

为了截获可能有问题的引用传递，算法可以在跟踪过程中按照下式方式修改增变者的动作：

* **写关卡**-截获把一个指向未被访问的对象o的引用写入一个已扫描对象o1的运算。在这种情况下，将o作为可达对象并将其放入待扫描集合。
* **读关卡**-截获未被访问或待扫描对象中的引用的读运算。只要增变者从一个处于未被访问或待扫描状态中的对象读取一个指向对象o的引用时，就将o设置为可达的，并将其放入待扫描对象的集合
* **传递关卡**-截获在未被访问或待扫描对象中原引用丢失的情况。只要增变者覆写一个未被访问或待扫描对象中的引用时，保存即将被覆写的引用并将其设置为可达的，然后将这个引用本身放入待扫描集合。

**写关卡的实现**

* 在增变阶段记录下所有被写入到已扫描对象中的新引用，可以将这些引用放入一个列表。如果不考虑从列表中剔除重复的引用，列表的大小和已对扫描对象的写运算的数量成正比。
* 可以用被写位置的列表来记录它们，其中可能会消除重复的位置。

**增量结合和拷贝技术**

上述的方法对于标记-清扫式垃圾回收来说已经足够了。因为拷贝回收和增变者的相互影响，它的实现要稍微复杂一点，处于已扫描或者待扫描的状态中的对象有两个地址，一个位于From半空间，另一个半位于To空间。和算法7.16一样，必须保存一个从对象的旧地址到其重新定位之后的地址的映射。

可以选择两种更新引用的方法

* 可以让增变者在From空间中完成所有的运算，只是在垃圾回收结束的时候才更新所有的指针，并将所有内容都拷贝到To空间
* 可以让程序直接改变To空间中的表示。

#### 部分回收概述

通常80%～90%的新分配对象在几百万条指令之内，或者在分配了另外的几兆字节之前就消亡了。也就是说，对象通常在垃圾回收过程中启动之前就已经变得不可达了。因此，频繁地对新对象进行垃圾回收具有相当高的性价比。

然而，经历了一次回收的对象很可能在经过多次回收之后依然存在。把将在一轮部分回收中被回收的对象集合称为目标集，而将其他对象称为稳定集。在理想状态下，一个部分回收器应该回收目标集中所有无法从根集到达的对象。实际上，部分回收器只是保守地回收那些无法从根集和稳定集到达的对象。因为稳定集中的一些对象自身也是不可达的，可能会把目标集中的实际一些实际上根本不存在从根集开始的路径的对象当成可达对象。

部分垃圾回收器常常被实现为拷贝垃圾回收器。通过使用链表来跟踪可达对象，也可以实现为非拷贝回收器

#### 世代垃圾回收

**世代垃圾回收(generational garbage collection)**是一种充分利用了大多数对象“英年早逝”特性的有效方法。在世代垃圾回收中，堆区被分成一系列小的区域。用0，1，2，...,n进行编号，序号越小的区域存放的对象越年轻。对象首先在0区域被创建。当这个区域被填满时，它的垃圾被回收，且其中的可达对象给被移到1区。现在，0区再次被填满，它的垃圾又被回收且它的可达对象被拷贝到1区，与之前的被拷贝的对象合在一起。这个模式一直被重复，直到1区也被填满为止，此时对应于0区和1区应用垃圾回收。

一般来说，每一轮垃圾回收都是针对序号小于等于某个i的区域进行的，应该将i选择为当前被填满区域的最小编号。每当一个对象经历了一轮回收(即它被确定为可达的)，它就从它当前所在区域被提升到下一个较高的区域，直到它到达最老的区域，即序号为n的区域。

当区域i及更低区域中的垃圾被回收时，从0到i的区域组成了目标集，所有序号大于i的区域组成了稳定集。为了各种可能的部分回收找到根集，为每个区域i保持了一个被记忆集，该集合由指向区域i中的对象且位于大于i的区域中的所有对象组成。在i上激活的一次部分回收的根集包括了区域i及更低区域的被记忆集。

在这个方案中，只要对i进行回收，所有序号小于i的区域也将进行垃圾回收。有两个原因促使采用这个策略：

* 因为较年轻的世代往往包含较多的垃圾，也就更频繁地被回收。所以可以将它们和较老的世代一起回收
* 根据这种策略，只需要记录从较老世代指向较新世代的引用。也就是说，对最年轻的世代的对象进行写运算，以及将对象提升到下一个世代时都不需要更新任何被记忆集。

世代回收器偶尔也需要执行完整的跟踪步骤，因此也会在程序运行时引入较长时间的停顿。

#### 列车算法

列车算法的增量式回收方法用于改进对成熟对象的处理。它可以用来回收所有的垃圾。但是更好方法是使用世代方法来处理的年轻的对象，只有当这些对象经历了几轮世代回收之后仍然存在，才将它们提升到另一个由列车算法管理的堆区。列车算法的另一个优点是永远不需要进行全面的垃圾回收过程，而在世代垃圾回收中却仍然存在必须偶尔那样做。

列车算法使用固定大小的被称为车厢(car)的区域。当没有对象比磁盘块更大时，一节车厢可以是一个磁盘块，否则可以将车厢的尺寸设得更大。但是车厢的大小确定就不再变化。多节车厢被组织为列车。一辆列车中的车厢数量没有限制。车厢之间按照词典顺序进行排序。

列车算法有两种垃圾回收的方式：

* 在一个增量式垃圾回收步骤中，按照词典顺序排列的第一节车厢首先被回收。因为我们保留了一个来自车厢之外的所有指针de“被记忆”列表，所以这一步类似于世代算法中针对第一个回收区域的步骤。我们确定出没有任何引用的对象，以及完全包含在这节车厢里的垃圾循环。该车厢中的可达对象总是被移至其他的某个车厢中，因此每个被回收过的车厢都变成空车厢的，可以从这辆列车中删除。
* 第一辆列车没有外部引用。也就是说，没有从根集指向该列车中任何车厢的指针，并且各节车厢中的记忆集中只有来自本列车的其他车厢引用，没有来自其他列车的引用。在这种情况下，该列车就是一个巨大的循环垃圾集合，可以删除整辆列车。

**被记忆集**

列车算法的细节，每节车厢有一个被记忆集，由指向该车厢中对象的引用组成，这些引用来自：

* 同一辆列车中序号较高的车厢中的对象
* 序号较高的列车中的对象

此外，每辆列车有一个被记忆集，它由来自较高序号列车中的引用组成。也就是说，一个列车的被记忆集是它内部的所有车厢的被记忆集的并集，但是不包含列车内部的引用。因此，可以将车厢的被记忆集划分成“内部”(同一列车)和“外部”(其他列车)两个部分，同时表示这两种不同类型的被记忆集合。

注意，指向这些对象的引用可以来自各个地方，不只是来自按字典顺序排列的序号较高的车厢。然而，算法中的两种垃圾回收过程分别处理第1辆列车的第1节车厢和整个第1辆列车。因此，当在垃圾回收中需要使用被记忆集的时候，已经没有更早的地方可以有引用到达被处理的车厢或者列车。因此，记录下指向较高序号车厢的引用就没有什么意义。

**管理列车**

目标是找出第一辆列车中所有非循环垃圾的对象。此时，第一辆列车要么只包含了循环垃圾，因此将在下一轮垃圾回收时被回收；要么其中的垃圾不是循环的，那么它的车厢就可以被逐个回收。

因为对一辆列车中的车厢数目没有限制，每当需要更多的空间时，在原则上我们可以直接向同一辆列车中加入新的车厢。但是偶尔也需要创建出新的列车。可以设定每创建k个对象之后就新建一辆列车。也就是说，当最后一辆列车的最后车厢中还没有足够的空间时，被创建的对象一般会放置在这节车厢中；如果该车厢中没有足够的空间，该对象就会被放到一个即将被加入到最后一个车厢之后的新车厢中。然而会定期新建一列只有一节车厢的列车，并将新对象放入其中。

**单节车厢的垃圾回收**

列车算法的核心是如何在一轮垃圾回收中处理第1辆列车的第1节车厢。一开始，可达集包括了该车厢中被来自根集的引用指向的对象，以及被该车厢的被记忆集中的引用指向的对象。然后，像标记-清扫式回收器那样扫描这些对象，但是不会扫描任何可达的位于被回收车厢之外的对象。在这次跟踪之后，该车厢中的某些对象可能被确定为垃圾。因为无论如何，整节车厢都将消失，因此不必回收他们的空间。

然而该车厢中很可能还有一些可达对象，这些对象必须转移到其他地方。移动一个对象的规则如下：

* 如果被记忆集中有一个来自其他列车的引用（该列车的序号高于被回收车厢所在列车的序号)，那么将这个对象移到这些列车中的某一辆中。如果在发出一个引用的某辆列车中能够找到足够的空间，就将该对象移动这辆列车的某节车厢中。如果找不到空间，它就进入一个新的，最末端的车厢。
* 如果没有来自其他列车的引用，但是存在来自根集或第1辆列车的引用，那么就将此对象移到同一列车中的其他车厢中。如果没有足够的空间，就创建一个新的车厢放到列车的末端。如果有可能，挑选有一个指向该对象的的引用的车厢，以尽快把循环结构放到同一个车厢中。

为了避免**恐慌模式**这种循环垃圾引用的问题，只要遇到一个**无效(futile)**的垃圾回收，就需要改变做法，所谓无效垃圾回收是指，在回收一节车厢时没有一个对象可以作为垃圾删除或者被移动到另一辆列车中。需要做出两个变化:

* 当指向第一辆列车中的某个对象的某个引用被覆写时，将这个引用保留为根集的一个新成员
* 在进行垃圾回收时，如果第1节车厢中的第一个对象有来自根集的引用，其中包括在第1点中设置的哑引用，那么即使该对象没有来自其他列车的引用。

### 垃圾回收中高级论题

#### 并行和并发垃圾回收

当将垃圾回收应用到并发或者多处理器机器上运行的应用程序时。对于服务器应用，在同一时刻运行成千上万个线程是常有的事情；其中的每个线程都是一个增变者。堆区通常包含几千兆的存储。

可处理大规模系统的垃圾回收算法必须充分利用系统的多处理器。如果一个垃圾回收器使用多个线程，就称为其是**并行的(parallel)**。如果回收器和增变者同时运行，就说它是**并发的(concurrent)**。

将描述一个并行的且基本上并发的垃圾回收器。使用一个并发且运行的阶段来完成大部分的跟踪工作，然后执行一个全面停顿式的步骤来保证找到所有的可达对象并回收存储空间。这个算法在本质上没有引入新的有关垃圾回收的基本办法，它说明了如何将曾经描述的思想组合起来，创造出一个解决并发，并行的垃圾回收问题的完整解决方案。然而，并行执行的本质会带来一些新的实现问题。将讨论这个算法如何使用一个相当常见的动作队列模型，在并行计算过程中协调多个线程。

一个增量式分析完成下面三个步骤：

* 找到根集。
* 增变者的执行和可达对象的跟踪交替进行。
* 再次暂停增变者的运行，重新扫描所有可能保存了指向未被访问对象的引用的卡片。

一个并行，并发垃圾回收算法的大概描述：

* 扫描每个增变者线程的根集，将所有可以从根集中直接到达的对象设为待扫描状态。
* 扫描处于待扫描状态的对象。为了支持并行运算，使用一个由固定大小的动作包(work packet)组成的工作队列。每个工作包保存了一些待扫描对象。当发现待扫描对象时，它们就被放置到工作包中。等待工作的线程将从队列中取出这些工作包。
* 扫描脏卡片中的对象。当工作队列中不再有待扫描对象，并且所有线程的根集都已经被扫描之后，重新扫描这些卡片以寻找可达对象
* 最后一步保证所有的可达对象都被标记为已访问的。

*必须控制启动跟踪过程的频率*。增变者创建出必须被扫描的新对象和新引用，而跟踪过程则试图扫描所有的可达对象，并重新扫描同时产生的脏卡片。在需要进行垃圾回收之前过分频繁地启动跟踪过程是没有必要的，因为这样做会增加漂浮垃圾的数量。因此，算法必须适当地适当地选择启动回收的时机和跟踪的频率。

#### 部分对象重新定位

拷贝或压缩回收器的优势在于消除碎片。然而，这些回收器需要不小的开销。压缩回收器需要在垃圾回收结束时移动所有的对象并更新所有的引用。拷贝回收器在跟踪过程中就找出可达对象的位置。如果跟踪采用增量式执行方式，要么对增变者的每个引用进行转换，要么到最后才移动所有的对象并更新它们的引用。

可以改用一个拷贝世代垃圾回收器。它在回收年轻对象并减少碎片方面很有效，但是在回收成熟对象时比较昂贵。可以使用列车算法来限制每次分析时处理的成熟数据的数量。然而，列车算法的代价和每个区域的被记忆集的大小相关。

有一种混合型的回收方案，它使用并发跟踪来回收所有的不可达对象，同时只移动部分对象。这种方法减少了碎片，又不会因为在每个回收循环中进行重定位而引起额外的开销。

* 在跟踪开始之前，选择将被清空的一部分堆区
* 当标记可达对象时，记住所有指向指定区域内对象的引用
* 当跟踪完成时，并行地清扫存储空间以回收被不可达对象占用的空间
* 最后，清空占据指定区域的可达对象，并修正指向被清空对象的引用

#### 类型不安全的语言的保守垃圾回收

在C和C++中，没有任何内存位置可被认为是不可达的。可以为这一类程序构造出一种保守的垃圾回收器（也就是不一定回收所有的垃圾回收器)，在实践中它能够很好地完成任务。

保守的垃圾回收器假定不可以随意构造出一个地址，或者在没有指向某已分配存储块中某处的地址的情况下得到该存储块的地址。可以在程序中找出所有满足这一假设的垃圾。方法是，对于在任意可达存储区域中找出所有满足这一假设的垃圾。方法是，对于在任意可达存储区域中找到一个二进制位模式，如果该模式可以被构造成一个内存位置，就认为它是一个有效地址。这种方案可能会把有些数据错当作地址。然而，因为这只会使得垃圾回收器保留地回收垃圾，留下的数据包含了所有必要的数据。

对象重定位需要更新所有指向旧地址的引用，使之指向新地址，因此它和保守的垃圾回收方法是不兼容的。因为保守的垃圾回收器并不能确认某个位模式是否真的指向某个实际地址，所以它不能修改这些模式并使之指向新的地址。

一个保守的垃圾回收器的工作方式，首先修改内存管理器，使之为所有已分配内存块保存一个**数据映射(data map)**。这个映射使我们很容易地找到一个内存块的起止位置。这两个起止位置跨越了多个地址。跟踪过程开始时，首先扫描程序的根集，找出所有看起来像内存位置的位模式。

#### 弱引用

虽然程序员使用了带有垃圾回收机制的语言，但是仍然希望自己管理内存，或者管理部分内存。尽管仍然存在一些引用指向某些对象，但程序员知道这些对象不会再被访问。

例：词法分析器通常会管理一个符号表，为它碰到的每个标识符创建一个对象。比如，这些对象可能作为词法值被附加于语法分析树中代表这些标识符的叶子结点上。然而，这些标识符的字符串作为键值构造一个散列表有助于这些对象进行定位。这个散列表可以在词法分析器碰到一个标识符词法单元时更容易找到对应的对象。

当编译器扫描完成标识符I的作用域时，I的符号表对象不再有任何来自语法分析树的引用，也没有来自可能被编译器使用的其他中间结构的引用。然而，在散列表中仍然存在一个指向这个对象的引用。因为散列表是编译器根集的一部分，所以这个对象不能作为垃圾被回收。如果碰到了另一个词素和I相同的标识符，编译器就会发现I已经过时了，指向I的对象的引用将被删除。然而，如果没有遇到词素相同的其他标识符，那么I的对象仍然是不可回收的，尽管在之后的整个编译过程中它都是无用的。

一种被称为**弱引用(weak reference)**的技术支持程序员依靠自动垃圾回收来解决问题，并且不会因为那些实际不再使用的可达对象而给堆区存储带来负担。在这样的系统中，允许将某些引用声明为弱引用。弱引用的一个例子就是上面讨论的散列表中的所有引用。当垃圾回收器扫描一个对象时，它不会沿着该对象内的弱引用前进，也不会将它们指向的对象设置为可达的。当然，如果有另一个不弱的引用指向这一个对象，这个对象仍然是可达的。

### 第七章总结

* **运行时刻组织**-为了实现源语言中的抽象概念，编译器与操作系统及目标机器协同，创建并管理了一个运行时刻环境。该运行时刻环境有一个静态数据区，用于存放对象代码和在编译时刻创建的静态数据对象。同时它还有动态的栈区和堆区，用来管理在目标代码执行时创建和销毁的对象。
* **控制栈**-过程调用和返回通常由称为控制栈的运行时刻栈管理。可以使用栈结构的原因是过程调用在时间上是嵌套的。也就是说，如果p调用q，那么q的活动嵌套在p的活动之内。
* **栈分配**-对于那些允许或要求局部变量在它们的过程结束之后就不可访问的语言而言，局部变量的存储空间可以在运行时刻栈中分配。对于这样的语言，每一个活跃的活动都在控制栈中有一个活动记录。活动树的根结点位于栈底，而栈中的全部活动记录对应于活动树中到达当前控制所在活动的路径。当前活动记录位于栈顶。
* **访问栈中的非局部数据**-对于带有嵌套过程的语言而言，可以通过访问链来访问栈中的非局部数据。访问链是加在各个活动记录中的指针。可以顺着访问链组成的链路到达正确的活动记录，从而找到期待的非局部数据。显示表是一个和访问链联合使用的辅助数组，它提供了一个不需要使用访问链链路的高效捷径。
* **堆管理**-堆是用来存放生命周期不确定的，或者可以生存到被明确删除时刻的数据的存储区域。存储管理器分配和回收堆区中的空间。垃圾回收在堆区中找出不再被使用的空间，这些空间可以回收并用于存放其他数据项。对于要求垃圾回收的语言，垃圾回收器是存储管理器的一个重要子系统
* **利用局部性**-通过更好地利用存储的层次结构，存储管理器可以影响程序的运行时间。利用存储的不同区域所花的时间可能从几纳秒到几毫秒不等。幸运地是，大部分程序将它们的大部分时间用于执行相对较小的一部分代码，并且此时只会访问一小部分数据。如果一个程序很可能在短期内再次访问刚刚访问过的存储位置，该程序就具有时间局部性。如果一个程序很可能访问刚刚访问的存储区域附近的位置，该程序就具有空间局部性。
* **减少碎片**-随着程序分配和回收存储，堆区很可能变得破碎，或者说被分割成大量细小且不连续的存储空间（或者称为窗口）。best-fit策略分配能够满足空间请求的最小可用窗口。尽管best-fit策略提高了空间利用率，但是对于空间局部性而言它可能并不是最好的。通过合并或者说接合相邻的窗口来减少碎片。
* **人工回收**-人工存储管理有两个常见的问题：没有删除那些不可能再被引用数据，这称为内存泄漏错误；引用已经被删除的数据，这称为悬空指针或者引用错误。
* **可达性**-垃圾就是不能被引用或者说到达的数据。有两种寻找不可达对象的基本方法；要么截获一个对象从可达变为不可达的转换，要么周期性地定位所有可达的对象，并推导出其余对象都是不可达的。
* **引用计数回收器**-维护了指向一个对象的引用计数，当这个计数变为0时，该对象就变成不可达的。这样的回收器带来了维护引用的开销，并且可能无法找出“循环”的垃圾，即由相互引用的不可达对象组成的垃圾。这些垃圾也可能通过由引用组成的链路相互引用。
* **基于跟踪的垃圾回收器**-从根集出发，迭代地检查或跟踪所有的引用，找出所有可达对象。根集包括了所有不需要对任何指针解引用就可直接访问的对象。
* **标记-清扫式回收器**-在一开始的跟踪阶段访问并标记所有的可达对象，然后清扫堆区，回收不可达对象
* **标记并压缩回收器**-改进了标记并清扫算法。它们把堆区中的可达对象重新定位，从而消除存储碎片。
* **拷贝回收器**-将跟踪过程和发现空闲过程之间的依赖关系打破。它将存储分为两个半空间A和B。首先使用某个半空间。比如说A，来满足分配请求，直到它被填满。此时垃圾回收器开始工作，将可达对象拷贝到另一个半空间，也就是B，然后对换两个半空间的角色。
* **增量式回收器**-简单的基于跟踪的回收器在垃圾回收期间会停止用户程序的执行。增量式回收器让垃圾回收过程和用户程序（或者说增变者）交错运行。增变者可能干扰增量式可达性分析，因为它可能改变之前已扫描对象中的引用。因此，增量式回收器通过超量估计可达对象的集合，达到安全工作的目标。所有的“漂浮垃圾”可以在下一轮回收中被删除。
* **部分回收器**-同样可以减少停顿时间，每次只回收一部分垃圾。最有名的部分垃圾回收算法是世代垃圾回收方法，它根据对象已分配时间的长短对对象分区，对新建对象进行更频繁的回收操作，因为它们的生命周期通常较短。另一个算法列车算法使用固定长度的被称为车厢的区域。这些车厢被组织成列车。每一个回收步骤都处理尚存的第1辆列车中的当前第一节车厢。当第一节车厢被回收时，可达对象被移动到其他车厢中，这节车厢中最终只剩下垃圾，因此可以将其从该列车中删除 

## 第八章：代码生成

编译器模型的最后一步是代码生成器，它以编译器前端生成的**中间表示(IR)**和相关的符号表信息作为输入，输出语义等价的目标程序。

对代码生成器的要求是很严格的。目标程序必须保持源程序语义的含义，还必须要很高的质量。也就是说，它必须有效地利用目标机器上的可用资源。此外，代码生成器本身必须能够高效运行。

从数学上讲，为给定源程序生成一个最优的目标程序是不可判定问题，在代码生成中碰到的很多子问题（比如寄存器分配）都具有难以处理的计算复杂性。在实践中，必须使用那些能够产生良好但是不一定最优的代码启发性技术。

代码生成器主要有三个任务

* 指令选择
* 寄存器分配和指派
* 指令排序

很多代码生成器把IR指令分成“基本块”，每个基本块由一组总是一起执行的指令组成

### 代码生成器设计中的问题

虽然代码生成器设计依赖于中间表示形式，目标语言和运行时刻系统的特定细节但指令选择，寄存器分配和指派以及指令排序等任务会在几乎所有的代码生成器设计中碰到。

代码生成器最重要的标准是生成正确的代码。正确性问题非常突出的原因是代码生成器会碰到很多特殊情况。在优先考虑正确性的情况下，另一个重要的设计目标是把代码生成器设计的易于实现，测试和维护。

#### 代码生成器的输入

代码生成器的输入是由前端生成源程序的中间表示形式以及符号表中的信息组成的。这些信息用来确定IR中的名字所指的数据对象的运行时刻地址。

IR的中间表示形式的选择有很多，包括诸如四元式，三元式，间接三元式等三地址表示方式；也包括诸如字节代码和和堆栈机代码的虚拟机表示方式；包括诸如后缀表示的线性表示方式；还包括诸如语法树和DAG的图形表示方式。

首先假设前端已经扫描，分析了源程序，并把它转化为了相对低层次的中间表示形式，因此在IR中出现的名字的值可以能被目标机直接处理的量来表示。这些量可以是整数，浮点数等。还假设所有的语法和静态语义错误都能被检测出来，必要的类型检查都已经完成，而类型转换运算已经被插入到必要的地方。

#### 目标程序

构造一个能够产生高质量机器代码的代码生成器的难度会受到目标机器的指令集体系结构的极大影响。最常见的目标体系结构是RISC(精简指令计算机)，CISC(复杂指令计算机)和基于堆栈的结构。

RISC机通常有很多寄存器，三地址指令，简单的寻址方式和一个相对简单的指令体系结构。相反，CISC机通常具有较少寄存器，辆地址指令，多种寻址方式，多种类型的寄存器，可变长度的指令具有副作用的指令。

在基于栈的机器中，运算是通过把运算分量压入一个栈，然后再对栈顶的运算分量进行运算而完成的。为了获得高性能，栈顶元素通常保存在寄存器中。

对于Java，JVM是一个Java字节码的软件解释器。字节码是由Java编译器生成的一种中间语言。这个解释器提供了跨平台的软件兼容性。

解释执行会引起很高的性能损失，有时可能达到10倍的数量级。为了解决这个问题，可以使用**即时(Just-In-Time JIT)**Java编译器。这些即时编译器在运行时刻把字节码翻译成目标机上的本地硬件指令集。另一个提高Java程序性能的方法是建立一个编译器，把Java程序直接编译成目标机器指令，彻底绕过字节码。

输出一个使用绝对地址的机器语言程序优点是程序可以放在某个内存中的某个固定位置上，并立即执行，程序可以很快的进行编译和执行。

输出可重定位的机器语言程序(通常称为目标模块，object module)可以使各个子程序能够被分别编译。一组可重定位的目标模块可以被一个链接加载器链接到一起并加载运行。

输出一个汇编程序使代码生成过程变得稍微容易一些。可以生成符号指令，并使用汇编器的宏机制来帮助生成代码。这么做的代价是代码生成之后还需要增加一个汇编步骤。

#### 指令选择

代码生成器必须把IR程序映射成可以在目标机上运行的代码序列。完成这个映射的复杂性由如下的因素决定：

* IR的层次
* 指令集体系结构本身的特性
* 想要达到的生成代码的质量

如果IR是高层次的，代码生成器就要使用代码模版把每个IR语句翻译成机器指令序列。但是，这种逐个语句生成代码的方式通常会产生质量不佳的代码。这些代码需要进一步优化。如果IR中反映了相关计算机的某些低层次细节。那么代码生成器就可以使用这些信息来生成更加高效的代码序列。

目标机指令集本身的特性对指令选择的难度有很大的影响。比如，指令集的统一性和完整性是两个很重要的因素。如果目标机没有以统一的方式支持每种数据类型，那么总体规则的每个例外都需要进行特别处理。比如在某些机器上，浮点数运算使用单独的寄存器完成。

形如`x = y + z`的三地址语句可以被翻译成如下的代码序列：

```asm
L0 R0, y         ;R0 = y   
ADD R0, R0, z    ;R0 = R0 + z
ST x, R0         ;x = R0
```

这种策略常常会产生冗余的加载和存储运算。比如，下面的三地址语句序列：

```asm
a = b + c
d = a + e
```

会被翻译成

```
LD R0, b        ;R0 = b
ADD R0, R0, c   ;R0 = R0 + c
ST a, R0        ;a = R0
LD R0, a        ;R0 = a
ADD R0, R0, e   ;R0 = R0 + e
ST d, R0        ;d = R0
```

上面的第4个语句是冗余的，因为它加载了一个刚刚保存到内存的值。并且如果a以后不再被使用，那么第3个语句也是冗余的。

在大多数机器上，一个给定的IR程序可以用很多种不同的代码序列来实现。这些不同的实现之间在代价上有显著的差别。因此，对中间代码的简单翻译虽然能产生正确的目标代码，但是这些代码却可能过于低效而让人难以接受。

比如，如果目标机有一个**加一指令(INC)**。那么三地址指令`a = a + 1`可以用`INC a`来实现。

#### 寄存器分配

代码生成的关键问题之一是决定哪个值放在哪个寄存器里面。寄存器的目标机上运行速度最快的计算单元，但是通常没有足够的寄存器来存放所有的值。没有存放在寄存器中的值必须存放在内存中。使用寄存器运算分量的指令总是要比那些运算分量在内存中的指令短并且快。因此，有效利用寄存器非常重要。

寄存器的使用经常被分解成为两个子问题。

* **寄存器分配**-对于源程序中的每个点，选择一组将被存放在寄存器中的变量。
* **寄存器指派**-指定一个变量被存放在哪个寄存器中。

即使对于单寄存器机器，找到一个从寄存器到变量的最优指派也是很困难的。从数学上讲，这个问题是NP完全的。而且，目标机的硬件和/或操作系统可能要求代码遵守特定的寄存器使用规则，从而使这个问题变得更加复杂。

例：有些机器要求为某些运算分量和结果使用寄存器对(即一个偶数号寄存器和相邻的奇数号寄存器)。比如，在某些机器上，整数乘法和整数除法就涉及寄存器对。乘法的指令如下：

```asm
M x, y
```

其中被乘数x是偶数/奇数寄存器对中的奇数号寄存器，而乘数y则可以存放在任意位置。乘法结果占据了整个偶数/奇数寄存器时，除法形式的指令如下：

```asm
D x, y
```

其中，被除数占据了整个偶数/奇数寄存器对，x是其中的偶数号寄存器；而除数是y。相除之后，偶数号寄存器保存余数，而奇数号寄存器保存商。

三地址代码

```
t = a + b
t = t * c
t = t / d
```

最优机器代码序列

```
L  R1, a
A  R1, b
M  R0, c
D  R0, d
ST R1, t
```

三地址代码

```
t = a + b
t = t + c
t = t / d
```

最优机器代码序列

```
L  R1, a
A  R1, b
A  R0, c
SRDA R0, 32
D  R0, d
ST R1, t
```

Ri表示第i号寄存器。SRDA表示双算术右移，而`SDRA R0 32`把被除数从R0中移人到R1并把R0清空，使得所有位都等于被除数的正负号位。L，ST和A分别表示加载，保存和相加。需要注意的是，把a加载到哪个寄存器的最优选择依赖于最终会对t做什么样的运算。

#### 求值顺序

计算执行的顺序会影响目标代码的效率。但在一般问题下，好到最好的顺序是一个困难的NP完全问题。

### 目标语言

#### 一个简单的目标机模型

目标计算机是一个三地址机器的模型，它具有加载和保存操作，计算操作，跳转操作和条件跳转。这个计算机的内存按照字节寻址它具有n个通用寄存器R0，R1，...,Rn-1。一个完整的汇编语言具有几十到上百个指令。将只使用一个很有限的指令集合，并假设所有的运算分量都是整数。大部分指令包含一个运算符，然后是一个目标地址，最后是一个源运算的分量列表。指令之前可能有一个标号。假设有如下种类的指令可用：

* **加载运算**-`LD dst`
* **保存运算**-`ST x`
* **计算运算**-`OP dst src1, src2`
* **无条件跳转**-`BR L`
* **条件跳转**-`Bcond r, L`

假设目标机有多种寻址方式

* 在指令中，一个位置可以是一个变量名x，它指向分配给x的内存位置(即x的左值)
* 一个位置可以是一个带有下标的形如a(r)的地址，其中a是一个变量，而r是一个寄存器。a(r)所表示的内存位置按照如下方式计算得到：a的左值加上存放在寄存器r中的值。比如，指令`LD R1, a(R2)`的效果是`R1 = contents(a + contents(R2))`，其中`contents(x)`表示x所代表的寄存器或内存位置中存放的内容。这个寻址方式可以用于沿指针取值。
* 还支持另外两种间接寻址模式：`*.r`表示在寄存器r的内容所表示的位置上存放的内存位置。
* 直接常数寻址模式。在常数前面加一个前缀`#`，指令`LD R1, #100`把整数100加载到R1中，而`ADD R1, R1, #100`则把100加到寄存器R1中去。

三地址语句`z = x - y`可以使用下面的机器指令序列实现：

```asm
LD R1, y  ; R1 = y
LD R2, z  ; R2 = z
SUB R1, R1, R2  ; R1 = R1 - R2
ST x, R1        ; x = R1
```

#### 程序和指令的代价

确定编译和和运行一个程序的实际代价是一个复杂的问题。总之，为一个给定的源程序找出一个最优的的目标程序是一个不可判定问题，而很多相关的子问题都是NP困难的。

把一个指令的代价设定为1加上与运算分量寻址模式相关的的代价。这个代价对应于指令中字的长度。寄存器寻址模式具有的附加代价为0，而涉及内存位置或常数的寻址方式的附加代价为1。

假设对于一个指定的输入，目标语言程序的代价是当此程序在输入上运行时所执行的所有指令的代价总和。优秀的代码生成算法的目标是使得程序在典型输入上运行时所执行的指令代价总和最小。

### 目标代码中的地址

每个正在执行的程序需要在它的逻辑地址空间上运行。这个空间被划分为四个代码及数据区域：

* 一个静态确定的代码区Code。这个区存放可执行的目标代码。目标代码的大小可以在编译时刻确定
* 一个静态确定的静态数据区Static。这个区存放全局常量和编译器生成的其他数据。全局常量和编译器数据的大小也可以在编译时刻确定
* 一个动态管理的堆区Heap。这个区存放程序运行时刻分配和释放的数据对象。Heap的大小不能在编译时刻静态确定。
* 一个动态管理的栈区Stack。这个区存放过程的活动记录。活动记录会随着过程的调用和返回被创建和消除。和堆区一样，栈区的大小也不能在编译时刻确定。

#### 静态分配

关注下面的三地址语句

* call callee
* return
* halt
* action

活动记录的大小和布局是由代码生成器通过存放于符号表中的名字的信息来确定的。假设活动记录的第一个位置存放返回地址。

首先考虑最简单的情况(即静态分配)时的代码。这里，中间代码中`call callee`语句可以包含两个目标机指令的序列来实现：

```
ST callee.staticArea, #here+20
BR callee.codeArea
```

ST指令把返回地址保存到callee的活动记录的开始处，而BR把控制传递到被调用过程callee的目标代码上。属性callee.staticArea是一个常量，给出了callee的活动记录开始处的地址，而属性callee.codeArea也是一个常量，指向运行时刻内存中Code区中被调用过程callee的第一个指令的地址。

ST指令中的运算分量`#here+20`是返回地址的文字表示，它是紧跟在BR指令之后的指令的地址。假设`#here`是当前指令的地址，而调用序列中的三个常量加上两个指令的长度为5个字，即20个字节。

过程代码的结尾处是一个返回到调用者过程的指令。但是没有调用者的第一个过程例外，它的最后一个指令是HALT。这个指令把控制返回给操作系统。一个return语句可以使用一个简单的跳转语句实现：

```
BR *callee.staticArea
```

它把控制流到保存在callee的活动记录开始位置的地址上。
 
#### 栈分配

如果在保存活动记录时使用相对地址时，静态分配就可以变成栈分配。但是在栈分配方式中，只有等到运行时刻才能知道一个过程的活动记录的位置。这个位置通常存放在一个寄存器里面，因此活动记录中的字可以通过相对于寄存器中值的偏移量来访问，目标机的下标地址模式可以方便的完成这种访问。

活动记录的相对地址可以用于相对于活动记录中的任一已知位置的偏移量来表示。为方便起见，将在寄存器SP中维护一个指向栈顶的活动记录的开始处的指针，这样就可以使所有的偏移量都是正数。当发生过程调用时，调用过程增加SP的值，并把控制传递到被调用过程。在控制返回到调用者时，减少SP的值，从而释放被调用过程的活动记录。

第一个过程的代码把SP设置成内存中栈区的开始位置，完成对栈的初始化。

#### 名字的运行时刻地址

存储分配策略以及过程的活动记录中局部数据的布局决定了如何访问名字对应的内存位置。在任何情况下，名字必须最终被替代为访问存储位置的代码。考虑简单的三地址拷贝语句`x = 0`的细节，假设在处理完一个过程的声明部分后，x的符号条目包含了x的相对地址12。如果x被分配在一个从地址static开始的静态分配区域中，那么x的实际运行时刻地址是`static + 12`。虽然编译器最终可以在编译时刻确定`static + 12`的值，但是在生成访问该名字的中间代码时还可能不知道静态区域的位置。在这种情况下， 生成“计算”`static + 12`的三地址代码是有意义的。这个计算在程序运行之前就会完成：它或者在代码生成阶段完成，或者由加载器完成。那么，赋值语句`x = 0`被翻译成
```
static[12] = 0
```
如果静态区从地址100开始，这个语句的目标代码是
```
LD 122, #0
```

### 基本块和流图

一种用图来表示中间代码的方法。即使这个图没有显式地被代码生成算法生成。上下文信息有助于更好地生成代码。如果知道程序中的值是如何被定值和使用的，就可以更好地分配寄存器。因此这个方法可以按照如下方式构造：

* 把中间代码划分成为基本块，每个基本块是满足下列条件的最大的连续三地址指令序列。
1. 控制流只能从基本块中的第一个指令进入该块。也就是说，没有跳转到基本块中间的转移指令
2. 除了基本块中的最后一个指令，控制流在离开基本块之前不会停机或跳转
* 基本块形成了流图的结点。而流图的边指明了哪些基本块可能紧随一个基本块之后运行。

#### 基本块

以第一个指令作为基本块的开始，然后不断地把后续指令加进去，直到碰到一个无条件跳转，条件跳转指令或者下一个指令前面的标号为止。当没有跳转和标号时，控制流直接从下一个指令到达下一个指令。

**算法8.5 把三地址指令序列划分成基本块**

输入：一个三地址指令序列
输出：输入序列对应的一个基本块列表，其中每个指令恰好被分配给一个基本块。
方法：首先，确定中间代码序列中哪些指令是首指令，即某个基本块的第一个指令。跟在中间程序末端之后的指令不包含在首指令集合中，选择首指令的规则如下：

* 中间代码的第一个三地址指令是一个首地址
* 任意一个条件或无条件转移指令的目标指令是一个首指令
* 紧跟在一个条件或无条件转移指令之后的指令是一个首指令

然后，每个首指令对应的基本块包括了从它自己开始，直到下一个首指令(不含)或者中间程序的结尾指令之间的所有指令。

#### 后续使用信息

知道一个变量的值接下来会在什么时候使用对于良好的代码是非常重要的。如果一个变量的值当前存放在一个寄存器中，且之后一直不会被使用，那么这个寄存器就可以分派给另一个变量。

在一个三地址语句中对一个名字的**使用(use)**的定义如下。假设三地址语句i给x赋了一个值。如果语句j的一个运算分量为x，并且从语句i开始可以通过未对x进行赋值的路径到达语句j，那么说语句j使用了在语句i处计算得到的x的值，可以进一步说x在语句i处活跃。

**算法8.7 对一个基本块中的每一个语句确定活跃性与后续使用信息**

输入：一个三地址语句的基本块B，假设在开始的时候符号表显示B中的所有非临时变量都是活跃的
输出：对于B的每一个语句i：`x = y + z`，将x，y及z的活跃性信息及后续使用信息关联到i
方法：从B的最后一个语句开始，反向扫描到B的开始处。对于每个语句i：`x = y + z`，做下面的处理：

* 把在符号表中找到有关的x，y和z的当前后续使用和活跃性信息与语句i关联起来。
* 在符号表中，设置x为“不活跃”和”无后续使用“
* 在符号表中，设置y与z为“活跃”，并把它们下一次使用设置为语句i。

使用+作为代表任意运算符的符号。如果三地址语句i形如`x = +y`或者`x = y`，那么处理步骤仍然和上面相同。只是忽略了对z的处理。

#### 流图

当将一个中间代码程序划分成基本块之后，用一个流图来表示它们之间的控制流。流图的结点就是这些基本块。从基本块B到基本块C之间有一条边当且仅当基本块C的第一个指令可能紧随跟在B的最后一个指令之后执行。村子这样一条边的原因有两种：

* 有一个从B的结尾跳转到C的开头的条件或无条件跳转语句
* 按照原来的三地址语句序列中的顺序，C紧跟在B之后，且B的结尾不存在无条件跳转语句

说B是C的**前继(predecessor)**，而C是B的一个**后继(successor)**，通常会增加称为入口和出口的两个结点，它们不和任何中间指令对应。从入口到流图的第一个可执行结点(即包含了中间代码的第一个指令的基本块)有一条边。从任何包含了可能是程序的最后执行指令的基本块到出口有一条边。如果程序的最后指令不是一个无条件转移指令，那么包含了程序的最后一条指令的基本块是出口结点的一个前驱。但任何包含了跳转程序到程序之外的跳转指令的基本块也是出口结点的前驱。

#### 流图的表示方式

流图就是通常的图，它可以用任何适合表示图的数据结构来表示。结点(即基本块)的内容需要有它们自己的表示方式。可以用一个指向该基本块在三地址指令数组中的首地址的指针，再加上基本块的指令数量或一个指向结尾指令的指针来表示结点的内容。但是，因为可能会频繁改变一个基本块中的指令数量，所以为每个基本块创建一个指令链表是一种高效的表示方法。

#### 循环

事实上每个程序会花很多时间执行循环`for`,`while`,`do-while`，所以对于一个编译器来说，为循环产生优良的代码就变得非常重要。很多代码转换依赖于对流图中“循环”的识别。如果下列条件成立，就说流图中的一个结点集合L是一个循环。

* 在L中有一个被称为循环入口的结点，它是唯一的其前驱可能在L之外的结点。也就是说，从整个流图的入口结点开始到L中的任何结点的路径都必然经过循环入口的结点，并且这个循环入口结点不是整个流图的入口结点本身
* L中的每个结点都有一个到达L的入口结点的非空路径，并且该路径全部在L中。

### 基本块的优化

仅仅通过对基本块本身进行局部优化，就常常可以实质性地降低代码运行所需的时间。

#### 基本块的DAG表示

很多重要的优化技术首先把一个基本块转换成一个DAG(有向无环图)。为一个基本块构造DAG的方法：

* 基本块中出现的每个变量有一个对应的DAG的结点表示其初值
* 基本块中的每个语句s都有一个相关的结点N。N的子结点是基本块中的其他语句的对应结点。这些语句是在s之前，最后一个对s所使用的某个分量进行定值的语句
* 结点N的标号是s中的运算符；同时还有一组变量被关联到N，表示s是在此基本块内最晚对这些变量定值的语句。
* 某些结点被指明为输出结点。这些结点的变量在基本块的出口处活跃。也就是说，这些变量的值可能以后会在流图的另一个基本块中被使用到。计算得到这些“活跃变量”是全局数据流分析的问题。

基本块的DAG表示使得可以对基本块所代表的代码进行一些转换，以改进代码质量。

* 可以消除局部公共子表达式。所谓公共子表达式就是重复计算一个已经计算得到的值的指令，
* 可以消除**死代码(dead code)**，即计算得到的值不会被使用的指令
* 可以对相互独立的语句进行重新排序，这样的重新排序可以降低一个临时值需要保持在寄存器中的作用
* 可以使用代数规则来重新排列三地址指令的运算分量的顺序。这么做有时可以简化计算过程。

#### 寻找局部公共子表达式

检测公共子表达式的方法是这个样子的，当一个新的结点M将被加入到DAG中时，检查是否存在一个结点N，它和M具有同样的运算符和子结点，且子结点顺序相同。如果存在这样的结点，N计算的值和M计算的值是一样的，因此可以用N替换M。

#### 消除死代码

在DAG上消除死代码的操作可以按照如下方式实现。从一个DAG上删除所有没有附加的活跃变量的根结点(即没有父结点的结点)。重复应用这样的处理过程就可以从DAG中消除所有对应于死代码的结点。

#### 代数恒等式的使用

代数恒等式表示基本块的另一类重要的优化方法，如可以使用如下的恒等式来从一个基本块中消除计算步骤：

```
x + 0 = 0 + x = x  x - 0 = x
x * 1 = 1 * x = x  x / 1 = x
```

另一类代数优化是局部**强度消减(reduction in strength)**，就是把一个代价较高的运算替换为一个代价较低的运算，如：

代价较高的|代价较低的
-|-
$$x^2$$|$$x \times x$$
$$2 \times x$$|$$x + x$$
$$x / 2$$|$$x \times 0.5$$

第三种相关的优化是常量合并(constant folding)。使用这种方法时，在编译时刻对常量表达式求值，并把此常量表达式替换为求出的值。因此，表达式`2 * 3.14`可以被替换为`6.28`。

结合律也可以用于揭示公共子表达式。比如：
```
a = b + c;
e = c + d + b;
```
可能生成下面的中间代码:
```
a = b + c;
t = c + d;
e = t + b;
```
如果t没有在基本块之外使用，通过应用+的交换律和结合律，可以把这个序列改为：
```
a = b + c;
e = a + d;
```

*注意：计算机算术因为溢出等原因可能不一定遵守数学上的代数恒等式*

#### 数组引用的表示

在DAG中，表示数组正确访问的正确方法如下：

* 从一个数组中取值并赋值给其他变量的运算（如`x = a[i]`)用一个新创建的运算符为`= []`的结点表示。这个结点的左右子结点分别代表数组初始值和下标i，变量x是这个结点的标号之一。
* 对数组的赋值用一个运算符`[] =`的结点来表示，这个结点的三个子结点分别表示a0，j和y。没有变量用这个结点标号。不同之处在于此结点的创建杀死了所有当前已经建立的，其值依赖于a0的结点。一个被杀死的结点不可能再获得任何标号，它们不可能成为一个公共子表达式。

#### 指针赋值和过程调用

当像下面的赋值语句

```
x = *p
*q = y
```

那样，通过指针进行间接赋值时，并不知道p和q指向哪里。从效果看，`x = *p`是对任意变量的使用，而`*q = y`可能对任意一个变量赋值。其结果是，运算符`*=`必须把当前所有带有附加标识符的结点当作参数。但是这么做会影响死代码的消除过程。`* =`运算符会把至今为止构造出来的DAG中的其他结点全部杀死。

可以进行一些全局指针分析，以便把一个指针在代码中某个位置上可能指向的变量限制在一个较小的子集内。即使是局部分析也可能限制一个指针指向的范围。比如，对于下面的序列:

```
p = &x
*p = y
```

知道是x（而不是其他变量）被赋予y的值。因此，只需要杀死以x为附加变量的结点，不需要杀死其他结点。

过程调用和通过指针赋值很相似，在缺乏全局数据流信息的情况下，必须假设一个过程调用使用和改变了它访问的所有数据。因此，如果变量x在一个过程P的访问范围之内，对P的调用不仅使用了以x为附加变量的结点，还杀死了这个结点。

#### 从DAG到基本块的重组

对DAG的各种优化处理可以在生成DAG图时进行，也可以在DAG构造完成后通过对DAG的运算完成。在完成这些处理优化后，就可以根据优化得到的DAG重组生成相应基本块的三地址代码。对每个具有一个或多个附加变量的结点，构造一个三地址语句来计算其中某个变量的值。倾向于把计算得到的结果赋给一个在基本块出口处的活跃的变量。但是，如果没有全局活跃变量的信息作为依据，就要假设程序的所有变量都在基本块的出口处活跃(但是不包含编译器为了处理表达式而生成的临时变量)。

如果结点有多个附加的活跃变量，就必须引入复制语句，以便给每一个变量都赋予正确的值。有时我们可以通过全局优化技术，设法用其中的一两个变量来替代其他变量，从而消除这些复制语句。

当从DAG重构基本块时，不仅要关心用哪些变量来存放DAG中结点的值，还要关心计算不同结点值的指令的顺序。应该记住如下规则：

* 指令的顺序必须遵守DAG中的结点的顺序。
* 对数组的赋值必须跟在所有在它之前的对同一数组的赋值或求值运算之后
* 对数组元素的求值必须跟在所有在它之前的对同一数组的赋值指令之后。对同一数组的两个求值运算可以交换顺序，只要在交换时它们都没有越过某个对同一数组的赋值运算即可
* 一个变量的使用必须跟在所有在它之前的过程调用或指针间接赋值运算之后
* 任何过程调用或者指针间接赋值都必须跟在所有在它之前的对任何变量的求值运算之后

也就是说，当重组代码的时候没有一个语句可以跨越过程调用或指针间赋值运算。只有在两个使用同一数组的指令都是数组访问而不是对数组元素赋值时，它们才可以交换顺序

### 一个简单的代码生成器

在代码生成器中的主要问题之一是决定如何最大限度地利用寄存器。寄存器主要有以下4种使用方法：

* 在大部分机器的体系结构中，执行一个运算时该运算的部分或者全部运算分量必须存放在寄存器中
* 寄存器很适合作临时变量，即在计算一个大表达式时存放其子表达式的值。或者更一般地讲，寄存器适合用于存放只在单个基本块内使用的变量的值
* 寄存器用来存放在一个基本块中计算而在另一个基本块中使用的全局值。
* 寄存器经常用来帮助进行运行时刻的存储管理。比如，管理运行时刻栈包括栈指针的维护，栈顶元素也可能被存放在寄存器中

#### 寄存器和地址描述符

代码生成器算法依次考虑了各个三地址指令，并决定需要哪些加载指令来把必需的运算分量加载进寄存器。在生成加载指令后，开始生成运算代码。然后，如果有必要把结果存放入一个内存位置，它还会生成相应的保存指令。

为了做出这些必要的决定，需要一个数据结构来说明哪些程序变量的值当前被存放在哪个或哪些寄存器里面。还需要知道当前存放在一个给定变量的内存位置上的值是否就是这个变量的正确值。因为变量的新值可能已经在寄存器中计算出来但还没有存放到内存中。这个数据结构具有下列描述符：

* 每个可用的寄存器都有一个**寄存器描述符**
* 每一个程序变量都有一个**地址描述符**

#### 代码生成算法

这个算法的一个重要福分是函数`getReg(I)`。这个函数为每个与三地址指令I有关的内存位置选择寄存器。函数`getReg`可以访问这个基本块的所有变量对应的寄存器和地址描述符。这个函数还可能需要获取一些有用的数据流信息，比如哪些变量在基本块出口处活跃。

在一个形如`x = y + z`的三地址指令中，将把`+`当作一般的运算符，而ADD当作等价的机器指令。因此，没有利用`+`的交换性。这样，当实现这个运算时，`y`的值必须在ADD指令中给出的第二个寄存器中，而绝不会是第三个寄存器。可以按照下面的方法来改进算法：只要是`+`是一个满足交换律的运算符，算法同时为`x = y + z`和`x = z + y`生成代码；随后再选择一个比较好的代码序列。

**运算的机器指令**

对每个形如`x = y + z`的三地址指令，完成下列步骤:

* 使用`getReg(x = y + z)`来为x，y，z选择寄存器。把这些寄存器称为Rx,Ry和Rz
* 如果y不在Ry中，那么生成一个指令`LD Ry, y'`，其中`y'`是存放y的内存位置之一
* 类似地，如果z不在Rz内，生成一个指令`LD Rz, z'`，其中`z'`是存放z的位置之一。
* 生成指令`ADD Rx', Ry', Rz`

**赋值语句的机器指令**

形如`x = y`的三地址指令是一个重要的特例，假设`getReg`总是为x和y选择同一个寄存器。如果y没有在寄存器Ry中，那么生成机器指令`LD Ry', y`。如果y已经在Ry中，不需要做任何事情。只需要修改Ry的寄存器描述符，表明Ry中也存放了x的值。

**基本块的收尾处理**

在代码结束的时候，基本块中使用的变量可能仅存放在某个寄存器中。如果这个变量是一个只在基本块内部使用的临时变量，就没有问题；当基本块结束时，可以忘记这些临时变量的值并假设这些寄存器是空的。但如果一个变量在基本块的出口处活跃，或者我们不知道哪些变量在出口处活跃，那么就必须假设这个变量的值会在以后被用到。

#### 函数getReg的设计

实现这个函数可以选择多种方法。使用`x = y + z`作为一般性的例子，首先必须为y和z分别选择一个寄存器。这两次选择所面临的问题相同，因此将集中考虑为y选择寄存器Ry的方法，选择规则如下：

* 如果y当前就在一个寄存器中，则选择一个已经包含了y的寄存器作为Ry。不需要生成一个机器指令来把y加载到这个寄存器
* 如果y不在寄存器中，但是当前存在一个空寄存器，那么选择这个空寄存器作为Ry
* 比较困难的情况是y不在寄存器中也没有空寄存器。设R是一个候选寄存器，且假设v是R的寄存器描述符表明的已位于R中的变量。需要保证要么v的值已经不会被再次使用，要么还可以到别的地方获取v的值。可能的情况包括：

1. 如果v的地址描述符说v还保存在R之外的其他地方，就完成了任务。
2. 如果v是x，即由指令I计算的变量，且x不同时是指令I的运算分量之一，就完成了任务。
3. 否则，如果v不会在此之后被使用，那么就完成了任务
4. 如果前面的三个条件都不满足，就需要生成保存指令`ST v, R`来把v的值复制到它自己的内存位置上去。这个操作称为**溢出操作(spill)**

因为在那个时刻R可能存放了多个变量的值，所以我们需要对每个这样的变量v重复上述步骤。最后R的得分是需要生成的保存指令的个数。选择一个具有最低得分的寄存器(或之一)。

Rx寄存器和Ry寄存器选择的区别：

* 因为x的一个新值正在被计算，因此只存放了x的值的寄存器对Rx来说总是可接受的。即使x就是y或者z之一。
* 如果y在指令I之后不再使用，且Ry仅仅保存了y的值，那么Ry同时也可以用作Rx。对z和Rz也有类似选择

*注意：需要特别考虑的问题是当I是复制指令`x = y`时，利用上面描述的方法选择Ry，最后令Rx=Ry*

### 窥孔优化

另一种优化代码的策略：先生成原始嗲吗，然后对目标代码进行“优化”转换，提高目标代码的指令，但是不能使用任何数学度量之下都是最优的。

一个简单有效且用于局部改进目标代码的技术是**窥孔优化(peephole optimization)**。它在优化的时候检查目标指令的一个滑动窗口。窥孔优化技术并不要求在窥孔中的代码一定是连续的，尽管有些实现要求代码连续。

具有窥孔优化特点的程序变换的例子：

* 冗余指令消除
* 控制流优化
* 代数化简
* 机器特有指令的使用

#### 消除冗余的加载和保存指令

如果在目标程序中看到指令序列

```
LD R0, a
ST a, R0
```

就可以删除其中的保存指令，因为不管这个保存指令何时执行，第一个指令保证a的值已经被加载到寄存器R0中。为了保证的这样的转换是安全的，这两个指令必须在同一个基本块内。

这种类型的冗余加载/保存指令不会由简单代码生成算法生成。

#### 消除不可达代码

另一个窥孔优化的机会是消除不可达的指令。一个紧跟在无条件跳转之后的不带标号的指令可以被删除。通过重复这个运算，就可以删除一个指令序列。比如，为了调试的目的，一个大型程序中可能含有一些只有当变量debug等于1时才运行的代码片段。在中间表示形式中，这个代码看起来可能就像:

```
    if debug == 1 goto L1
L1: print debugging information
L2: 
```

一个显而易见的窥孔优化方法是消除级联跳转指令。因此不管debug的值是什么，上面的代码序列可以被替换为：

```
    if debug != 1 goto L2
    print debugging information
L2: 
```

如果debug在程序开始的时候被设置为0，常量传播优化将把这个序列转换为:

```
    if 0 != 1 goto L2
    print debugging information
L2: 
```

#### 控制流优化

简单的中间代码生成算法经常生成目标为无条件跳转指令的无条件跳转指令，到达条件跳转指令的无条件跳转指令，或者到达无条件跳转指令的条件跳转指令。这些不必要的跳转指令可以通过下面几种窥孔优化技术从中间代码或者目标代码中消除。可以把序列

```
    goto L1
    ...
L1: goto L2
```

替换为

```
    goto L2
    ...
L1: goto L2
```

如果没有跳转到L1的指令，并且语句`L1: goto L2`之前是一个无条件跳转指令，所以可以消除这个语句。

类似地，序列

```
    if a < b goto L1
    ...
L1: goto L2
```

可以被替换为序列

```
    if a < b goto L2
    ...
L1: goto L2
```

最后，假设只有一个到达L1的跳转指令，且L1之前是一个无条件跳转指令，那么序列

```
    goto L1
    ...
L1: if a < b goto L2
L3: 
```

可以被替换为序列

```
    if a < b goto L2
    goto L3
    ...
L3:  
```

虽然两个序列中的指令个数相同，但是在第二个序列中有时可以跳过无条件跳转指令，而在第一个序列中却不可能。因此，第二个序列的运行时间要优于第一个序列的运行时间。

#### 代数化简和强度消减

代数恒等式也可以被窥孔优化器用于消除窥孔中类似于：

```
x = x + 0
或者
x = x * 1
的三地址语句
```

类似地，强度消减转换也可以应用到窥孔中，把代价比较高的运算替换为目标机器上代价较低的等价运算。有些机器指令和另一些指令相比其代价要低很多，经常被当作相应的高代价运算的特殊情况来使用。比如，用`x * x`实现`x^2`的代价总是比通过调用求幂函数实现`x^2`的代价要低。对于乘数(除数)为2的幂的定点数乘法(除法)，用移位运算实现的代价要低一些。除数为常数的浮点数除法可以通过乘数为该常量倒数的乘法来求近似值。

#### 使用机器特有的指令

目标机可能会有一些能够高效实现某些特定运算的硬件指令。检测允许使用这些指令的情况可以显著地降低运行时间。比如，有些机器具有自动增量和自动减量的寻址模式。这些指令在使用一个运算分量的值之前或之后，将运算分量的值自动加一或减一。在参数传递时的压栈或出栈运算中使用这个模式可以大大提高代码的质量。

### 寄存器分配和指派

只涉及寄存器运算分量的指令要比那些涉及内存运算分量的指令运行得快。在现代的机器上，处理器速度要比内存速度快一个数量级以上。因此，寄存器的有效利用对生成优质代码是非常重要的。

寄存器分配和指派的方法之一是把目标程序中的特定值分配给特定的寄存器。比如，可以确定把基地址指派给一组寄存器，算术计算则使用另一组寄存器，栈顶指针指派给一个固定的寄存器，等等。

这个方法的优点是使代码生成器的设计变得简单。但因为它的应用有太多限制，所以寄存器的使用效率较低：有些被占用的寄存器在相当数量的代码运行中没有被使用到，同时却不得不生成很多不必要的其他寄存器的加载和保存运算指令。

在大多数计算环境中还是要保留一些寄存器。这些被保留的寄存器可以被用作基地址寄存器，栈顶指针寄存器或者其他类似的用途。

#### 全局寄存器分配

全局寄存器分配的策略之一是分配固定多个寄存器来存放每个内部循环中最活跃的值，在不同的循环中所选择的值也有所不同。这个方法的缺点是固定的寄存器个数并不总是恰好等于用于全局寄存器分配的最佳数量，但是实现起来很简单。

#### 使用计数

通过在循环L运行时把一个变量x保存在寄存器里面，可以节省从内存中加载x的开销。如果把x分配在寄存器中，对x的每一次引用可以节省一个单位的成本。如果能够避免在某个基本块的结尾把x保存回内存，也可以省略2个单位的开销：保存指令和之后的加载指令。

在支出方面，如果x在循环头部的入口处活跃，必须在进入循环L之前把x加载到它的寄存器中。这个加载的成本是两个成本单元。类似地，对于循环L的每个出口基本块B，如果x在B的某个L之外的后继入口处活跃，必须以两个单位的代价把x保存起来。

#### 外层循环的寄存器指派

在为内层循环指派寄存器并生成代码之后，可以把同样的想法应用到更大的外围循环上去。如果一个外层循环L1包含一个内层循环L2，在L2中分配的寄存器名字不一定要在L1-L2部分也分配到一个寄存器。然而，如果决定在L2中(而不是在L1中)为x分配一个寄存器，必须在L2的入口处加载x，而在L2的出口处保存x。把在外层循环L中选择为哪些名字分配寄存器的标准留作练习，在选择时假设已经为所有嵌套在L内部的循环完成了名字选择。

#### 通过图着色方法进行寄存器分配

当计算中需要一个寄存器，但所有可用寄存器都在使用时，某个正被使用的寄存器的内容必须被保存(溢出)到一个内存位置上，以便释放出一个寄存器。图着色方法是一个可用于分配寄存器和管理寄存器溢出的简单且系统化的技术。

这个方法需要进行两趟处理。在第一趟处理中选择目标机器指令，处理时假设有无穷多个符号化寄存器。经过这次处理，中间代码中使用的名字变成了寄存器的名字，而三地址指令变成了机器指令。如果对变量的访问要求一些指令使用栈指针，显示表指针，基址寄存器或其他的量来辅助访问，就假设这些量存放在那些为相应目的使用某种访问模式。如果访问方式更加复杂，这个访问就必须被分解成为过个机器指令，并且需要创建一个或多个临时的符号化寄存器。

在选择好了指令之后，第二趟处理把物理寄存器指派给符号化寄存器。这一次处理的目标是寻找到一个溢出代价最小的指派方法。

在第二趟处理中，对每个过程都高燥了一个寄存器冲突图。图中的结点是符号化寄存器。对于任意两个结点，如果一个结点在另一个被定值的地方是活跃的，那么这两个结点之间就有一条边。

然后就可以尝试用k中颜色对寄存器冲突图进行着色，其中k是可指派的寄存器的个数。一个图被称为已着色当且仅当每个结点都被赋予了一个颜色，并且没有两个相邻的结点的颜色相同。一种颜色代表一个寄存器。着色方案保证不会把同一个物理寄存器指派给两个可能相互冲突的符号化寄存器。

一般来说，确定一个图是否k-可着色是一个NP完全问题，但在实践中常常可以使用下面的启发式技术进行快速着色。假设图G中有一个结点n，其邻居个数少于k个。把n及和n相连的边从G中删除后得到一个图G‘。对图G‘的一个k-着色方案可以扩展称为一个对G的k-着色方案：只要n指派一个尚未指派给它的邻居的颜色就可以了。

通过不断地从寄存器冲突图中删除边数小于k的结点，要么最终得到一个空图，要么得到的图中每个结点都至少有k个相邻的结点。在第一种情况下，可以依照结点被删除的相反顺序对结点进行着色，从而得到一个原图的k-着色方案。在第二种情况下已经不存在k-着色方案了。此时就需要通过引入保存和重新加载寄存器的代码，将某个结点溢出。

### 通过树重写来选择指令

指令选择可能是一个大型的排列组合任务。对于像CISC这样的具有丰富寻址模式的机器，或者具有某些特殊目的的指令的机器尤其如此。即使假设求值的顺序已经给定，并且假设寄存器通过另一个独立的机制进行分配，指令选择----为实现中间表示形式中出现的运算符而选择目标语言指令的问题仍然是一个规模很大的排列组合任务。

在本节中，把指令选择当作一个树重写问题来处理。目标指令的树形表示已经在代码生成器的生成器中得到有效使用。这种生成器可以依据目标机器的高层规约自动构造出一个代码生成器的指令选择阶段。对于某些机器，相对于使用树表示方法而言，使用DAG表示方法能够生成更好的代码，但是DAG匹配比树匹配更加复杂。

#### 树翻译方案

代码生成过程的输入是一个由目标机器的语义层次上的树组成的序列。

#### 通过覆盖一个输入树来生成代码

一个树翻译方案按照下面的方式工作。给定一个输入树，在这些树重写规则中的模版被使用来覆盖输入树的子树。如果找到一个匹配的模版，那么输入树中匹配的子树将被替换为相应规则中的替换结点，并且执行规则的相关动作。如果这个动作包含了一个机器指令序列，那么就会生成这些指令。这个过程一直重复，直到这个树被规约成单个结点，或者找不到匹配的模版为止。

描述一个代码生成器的过程就变得和使用语法制导翻译方案来描述翻译器的过程类似。写出一个树翻译方案来描述目标机的指令集合。在实践中，将试图找到一个能够

#### 通过扫描进行模式匹配

在考虑通用的树匹配方法之前，先考虑一个特殊的匹配方法。这个方法使用LR语法分析器来完成模式匹配。输入树可以用前缀方式表示为一个串。

一个树翻译方案可以转换为一个语法制导的翻译方案，方法是把每个树重写规则替换为相应的上下文无关文法的产生式。对于一个树重写规则，相应的产生式的右部就是其指令模版的前缀表示方式，

一个用于代码生成的语法具有很大的二义性。在构造语法分析器的时候，对于如何处理语法分析动作冲突的问题需要小心，在没有指令代价信息的时候，总体处理规则是偏向于执行较大的规约，而不是较小的规约。这意味着在一个规约-规约冲突中，优先选择较长的规约；在一个移入-规约冲突中，优先选择移入动作。

在代码生成中使用LR语法分析方法有多个好处：

* 
* 
* 

<!-- 龙书第2版看到了第378页-->

### 第八章总结

* **代码生成**-
* **指令选择**-
* **寄存器分配**-
* **寄存器指派**-
* **可重定向编译器**-
* **虚拟机**-
* **CISC机**-
* **RISC机**-
* **基本块**-
* **流图**-
* **流图中的循环**-
* **基本块的DAG表示**-
* **窥孔优化**-
* **指令选择**-
* **Ershov数**-
* **溢出代码**-

## 第九章：机器无关优化

### 第九章总结

* **全局公共子表达式**-
* **复制传播**-
* **代码移动**-
* **归纳变量**-
* **数据流分析**-
* **基本块的数据流分析**-
* **到达定值**-
* **活跃变量**-
* **可用表达式**-
* **数据流问题的抽象**-
* **单调框架**-
* **可分配框架**-
* **抽象框架的迭代解法**-
* **常量传播框架**-
* **部分冗余消除**-
* **支配结点**-
* **流图的深度优先排序**-
* **边的分类**-
* **回边**-
* **可归约流图**-
* **自然循环**-
* **深度优先排序**-
* **区域**-
* **区域和可归约流图**-
* **基于区域的数据流分析**-
* **基于区域的归纳变量检测**-

## 第十章：指令级并行性

### 第十章总结

* **体系结构问题**-
* **数据依赖**-
* **消除依赖关系**-
* **基本块的数据依赖图**-
* **带优先级的拓扑排序**-
* **列表调度**-
* **基本块之间的代码移动**-
* **do-all循环**-
* **do-cross循环**-
* **循环的列表调度算法**-

## 第十一章：并行性和局部优化

### 第十一章总结

* **数组的并行性和局部性**-
* **访射访问**-
* **迭代空间**-
* **Fourier-Motzkin消除算法**-
* **数据依赖于数组访问**-
* **矩阵的秩和数据复用**-
* **数据依赖关系和丢番图方程**-
* **解丢番图线性方程**-
* **空间划分约束**-
* **基本代码转换**-
* **并行运算的同步**-
* **流水线化**-
* **时间划分约束**-
* **求解时间划分约束**-
* **分块**-
* **条状挖掘**-

## 第十二章：过程间分析

### 第十二章总结

* **过程间分析**-
* **调用点**-
* **调用图**-
* **内联**-
* **控制流相关性和上下文相关性**-
* **基于克隆的上下文分析**-
* **基于摘要的上下文分析**-
* **过程间分析计数的应用**-
* **Datalog**-
* **Datalog规则**-
* **IDB和EDB断言**-
* **Datalog程序的求值**-
* **Datalog程序的增量求值**-
* **Java指针分析**-
* **使用类型信息改进指针分析**-
* **过程间指针分析**-
* **寻找调用图**-
* **上下文相关分析**-
* **二分决策图**-
* **BDD和关系**-
* **使用BDD实现数据流分析**-




