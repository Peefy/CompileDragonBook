
# 《编译原理》《Principles of Compiler Design》(龙书)笔记

主要包括词法分析、语法分析、语法制导分析、类型检查、运行环境、中间代码生成、代码生成、代码优化等

## 第一章：编译简介

编译器的编写涉及到程序设计语言，计算机体系结构、语言理论、算法和软件工程等学科。

编译器是一个程序，读入某种语言(**源语言**)编写的程序并将其翻译成一个与之等价的另一种语言(**目标语言**)编写的程序。作为这个翻译过程的一个重要部分，编译器能够将用于报告被编译的源程序中出现的错误。

不同的语言需要不同的编译器。根据编译器的构造方法或者要实现的功能，编译器被分为**一遍编译器**、**多遍编译器**、**装入并执行编译器**、**调试编译器**、**优化编译器**等多种类别。实际上，任何编译器所要完成的基本任务都是相同的。通过理解这些任务，可以利用同样的基本技术为各种各样的源语言和目标机器构建编译器。

编译器的早期工作主要集中在如何把算术表达式翻译成机器代码。

编译的组成：

* **分析**-分析部分将源程序切分成一些基本块并形成源程序的中间表示
* **综合**-综合部分把源程序的中间表示转换为所需的目标程序

在分析期间，源程序所蕴含的操作将被确定下来并被表示成一个称为**语法树**的分层结构。语法树的每个节点表示一个操作，该节点的子节点表示这个操作的参数。

首先完成某种类型分析的软件工具

* **结构编辑器**-结构编辑器将一个命令序列作为输入来构造一个源程序。如可以检查输入的格式是否正确，自动地提供关键字，自动匹配括号
* **智能打印机**-智能打印机能够对程序进行分析，打印出结构清晰的程序。
* **静态检查器**-读入一个程序并分析，不运行的情况下发现程序的潜在错误。如可以检查出源程序永远不能被执行的语句，也可以查出变量在被定义前被引用。
* **解释器**-解释器不是通过翻译来产生目标程序，而是直接执行源程序中蕴含的操作。

当然编译器不一定用于编译程序到汇编，还可以用于:

* **文本格式器**-文本格式器输入是一个字符流。输入字符流中的多数字符串是需要排版输出的字符串
* **硅编译器**-输入是一个源程序，输出是一个以适当语言书写的电路设计
* **查询解释器**-查询解释器把含有关系和布尔运算的谓词翻译成数据库命令，在数据库中查询满足该谓词的记录。

### 编译器的前驱和后继

源程序->预处理器->编译器->目标汇编程序->汇编器->可重定位机器代码->装载器->绝对机器代码

预处理器可以将存储在不同文件中的程序模块哦集成为一个完整的源程序，也能够把源程序中称为宏的缩写语句展开为原始语句加入到源程序中。

**源程序的分析过程**

* **线性分析**-从左到右地读构成源程序的字符流，而且把字符流分组为多个**记号(token)**,而记号是具有整体含义的字符序列
* **层次分析**-在层次分析中，字符串或记号在层次上划分为具有一定层次的多个嵌套组，每个嵌套组具有整体的含义
* **语义分析**-进行某些检查，以确保程序各个组成部分确实是有意义的组合在一起的。

1. 词法分析：在编译器中，线性分析被称为词法分析或者扫描。

例如，在词法分析中，一下赋值语句的字符串将被分组为以下记号token组

```
position := initial + rate * 60
```
 
* 标识符 `position`
* 赋值符号 `:=`
* 标识符 `initial` 
* 加号 `+`
* 标识符 `rate`
* 乘号 `*`
* 数字 `60`

2. 语法分析：层次分析被称为**语法分析(parsing或者syntax analysis)**,他把源程序的记号进一步分组，产生被编译器用于生成代码的语法短语。通常，源程序的语法短语用分析树来表示。比如

```
position := initial + rate * 60
```

可以被表达为如下**分析树**

```json
{
"赋值语句 := " : {
    "left" : "标识符 position", 
    "right" : {
        "表达式 + " : {
            "left" : "表达式-标识符 initial",
            "right" : {
                "表达式 * " : {
                    "left" : "表达式-标识符 rate", 
                    "right" : "表达式-数字 60"
                }
            }
        }
    }
}
}
```

程序的层次结构通常是通过**递归规则**来表达的，可能把下述规则作为**表达式定义**的一部分：

* 任何一个标识符(identifier)都是表达式
* 任何一个数(number)都是表达式
* 如果ex1和ex2都是表达式,那么ex1 + ex2; ex1 * ex2; (ex1)也是表达式

类似地，许多序言用下列规则来递归得定义**语句**:

* 如果id1是标识符，ex1是表达式,那么id1 := ex1 是一个语句
* 如果ex1是表达式，state1是一个语句，则下述代码也是语句
```
while (ex1) do state1
if (ex1) then state1
```

*注意：词法分析和语法分析的界限在某种程度上是不确定的。决定词法分析和语法分析的界限的因素是源语言是否具有递归结构，词法结构不要递归，而语法结构常常需要递归*

上下文无关法是递归规则的一种形式化，可以用来指导语法分析

例如:在识别源语言的标识符(由字母开头的字母和数字串)时，不需要递归，只需要简单扫描输入流就可以完成标识符的识别。一般地，直到遇见一个既不是字母也不是数字的字符为止，在这之前扫描到的数字和字母归结为一个**标识符记号(identifier)**,被分组的字符存储到**符号表中**

另一方面，这种线性扫描不具有分析源语言的表达式或语句的能力。

**语法树**是**分析树**的一种压缩表示

```json
{
":=" : {
    "left" : "position", 
    "right" : {
        "+" : {
            "left" : "initial",
            "right" : {
                "*" : {
                    "left" : "rate", 
                    "right" : "toreal 60"
                }
            }
        }
    }
}
}
```

3. 语义分析

语义分析阶段检测源程序的语义错误，并收集代码生成阶段要用到的类型信息。语义分析利用语法分析阶段确定的层次结构来识别表达式和语句中的操作符和操作数

语义分析的一个重要组成部分是类型检查。类型检查负责检验每个操作符的操作数是否满足源语言的说明。例如：很多程序设计语言都要求每当一个实数用于数组的索引时都要报错。程序设计语言可能允许一些操作数的强制类型转换。例如：一个二元算术操作符的操作数可以是一个整数和一个实数。这种情况下，编译器把整数强制转换成实数

4. 文本格式器中的分析

将文本格式器的输入看成是由多个盒子构成的层次结构的说明是有益的。一个盒子是一个用某种位模式填充的矩形区域，填充的位模式表明该区域被输出设备打印成浅黑像素还是黑像素

### 编译器的各阶段

编译器是分阶段执行的，除了部分编译过程，还包括**符号表管理器**和**错误处理器**

符号表是一种数据结构，每个标识符在符号表中都有一条记录，这种数据结构允许我们快速地找到每个标识符的记录

编译的每个阶段都可能遇到错误。在编译过程中遇到错误后，必须以恰当的方式进行错误处理，使编译器能继续运行，以检测出源程序中的更多错误。发现错误即停止运行的编译器不是一个好的编译器。

**语法分析**和**语义分析**阶段通常能够处理编译器所能检测到的大部分错误。词法分析阶段能够检测出输入中不能形成源语言任何记号的错误字符串。语法分析阶段可以确定记号流中违反源语言结构（语法）规则的错误。语义分析阶段试图检测出具有正确的语法结构但对操作无意义的部分。

**源程序->词法分析器->语法分析器->语义分析器->中间代码生成器->代码优化器->代码生成器**

中间代码可以看成某种抽象机的程序。源程序的中间表示应该具有两个重要性质。一是易于产生，而是易于翻译成目标程序。

比如用**三地址码**表示，类似于某种机器的汇编语言，这种机器的每个存储单元的作用类似于寄存器。三地址码由指令序列组成，每个指令最多有三个操作数。

不同编译器产生的代码的优化程度差别很大。

编译的最后一个阶段是目标代码生成，生成可重定位的机器代码或者汇编代码。这一阶段的一个关键问题是变量的寄存器分配。

### 编译器的伙伴：预处理器

预处理产生编译器的输入，一般具有以下功能

* 宏处理：预处理器允许用户在源程序中定义宏。宏是被经常使用的较长结构的缩写。
* 文件包含：预编译器可以把头文件包含到程序正文中。例如：C语言的预处理器能够用`<global.h>`文件的内容替代源程序中的语句 `#include <global.h>`
* \"理性\"预处理器：这些处理器能把现代控制流和数据结构化机制添加到比较老式的语言中。
* 语言扩充：通过大量的内部宏定义来增强语言的能力

有些编译器能够完成汇编器的工作，产生可重定位的机器代码，交给装配器(loader)或者连接编辑器(link-editor)处理。

*汇编代码*：机器代码的容易记忆的形式。汇编代码使用名称而不是二进制代码来表示操作

汇编语言也使用宏工具，汇编语言的宏工具与前面讨论过的那些宏预处理器类似。

**两遍汇编**-最简单的汇编器对输入汇编源程序文件进行两遍扫描，每遍读入文件一次。第一遍扫描中，表示存储单元的所有标识符都被识别出来并存入符号表。在第二遍扫描中，汇编器再一次从头扫描输入文件。这一次将每个操作符翻译成机器语言中代表相应操作的二进制位序列，将代表存储单元的每个标识符翻译成符号表中该标识符的地址。

第二遍扫描的输出是可重定位的机器代码。

汇编器把汇编指令翻译成的机器代码。

装配器完成程序的装入和连接编辑两项功能。

### 编译器各阶段的分组

编译的多个阶段可以分为**前端**和**后端**两个大的阶段。前端包括依赖源语言并在很大程度上独立于目标机器的某些阶段或者某些阶段的某些部分。前端一般包括词法分析、语法分析、符号表的建立、语义分析、中间代码生成以及相关的错误处理。相当一部分代码优化工作也在前端完成。

后端包括编译器中依赖于目标机器的阶段或某些阶段的某些部分。一般来说，后端完成的任务不依赖于源语言而只依赖于中间语言。后端主要包括代码优化、代码生成以及相关的错误处理和符号表的操作。

为不同的机器编写相同源语言的编译器时，通常采用如下方法：首先为所有的机器编写相同的编译器前端或者已有的编译器前端，然后为每个机器编写编译器的后端。

还可以将不同的源语言编译成同一种中间语言，对不同的前端使用相同的后端，从而得到同一机器上的不同编译器。

**编译器的遍**

编译器的若干个阶段通常是以一遍来实现的，每遍读一次输入文件、产生一个输出文件。编译器的阶段组合为遍的方式千差万别，因此我们趋向于按阶段而不是按遍来讨论编译器。

例如词法分析、语法分析、语义分析以及中间代码生成可以被组合为一遍。这样，词法分析形成的记号流可以被直接翻译成中间代码。语法分析器根据读到的记号token识别语法结构，当需要下一个记号时，通过调用词法分析器获得所需的记号。一旦语法结构找出来了，语法分析器就调用中间代码生成器完成语义分析并生成中间代码的一部分。

**减少编译的遍数**

如果编译的遍数越少，读写中间文件的时间开销就小。但是如果将多个阶段组合为一遍，就不得不将这个程序保存在内存中，但是这样消耗的空间就急剧提高。

一般词法分析器和语法分析器之间的接口通常被限制于**单个记号token**

所以在某些情况下，可以为某些尚不知晓的信息留下空白位置，待获得这些信息后再填上这些空白位置。通过**回填**技术，把中间代码和目标代码划归到一遍中。

#### 编译器的构造工具

编译器的编写者使用*调试器*、*版本管理器*、*描述器(profiler)*等软件工具是十分有益的。

当第一批编译器被编写出来不久，用于辅助编译器编写过程的系统就出现了。这些系统常被称为编译器的编译器、编译器生成器或者翻译器编写系统。

所有语言的词法分析器除了对特殊的关键字和符号识别以外基本上都是一样的。

* 分析器生成器：这类工具生成的语法分析器一般都以上下文无关文法为基础
* 扫描器生成器：这类工具一般都根据正规表达式为基础的说明自动生成词法分析器
* 语法制导翻译引擎：产生一系列的翻译程序
* 自动代码生成器：这类工具以一个规则集合为输入。
* 数据流引擎：完成高质量代码优化所需要的很多信息都包含*数据流分析*

## 第二章：简单的一遍编译器

这章是词法分析、语法分析、语法制导翻译、类型检查、运行时环境、中间代码生成章节的内容简介。重点是编译器的前端部分：词法分析、语法分析和中间代码生成。

程序设计语言描述的两方面定义：程序模式(语言的语法)、程序含义(语言的语义)

表示法：**上下文无关**文或者BNF(Backus-Naur范式)。使用现有的表示法描述语言的语义要比描述语言的语法难的多。因此，在定义语言的语义时，使用非形式化方法和启发性实例。

**上下文无关**除了可以用于定义语言的语法之外，还可用于指导源程序的翻译。面向语法的编译技术，如**语法制导翻译技术**，对于组织编译器的前端十分有用

在语法制导翻译技术中，将构造一个把**中缀表达式**转换成**后缀表达式**的编译器

例如中缀表达式`9+5-2`的后缀表达形式为`95-2+`，可以使用一个堆栈把后缀表达式直接转换成计算该表达式的计算机代码

字符流->词法分析器->记号流->语法制导翻译器->中间表示

词法分析将每个输入字符变成一个个包含数字、标识符、关键字等复杂的词法结构

语法制导翻译器有一个语法分析器和一个中间代码生成器构成

### 语法定义

一个语法非常自然地描述了许多程序设计语言结构的层次结构。例如C语言中的if-else语句具有如下形式:

```
if (表达式) 语句 else 语句
```

整个语句是由一个关键字if、一个左括号、一个表达式、一个右括号、一条语句、关键字else和另外一条语句组成的序列。如果使用变量`expr`来标识表达式，使用变量`stmt`来标识一条语句

```
stmt -> if (expr) stmt else stmt
```

这里，箭头可以读作“可以具有形式”。这样的规则称为**产生式(production)**。在一个产生式中，像关键字if和括号这样的词法元素称为**记号(token)**,像expr和stmt这样的变量表示一个记号序列，并称之为**非终结符(nonterminal)**

**上下文无关文法**包含如下四个部分:
* 一个记号集合，称为终结符号
* 一个非终结符集合
* 一个产生式集合：每个产生式具有一个左部和右部，左部和右部由箭头连接，左部是一个非终结符，右部是记号和(或)非终结符序列
* 一个开始符号。开始符号是一个指定的非终结符

约定，定义语法时只需列出文法的产生式，并把以开始符号为左部的产生式列在最前面。数字、类似于<=的符号、类似于**while**的黑体关键字均为终结符，斜体名字表示非终结符，任何非斜体的名字或者符号都是**记号token**。为了表示上的方便，常把具有相同左部的产生式合并，写成一个产生式，其左部为所有产生式共有的那个非终结符，右部为所有产生式右部的组合，每个右部用'|'分隔，'|'读作'或'

对于表达式`9-5+2`,下面的文法描述了这些表达式的语法,产生式为：

```
list -> list + digit
list -> list - digit
list -> digit
digit -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```

左部的非终结符皆为*list*(列表)的按个产生式的右部可以合并为:

```
list -> list + digit | list - digit | digit
```

文法的记号是下列符号

```
+ - 0 1 2 3 4 5 6 7 8 9
```

斜体词*list*和*digit*是非终结符，*list*是开始非终结符，因为它所对应的产生式列在最前面。

如果一个非终结符出现在一个产生式的左部，该产生式称为该非终结符的产生式。记号串是零个或多个记号的序列。一个包含零个记号的记号串称为空串，记为**e**

从开始符号出发，反复代替产生式中的非终结符(用该非终结符的产生式的右部)，一个文法可产生一个串。由一个文法的开始符号产生的记号串形成了该文法定义的语言。

例子：Pascal语言的begin-end语句块(block)是由分号分隔的语句序列。begin-end语句块的文法结构与上述列表的差别仅在于**begin**和**end**之间允许有空语句。
begin-end语句块的文法:

```
block begin opt_stmt end

opt_stmt -> stmt_list | e
stmt_list -> stmt_list ; stmt | stmt
```

### 分析树

分析树描绘了如何从文法的开始符号开始推导出它的语言中的一个语句。如果非终结符A具有一个产生式A->XYZ,则A的一棵分析树如右图所示，内节点标记为A，A的三个子节点从左到右分别标记为X,Y和Z。

形式地说，给定一个上下文无关文法，分析树是具有如下特性的树：

1. 树根标记为开始符号
2. 每个叶节点由**记号token**或者**空串e**标记
3. 每个内节点由一个非终结符标记
4. 如果A是某个内节点的非终结符号标记，X1,X2,...,Xn是该节点从左到右排列的所有子节点的标记，则A->X1X2...Xn是一个产生式。这里，X1,X2,...,Xn是一个终结符或非终结符。对于A->e,分析树中标记为A的节点只有一个标记为e的子节点

```json
{
    "node" : "A", 
    "childrens" : [
        "X", 
        "Y",
        "Z"
    ]
}
```

一棵分析树从左到右的叶节点是这棵分析树生成的结果。分析树生成的结果是由根节点的非终结符生成或导出的串。

任何树的叶节点都满足从左到右都满足从左到右排列的自然顺序，即如果a和b具有相同的父节点，且a在b的左部，则a和a的所有后代都在b和b的所有后代的左部。

一个文法生成的语言是它的某个分析树生成的串的集合。为给定的记号串找到一个分析树的过程称为这个串的**语法分析(parsing)**

### 二义性

一棵分析树读完它的叶节点只能生成唯一的一个串，但是一个文法可能有多棵分析树生成相同的记号串。这样的文法称为具有*二义性*的文法。

判断一个文法是否具有二义性，只需检查是否存在一个具有多棵分析树的记号串。在构造程序设计语言及其编译器时，需要设计无二义性文法，或者使用增加了额外的规则解决二义性问题的二义性文法。

### 操作符operator的结合规则

在大多数的程序设计语言中，加、减、乘、除四种算术操作符都是左结合的。

某些常用操作符是右结合的，如指数操作。C语言中的赋值运算操作符‘=’号也是右结合的。

例如，在C语言中，表达式`a=b=c`等价于`a=(b=c)`

由右结合的操作符构成的串，如a=b=c,可以由如下文法产生:

```
right -> letter = right | letter
```

下述两个树给出了左结合操作符‘-’和右结合操作符‘=’的分析树的比较。可以看到‘-’分析树向左下端延伸，‘=’分析树向右下端延伸

```json
{
    "node" : "list",
    "child" : [
        {
            "node" : "list", 
            "child" : [
                {
                    "node" : "list",
                    "child" : [
                        {
                            "node" : "digit",
                            "child" : [
                                {
                                    "node" : "9",
                                    "child" : "null"
                                }
                            ]
                        }
                    ]
                },
                {
                    "node" : "-",
                    "child" : "null"
                },
                {
                    "node" : "digit",
                    "child" : "null"
                }
            ]
        },
        {
            "node" : "-",
            "child" : "null"
        },
        {
            "node" : "digit",
            "child" : [
                {
                    "node" : "2",
                    "child" : "null"
                }
            ]
        }
    ]
}
```

```json
{
    "node" : "-",
    "child" : [
        {
            "node" : "letter",
            "child" : [
                {
                    "node" : "a",
                    "child" : "null"
                }
            ]
        },
        {
            "node" : "=",
            "child" : "null"
        },
        {
            "node" : "right",
            "child" : [
                {
                    "node" : "right",
                    "child" : [
                        {
                            "node" : "letter",
                            "child" : [
                                {
                                    "node" : "b",
                                    "child" : "null"
                                }
                            ]
                        },
                        {
                            "node" : "=",
                            "child" : "null"
                        },
                        {
                            "node" : "right",
                            "child" : [
                                {
                                    "node" : "right",
                                    "child" : [
                                        {
                                            "node" : "letter",
                                            "child" : [
                                                {
                                                    "node" : "c",
                                                    "child" : "null"
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}
```

### 操作符的优先级

当不止一种操作符操作出现的时候，需要确定操作符之间的优先关系。比如乘法`*`比`+`具有更高的优先级。

在优先级表中，操作符按照优先级递增的次序排列，相同优先级的操作符出现在同一行上

```
左结合：+ -
左结合：* /
```

考虑表达式`9+5*2`

使用两个非终结符*expr*和*term*分别表示两个不同的优先级层次，使用另一个非终结符*factor*产生表达式中的基本单元。表达式中的基本单元是数字和带括号的表达式。*factor*的产生式如下：

```
factor -> digit | (expr)
```

现在考虑具有最高优先级的二元操作符`*`和`/`。由于这些操作符是左结合的。其产生式和左结合的*list*的产生式类似：

```
term -> term * factor | term / factor | factor
```

类似地，expr生成由其他操作符分隔的*term*表

```
expr -> expr + term | expr - term | term
```

所以算术表达式的最终文法为：

```
expr -> expr + term | expr - term | term
term -> term * factor | term / factor | factor
factor -> digit | (expr)
```

*语句的语法*：在多数语言中，可以使用关键字识别语句。除了赋值语句和过程调用语句以外，所有的Pascal语句都由一个关键字开始。一些Pascal语句可以用下面的二义性文法来定义，其中id表示一个标识符:

```
stmt -> id := expr
| if expr then stmt
| if expr then stmt else stmt
| while expr do stmt
| begin opt_stmts end
```

### 语法制导翻译

为了翻译程序设计语言的某个结构，除了为该结构生成的代码以外，编译器还需要保存许多信息。例如：编译器可能需要知道这个结构的类型、目标代码中第1条指令的位置、生成的指令的个数。

属性可以表示任意的信息，如类型、串、内存位置等。

### 后缀表示

表达式E的后缀形式可以归纳地定义如下：

1. 如果E是一个变量或者常量，则E的后缀表示是E本身
2. 如果E是形如`E1 op E2`的表达式，其中op是一个二元操作符，则E的后缀表示是E1'E2'op，这里E1'和E2'分别是E1和E2的后缀表示
3. 如果E是形如`(E1)`的表达式，则E1的后缀表示是E的后缀表示。

因为一个表达式的操作符的位置和每个操作符的操作个数(参数数量)只允许后缀表达式的一种解码方式，所以在后缀表示中不需要括号。例如,`(9 - 5) + 2`的后缀表示是`95-2+`,
`9 - (5 + 2)`的后缀表示是`952+-`

一个数字记号的后缀形式是该数字本身。

#### 语法制导定义

语法制导定义使用上下文无关文法来说明输入的语法结构。它通过每个文法符号和一个属性集合相关联，通过每一个产生式和一个语义规则集合相关联。

文法和语义规则集合构成了语法制导定义

翻译是一个输入到输出的映射。首先构建x的分析树。假定分析树的节点n用文法符号X标识。用X.a表示节点n上X的属性a的值。节点n上的X.a的值是使用与X产生式相关联的属性a的语义规则来计算的。每个节点都具有属性值的分析树称为注释分析树。

**综合属性**-分析树的某个节点的属性值是由其子节点的属性值确定的。一棵分析树的所有综合属性值的计算只需要分析树的一次自底向上遍历。

**注释分析树**

```json
{
    "val" : "95-2+",
    "child" : [
        {
            "val" : "expr.t = 95-",
            "child" : [
                {
                    "val" : "expr.t = 9",
                    "child" : [
                        {
                            "val" : "term.t = 9",
                            "child" : []
                        }
                    ]
                },
                {
                    "val" : "-",
                    "child" : []
                },
                {
                    "val" : "term.t = 5",
                    "child" : []
                }
            ]
        },
        {
            "val" : "+",
            "child" : []
        },
        {
            "val" : "term.t = 2",
            "child" : []
        }
    ]
}
```

#### 树的深度优先遍历DFS

本章所有的翻译都是通过按照一种预订的顺序对分析树属性的语义规则进行计算来实现的。树的遍历是指从根开始，以某种顺序访问树的每一个节点。DFS从根开始，从左到右递归访问每个节点的子节点。

一旦给定节点的所有后代都被访问，则该节点的语义规则将被计算。之所以称之为“深度优先”遍历，是因为它尽可能地访问一个节点的未访问的子节点。于是它尽可能访问离根最远的节点。

#### 翻译模式

一个翻译模式是一个上下文无关文法，其中被称为语义动作的程序段被嵌入到产生式右部。

一个翻译模式类似于语法翻译制导定义，只是语义规则的计算顺序是显式给出的。一个语义动作的执行位置通过用括号把语义动作括起来并将其放在产生式的右部来表示。

当给一个翻译模式画一棵分析树的时候，通过为语义动作构造一个特殊的子节点来指出语义动作，并使用虚线连接到其产生式的节点。

翻译模式的语义动作把翻译的输出以一次一个字符或一个字符串的形式写入一个文件。例如通过每次写`9-5+2`中一个字符的方式把表达式`9-5+2`翻译成`95-2+`，而不需要额外的空间存储子表达式的翻译。当输出按照这种方式递增地被创建时，写字符的顺序变得很重要。

作为一般规则，多数分析方法都以一种“贪心”的方式从左到右地处理输入

语法分析时决定一个记号串是否能由一个**文法**产生的过程。语法分析器应该具有构造分析树的能力，否则，不能保证翻译的正确性。

可以为任何文法构造语法分析器。实际中使用的文法一般都具有特定的形式。对于任意上下文无关文法，可以构造一个时间复杂性为`O(n^3)`的语法分析器，即在`O(n^3)`时间内完成对具有n个记号的串的语法分析，通常可以构造一个可快速分析的文法。*线性时间复杂性算法*足以分析实际中出现的所有程序设计语言

程序设计语言语法分析器总是从左到右扫描输入，每次超前扫描一个记号。

语法分析方法可以分为两类：自顶向下方法和自底向上方法。这些术语是指构造分析树节点的顺序。前者按照从根节点到叶节点的顺序构造分析树，后者按照从叶节点到根节点的顺序构造分析树。

自顶向下分析器是常用的语法分析器，其原因在于这种语法分析器可以很容易地通过自顶向下的方法手工构造出来。然而，自底向上分析方法可以处理大量文法和翻译模式，所以直接从文法产生语法分析器的软件工具通常使用自底向上的方法。

#### 自顶向下语法分析

```
type -> simple | id | array [ simple ] of type
simple -> integer | char | num dotdot num
```

为了自顶向下地构造一个分析树，从标有开始非终结符的根节点开始，反复执行下面两步

1. 在标有非终结符A的节点n，选择A的一个产生式，用该产生式右部的符号构造节点n的子节点。
2. 寻找下一个要构造子树的节点。

对于某些文法，上面的步骤可以通过一次从左到右扫描输入串来实现。输入中当前被扫描的记号通常是被称为**超前扫描符号(lookahead symbol)**。最初，扫描超前符号是输入串的第一个记号，即最左端的记号。

``` 
array [num .. num] of integer
```

```json
{
    "name" : "type",
    "child" : [
        {
            "name" : "array",
            "child" : []
        },
        {
            "name" : "[",
            "child" : []
        },
        {
            "name" : "..",
            "child" : []
        },
        {
            "name" : "simple",
            "child" : [
                {
                    "name" : "num",
                    "child" : []
                },
                {
                    "name" : "dotdot",
                    "child" : []
                },
                {
                    "name" : "num",
                    "child" : []
                }
            ]
        },
        {
            "name" : "]",
            "child" : []
        },
        {
            "name" : "of",
            "child" : []
        },
        {
            "name" : "integer",
            "child" : []
        }
    ]
}
```

如果当前被考察的分析树的节点是一个终结符，而且该终结符与超前符号匹配，则分析树的箭头和输入的箭头都进一步。输入的下一个记号称为新的超前扫描符号，分析树的下一个子节点将被考察。

#### 预测分析法

**递归下降分析法**是一种自顶向下的语法分析方法，在这种方法中，我们执行一组递归过程来处理输入串。每一个过程都唯一地与分发的一个非终结符相关联。

在预测分析法中，超前扫描符号无二义性地确定了为每个非终结符选择的过程。处理输入时调用的过程序列隐式地定义了输入串的分析树。

下面的与**预测语法分析器**由非终结符type的过程、非终结符simple的过程和一个称为match的过程组成。用match过程来简化type过程和simple过程的代码。如果变量t和超前扫描符号匹配，输入符号串的箭头将前进一步，指向下一个输入记号。

match过程改变了当前被扫描的输入记号lookahead变量的值。

```
match(array);match('[');simple;match(']');match(of);type
```

示例预测语法分析器的伪代码

```
procedure match(t : token);
begin
    if lookhead == t then
        lookhead := nexttoken;
    else error
end;

procedure type;
begin
    if lookahead is in {integer, char, num} then
        simple;
    else if lookahead == '↑' then begin
        match('↑');
        match(id);
    end
    else if lookahead == array then begin
        match(array); 
        match('[');
        simple;
        match(']');
        match(of);
        type;
    end
    else error
end

procedure simple;
begin
    if lookahead == integer then
        match(integer);
    else if lookahead == char then
        match(char);
    else if lookahead == num then begin
        match(num);
        match('..');
        match(num);
    end
    else error
end
```

在`array`和`[`匹配之后，超前扫描符号是`num`。这时，过程simple被调用

超前扫描符号指导产生式的选择。如果产生式的右部由一个记号开始，则当该记号与超前扫描符号匹配的时候这个产生式被选用

预测分析依赖于产生式右部产生的第一个符号是什么。更精确地说，令a是非终结符A的某产生式的右部。定义FIRST(a)是作为由a产生的一个或多个串的第一个符号出现的集合。
如果a是e或者可以产生e，则e也属于FIRST(a)

例如
```
FIRST(simple) = {integer, char, num}
FIRST(↑id) = {↑}
FIRST(array [ simple ] of type) = {array}
```

实际上，许多产生式的右部都由记号开始，从而简化了FIRST集合的构造。

如果有两个产生式A->a和A->b可供选用，则必须考虑相应的**FIRST集合**。无回溯的递归下降分析方法要求FIRST(a)和FIRST(b)不相交。这样超前扫描符号就可以选择正确的过程去执行。如果超前扫描符号在FIRST(a)集合中，则使用a，否则，如果超前扫描符号在FIRST(b)中，则使用b

右部是e的产生式称为e产生式，需要特殊处理。当没有其他产生式可用的时候，递归下降语法分析器把e产生式作为默认产生式使用。例如

```
stmt -> begin opt_stmts end
opt_stmts -> stmt_list | e
```

当分析到opt_stmts时，如果超前扫描符号没有在FIRST(stmt_list)集合中，则使用e产生式。如果超前扫描符号时end，这种选择是正确的，除了end之外的任何超前扫描符号都将导致一个错误，可以在stmt的语法分析中检测到。

预测语法分析器是一个由多个过程组成的程序，每个过程对应一个非终结符。每个过程完成如下两项任务

* 检查超前扫描符号，决定使用哪个生产式。如果超前扫描符号在FIRST(a)中，则选择使用右部为a的生产式。对于任何超前扫描符号，如果产生式右部存在冲突，那么我们不能在这种文法上使用这种分析方式。如果超前扫描符号不在任何其他右部的FIRST集合中，右部具有e的产生式将被使用。
* 过程通过模仿其右部来使用一个产生式。一个非终结符号导致该非终结符对应的过程被调用。一个与超前扫描符号匹配的记号导致下一个输入记号被读入。如果在某个点上，产生式的记号与超前扫描符号不匹配，则报告出错。

#### 左递归

递归下降语法分析器可能会造成无限循环。当出现下面这样一个左递归产生式时，无限循环就会出现:
```
expr -> expr + term
```
在这里，产生式右部的最左边符号和产生式左部的非终结符是相同的。假定expr对应的过程要使用这个产生式。因为右部是由expr开始的，所以expr过程被递归调用，出现了无限循环。

*注意：只有右部终结符与超前扫描符号匹配时，超前扫描符号才会发生改变*：因为产生式是以非终结符expr开始的，输入符号在递归调用期间没有机会改变，所以导致无限循环。

通过重写与递归相关的产生式，可以消除左递归产生式：

```
A -> Aa | b
```

同样的结果可以通过如下方式改写产生式得到:

```
A -> bR
R -> aR | e
```

这里R是一个新的非终结符。产生式R->aR以R自身作为产生式右部最后一个符号，因而是右递归的。

向右下侧延伸的分析树使得包含左结合操作符表达式的翻译变得困难。通过基于右递归文法的翻译模式的仔细设计，可以将表达式正确翻译成后缀形式。

### 简单表达式的翻译器

可以由C语言编写一个语法制导翻译器，这个翻译器可以把算术表达式翻译成后缀形式

先从最简单的表达式开始，即由加号和减号分隔的由数字构成的表达式，在随后的两节中将其扩展为包括数字、标识符和其他操作符。

一个语法制导翻译模式可以作为一个翻译器的规范。通常，一个给定翻译模式的文法在能够被预测语法分析器分析之前需要加以修改。预测语法分析器不能处理左递归文法，可以通过消除左递归得到一个适用于预测递归下降编译器的文法。

#### 抽象语法与具体语法。

**抽象语法树**-在一个抽象语法树中，每个节点表示一个操作符，该节点的子节点表示操作数。与此相对应的，分析树称为具体语法树，相应的文法为具体语法。

希望的翻译模式所基于的文法的分析树尽可能与语法树相同。然而有时文法是左递归的，不适用于预测分析。所以产生矛盾：一方面需要一个便于分析的文法，另一方面为了便于翻译，又需要一个不同的文法。最明显的解决方法是消除左递归。

#### 非终结符expr、term和rest的过程。

match函数把给定的记号与超前扫描符号进行匹配，然后读取输入串中的下一个符号，并将其作为新的超前扫描符号

```cpp
static char lookahead;

inline bool isdigit(char c) {
    return '0' <= c && 'c' <= '9';
}

inline bool isalpha(char c) {
    return ('a' <= c && 'c' <= 'z') || ('A' <= c && 'c' <= 'Z');
}

inline bool isidenfierchar(char c) {
    return isalpha(c) || c == '_';
}

void expr() {
    term();
    rest();
}

void rest() {
    if (lookahead == '+') {
        match('-');
        term();
        putchar('+');
        rest();
    } 
    else if (lookahead == '-') {
        match('-');
        term();
        putchar('-');
        rest();
    }
}

void term() {
    if (isdigit(lookahead)) {
        putchar(lookahead);
        match(lookahead);
    }
    else 
        error();
}

void match(char c) {
    lookahead == c ? lookahead = getchar() : error();
}

void error() {
    // 打印错误信息
    printf("syntax error\n");
    // 停止
    exit(1);
}
```

#### C语言和其他Algol派生语言(如Pascal语言)之间的区别

操作|C语言|Pascal语言
-|-|-
赋值|=|:=
相等测试|==|=
不等测试|!=|<>

#### 翻译器的优化

*某些递归可以用循环替换*,如果一个过程中执行的最后一条语句是对该过程的递归调用，则该调用称为是尾递归的。

可以使用循环代替尾递归来加速程序。对于没有参数的过程，可以用一个专一到过程开始位置的跳转语句来替换尾递归。

```cpp
void rest_override() {
    L : 
    if (lookahead == '+') {
        match('+'); term(); putchar('+'); goto L;
    } 
    else if (lookahead == '-') {
        match('-'); term(); putchar('-'); goto L;
    }
}
```

```cpp
void expr_override() {
    term();
    while (1) {
        if (lookahead == '+') {
            match('+'); term(); putchar('+'); goto L;
        } 
        else if (lookahead == '-') {
            match('-'); term(); putchar('-'); goto L;
        }
    }
}
```

函数match检查记号是否匹配。如果超前扫描符号匹配，match读入下一个输入，否则调用出错例程，报告错误信息

### 词法分析

可以为上面的翻译器增加一个词法分析器。词法分析器读入输入串，将其转换成将被语法分析器分析的记号流。

一个语言的语句是由记号串构成的。构成一个记号的输入字符序列称为词素。词法分析器和记号的词素(当然词素所对应的字节数由文件的编码决定)表示分隔开来。

#### 删除空白符和注释

许多语言允许空白符(空格、制表符、换行符)出现在记号之间。源程序中的注释一般都将被语法分析器和翻译器忽略，所以也可以看成空白符

如果词法分析器消除了空白符，语法分析器就不必再考虑空白符.修改文法使得语法中包含空白符的做法实现起来很难。

#### 常数

在一个表达式中，任何一个允许单个数字出现的位置都应该允许任何整型常数出现。因为整型常数是一个数字序列。可以通过在文法中添加产生式或者创建常数的记号使整型常数成为合法的。由于翻译器件把数作为一个单元来处理

令`num`是表示整数的记号。当一个数字序列出现在输入流中时时，词法分析器将把`num`传递给语法分析器。整数的值作为记号`num`的属性值传递给语法分析器。

如`31+28+59`就可以写成`<num, 31>` `<op, +>` `<num, 28>` `<op, +>` `<num, 59>`

### 标识符和关键字

程序设计语言使用标识符作为变量名、数组名、函数名和其他一些语言对象名。程序设计语言的文法常把标识符作为记号处理。基于这类文法的语法分析器在输入中每遇到一个标识符都赋予它们相同的记号`id`

例如词法分析器将`count = a + b`转换成记号流`<id, count>` `<op, =>` `<id, a>` `<id, b>` 

当标记为`id`的实例词素`count`,`a`,`b`时，翻译器需要某种机制来决定该词素是否出现过。符号表就是这样一种机制。词素存储在符号表的一个表项中，而指向该表项的指针则称为记号`id`的一个属性

许多程序设计语言使用固定的字符串(如`begin`、`end`、`if`)作为标点符号标志或者某种结构的标识。这些字符串称为**关键字**，通常也满足形成标识符的规则。

需要一种机制来决定一个词素何时形成关键字何时形成标识符。

一般将关键字作为保留标识符，也就是说，只有字符串不是关键字时它才形成标识符。

如果相同的字符出现在多个记号的词素中，又会遇到记号分割的问题。例如，Pascal中的`<`,`<=`和`<>`中都包含`<`

### 词法分析器的接口

词法分析器介于语法分析器和输入流之间，并与这两者交互。词法分析器从输入串读字符并形成词素，然后将词素生成的记号及其属性值传递给编译器的下一个阶段。在某些情况下，词法分析器在把记号传给语法分析器之前，需要从输入串超前地读入一些字符，以确定需要传递给语法分析器的正确记号。

词法分析器一次从输入字符串中多读取若干个字符，多读入的字符经过分析后必须退回给输入流，因为它可能是下一个词素的开始符号。

词法分析器和语法分析器形成`生产者-消费者`对。词法分析器产生记号，语法分析器消费记号。产生的记号在被消费之前保存在记号缓冲区中。两者的交互仅受缓冲区大小的限制。原因是：当缓冲区满时，词法分析器不能继续产生记号；当缓冲区空时，语法分析器不能继续分析。通常，缓冲区只能存储一个记号。在这种情况下，二者之间的交互可以通过下面的方式简单地实现：使词法分析器称为被语法分析器调用并为语法分析器返回所需的记号的过程。

**输入缓冲技术**-读入字符和退回字符操作一般都通过建立一个输入缓冲区来实现。编译器每次把一组字符读入缓冲区，用一个指针指向当前已经被分析的输入部分。如果需要退回字符，只需将指针向回移动。为了能够给出详细的错误报告信息(如，必须给出错误出现在输入串的位置)，我们需要保存输入字符。输入字符的缓冲可以提高编译器的效率，每次读一组字符比每次读一个字符的效率高。

### 词法分析器例子

可以为之前的表达式翻译器构造一个简单的词法分析器。词法分析器的目的是使表达式中只允许出现空白字符和由多个数字组成的数

例如使用C语言，可以使用`<stdio.h>`中已经实现了的输入串的缓冲处理，分别调用`getchar`和`ungetc`来实现读入字符和推回字符。设c是字符变量，语句c=getchar()和ungetc(c, stdin)来实现读入字符和推回字符

使用词法分析器函数`lexan()`返回记号的整数编码(比如C语言里面的枚举)。对于num这样的记号，其编码可以用大于任何单个字符的整数编码的整数进行编码，即256。同时把全局变量tokenval设置成这串数字的值。例如：输入串中7后面跟着6，则tokenval变量的值是76

为了允许数出现在表达式中，需要对文法做一点修改。用终结符factor代替，并引入下面的产生式和语义动作：

```
factor -> (expr) | num { print(num.value) }
```

```c
void factor() {
    if (lookahead == '(') {
        match('('); expr(); match(')');
    }
    else if (lookahead == NUM) {
        printf(" %d ", tokenval); match(NUM);
    }
    else {
        error();
    }
}
```

下述给出了lexan函数的实现，每次读入一个字符到变量t。如果字符是空格或者制表符(即`'\t'`),则没有记号返回给语法分析器，只是再进行一次while循环。如果字符是一个换行符`'\n'`,仍然没有记号返回给语法分析器，只是将全局变量lineno加1。lineno用来记录输入的行数，在报错时用来指示出错行号以帮助程序调试者定位错误。

文件`<ctype.h>`中的函数`isdigit(t)`用来判定一个输入字符t是否是数字。如果是数字，其整型值由表达式t-'0'给出。对于其他字符集，该转换可能有些不同。该词法分析器将被加入到表达式翻译器。

```c
int lexan() {
    int t;
    while (1) { 
        // 从输入流中获取一个字符的ASCII码
        t = getchar();
        // 去除空格和制表符
        if (t == ' ' || t == '\t')
            ;
        // 换行符
        else if (t == '\n' || t == '\r')
            lineno += 1;
        else if (isdigit(t)) {
            tokenval = CHAR_TO_NUM(t);
            t = getchar();
            while (isdigit(t)) {
                tokenval = tokenval * 10 + CHAR_TO_NUM(t);
            }    
            ungetc(t, stdin);
            return NUM;
        } 
        else { 
            tokenval = NONE;
            return t;
        } 
    }  
} 
```

### 符号表

符号表示一种数据结构，通常用于保存源语言结构的各种信息。编译器分析阶段收集信息放入符号表，在综合阶段使用符号表中的信息生成目标代码。例如，在词法分析阶段，形成标识符的字符串或词素被存储在符号表的一个表项中。编译器的以后各阶段会在这个表项上逐步添加其他信息，如标识符的类型、用处(如用作过程名、变量名或标号)以及存储位置。在代码生成阶段，编译器使用这些信息生成存取这些变量的正确代码。

#### 符号表接口

与符号表有关的例程的功能主要是存取词素，当一个词素被保存时，也保存与该词素相关的记号。下边是在符号表上执行的操作：

* **insert(s, t)**-将字符串s和记号表td的插入符号表，返回相应表项的索引
* **lookup(s)**-到符号表中查找字符串s，如果找到则返回相应表项的索引，否则返回0

词法分析器使用lookup操作确定某个词素相关的记号。下边是在符号表上执行的操作：

* **insert(s, t)**-将字符串s和记号t的插入符号表，返回相应表项的索引
* **lookup(s)**-到符号表中查找字符串s，如果找到哦啊则返回相应表项的索引，否则

词法分析器使用lookup操作确定某个词素的项在符号表中是否已经存在。如果不存在，它使用insert操作在符号表中建立一个新表项存储该词素及相关信息。

#### 处理保留的关键字

上述符号表子程序能够处理任何保留的关键字的集合。例如，考虑具有div和mod词素的两个记号`div`和`mod`。用下面的调用来初始化符号表：

```
insert("div", div);
insert("mod", mod);
```

符号表如此初始化后，调用lookup("div")将返回记号`div`,于是div不能再被用作标识符。

*任何保留关键字的集合都可以通过适当地初始化符号表而得到正确的处理*

### 符号表的实现方法

首先不希望预留固定的大小的空间来保存形式标识符的词素，因为固定大小可能不足以保存长标识符，而对于短标识符(如i)又会造成空间的浪费。

可以使用单独的数组lexemes存储形成标识符的字符串。每一个字符串用一个字符串终结符EOS结束。EOS不会出现在任何标识符。符号表数组symtable中的每个表项都是一个包含两个域的记录：一个域是指向词素开始位置的指针域lexptr，另一个域是存储记号的token域。符号表可以更多的域以存储属性值，不作详细讨论

下面列出了处理标识符的词法分析器的伪代码

```
function lexan : integer
var lexbuf : array[0..100] of char;
    c : char;
begin
    loop begin
        读一个字符到c
        if c是空格或制表符 then
            什么也不做
        else if c是换行符 then
            lineno := lineno + 1
        else if c是一个数字 then begin
            该数字和其后数字的所表示的数的值存入tokenval
            return NUM
        end
            else if c是一个字母 then begin
                将c和其后的连续字母和数字存入lexbuf
                p := lookup(lexbuf)
                if p = 0 then
                    p := insert(lexbuf, ID);
                tokenval := p
                return 表项p的token域
            end
            else begin
                将tokenval置为NONE;
                return 字符c的整数编码
            end
        end
end
```

### 抽象堆栈机

编译器可以划分为前端和后端两部分。前端构造源程序的中间表示，后端从中间生成目标代码。一种流行的中间表示是**抽象堆栈机代码**。编译器划分为前端和后端可以使之经简单修改就可以运行在一台新机器上。

**抽象堆栈机**把*指令存储器*和*数据存储器*分开,并且所有的算术操作都在堆栈上执行。指令个数非常有限，可以分为三类：整型算术、堆栈操作和控制流

#### 算术指令

抽象机必须用中间语言实现每一个操作符。抽象机直接支持像加法和减法这样的简单操作。更复杂的操作需要由一个抽象机指令系列来实现。

为简化堆栈机的描述，假定每个算术操作对应一条指令。

一个算术表达式的抽象机代码用堆栈模拟该后缀表达式的计算。这个计算过程从左到右处理后缀表达式，遇见操作数，就将其压入**堆栈**,当遇到一个k元操作符时，它的最左面的参数在栈顶下面k-1的位置，最右面的参数在栈顶。在栈顶的k个元素上应用这个k元操作符：弹出操作数，并将结果压入堆栈。例如，对*后缀表达式*`13+5*`进行计算时，需要执行下面的动作

* 1入栈
* 3入栈
* 将栈顶的两个元素相加，从栈中弹出这两个元素，并将结果4压入堆栈
* 5入栈
* 将栈顶的两个元素相乘，从栈中弹出这两个元素，将结果20压入堆栈

最后栈顶元素20是整个表达式的最终结果。

在中间语言中，所有的值都是整数，0可以对应于布尔值false，非0值可以对应于布尔值true。布尔型操作符and和or要求其两个参数都已计算完毕

#### 左值和右值

赋值表达式左部和右部的标识符的含义是不一样的。如赋值语句
```
i := 5
i := i + 1
```
表达式的右部是一个整型值，左部是值要存放的位置。与此相似，如果p和q是指向字符的指针，表达式`q↑ := q↑`中，右部`q↑`表示一个字符，左部`p↑`表示这个字符该存储的位置。术语*左值*和*右值*分别指赋值表达式左部和右部对应的值。也就是说，右值是平常意义上的值，而左值是一个位置。

#### 堆栈操作

几个访问数据内存的指令:

* **PSH v**-将v压入栈顶
* **RVALUE l**-将存储器位置l上的数据内容压入栈
* **LVALUE l**-将存储器位置l的地址压入栈
* **POP**-弹出栈顶元素
* **:=**-栈顶元素的右值被存放到栈顶的下一个元素的左值中，且二者均被弹出
* **COPY**-把栈顶元素的副本压入栈顶

#### 表达式的翻译

**使用堆栈机计算表达式的代码与表达式的后缀表示密切相关**

根据定义，计算E+F的堆栈机代码是计算E的代码、计算F的代码以及将它们的值相加的指令的连接。因此，将表达式翻译成堆栈机代码可以通过修改翻译器得到

本节生成的表达式堆栈机代码中，数据位置是用符号地址表示的。表达式a+b翻译成

```
RVALUE a
RVALUE b
+
```

即把a和b位置上的数据压入栈顶，然后将栈顶的两个数据弹出，将其相加，把结果压入栈顶。

赋值表达式翻译成堆栈机代码的过程时：被赋值的标识符的左值压入栈顶，计算表达式，将结果的右值赋给标识符。例如，赋值语句：

```
day := (1461 * y) div 4 + (153 * m + 2) div 5 + d
```

被翻译成如下形式的代码

```
LVALUE day   
PUSH 1464
RVALUE y
*
PUSH 4
div
PUSH 153
RVALUE m

*
PUSH 2
+ PUSH 5
div
+
RVALUE d
+
:= 
```

赋值语句可以形式化地表示如下：

```
stmt -> id := expr { stmt.t := 'lvalue' || id.lexeme || expr.t || ':=' }
```

每个非终结符具有属性t,t给出这个非终结符的翻译。标识符id的属性lexeme给出了标识符的字符串表示。

#### 控制流

堆栈机是顺序执行指令的，除非碰到条件指令或者无条件转移语句。说明转移目标地址方法有如下几种：

* 转移指令的操作数给出转移的目标地址
* 转移指令操作数给出转移的相对地址(正数或负数)
* 用符号表示转移的目标地址，即机器所支持的标号

在前两种方法中，操作数有可能从栈顶获得。

例如，堆栈机的控制流指令如下:

* **LABEL l**-说明转移的目标l
* **GOTO l**-从标有l的指令开始执行下一条指令
* **GOFALSE l**-弹出栈顶值，如果是0，则转移到l
* **GOTRUE l**-弹出栈顶值，如果非0，则转移到l
* **HALT**-停止执行程序

#### 语句的翻译

条件语句和while语句的代码框架

*if*

```
expr 代码
GOFALSE out
stmt1代码
LABEL out
```

*while*

```
LABEL test
expr 代码
GOFALSE out
stmt1代码
GOTO test
LABEL out
```

在源程序的翻译中，只允许有一个`LABEL out`指令，否则，执行到`GOTO out`语句时将产生冲突而不知道将控制转到何处。因此，当翻译if语句时，需要采取某些机制，用唯一的标号替换代码框架中的out

假设newlabel是一个过程，每次调用它时，返回一个新标号。

```
stmt -> if expr then stmt1 {
    out := newlabel;
    stmt.t = expr.t ||
        'gofalse' out ||
        stmt1.t ||
        'label' out
}
```

#### 输出一个翻译

上述的表达式翻译器使用print语句逐渐生成一个表达式的翻译。类似的print语句也可以用于产生一个语句的翻译。此处不再使用print语句而使用emit过程来隐藏输出细节

```
stmt -> if 
    expr { out := newlabel; emit('GOFALSE', out); }
    then
    stmt1 { emit('label', out); }
```

当产生式中出现语义动作时，按照从左到右的顺序考虑产生式右部的每一个元素。在上面的产生式中，语义动作的顺序如下：在分析expr指令时out设置成newlabel返回的标号，然后输出`GOFALSE`指令，在分析stmt1语句时，执行语义动作，最后label指令被输出。假设在分析expr和stmt1的过程中，语义动作输出了这些非终结符的代码。

语句序列的翻译是简单地将各个语句连接起来。

多数单入口单出口的语法结构的翻译都和while语句的翻译相似。这一点将通过考虑表达式中的控制流来说明

```
procedure stmt;
var test, out: interger; /* 标号 */
begin
    if lookahead = id the begin
        emit('LVALUE', tokenval); match(id); match(':='); expr;
    end
    else if lookahead = 'if' then begin
        match('if');
        expr;
        out := newlabel;
        emit('GOFALSE', out);
        match('then');
        stmt;
        emit('LABEL', out);
    end
    else error;
end
```

表达式
```
expr1 or expr2
```
可以实现为
```
if expr1 then ture else expr2
```
下面的代码可以实现or的操作
```
COPY
GOTURE out
POP
expr2
LABEL out
```

`GOTRUE`和`GOFALSE`指令弹出栈顶数值来简化条件语句和while语句的代码生成。通过备份expr1的值，如果`GOTRUE`指令产生转移，则栈顶值为真。

用于构建一个编译器前端的语法制导技术。可以给出一个C语言的编写的翻译器，它把用分号分隔的中缀表达式序列翻译为相应的后缀表达式序列。表达式由数字、标识符、操作符(+,-,*,/,div,mod)构成。

### 翻译器的描述

记号`id`用来表示一个由字母开始的非空字母数字序列，num是一个数字序列，eof是一个表示文件结束的字符。记号由空格、制表符和换行符("空白符")分隔：记号`id`的属性lexeme给出了形成该记号的字符串。`num`的属性值value给出了由`num`表示的整型数。

#### 词法分析器模块lexer.c

词法分析器是一个`lexan()`的程序，语法分析器调用`lexan()`程序获取记号。lexan()每次读入一个字符，并将它发现的记号返回给语法分析器。与记号关联的属性的值被赋给全局变量tokenval.

下列记号是语法分析器所需要的：

```
+ - * / DIV MOD (  ) ID NUM DONE
```
ID表示一个标识符, NUM是一个数字, DONE是文件末尾字符。空白符已经被词法分析器去除。

词法分析器使用符号表程序lookup判定一个标识符词素是否曾经出现过。insert程序将新词素存储到符号表中。每当读到一个换行符，全局变量lineno加1.

#### 语法分析器模块parser.c

首先上述的翻译模式消除左递归，以使文法可以由递归下降语法分析器进行语法分析。转换后的翻译模式如下述所示.

```
start -> list eof
list -> expr; list | e
expr -> term moreterms
moreterms -> + term {print('+')} moreterms 
           | - term {print('+')} moreterms 
           | e
term -> factor morefactors
morefactors -> * factor {print('+')} morefactors 
             | / factor {print('/')} morefactors 
             | div factor {print('DIV')} morefactors 
             | mod factor {print('MOD')} morefactors 
             | e
factor -> { expr }
        | id {print(id.lexeme) }
        | num {print(num.value) }
```

函数`parse()`实现文法的启示符号，在它需要一个新的记号时调用`lexan`函数。语法分析器使用`emit`函数产生输出并用`error`函数报告语法错误

#### 输出模块emitter.c

输出模块由单个函数emit(t, tval)组成，它为具有属性值tval的记号t产生输出

#### 符号表模块symbol.c和init.c

符号表的数组symtable的每一项由一个指向lexemes数组的指针和一个表示记号的整数编码组成。insert(s, t)操作返回词素s(词素s构成记号t)在symtable中的索引。lookup(s)函数返回词素s在symtable中项的索引，如果s不存在，返回0.

init.c模块用于为符号表symtable预加载关键字。所有关键字的词素和记号表示都保存在keywords数组中，keywords数组与symtable数组有相同的类型。init()函数顺序地扫描keywords数组，利用insert()操作将关键字插入符号表。这种组织方式使得关键字的记号表示容易改变。

#### 错误处理模块error.c

错误处理模块负责错误的报告，这是极为基本的。一旦语法错误被发现，编译器将显示一条消息说明当前输入行出现错误，并停止分析。

*一种较好的错误恢复技术是使编译器跳过出错的语句，继续进行语法分析*

#### 编译器的建立

global.h

```c
#ifndef _GLOBAL_H_
#define _GLOBAL_H_

#include <stdio.h>    // 输入/输出
#include <ctype.h>    // 加载字符测试程序
#include <string.h>

#define BSIZE 128     // 缓冲区大小
#define NONE  -1
#define EOS   '\0'

#define NUM  256
#define DIV  257
#define MOD  258
#define ID   259
#define DONE 260

#ifndef pass
#define pass
#endif

extern int tokenval;  // 记号的属性值
extern int lineno;    // 行号

// 符号表的表项格式
typedef struct entry {
    char * lexptr;
    int token;
} entry;

entry symtabel[];

/* function declare  */

void error(const char* m);  // 生成所有的出错信息
void emit(int t, int tval);  // 生成输出
int lookup(char s[]); // 返回s符号表项的位置
int insert(char s[], int tok); // 插入符号表，返回s表项的位置
int lexan();  // 词法分析器 或者记号 token 
void parse(); // 分析并翻译表达式列表
void init();

#endif

```

emtter.c

```c

#include "global.h"

// 打印输出模块

// 生成输出
void emit(int t, int tval) {
    switch (t)
    {
    case '+': case '-': case '*': case '/':
        printf("%c\n", t);
        break;
    case DIV:
        printf("DIV\n"); break;
    case MOD:
        printf("MOD\n"); break;
    case NUM:
        printf("%d\n", tval); break;
    case ID:
        printf("%s\n", symtabel[tval].lexptr); break;
    default:
        printf("token %d, tokenval %d\n", t, tval); break;
    }
}
```

error.c

```c

#include "global.h"

// 错误处理模块

// 生成所有的出错信息
void error(const char* m) {
    fprintf(stderr, "line: %d : %s\n", lineno, m);
    exit(1);  /* 非正常终止 */
}

```

init.c

```c

#include "global.h"

// 初始化模块

// 关键字
entry keywords[] = {
    {"div", DIV},
    {"mod", MOD},
    {"0", 0},  // 关键字结尾
};

// 将关键字填入符号表
void init() {
    entry * p;
    for (p = keywords;p->token;p++) {
        insert(p->lexptr, p->token);
    }
}

void main() {
    init();
    parse();
    exit(0);
}

```

lexer.c

```c

#include "global.h"

// 词法分析器模块

char lexbuf[BSIZE];
int tokenval = NONE;  // 记号的属性值
int lineno = 1;    // 行号

// 词法分析器 或者记号 token 
int lexan() {
    int t;
    for (;;) {
        t = getchar();  // 从字节流获取一个字符
        if (t == ' ' || t == '\t' || t == '\v') // 去除空白符
            pass;
        else if (t == '\n' || t == '\r')  // 检测换行符
            lineno = lineno + 1;
        else if (isdigit(t)) {
            ungetc(t, stdin);
            scanf("%d", &tokenval);
            return NUM;
        }
        else if (isalpha(t)) {
            int p, b = 0;
            while (isalnum(t)) {
                lexbuf[b] = t;
                t = getchar();
                b = b + 1;
                if (b > BSIZE)
                    error("compiler error");
            }
            lexbuf[b] = EOS;
            if (t != EOF)
                ungetc(t, stdin);
            p = lookup(lexbuf);
            if (p == 0)
                p = insert(lexbuf, ID);
            tokenval = p;
            return symtabel[p].token;
        }
        else if (t == EOF)
            return DONE;
        else {
            tokenval = NONE;
            return t;
        }
    }
}

```

parse.c

```c

#include "global.h"

// 词法翻译器模块

int lookahead;

static void expr();
static void term();
static void factor();
static void match(int t);

// 分析并翻译表达式列表
void parse() {
    lookahead = lexan();
    while (lookahead != DONE) {
        // 匹配表达式
        expr(); 
        // 每个表达式结尾要匹配句尾;
        match(';');
    }
}

static void expr() {
    int t;
    term();
    while (1) {
        switch (lookahead)
        {
        // + - 优先级比* / ( ) 低，最后匹配
        case '+': case '-':
            t = lookahead;
            match(lookahead); term(); emit(t, NONE);
            break;
        default:
            return;
        }
    }
}

static void term() {
    int t;
    factor();
    while (1) {
        switch (lookahead)
        {
        case '*': case '/': case DIV: case MOD:
            t = lookahead;
            match(lookahead); factor(); emit(t, NONE);
            break;  
        default:
            return;
        }
    }
}

static void factor() {
    switch (lookahead)
    {
    case '(':
        match('('); expr(); match(')'); 
        break;
    case NUM:
        emit(NUM, tokenval); match(NUM); 
        break;
    case ID:
        emit(ID, tokenval); match(ID); 
        break;
    default:
        break;
    }
}

static void match(int t) {
    if (lookahead == t)
        lookahead = lexan();
    else 
        error("syntax error!");
}

```

symbol.c

```c

#include "global.h"

// 符号模块

#define STRMAX 999    // lexemes数组的大小
#define SYMMAX 1000   // symtable的大小

char lexemes[STRMAX];
int lastchar = -1;   // lexemes中最后引用的位置
entry symtabel[SYMMAX];
int lastentry = 0;   // symtable中最后引用的位置

// 返回s符号表项的位置
int lookup(char s[]) {
    int p = 0;
    for (p = lastentry;p > 0; p = p - 1) {
        if (strcmp(symtabel[p].lexptr, s) == 0)
            return p;
    }
    return 0;
}

// 插入符号表，返回s表项的位置
int insert(char s[], int tok) {
    int len;
    len = strlen(s);
    if (lastentry + 1 >= SYMMAX) {
        error("symbol table full!");
    }
    if (lastchar + len + 1 >= STRMAX) {
        error("lexemes array full!");
    }
    lastentry = lastentry + 1;
    symtabel[lastentry].token = tok;
    symtabel[lastentry].lexptr = &lexemes[lastchar + 1];
    lastchar = lastchar + len + 1;
    strcpy(symtabel[lastentry].lexptr, s);
    return lastentry;
}

```

## 第三章：词法分析

实现简单词法分析的简单方法包括两步：首先建立一张描述源语言记号的结构的图。然后，手工地把这张图翻译成能够识别源语言记号的程序。用这种方法可以产生有效的词法分析器。

这种词法分析器的技术也经常用于其他领域，如查询语言与信息检索系统。在每个应用中，最基本的问题是如何设计与说明一种特殊的程序，它能够完成由字符串中的模式触发的动作。

还有一些语言是用正则表达式描述模式(识别正则表达式的有穷自动机识别器)。例如，模式扫描语言AWK利用正则表达式来选择输入行进行处理，UNIX系统的shell允许用户通过正则表达式指定一组文件名，如UNIX命令`rm *.o`用来删除所有文件名以`.o`结尾的文件。

词法分析器的自动生成工具可以使具有不同背景的人员在他们各自的应用领域中使用匹配的模式。

词法分析器的生成器的最大优点是它能利用最著名的模式匹配算法为哪些不精通模式匹配技巧的人产生有效的词法分析器。

### 词法分析器的作用

词法分析(lexer)时编译的第一阶段。词法分析器的主要任务是读入输入字符，产生记号序列，提交给语法分析使用。这种交互通常可以通过使词法分析器作为语法分析器的子程序或协作程序来实现。当词法分析器收到语法分析器发出的“取下一个记号”的命令时，词法分析器读入输入字符，直到识别出下一个记号。

词法分析器是编译器中读入源程序的部分，因此它还可以完成一些相关的辅助任务。一个任务是滤掉源程序中的注释、空格、制表符、换行符；另一个任务是使编译器能将发现的错误信息与源程序的出错位置联系起来。

例如，词法分析器负责记录遇到的换行符，以便将行号与出错位置联系起来。在某些编译器中，词法分析器负责拷贝一份源程序，并将出错信息加入其中。如果源语言支持宏处理功能，可以在词法分析阶段完成这些预处理功能。

词法分析器可以分为两个阶段:第一个阶段是扫描阶段，第二个阶段是词法分析阶段。
扫描程序负责完成一些简单的任务，词法分析器要完成比较复杂的任务。
例如，Fortran编译器可以使用扫描程序从输入中清楚空格。

#### 词法分析中问题

* 词法分析和语法分析分离可以简化两者的设计
* 提高编译器的效率。编译器的大部分时间消耗在读源程序并将其切分为记号方面。采用专门的缓存技术来进行输入字符串的读取和记号的处理可以显著提高编译器的性能
* 增强编译器的可移植性。

#### 记号、模式、词素

记号|词素示例|模式的非形式描述
-|-|-
const|`const`|const
if|`if`|if
relation|`<`,`<=`,`=`,`<>`,`>`,`>=`|`<`或`<=`或`=`或`<>`或`>`或`>=`
id|`pi`,`count`,`i`,`j`,`D2`,`val_sudu`|字母打头的字母数字串(可包含下划线)
num|`3.1416`,`0`,`6.2`,`0x32`,`2e4`|任何数字常数(科学计数法、小数点、其他十进制、二进制等)
literal|`"core dumped"`|在"与"之间除"以外的任何字符(注意转移字符)

把记号作为源语言文法的终结符，用黑体名字表示记号。由记号的模式所匹配的词素表示源程序的字符串，它们是词法单位。

在多数程序设计语言中，关键字、操作符、标识符、常量、文字串和标点符号(如括号、逗号、分号)被处理为`记号token`.

记号的返回通常是通过传递代表这个记号的整数来实现的，一般是枚举或者常量，或者记号本身的ascii码

`模式` 是描述源程序中表示特定记号的词素的规则。如上述表格的`const`的模式是一个字符串const,它是一个关键字。记号`relation`的模式是6个Pascal关系操作符的集合，为了能精确地描述`id`(表示标识符)和`num`(表示数)这样更复杂的记号，将使用`正则表达式`

某些语言的约定给词法分析带来了困难。例如Fortran语言要求某些结构出现在输入行的固定位置，于是`词素对准(alignment)`对确定源程序的正确性非常重要。现代语言设计的倾向是自由格式输入，允许各种结构出现在输入行的任何地方。

不同语言在空格的处理上有较大差别。在一些语言中，空格无意义(字符串中的空格除外)。在程序中可以随意加入空格来改善其可读性。对空格的约定增加了识别`记号`的复杂性。

很多语言规定某些字符串是保留的，即它们的含义是预定义的，不能由用户改变。如果关键字不是保留的，那么词法分析器必须能区分出关键字和用户自定义的标识符。

在PL/I语言中关键字不是保留的，因而把关键字从标识符区别出来的规则相当复杂。

比如
```PL
IF THEN THEN THEN = ELSE; ELSE ELSE = THEN;
```

#### 记号的属性

如果不止一个记号的模式能匹配到一个词素，词法分析器必须为这个记号提供附加的关于匹配的特殊词素的信息。例如，模式`num`既能匹配到字符串0，也能匹配到字符串1，此时代码生成器需要知道num到底匹配了哪一个字符串。

词法分析器把与记号有关的信息收集到记号的属性中。记号影响语法分析，而属性影响记号的翻译。在实际的实现的时候，记号通常只有一个属性，即指向符号表中一个表项的指针，与记号有关的信息保存在这个对应的表项中。

为了诊断错误，不仅需要知道匹配标识符的词素，而且还需要知道这个词素第一次出现的行号。这些信息都可以存储在符号表中该标识符对应的表项内。

例如，Fortran语句`E = M * C ** 2`，可以用记号和它们的属性值组成的二元组序列表示如下
```
<id, 指向符号表中与E相关的表项的指针>
<assign_op,>
<id, 指向符号表中与M相关的表项的指针>
<multi_op,>
<id, 指向符号表中与C相关的表项的指针>
<exp_op,>
<num,整数值2>
```

注意，某些二元组不需要属性值，它的第一个分量足以标识词素。记号`num`的属性是一个整数值。当然，编译器也可以把形成数的字符串存入符号表中，并让记号`num`的属性是指向符号表中相应表项的指针。

#### 词法错误

因为词法分析器不能从全局的角度考察源程序，所以能在词法层发现的错误是有限的。如果词法分析器在如下的C程序第一遇到fi

```
fi (a == f(x))
```

它无法区别fi究竟是关键字if的错误拼写还是一个未声明的函数标识符。由于fi是合法的标识符，词法分析器必须返回该标识符的记号，而让编译器的其他阶段去处理这种错误。

有时会出现由于剩余输入的前缀不能和任何记号的模式匹配而使词法分析器无法处理的情况。此时，最简单的错误恢复策略也许是“紧急方式”恢复，即反复删掉剩余输入最前面的字符，直到词法分析器能发现一个正确的记号为止。这种恢复技术可能会给语法分析带来一些麻烦，但在交互计算中是非常有效的。

其他错误恢复动作包括:

* 删除一个多余的字符
* 插入一个遗漏的字符
* 用一个正确的字符代替一个不正确的字符
* 交换两个相邻的字符

这样的错误变换可以用于对输入错误的修补。最简单的策略是看一下剩余输入的前缀能否通过上面的一个变换变成一个合法的词素。这种策略假设大多数词法是多、漏或错一个字符或者相邻的两个字符错位的结果。

在程序中发现错误的一种方法是计算把一个错误程序转换成一个语法上正确的程序所需要的错误变换个数的最小值。

当把一个错误程序转换成一个正确程序所需的最短错误变换序列长度为k时，我们说这个程序有k个错误。最小距离错误校正是一种理论上的标准，但是因为其实现起来代价太高，实际上并不常用。然而一些试验性的编译器在进行局部校正时确实用到了最小距离标准

### 输入缓冲

**双缓冲输入方案**，为识别记号而需要进行超前扫描的情况下非常有用。

**标志(sentinel)**标记缓冲区边界

实现词法分析器最常用的三种方案：

* 使用词法分析器生成器(如Lex编译器),从基于正则表达式的说明自动产生一个词法分析器。在这种情况下，由生成器提供子程序实现输入流的读取和缓冲。
* 使用传统的程序设计语言编写词法分析器，并使用该语言提供的I/O功能对输入流进行读取
* 使用汇编语言编写词法分析器，并显示地控制输入流的读取

构造的词法分析器效率越高，构造的难度就越大。

但由于词法分析器是编译器中唯一的逐个字符读取源程序的阶段，所以它可能会耗费大量的时间。因此，在设计编译器时，词法分析器的速度是一个关键因素。

利用自动生成器自动生成词法分析器的方案

#### 双缓冲区

对很多语言来说，在一个词素被一个模式匹配上之前，词法分析器往往需要超前扫描该词素后面的若干字符。

把一个缓冲区分成两个部分，每部分能容纳N个字符，一般来说，N是一个磁盘块中字符的个数，如1024或者4096.

每次用一个系统读命令向缓冲区的每半部分读入N个字符，而不是每读入一个字符调用一次读命令。如果剩余的输入数据不足N个字符，则在缓冲区中最后一个输入字符后面会读进来一个特殊字符`eof`,`eof`不同于任何其他的输入字符，它用于标识源文件的结尾。

输入缓冲区包括两个指针，在两个指针之间的字符串就是当前的词素。一开始，两个指针都指向下一个要识别的词素的第一个字符上。
然后，其中一个指针(即向前forward指针)向前扫描，直至发现一个与某个模式匹配的词素为止。一旦一个词素被确定，向前指针将指向它的最右字符。在处理完这个词素后，两个指针同时定位到这个词素的一个字符。在这种策略中，注释和空白符可以由不生成的记号的模式来匹配。

如果向前指针将要移过缓冲区的中间标记，则往缓冲区的右半部读入N个新字符。如果向前指针将要移过缓冲区的右端，则往左半部读入N个新字符，且将向前指针绕回到缓冲区的头部继续处理。

这种缓冲机制在多数情况下都非常有效，但限制了超前扫描的数量。在超前扫描时，若向前指针需要移动的距离超过了缓冲区的长度，词法分析器就无法识别出记号。

#### 标志(sentinel)

如果采用双缓冲的模式，在每次移动向前指针时都必须检查是否到了缓冲区某半部分的末尾，若是，则需重装缓冲区的另半部分，

```
if forward在缓冲区第一部分末尾 then begin
    重装缓冲区第二部分;
    forward := forward + 1
end
else if forward在缓冲区第二部分末尾 then begin
    重装缓冲区第一部分
    将forward移到缓冲区第一部分开始
end
else 
    forward := forward + 1
```

如果先前指针不在缓冲区某半部分的末尾，上述代码每次移动向前指针时都需要做两次测试。如果我们在缓冲区两部分的结尾处各设置一个标志字符，则可以减少一次测试。

这个“标志”必须是源语言词素集合的特殊字符。一个比较自然的选择就是eof,

在大部分情况下，算法只需测试一次，以判断forward指针是否已经指向eof。只有当到达缓冲区半部分的末尾或源文件尾时，算法才需要进行更多的测试。由于在两个eof之间有N个字符。每个输入字符的平均检查次数近似于1.

还需要确定如何处理向前指针当前所指的字符。该字符可能是一个记号的结尾标志，也可能正被识别的关键字的一部分，还可能是其他各种情况。

如果所选的实现语言支持case语句。则可以用它来完成这些测试。例如。可用case语句的一个分支来实现测试。

### 记号的描述

正则表达式是表示模式的一种重要方法，每个模式匹配一个字符串集。因此正则表达式将作为字符串集的名字。

#### 串和语言

术语**字母表**和**字符类**表示有限符号的集合。符号的典型例子是字母和字符。集合{0,1}是二进制字母表。ASCII和EBCDIC是两个计算机字母表实例。

字母表上的**字符串**是该字母表中符号的有穷序列。在语言理论中，术语句子和字常作为“符号串”的同义词。符号串s的长度是出现在s中的符号的个数，通常记作|s|。例如，banana是长度为6的符号串。空字符串是长度为0的特殊字符串，用e表示。

术语|定义
-|-
s的前缀|去掉串s尾部的0个或多个符号后得到的字符串。例如ban是banana的前缀
s的后缀|去掉串s头部的0个或多个符号后得到的字符串。例如nana是banana的一个子串。
s的子字符串|去掉上的一个s前缀和一个后缀得到的字符串。例如，nan是banana的一个子串。s的每个前缀和后缀都是s的一个子串，但子串并不总是s的前缀或后缀。对于每个字符串s，s和e是s的前缀、后缀和子串
s的真前缀|如果非空串x是串s的前缀(后缀、子串)，而且s!=x,则称x是s的真前缀
s的子序列|从串s中删除0个或多个符号后得到的串(这些被删除的符号可以不相邻)。例如，baaa是banana的子序列

*语言*是给定字母表上的任意一个字符串的集合。这个定义是广义的。像空集和仅包含空符号串的集合{e}这样的抽象语言也符合这个定义。所有语法正确的pascal程序的集合和所有语法正确的英语句子的集合也都符合这个定义，当然，要描述后两个集合要难的多。

字符串的连接和乘积`a+b=ab`,`s^2=ss`

#### 语言上的运算

有一些重要的运算可以应用到语言中。对词法分析而言，感兴趣的是`并`、`连接`和`闭包运算`.

例：令L由大小写字母组成的字母表={A,B,...,Z,a,b,...,z},D由10个数字组成的字母表表示集合{0,1,...,9}

* L∪D是字母和数字的集合
* LD是一个字母后随一个数字的符号串的集合
* L4是由四个字母构成的符号串的集合
* L*是所有字母构成的串(包括e)的集合（L的克林Kleene）
* L(L∪D)是所有以字母开头的字母数字串的集合
* D+是由一个或多个数字构成的数字串的集合（L的正闭包）

#### 正则表达式

在Pascal语言里，标识符是一个字母后跟随零个或多个字母或数字组成的符号串，即一个标识符是例子中所定义的集合中的元素。

使用正则表达式，可以将Pascal的标识符集可以定义为：

```
letter(letter|digit)*
```

其中竖线的含义是“或”，括号用于把子表达式组在一起，星号的含义是“零个或多个”括号中的表达式，`letter和(letter|digit)*`的并列表示两者的连接

建立正则表达式时，可以先定义简单的正则表达式，然后用它们构造出更复杂的正则表达式。每个正则表达式r表示一个语言L(r)。这些定义规则说明L(r)是怎样由r的子表达式所表示的语言以不同的方式组合形成的。

下面是定义**字母表∑**上的正则表达式的规则，每一条规则后带有所定义的正则表达式所表示语言的一个说明：

* **规则1**：e是正则表达式，它表示{e},即包含空串的集合
* **规则2**：如果a是∑上的符号，那么a是正则表达式，表示{a},也就是包含符号串a的集合。虽然，我们使用相同的表示法，但正则表达式a、符号串a和符号a这三者的含义是不同的，可以从上下文中清楚地区分出所谈到的a的具体含义
* **规则3**：假定r和s都是正则表达式，分别表示语言L(r)和L(s),则：
1. `(r)|(s)`是正则表达式，表示`L(r)∪L(s)`
2. `(r)(s)`是正则表达式，表示`L(r)L(s)`
3. `(r)*`是正则表达式，表示`(L(r))*`
4. `(r)`是正则表达式，表示`L(r)`

正则表达式表示的语言叫做`正规集`

正则表达式的说明是一种递归定义。规则1、2是定义的基础。把e和出现在正则表达式中的∑中的符号称为*基本符号*，规则3提供了归纳的步骤.

1. 一元运算符`*`具有最高的优先级，并且是左结合的
2. 连接的优先级次之，也是左结合的
3. `|`的优先级最低，同样是左结合的

那么在正则表达式中可以避免一些不必要的括号。在此约定下,`(a)|((b)*(c))`等价于`a|b*c`。这两个表达式都表示由单个a构成的符号串或者由0个或多个b后面跟着一个c组成的符号串集合。

令`∑={a,b}`

1. 正则表达式`a|b`表示集合`{a,b}`
2. 正则表达式`(a|b)(a|b)`表示`{aa,bb,ba,bb}`,即由a和b组成的长度为2的符号串的集合。表示同样集合的另一正则表达式是`aa|ab|ba|bb`
3. 正则表达式`a*`表示由零个或多个a组成的所有串的集合`{e,a,aa,aaa,...}`
4. 正则表达式`(a|b)*`表示由零个或多个a或b构成的符号串集合，即由a和b构成的所有符号串的集合。这个集合也可用另一个正则表达式`(a*b*)*`来表示
5. 正则表达式`a|a*b`表示串a和零个或多个a后跟随一个b构成的符号串的集合。

如果两个正则表达式r和s表示同样的语言，则称r和s等价，记作`r=s`。例如，`(a|b)=(b|a)`.正则表达式遵循一些代数定律，它们可以用于正则表达式的等价变换。

下表示正则表达式r,s和t遵循的代数定律

公理|描述
-|-
`r|s=s|r`|`|`是可交换的
`r|(s|t)=(r|s)|t`|`|`是可结合的
`(rs)t=r(st)`|连接是可结合的
`r(s|t)=rs|rt`或`(s|t)r=sr|tr`|连接对`|`是可分配的
`er=r`或`re=r`|空串`e`是连接的单位元
`r*=(r|e)*`|`*`和`e`的关系
`r**=r*`|`*`是幂等的

#### 正则定义

为表示方便，希望为正则表达式命名，并用这些名字来定义正则表达式，就如同它们也是符号一样。如果∑是基本符号的字母表，那么正则定义是如下形式的定义序列：
```
d1->r1
d2->r2
...
dn->rn
```
其中，每个di都是一个名字，并且它们各不相同，每个ri是∑∪{d1,d2,...,dn-1}(即基本符号和前面定义的名字)中符号上的正则表达式。由于限制了每个ri中只含∑中的符号和在它之前定义的名字，所以可以通过反复地用名字所代表的正则表达式替代该名字的方法为任何一个ri构造∑上的正则表达式。如果ri用到了dj，并且j>=i,则ri是递归定义的，而且这个替换过程不会中止。

例子：如前面所述，Pascal语言的标识符集合是以字母开头的字母数字串的集合，这个集合的正则定义时

```
letter -> A | B | ... | Z | a | b | ... | z
digit -> 0 | 1 | ... | 9
id -> letter(letter|digit)*
```

Pascal语言中的无符号数是形如`5280`、`39.37`、`6.336e4`、`1.849E-4`这样的符号串，下面的正则表达式定义给出了这类符号串的精确说明
```
digit -> 0|1|···|9
digits -> digit digit*
optional_fraction -> .digtis|e
optional_exponent -> (E(+|-|e)digits)|e
num -> digits optional_fraction optional_exponent
```
在这个定义中，optional_fraction是空串(空缺)或小数点后再上一个或多个数字。注意，小数点后至少要有一个数字，所以num不能匹配1.,但能匹配1.0

#### 缩写表示法

在正则表达式中，某些结构出现频繁，为方便起见，我们可以用缩写形式表示它们。

* **一个或多个实例**-一元后缀操作符*的意思是“一个或过个实例”。如果`r`是表示语言`L(r)`的正则表达式，那么`(r)*`是表示语言`(L(r))*`的正则表达式。正则表达式`a+`表示由一个或多个a构成的所有串的集合。操作符`+`和操作符`*`具有同样的优先级和结合。代数恒等式`r*=r+|e`与`r+=rr*`表达了克林闭包和正闭包`+`这两个操作符间的关系。
* **零个或一个实例**-一元后缀操作符`?`的意思是“零个或者多个实例”。`r?`是`r|e`的缩写式。如果r是正则表达式，则`(r)?`是表示语言`L(r)U{e}`的正则表达式。例如，使用`+`和`?`操作符，可以重写上述的例子
```
digit -> 0|1|···|9
digits -> digit*
optional_fraction -> (.digits)?
optional_exponent -> (E(+|-)?digits)?
num -> digits optional_fraction optional_exponent
```
* **字符类**-`[abc]`(其中a、b和c是字母表中的符号)表示正则表达式`a|b|c`.缩写的字符类`[a-z]`表示正则表达式`a|b|···|z`。使用字符类，可以用下述正则表达式描述标识符：`[A-Za-z][A-Za-z0-9]`

#### 非正规集

某些语言不能用正则表达式描述。
* 正则表达式不能用于描述均衡或者嵌套结构。例如，具有配对括号的符号串集合不能用正则表达式描述，但它们可以用上下文无关文法来描述
* 重复符号串不能用正则表达式表示。集合{wcw|w是a和b组成的串}不能用正则表达式描述，也不能用上下文无关法来说明
* 正则表达式只能表示固定次数的重复或给定结构的没有指定次数的重复。由于正则表达式不能比较任意两个数是否相等，因此不能用正则表达式描述早期Fortran语言中形如nHa1a2...an的Hollerith字符串，因为H后面的字符数目要等于H前面的十进制数

### 记号的识别

考虑下述文法片段
```
stmt -> if expr then stmt
    | if expr then stmt else stmt
    | e
expr -> term relop term
    | term
term -> id
    | num
```

其中，终结符if、then、else、relop、id和num产生由以下正则定义给出的串的集合：
```
if -> if
then -> then
else -> else
relop -> < | <= | = | <> | > | >=
id -> letter(letter|digit)*
num -> digit+(.digit)?(E(+|-)?digit+)?
```
其中，letter和digit的定义与前面相同。

对这个给定的语言，词法分析器将识别关键字if、then、else和由relop(关系操作符)、id(标识符)和num(数)表示的词素。为简单起见，假定关键字是保留的，也就是说，它们不能作为标识符使用。类似于例3.5，这里的num表示Pascal中的无符号整数和实数。

此外，我们还假定词素由空白符分隔。空白符是空格、制表符、换行符组成的非空序列。词法分析器还要完成去掉空白符的任务。这个任务通过把输入串与如下的ws正规定义相比较来完成：
```
delim -> blank | tab | newline
ws -> delim+
```
如果发现了与ws匹配的字符串，则词法分析器不返回记号给语法分析器，继续识别空白符后面的记号，然后把它返回给语法分析器。

记号的正则表达式模式

正则表达式|记号|属性值
-|-|-
`ws`|-|-
`if`|`if`|-
`then`|`then`|-
`else`|`else`|-
`id`|`id`|指向符号表表项的指针
`num`|`num`|指向符号表表项的指针
`<`|`relop`|LT
`<=`|`relop`|LE
`=`|`relop`|EQ
`<>`|`relop`|NE
`>`|`relop`|GT
`>=`|`relop`|GE

目标是构造一个词法分析器，这个词法分析器能利用上表在**输入缓冲区**中识别出下一个记号的词素，产生该词素相应的记号和属性值的二元组。关系操作符的属性值由符号常量`LT`,`LE`,`EQ`,`NE`,`GT`和`GE`给出

#### 状态转移图(状态转移图)

作为构造词法分析器的中间步骤，先构造**状态转移图(transition diagram)**状态转移图描绘语法分析器为得到下一个记号而调用词法分析器时词法分析器要做的动作。

假设输入缓冲区为长度1024，并且词素开始(*lexeme-beginning*)指针指向上次发现的词素后面的字符。当向前指针扫描输入流字符时，用状态转换图来记录所读信息的轨迹，方法是在读字符的过程中不断地在状态转移图的各位置之间移动。

状态转换图的位置用圆圈表示，叫做*状态*,状态间由箭头连接，称为边。由状态s到状态r的边上标记的字符表示使状态r的输入字符。标记`other`表示任意一个未被离开状态s的边所标定字符。

假设状态转换图是*确定的*，即没有一个符号可以同时离开一个状态的两条以上的边的标记匹配。使词法分析器的设计更加简单。如果使用恰当的工具，词法分析器的实现会更加容易。

状态转换图中具有一个状态标记为`start状态`,这个状态称为`初始状态`。识别记号时，将从这个状态开始。有些状态可以具有动作，当控制流到达一个具有动作的状态时，将执行这些动作。当进入一个状态时，需要读入下一个输入字符。若存在一个离开当前状态的边，其标记和读入字符匹配，控制就转到有这条边指向的状态，否则表示失败。

通常可能有多个状态转移图，每个图说明一组记号。如果沿着一个状态转换图识别输入字符串失败，需要把前向指针回退到进入该图开始状态时该指针所指向的输入字符串位置，并启动下一个状态转换图。因为在状态转换图的开始状态，词法分析器的词素开始指针和向前指针都指向同一个位置，所以向前指针被回退到词素开始指针所指向的位置。

*注意：如果在所有状态转换图上都失败了，则意味着输入字符串有词法错误。这时，需要调用错误恢复程序进行错误处理*

例：因为关键字是字母序列，所以它们也符合标识符的规则，即由字母开头的字母和数字的序列。一般来说，不为关键字单独构造状态转换图，而是把关键字看成特殊的标识符。

**把关键字从标识符中分离出来的一种简单技术是适当地初始化符号表**:将关键字再一开始就存入符号表。

对于上表中的记号，需要在开始扫描输入字符之前把字符串if、then和else填入符号表。这些符号的记号也将被记录在符号表中，以便它们在输入字符串中被识别出来，返回它们的记号。使用return语句分别使用gettoken()和install_id()来获得要返回的记号和属性值。过程install_id()访问缓冲区，标识符词素被定位在其中，并用该词素查符号表，如果在符号表找到了该词素，当它被标记为关键字时，install_id()返回0，当它是程序变量时,install_id()返回返回指向相应符号表表项的指针。如果在符号表中没有找到该词素，则把该词素作为变量填入符号表中，并返回指向新建表项的指针。

过程gettoken()也以类似的方式在符号表中查找词素。如果该词素是个关键字，则返回相应的记号，否则返回记号`id`.

**如果有要增加的关键字，无需修改状态转换图，只需将新增关键字对应的字符串和记号填入符号表即可**

如果不把关键字预先放入符号表，一个典型的程序设计语言的词法分析器的状态数会达到几百个。如果使用这种技术，需要的状态数可能不到一百个

```
num -> digit+(.digit)?(E(+|-)?digit+)?
```
一个给定记号的词素必须是最长的。例如，当输入串是`12.3E4时`，词法分析器不应该在发现`12`或`12.3`后就停止。这里假设`12.3E4`后面是一个非数字的字符。

一种避免多余匹配的方法是将这些状态转换图合并成一张图，一般来说这个任务比较艰巨。另一种方法是改变对失败的响应策略。

#### 状态转换图的实现

状态转换图序列可以变换成程序，用来识别该序列所定义的记号。我们将采用对所有状态转换图都适用的系统化方法来构造程序，该程序的大小与图中状态数和边数成正比。

每个状态对应一个代码段。如果一个状态具有出边，该状态的代码便读一个字符并选择应跟随的边。函数nextchar()用来从输入缓冲区中读入下一个字符，每次调用都向前移动指针，并返回读入的字符。如果存在标记为该字符的边，或标记为包含该字符的字符类的边，则控制转给这条边指向的状态所对应的代码。如果不存在这样的边，而且当前状态不是接收状态，调用fail()程序，把向前指针撤回到开始指针指向的位置，气动下一个状态转换图对应的代码继续匹配。如果不存在下一个状态转换图。fail()调用错误恢复程序，进行错误处理。

用全局指针变量lexical_value返回记号。当识别出一个标识符或一个数时，lexical_value被赋值为install_id()和install_num()过程返回的指针。记号类由词法分析器的主过程nexttoken()返回。

使用case语句查找下一个状态转换图的开始状态。在下述的实现中，两个变量state和start分别用来保存当前转换图的当前状态和起始状态。

```c
int state = 0, start = 0;
int lexical_value; /* 返回记号的第二个分量 */
int fail()
{
    forward = token_beginning;
    switch (start) {
        case 0: start = 9; break;
        case 9: start = 12; break;
        case 12: start = 20; break;
        case 20: start = 25; break;
        case 25: recover(); break;
        default: /* 编译错误 */
    }
    return start;
}
```

下述给出了状态0对应的代码,在状态转换图中一条边一条边地往下匹配的过程是通过不断地选择一个状态对应的代码段来执行，以确定出下一个状态，并将控制转到该状态对应的代码段去执行。

```c
token nexttoken()
{
    while(1) {
        switch (state) {
            case 0:
                /* c是超前扫描字符 */ 
                c = nexychar();
                if (c == blank || c == tab || c == newline) {
                    state = 0;
                    lexeme_beginning++;
                    /* 词素开始指针的前移 */
                }
                else if (c == '<') state = 1;
                else if (c == '=') state = 5;
                else if (c == '>') state = 6;
                else state = fail();
                break;
            case 9:
                if (isletter(c)) state = 10;
                else state = fail();
                break;
            case 10:
                if (isletter(c)) state = 10;
                else if (isdigit(c)) state = 10;
                else state = 11;
                break;
            case 11:
                retract(1);
                install_id();
                return gettoken();
            case 25:
                if (isdigit(c)) state = 26;
                else state = fail();
                break;
            case 26:
                c = nextchar();
                if (isdigit(c)) state = 26;
                else state = 27;
                break;
            case 27:
                retract(1);
                install_num();
                return NUM;
        }
    }
}
```

C代码while(1) `stmt` 会不断地重复执行`stmt`，直到遇见一个return为止。由于C语言不允许同时返回记号和属性值，所以`install_id()`和`install_num()`用全局变量来存放对应于**id**和**num**表项的属性值

如果实现状态转换图的语言没有case语句，可以为每个状态创建一个数组，用字符作下标。如果state1是这样的数组，则当超前扫描的字符是c时，`state1[c]`是指向需要执行的程序段的指针。这些代码段一般以转到下一个状态的代码段的goto语句结束。状态s的数组可以看成是s的间接状态转换表

### 词法分析器描述语言

目前有很多基于正则表达式从特定表示法构建词法分析器的工具。可以用正则表达式来描述记号模式，也可把正则表达式转换成模式匹配程序的算法之前。

Lex编译器广泛用于各种语言的词法分析器的描述，Lex编译器的输入称为Lex语言。讨论现有的工具的目的在于说明如何把*正则表达式*描述的模式与行为(如在符号表创建表项，这是词法分析器需要做的动作)结合起来。

Lex的使用方法

* 首先使用Lex语言写一个定义词法分析器的源程序lex.l
* 然后利用Lex编译器将lex.l转换成C语言程序lex.yy.c。它包括从lex.l的正则表达式构造的状态转换图的表格形式以及使用该表格识别词素的标准子程序。与lex.l中正则表达式相关联的动作是C代码段，这些动作可以直接加到lex.yy.c中。
* 最后，lex.yy.c通过C编译器生成目标程序a.out,a.out就是把输入流转换成记号序列的词法分析器

#### Lex说明

一个Lex程序由如下三部分组成:

* **声明部分**
* **转换规则**
* **辅助过程**

声明部分包括变量声明、符号常量声明和正则定义。（符号常量是被声明来表示常数的标识符。）

Lex程序的转换规则是如下形式的语句：

```
p1 {action_1}
p2 {action_2}
...
pn {action_n}
```

其中每个p是一个正则表达式，每个action表示当模式p匹配上一个词素后词法分析器所要执行的程序段。在Lex中，这些action是用C语言编写的，当然也可以用其他语言来实现。

Lex程序的第三部分包含action所需要的辅助过程。这些过程可以单独翻译，并与词法分析器一起装载。

由Lex创建的词法分析器与语法分析器协同工作的方式如下：词法分析器被语法分析器调用后，从尚未扫描的输入字符串读字符，每次读入一个字符，直到发现能与某个正则表达式pi匹配的最长前缀。然后，词法分析器执行action。通常action会将控制返回给语法分析器。然而，如果不讲控制交给语法分析器，词法分析器可以继续发现更多的词素，直到某个操作将控制返回给语法分析器。词法分析器的这种不断查找词素，直到以显式的return调用结束工作的方式，使其可以方便地处理空白符和注释。

词法分析器只返回记号给语法分析器，带有与词素相关信息的属性值是通过全局变量yylval传递的。

Lex的特点：在声明部分，可以看到转换规则所使用的符号常量的声明。这些声明被一对特殊括号%（和%）括在一起。所有出现在括号内的内容都直接复制到词法分析器lex.yy.c中。它们不作为正则定义或转换规则的一部分。对第三部分的辅助过程也进行同样的处理。

在声明部分还包含一些正则定义。每个定义有一个名字和这个名字所代表的正则表达式组成。例如，第一个名字定义为delim，它代表字符类`[\t\n]`,即空格、制表符(由`\t`表示)、换行符(由`\n`表示)三者之一。第二个是关于空白符定义，由名字ws表示。空白符是一个或多个分隔符组成的序列。注意：在Lex中词delim必须由大括号括起来以便与包含delim这五个字符的模式区别开。

在`letter`的正则定义中使用了字符类.`[A-Za-z]`表示大写字母A到Z或小写字母a-z中的任何一个。在id的定义(第5个定义)中使用了圆括号，圆括号是Lex语言的元符号，与通常情况下的含义相同，表示包括。类似，竖也是Lex语言的元符号，表示并。

在number的正则定义中可以看到更多的细节。？是元符号，表示出现过0次或一次。反斜杠被当成转义字符，使得Lex的元符号能表示它的本来意义。在number的定义中，小数点表示成`"\."`,因为在Lex和很多UNIX系统的处理正则表达式的程序中，单独的一个点表示除了换行符以外的所有字符的字符类。在字符类`[+\-]`中，减号前面的反斜杠是为了避免与减号表示范围的用法混淆.如`[A-Z]`

```lex
%{
    /* 符号常量定义
    LT, LE, EQ, NE, GT, GE,
    IF, THEN, ELSE, TD, NUMBER, RELOP  */
%}

/* 正则定义 */
delim    [ \t\n]
ws       [delim]+
letter   [A-Za-z]
digit    [0-9]
id       {letter}({letter}|{digit})*
number   {digit}+(\.{digit}+)?(E[+\-]?{digit}+)?

%%

{ws}     {/* 没有动作和返回值 */}
if       {return(IF);}
then     {return(THEN);}
else     {return(ELSE);}
{id}     {yylval = install_id(); return(ID);}
{number} {yylval = install_num(); return(NUMBER);}
"<"      {yylval = LT; return(RELOP);}
"<="     {yylval = LE; return(RELOP);}
"="      {yylval = EQ; return(RELOP);}
"<>"     {yylval = NE; return(RELOP);}
">"      {yylval = GT; return(RELOP);}
">="     {yylval = GE; return(RELOP);}

install_id() {
    /* 往符号表中填入词素的过程。yy_text 指向词素的第一个字符，yyleng表示词素的长度。将词素填入符号表，返回指向该词素所在表项的指针 */
}

install_num() {
    /* 与填词素的过程类似，只不过词素是一个数 */
}
```

还有一种方法能使字符保持本来的意义，即使他们是Lex的元符号。这种方法就是用引号把字符括起来。在转换规则部分，使用了这种方法来表示六个关系操作符。

现在，在考虑跟在第一个%%后面的转换规则。第一条规则表示如果发现ws(任何由空格、制表符和换行符组成的最长序列)则不做任何动作，控制也不返回给语法分析器，词法分析器继续识别记号，直到与某一个记号关联的动作调用的return语句。

第二条规则表示如果识别出`if`,则返回记号IF,它是表示某个整数的符号常量，语法分析器将这个整数理解为记号**if**。类似地，接下来的两条规则用来识别关键字then和else。

在**id**的规则中，关联动作的有两条语句。第一条语句将过程install_id的返回值赋给变量yylval，该过程的定义在第三部分给出。变量yylval是在Lex的输出lex.yy.c中定义的。语法分析器也可以访问这个变量。使用yylval的目的是保存词素的属性值，因为return (ID)语句(即第二个语句)只能返回记号类。

install_id的详细代码，Lex使用两个变量yytext和yyleng来保证第三部分的程序能够访问匹配的词素。变量yytext就是前面介绍的词素lexeme_beginning(开始指针)，即指向词素的第一个字符位置的指针。变量yyleng存放词素的长度。如果install_id在符号表中没有找到这个词素，则为它创建一个新的表项，输入流中从yytext开始的yyleng个字符被复制到一个字符数组中，并以一个字符串结尾符做结束标记，在符号表的新表项中填入一个指向这个字符起始位置的指针。

接下来的一条规则以类似的方式处理数。在最后的操作符六条规则中，yylval用来返回识别出的关系操作符对应的代码，而实际上对这个六个关系操作符返回的都是记号relop的代码。

一按一个匹配的词素是if。模式if和{id}均匹配这个词素，并且没有能匹配更长串的模式。匹配关键字if的模式先于匹配标识符的模式执行，所以if被匹配为关键字。

**采用将匹配关键字的模式置于匹配标识符的模式之前的策略，可以简单有效地保留关键字**

例子：假设读入的头两个字符是`<=`.模式`<`匹配上第一个字符，但它不是能匹配输入字符串的最长前缀的模式。Lex采用**选择最长匹配前缀的策略**方便地解决了`<`和`<=`之间的冲突。这里，当然`<=`被选择作为下一个记号。

#### 超前扫描操作

对于某些程序设计语言结构，词法分析器需要超前扫描词素后面的若干字符来确定一个记号

词法分析器在输入缓冲区超前地扫描一串字母或数字，接着扫描等号以及后面的一串字母或数字，最后扫描到逗号才能够判断出这不是一个赋值语句。但只有超前扫描符前面的D和O才是与模式匹配的词素的部分。经过成功的匹配，yytext指针指向字符D并且yyleng=2。注意，这个简单的超前扫描模式使得当DO后面跟着一些无意义的符号

在Lex中，可以把模式写成`r1/r2`的形式，其中r1和r2都是正则表达式。它的意思是当一个字符串与r1匹配时，还需其后的字符串与r2匹配，这样才算该字符串与r1匹配成功。在超前扫描操作符`/`，还需要其后的字符串与`r2`匹配，这样才算该字符串与`r1`匹配成功。在超前扫描操作符`/`后面的正则表达式`r2`表示需要进一步匹配的内容，这里它只是匹配模式的一个限制，而不是匹配的一部分。

```
DO/({letter}|{digit})* * ({letter}|{digit})*
```

超前扫描操作符还可以用来解决Fortran词法分析中的另一个难题：区别关键字和标识符。例如：`IF(I, J) = 3`是一个正确的赋值语句，而不是一个逻辑判断if语句。使用Lex描述关键字IF的一种方法是使用超前扫描操作符定义IF右边的正文。

识别关键字IF的模式可以写为(连带匹配其后的括号):

```
IF / \( .* \) {letter}
```

其中的圆点表示除了换行符以外的任何字符，而括号前面的反斜杠表示括号取其本来的意思，而不是正则表达式中的元符号

处理Fortran的if语句问题的另外一种方法是：当看到字符串`IF(`,先确定IF是否被声明为数组。如果是，才去匹配上面给出的整个模式。这样的检查使得由Lex说明自动实现一个`词法分析器`变得很难，而且它们在运行时可能耗费更多的时间，因为要由模拟状态转化图的程序频繁地判断是否要进行这样的检查。

### 有穷自动机

语言的`识别器`是一个程序，它以字符串x作为输入，当x是语言的句子时，回答“是”，否则回答“不是”。可以通过构造有穷自动机把正则表达式翻译成识别器。有穷自动机是更一般化的状态转换图，它可以是确定的或不确定的，其中“不确定”的含义是：对于某个输入符号，在同一个状态上存在不止一种转换。

确定和不确定的有穷自动机都能而且仅能识别正则集，即它们能够识别正则表达式所表示的语言。但是，它们之间有着**时空的权衡**,确定的有穷自动机导出的识别器比不确定的有穷自动机导出的识别器快得多，但确定的有穷自动机可能比与之等价的不确定的有穷自动机的方法。由于变成不确定的自动机更直接一些。

例如，表示所有以`.o`结尾的文件名的正则表达式是(.|o|c)*.o,其中c代表除.和o以外的任何字符。又如，C语言的注释是由开括号`/*`之后以`*/`结尾的任意字符序列组成的，其任何真前缀都不以`*/`结尾

#### 不确定的有穷自动机

不确定的有穷自动机(简写为NFA)是有个有以下几部分组成的数学模型：

* 一个状态的有穷集合S
* 一个输入符号集合∑，即输入符号字母表
* 一个转换函数move，它把由状态和符号组成的二元映射到状态集合
* 状态s0是唯一的*开始*或者*初始*状态
* 状态集合F是接收(或终止)状态集合

NFA可以用带标记的有向图表示，称为**转换图(transtion graph)**,其节点是状态，有标记的边表示转换函数。这种转换图和前面所讲的**状态转换图(transtion diagram)**很类似，但略有区别：同一个字符可以标记始于同一个状态的两个或多个转换，边可以由输入字符符号，也可以由特殊符号e标记。

可以在计算机上使用不同的方法实现NFA的转换函数。最简单的办法是使用转换表。转换表的每个状态占一行，每个输入符号占一列。表中第i行a列对应的表项是当输入为a时从状态i所能到达的状态的集合(实际上它很可能是指向状态集合的指针)

转换表表示的优点是能够快速地确定给定状态在给定字符上的转换。它的缺点是：当输入字母表较大而且大多数转换是空集时，需要耗费大量空间。转换函数的**邻接表表示法**能提供较紧凑的实现，但在确定一个给定的转换时速度较慢。

例：识别语言`(a|b)*abb`的NFA状态转换图，这个NFA的状态集合是{0,1,2,3}

当且仅当对应的转换图存在从开始状态到某个接受状态的路径，使得该路径的边上的标记恰好连城字符串x时，一个NFA接收输入字符串x。上述的NFA可以接受输入串`abb`,`aabb`,`babb`,`aaabb`,...例如，从状态0开始，沿着标记为a的边再回到状态0，然后沿着标记分别为a,b,b的边进入状态1,2,3.

一条路径可以用状态转换序列表示，其中的状态转换叫做移动。

#### 确定的有穷自动机

确定的有穷自动机(DFA)是不确定的有穷自动机的特例，其中：

* 没有一个状态有e换换，即在输入e上的转换
* 对每个状态s和输入符号a，最多只有一个标记为a的边离开s

确定的有穷自动机在任何状态下，对任一输入符号，最多只有一个转换。如果用转换表表示DFA的转换函数，那么表中的每个表项最多只有一个状态。因而，很容易确定DFA是否接受某输入字符串，因为从开始状态起，最多只有一条到达接受状态的路径可由这个符号串标记。

下边的算法说明怎样在一个输入串上模拟DFA的行为。

```
s := s0
c := nextchar
while c != eof do
end
if s is in F then
    return "yes"
else return "no"
```

输入以文件结束符eof结尾的串x，一个DFA D，其开始状态为s0，接受状态集合为F。输出：如果D接受x，则回答“yes”，否则回答“no”。方法：把图3-22的算法应用于输入字符串x。函数move(s, c)给出状态s上遇到的输入字符c时应该转换到的下一个状态。函数nextchar返回输入串x的下一个字符。

#### 从NFA到DFA的转换

多值转换函数使得很难用计算机程序模拟NFA。“接受”的定义仅仅是说必然存在一条从开始状态到某个接受状态的路径，该路径的标记是输入字符串。如果有很多路径其边上的标记都可以连成同样的输入字符串，则在找到一条接受路径或发现没有路径可到达接受状态前，可能不得不考虑所有这些路径

从NFA构造识别同样语言的DFA算法：这个算法通常被称为子集构造算法，有利于使用计算机程序模拟NFA。一个和它紧密相关的算法在下一章构造LR语法分析器时将起到重要作用

在NFA的转换表中，每个表项是一个状态集；而在DFA的转换表中，每个表项只有一个状态。从NFA变换到DFA的基本思想是让DFA的每个状态对应NFA的一个状态集。这个DFA用它的状态去记住NFA在读输入符号后到达的所有状态。这个子集T是从NFA的开始状态沿着那些标有a1a2...an的路径能达到的所有状态的集合。DFA的状态数有可能是NFA状态数的指数。

**子集构造算法**

输入：一个NFA N

输出：一个接受同样语言的DFA D

方法：为D构造转换表Dtram，DFA的每个状态是NFA的状态集，D将“并行”地模拟N对输入串的所有可能的移动

用下表的操作来记录NFA的状态集的轨迹(是代表NFA的状态，T代表NFA的状态集)

在读入一个输入符号前，N可以处于集合e-closure(s0)中的任何状态上，其中s0是N的开始状态。假定从s0出发经过输入字符串上的一系列移动，N到达集合T中的状态。令a是下一个输入符号。遇到a时，N可以移动到集合move(T,a)中的任何状态。由于由于e转换，遇到a以后，N可以处于e-closure(move(T, a))中的任何状态

操作|描述
-|-
e-closure(s)|从NFA状态s只经过e转换可以到达的NFA状态集
e-closure(T)|从T中的状态只经过e转换可以到达的NFA状态集
move(T,a)|从T的状态s

```
初始时，e-closure(s0)是Dstates中唯一的状态且未被标记；
while Dstates中存在一个未标记的状态T do begin
    标记T：
    for 每个输入符号a do begin
        U := e-closure(move(T, a))
        if U 没在Dstates中 then
            将U作为一个未标记的状态添加到Dstate中；
        Dtran[T,a] := U
    end
end
```

```
将T中所有的状态压入栈stack中；
将e-closure(T)初始化为T；
while 栈stack不空 do begin
    将栈顶元素t弹出栈；
    for 每个这样的状态u：从1到u有一条标记为e的边 do
        if u 不在e-closure(T) do begin
            将u添加到e-closure(T);
            将u压入栈stack中
        end
end
```

按上述的方法构造D的状态集合Dstates和D的转换表Dtram。D的每个状态对应于NFA的一个状态集，它是N读了某个输入符号序列后所能到达的全部状态，包括所有的e转换。D的开始状态是e-closure(s0)。使用上述的算法构造D的状态和转换。如果D的某个状态是至少包含一个N的接受状态的NFA的状态集，那么它是D的一个接受状态。

e-closure(T)是一个典型的从给定节点集合出发在转换图上搜索可达节点集的过程。这里，T的状态是给定的节点集合，转换图中只包含NFA中由e标记的边。计算e-closure(T)的简单算法是用栈来保存其边还没有完成e转换检查的状态。

例子：接受语言`(a|b)*abb`的另一个NFA N

这里的输入符号表是{a,b}。图中给出的算法告诉我们要先标记A，然后计算e-closure(move(A,a)).让我们首先计算move(A,a)，即对输入a从A状态可以转换到的N的状态集。在状态0，1，2，4和7中只有2和7有a上的转换，分别到达状态3和8.

e-closure(move({0,1,2,4,7}, a)) = e-closure({3,8}) = {1,2,3,4,6,7,8}

我们称这个集合为B。于是，`Dtran[A, a] = B`

在A中只有状态4对输入b有一个转换(转换到状态5)，所以DFA对输入b有一个从A到C的转换，其中C=e-closure({5}) = {1,2,4,5,6,7}.因此`Dtran[A,b] = C`

对新的没标记过的集合B和C继续这个过程，最终会使得所有的集合(即DFA的状态)都已标记过。因为包含11个状态的集合其不同子集“只有”2^11个，而且一个集合一旦被标记就永远是标记的，所以这个过程肯定能终止。最终，实际构造出的5个不同的状态集合是：
```
A = {0, 1, 2, 4, 7}
B = {1, 2, 3, 4, 6, 7, 8}
C=  {1, 2, 4, 5, 6, 7}
D = {1, 2, 4, 5, 6, 7, 9}
E = {1, 2, 4, 5, 6, 7, 10}
```

### 从正则表达式到NFA

从正则表达式建立其识别器的策略很多，各有优劣。其中有一个策略常用语文本编辑程序，该策略先使用本节将要介绍的算法从正则表达式构造NFA，然后利用算法NFA在输入串上的行为，若想提高运行速度，可以利用子集构造法把NFA变成DFA，

本节介绍一种直接由正则表达式构造DFA而无需建立过渡的NFA的方法。本节还将讨论基于NFA和DFA的识别器的实现在时间与空间复杂性的权衡问题。

#### 从正则表达式构造NFA

语法制导算法，该算法使用正则表达式的语法结构来制导构造过程。算法的分支遵循正则表达式定义的分支。首先构造自动机使其能够识别e和字母表中的任何符号，然后由此构造自动机来识别包含一个交换、一个连接或一个`克林闭包(closure)`运算符的正则表达式。例如，对于正则表达式r|s,可以从r和s的NFA构造出它的NFA。

在构造过程中，每步最多引入两个新的状态，于是，为一个正则表达式构造的最终NFA的状态数最多两倍于该正则表达式中符号和操作符数

算法 **(Thompson构造法)**，从正则表达式构造NFA

输入：字母表∑上的一个正则表达式r

输出：接受L(r)的NFA N

方法：首先，分析r并将其分解成最基本的子表达式，然后使用下面的规则1和规则2为r中的每个基本符号(e或字母表中的符号)构造NFA。基本符号对应正则表达式定义的1和2两部分。请注意，如果符号a在r中出现多次，则要为它的每次出现构造一个NFA。

然后，由正则表达式r的语法结构制导，用下面的规则3逐步地组合前面构造的NFA。直到获得整个正则表达式的NFA为止。在构造过程中所产生的中间NFA（与r的子表达式对应）有几个重要的性质：只有一个终态；开始状态无入边，终态无出边。

1. 对e，构造NFA，其中,i是新的开始状态，f是新的接受状态。很明显这个NFA识别{e}.

2. 对于∑中的每个符号a，构造NFA。同样，i是新的开始状态，f是新的接受状态。

3. 如果N(s)和N(t)是正则表达式s和t的NFA

对于正则表达式s|t,可构造复合的NFA N(s|t)如下：

这里i是新的开始状态，f是新的接收状态。从i到N(s)和N(t)的开始状态有e转换，从N(s)和N(t)的接受状态到f也有e转换。N(s)和N(t)的开始和接受状态不是N(s|t)的开始和接受状态。这样，从i到f的任何路径必须独立完整地通过N(s)或N(t),因此这个复合的NFA识别L(s)∪L(t).

这里，N(s)的开始状态称为复合后的NFA的开始状态，N(t)的接收状态称为复合后的NFA的接受状态。N(s)的接受状态和N(t)的开始状态合并，也就是说N(t)的开始状态上的所有转换现在变成了N(s)的接受状态上的转换。合并后的状态不作为复合后的NFA的接受或开始状态。从i到f的路径必须首先经过N(s)，然后经过N(t),所以路径上的标记是L(s)L(t)中的串。因为没有边进入N(t)的开始状态或离开N(s)的接受状态，所以从i到f的路径不能从N(t)回到N(s)，因此复合的NFA识别L(s)L(t)

(c) 对于正则表达式s*,可构造复合的NFA N(s*)如下：

在此，i和f分别是新的开始状态和接受状态。在这个复合的NFA中，可以沿着一条标记了e边直接从i到达f，这表示e属于(L(s))*。我们还可以从i经过一次或多次N(s)到达f。显然，这个复合的NFA识别(L(s))

(d) 对于括起来的正则表达式(s),使用N(s)本身作为它的NFA

上述算法构造的每一步都产生识别对应语言的NFA。此外，产生的NFA具有下列性质：

* N(r)的状态数最多是r中符号和运算符个数的两倍
* N(r)只有一个开始状态和一个接受状态，接受状态没有出边。作为构成成分的每个自动机也具有这一性质
* N(r)的每个状态或者有一个用∑中的符号标记的出边，或者至多有两个标记为e的出边

#### NFA的双堆栈模拟

算法每次从输入字符串读取一个字符，然后计算自动机N在读入输入字符串的每个前缀后可能进入的所有状态的集合。这个算法利用算法3.3生成的NFA的一些特殊性质，有效地计算非确定的状态集合。这个算法的运行时间与N*x成正比，其中|N|表示N的状态数，|x|表示串x的长度

算法3.4  模拟NFA

```
S := e-closure({s0})
a := nextchar
while a != eof do begin
    S := e-closure(move  )
end
if s ∩ F != ∅ then
else return "no"
```

输入：由算法3.3生成的NFA N和输入串x。假定输入串x由字符eof做结束标记，N以状态s0为开始状态，F是接受状态集

输出：如果N接收x，则返回"yes"，否则返回"no".

方法：把上述算法应用到输入串x。这个算法在运行时执行了*子集构造算法*。它分两步计算从当前的状态集到下一个状态集的转换。第一步，它先求move(S,a),即状态S在输入a(当前输入字符)上经过一个转换能到达的所有状态集合。第二步求出move(S,a)在经过0个或多个e转换后能到达的状态集。算法每次使用函数nextchar从输入字符串x读入下一个字符。当x中的所有字符都读完后，如果接受状态在当前集合S中，则返回“yes”，否则返回“no”。

算法3.4可以使用两个堆栈和由NFA状态做索引的位向量来有效地实现。一个堆栈用于跟踪非确定状态的当前集合的轨迹，另一个堆栈用于计算下一个非确定状态集。

使用位向量可以在常数时间内判断一个非确定状态是否已在堆栈中，以防重复加入。一旦已经在第二个栈求出了下一个状态，则两个栈的角色互换。由于每一个非确定状态至多有两个输出边，因此每个状态在一个转换中至多会增加两个新状态。我们用M表示N的状态数。因为一个栈中至多有|N|个状态，所以计算当前状态集的下一个状态集的时间与|N|成正比。因此，模拟N在输入字符串x上的行为需要的时间正比于|N|*|x|

注意：算法3.4是在运行时执行子集构造算法的。例如，比较上述的转换的NFA苟傲的DFA状态图。开始状态集和读a后可达到的状态集对应着DFA的A和B状态。

#### 时间空间的权衡

给定一个正则表达式r和输入字符串x，算法3.3为r构造一个NFA N。这种构造法的时间复杂性是O(|r|)，其中|r|是r的长度。N至多具有两倍于|r|的状态，每一个状态至多有两个转换，因此N的转换表的空间复杂性是O(|r|).使用算法3.4判断N是否接受字符串x，其时间复杂性是O(|r|*|x|).使用这种方法判断x是否在L(r)中的时间代价正比于r的长度和x长度的乘积。在很多文本编辑器中，当目标字符串x不是很长时，可以用这种方法寻找正则表达式模式。

第二种方法是先用Thompson构造法(算法3.3)从正则表达式r构造其NFA，然后再用子集构造法（算法3.2）构造NFA。我们利用转换表实现状态转换函数，并使用算法3.1模拟DFA在输入串x上的动作。这个算法时间代价与x的长度成正比，但与DFA的状态数无关。这种方法经常用于在文本文件中寻找正则表达式模式的模式匹配程序。一旦有穷自动机创建成功，查找的速度非常快。当目标串非常长时，这种方法是很有利的。

然而，存在一些正则表达式，它们的最小DFA也有很多状态，其状态数是正则表达式大小的指数。例如，若正则表达式`(a|b)*a(a|b)(a|b)...(a|b)`包含n-1个(a|b),则识别该正则表达式的任意DFA的状态数不可能少于2^n。这个正则表达式表示a和b的字符串，这个字符串的倒数第n个字符是a。

另一种方法是使用DFA，但通过利用“惰性转换计算”技术来避免创建整个状态的转换表。转换是在运行时计算的，只有在真正需要的时候才去计算给定状态在给定输入上的转换。计算的转换存储在cache中。每次要进行状态转换时，先检查cache。如果需要的转换步子cache中，我们才去计算它，并将其存入cache。如果cache满了，可以清除一些旧的转换，为新的转换腾出空间。

下标总结了用从NFA和DFA构造的识别器判断输入字符串x是否在由正则表达式r表示的语言中所需的最坏的时间、空间复杂性。“惰性”技术结合了NFA的空间需求小和DFA的时间需求小的特点。它的空间需求是正则表达式的大小加上cache的大小。它的运行时间几乎与DFA识别器相同。在某些应用中，“惰性”技术比DFA方法还要快，因为它没有计算不必要的状态转换。

自动机|空间|时间
-|-|-
NFA|`O(|r|)`|`O(|r|*|x|)`
DFA|`O(2^|r|)`|`O(|x|)`

### 设计词法分析器的生成器

构造一个在输入缓冲区中查找词素的识别器。如果有多个模式匹配成功，识别器将选择与最长词素匹配的模式。如果有多个模式与最长词素匹配，则选择第一个与最长词素匹配的模式。

有穷自动机是一种创建词法分析器的自然模型。由Lex编译器构造出的**词法分析器**由一个**输入缓冲区**，缓冲区有两个指针，其中一个是词素的**开始指针**，另一个是词素的**向前指针**。

Lex编译器根据使用Lex说明书写的正则表达式模式为有穷自动机构造转换表。词法分析器本身包括一个有穷自动机模拟器，这个模拟器使用转换表在输入缓冲区中查找正则表达式模式。

#### 基于NFA的模式匹配

一种基于NFA的模式匹配方法是为模式p1,p2,...,pn的NFA N构造状态转换表。为此，可以先使用算法3.3为每个模式pi构造NFA N(pi)，然后加入一个新的开始状态s0，并用e转换将s0和每个N(pi)的开始状态相连。

NFA修改必须保证该NFA能识别输入字符串中被匹配的最长前缀。在这个NFA中，每一个模式pi都有一个接受状态。当使用算法模拟NFA时，构造一个状态集序列，其中每个状态集都是NFA看到每个输入字符后能够进入的状态集。即使在一个状态集中包括了一个接受状态，但为了实现最长的匹配，仍需继续模拟NFA,穷尽当前输入符上的所有转换，即到达一个终止。

通常，所写的Lex说明总能使某个模式（也可以是错误模式）匹配成功。如果没有一个模式能匹配成功，则意味着没有把错误情况考虑周全，此时词法分析器需要把控制转给某个默认的错误恢复程序。

#### 词法分析器的NFA

从Lex说明构造词法分析器的另一种方法是使用DFA完成模式匹配。这种方法与上面描述的对NFA的模拟完全类似，知识在确定正确的模式匹配时有一些细微的差别。当使用子集构造算法进行NFA到DFA的转换时，在一个非确定状态的子集中可能会有多个接收状态。在这种情况下，在Lex说明中位置靠前的模式对应的接受状态具有优先权。类似于模拟NFA，在穷尽对当前的输入符号的转换之前，还需要继续进行状态转换。为了找到匹配的词素，需要将缓冲区的向前指针返回到DFA最后一次进入道接受状态时的位置上。

#### 实现超前扫描操作

由于在某些情况下表示特定记号的模式可能需要描述实际词素后面的一部分正文，所以需要使用超前扫描操作符`/`。将一个含有`/`的模式转换成NFA时，可以将l看成e，使得不用真正地在输入字符串中查找`/`.然而，当由这样的正则表达式表示的字符串在输入缓冲区被识别出来时，词素的末尾并不在NFA的接受状态的位置上，而是在最后一个在（假想的）`/`上具有转换的状态上

### 基于DFA的模式匹配器的优化

构建算法能小化DFA的状态数，所以可用于减小基于DFA的模式匹配器的大小。这个算法是高效的，其运行时间O(nlgn),n是NFA中的状态数。

#### NFA的重要状态

如果一个NFA状态有一个标记为非e的出边，则称这个状态是重要状态。子集构造在确定e-closure(move(T,a))时只使用了子集合T中的重要状态。仅当状态s是重要的，集合move(s,a)才是非空的。在构造过程中，两个子集可以被认为是等同的，如果它们的重要状态相同并且两者同时包含或不包含NFA的接受状态。

当子集构造法被应用由正则表达式经算法3.3生成的NFA时，可以利用NFA的特殊性质来将两种构造方法合二为一。合并的构造法把NFA的重要状态与出现在正则表达式中的符号相关联。只有字母表上一个符号出现在正则表达式中时，Thompson构造法才创建一个重要状态。例如，对于`(a|b)*abb`,Thompson构造法为每个a和b创建重要状态

结果NFA有且只有一个接受状态，但该接受状态不是重要的，因为它没有出边。通过在正则表达式r右端连接一个唯一的结束符`#`，我们给r的接受状态增加一个`#`上的转换，使它成为NFA的重要状态。换句话说，通过使用扩展的正则表达式`(r)#`，在子集构造过程中可以忽略接受状态。当构造结束时，任何在`#`上有转换的DFA的状态都是接受状态。

用语法树表示扩展的正则表达式。语法树的叶结点表示基本符号，内节点表示操作符。如果一个内节点被标记为连接1或*操作符，则分别称其为cat-节点、or-节点或star-节点。

正则表达式语法树的叶节点由符号表中的符号或e标记。对于每一个非e标记的叶节点，分配一个唯一的整数，这个整数表示叶节点的位置，同时也表示对应符号的位置。一个重复出现的符号会有多个位置。位置标记在符号的下边。NFA中被编号的状态对应着叶节点的位置。这些状态是NFA的重要状态，非重要状态用大写字母来表示

#### 从正则表达式到DFA

从扩展的正则表达式`(r)#`构造DFA。首先为正则表达式`(r)#`构造一个语法树T，然后通过遍历这棵语法树计算*nullable*,*firstops*,*lastops*和*followpos*四个函数。最后由`followpos`构造DFA.函数*nullable*,*firstops*和*lastops*定义在语法树的节点上，用于计算函数followpos，而函数followops定义在位置集合上

利用NFA的重要状态和正则表达式语法树的叶节点的等价性，可以绕过NFA的构造而直接构造一个其装填对应语法树的位置集合的DFA。NFA的e转换表示相当复杂的位置结构。特别地，它包含了这样的信息：什么时候一个位置可以跟随另一个位置，即输入到DFA的字符串中的每一个符号都可以被一个位置匹配。一个输入符号c只能由具有符号c的位置匹配，但不是每一个具有符号c的位置都一定匹配输入字符串中c的一次出现

一个位置匹配一个输入符号的概念将由函数followpos定义。如果i是一个位置，那么followpos(i)是满足如下条件的位置j的集合：对于某个输入字符串...cd...,位置i对应着c的出现，位置j对应着d的出现

算法 从正则表达式r构造DFA

输入：正则表达式r

输出：识别L(r)的DFA D

方法:
* 构造扩展的正则表达式`(r)#`的语法树T、其中#是附加在(r)后面的唯一结束标志
* 通过对T进行深度优先遍历计算函数nullable、firstops、lastpos和followpos的值
* 利用下述过程构造Dstates（D的状态集），生成D的状态转换表Dtran。Dstates中的状态是位置集，初始情况下，每一个状态都是“未标记的”，只有我们开始考虑其出边时，这个状态才变成“标记的”。D的开始状态是firstpos(root),接受状态是包含与结束符`#`相关位置的状态。

```
初始时，Dstates中唯一未标记的节点是firstpos(root),root是(r)#语法树的根节点：
while Dstates 中㛮一个未标记的状态T do begin
    标记T;
    for 每个输入符号a do begin
        令U是followpos(p)中的位置的集合，p是T中的某个位置，位置p的符号为a;
        if U非空而且不在Dstates中 then
            将U作为一个未标记的状态加入到Dstates中；
        Dtran[T,a] := U
    end
end
```

#### 最小化DFA的状态数

理论上的一个重要结论是：每一个正规集都可以由一个状态数最少的DFA识别，这个DFA是唯一的(状态名不同的同构情况除外)。

假定有一个DFA M，其状态合集是S，输入符号表是∑，每个状态对每个输入符号都有转换。如果不是这样，可以引入一个“死状态”d，d在所有输入符号上都转换到d。如果s在符号a上没有转换，加上一个在a上从s到d的转换。

字符串w区别状态s和t，如果：DFA M从状态s出发，对输入串w进行状态转换，最后停在某个接受状态；从t出发，对输入串w进行状态转换，停在一个非接受状态；反之亦然。

极小化DFA的状态数的算法是把DFA状态分成一些不相交的组，同一个组中的状态都是不可区别的，而不同组的状态则可以由某个输入串的区别。把每个状态组合并成一个状态。该算法先把所有状态划分为两个组，然后逐步将这个划分精细化。在一个划分中，如果两个状态处于同一分组，然后逐步将这个划分精细化。在一个划分中，如果两个状态处于同一分组则说明它们还没有被任何串区别出来，反之如果两个状态处于不同分组则说明它们已经被某个串区别出来。

初始划分包含两个组：接受状态组合非接受状态组。算法的基本步骤是从当前划分中取一个状态组。如果这些转换所到达的状态落入当前划分的两个或更多不同的状态组，那么A必须进一步划分，使得划分后的每个子集在a上的转换能落入当前划分的同一个状态组中。在当前划分中重复上述划分组的过程，直到没有任何一组需要再分裂为止。

算法3.6 最小化DFA的状态数

输入：DFA M(其状态集合为S)，输入符号集为∑，转换函数为f：S*∑->S,开始状态为s0，接受状态集为F

输出：一个DFA M，它和M接受同样的语言，且状态数最少。

方法：
* 构造具有两个组的状态集合的初始划分π；接受状态组F，非接受状态组S-F
* 对π采用下述的过程来构造新的划分π
* 如果π_{new} = π,零π_{final} = π，再执行步骤4；否则，令π = π_{new},重复步骤2
* 在划分π_{final}的每个状态组中选一个状态作为该组的代表。这些代表构成了简化后DFA M‘的状态。令s是一个代表状态，而且假设：在DFA M中，在输入a上有从s到t的转换。令t所在组的代表是r(r可能就是t)，那么在M'中有一个从s到r的a上的转换。令包含s0的状态组的代表是M'的开始状态，并令M'的接受状态是那些属于F集的状态所在组的代表。注意，π_{final}的每个组或者仅含F中的状态，或者不含F中的状态。
* 如果M'含有死状态(即一个对所有输入符号都有到自身的转换的非接受状态d)，则从M'中去掉它；删除从开始状态不可到达的状态；取消从任何其他状态的死状态的转换定义

```
for π中的每个组 do begin
    当且仅当对任意输入符号a，状态s和t在a上的转换到达π的同一组中的状态时，才把G划分成小组，以便G的两个状态s和t在同一小组中；
    /* 最坏情况下，一个状态就可能成为一个组 */
    用所有新形成的小组代替π中的G
end
```

#### 词法分析器的状态最小化

开始运行算法3.6，必须对识别不同记号的状态进行分组，以得到一个厨师划分

#### 表压缩方法

可以有多种方法来实现有穷自动机的状态转换函数。因为词法分析器是编译器中唯一逐个处理输入字符流的过程，所以它占用了编译器可观的时间。因此词法分析器需要最小化它对每一个输入字符所执行的操作个数。如果用DFA来实现词法分析器，则需要对状态转换函数进行有效的表示。

一个高度压缩但速度相比比较慢的方案是使用一个链表来存储每个状态的出边所表示的转换。在链表的最后存放一个默认的转换。这个默认的转换应该是最经常用到的转换

*表压缩方法*:既有数组表示法访问速度快的特点，又有链表结构占用空间小的优点。使用4个数组组成的数据结构，这些数组由状态做索引。base数组用于决定存储在next和check数组中的与每个状态相关的表项的基位置。default数组用于确定当前基位置无效情况下可选的基位置。为了计算状态s在遇到字符a后要进入的状态nextstate(s,a)，首先查看next和check这对数组。特别地，要从这两个数组中找到对应于状态s的表项所在位置`l=base[s]+a`,其中a可以看成整数。如果`check[l]=s`,取`next[l]`为s在输入a上的下一个状态。如果`check[l]!=s`,则令`q=default[s]`,然后用q代替s并递归地重复整个过程。该过程描述如下：
```
procedure nextstate(s,a):
    if check[base[s] + a] then
        return next[base[s] + a]
    else
        return nextstate(default[s],a)
```

## 第四章：语法分析

### 语法分析器的作用

语法分析器接收词法分析器提供的记号串，检查它们是否能由源程序语言的文法产生。希望语法分析器能用于易于理解的方式提示语法错误信息，并能从常见的错误中恢复出来，以便后面的输入能继续处理下去。

典型的文法的语法分析器有三类：

* **通用的语法分析方法**：如Cocke-Younger-Kasami算法和Earley算法，这些方法能分析任何文法。然而这些方法在生成编译器效率太低。
* **自顶向下方法**：沿着从顶向底的方向建立分析树
* **自底向上方法**：沿着从叶向根的方向建立分析树

无论哪一种方法，语法分析器都是自左向右地扫描输入字符串，每次读一个符号

最有效的自顶向下和自底向上分析方法智能处理文法的一些子类。然而，这些子类中的某些文法，如LL文法和LR文法，足以描述程序设计语言的大部分语法结构。LL文法的语法分析器常由手工实现

假设语法分析器的输出是对词法分析器产生的记号流的分析树的某种表示。实际上在分析过程中编译器还可以完成许多其他任务。例如，把与各种记号有关的信息收集到符号表中、进行类型检查和其他一些语义分析检查、如产生中间代码等。

语法错误的性质和两种错误恢复策略：**紧急方式恢复策略**和**短语级恢复策略**

#### 语法错误的处理

如果编译器只处理正确程序，它的设计和实现就可以大大简化。好的编译器应该能帮助程序员识别和定位错误。大多数程序设计语言的说明都没有描述编译器应该怎样响应语法错误，而是把它留给了编译器的设计者来处理。

* **词法错误**，如标识符、关键字或操作符的拼写错误
* **语法错误**，如算术表达式的括号不配对
* **语义错误**，如操作符作用于不相容的操作数
* **逻辑错误**，如无限的递归调用

源程序的多数错误诊断和恢复都集中在语法分析阶段。原因之一是多数错误都是语法错误，或者当来自词法分析器的记号流违背定义程序设计语言的文法规则时才暴露出来。另一个原因是现代语法分析方法的准确性使得它们能非常有效地检查出程序中的语法错误。在编译阶段准确地诊断语义和逻辑错误是非常困难的。

语法分析器中出错处理程序的基本目标是：
* 清楚而准确地报告错误的出现
* 迅速地从每个错误中恢复出来，以便能继续检查后面的错误
* 不能过分降低正确程序的处理速度

但是，有些情况下，错误的发生远远先于发现它的位置，而且很难诊断出这种错误的准确性质。更困难的是，出错处理程序可能需要猜测程序员编程时的意图

有些分析方法，如LL方法和LR方法，可以尽快地检查出语法错误。它们具有**萌发前缀性(viable-prefix property)**,即当它们一旦发现一个输入字符串的前缀不是该语言任何字符串的前缀时就能检查出错误。

例：多数错误可以简单地分为以下几类：60%是标点符号错，20%是操作符或运算对象错，15%是关键字错，剩下的5%是其他类型的错误

一种常见的标点错误是在函数说明的参数表中出现的标点，分号错误普遍出现的原因是不同语言在分号的用法上有很大区别。如在Pascal语言中，分号是语句的分隔符；在PL/1和C语言中，分号则是语句的结束符。研究表明，后一种用法较少出错

操作符错误的典型例子是漏写了`:=`中的冒号。关键字拼写错误通常比较少见，其典型的例子是writeln中的i

然而，另一类常见的错误是很难正确修复的，比如漏写了begin或end。多数编译器都不能修复这类错误。

出错处理程序的错误报告：应该报告源程序的错误被检测到的位置，比如显示出错的程序行，用指针指出检测到错误的位置。比如显示“此处遗漏了分号”

通常，一些语法分析器试图将自己恢复到某一状态，以便能够继续分析输入字符串或正确地处理出现的错误。

不充分地恢复程序可能会引起大量令人烦恼的“伪”错误的出现，这些错误不是程序设计人员造成的，而是由于错误恢复时改变了语法分析器的状态而引起的。同样，语法错误的恢复也可能引起语义伪错误，这些错误会在语义分析或代码生成阶段被检查出来。例如，错误恢复时，语法分析器可能跳过某个变量的声明，如变量zap。以后在表达式中碰到变量zap时，虽然语法上没有错，但由于符号表中没有变量zap的表项，会产生“zap没有定义”的出错信息。

编译器的一个保守的策略是：如果在输入流中查到某个错误，并且它离前一个错误非常近，则抑制这个错误信息的出现，即在发现一个语法错误后，编译器应该在成功地分析几个记号之后才报告下一个错误信息。然而，在某些情况下，可能会有太多的错误，以至于编译器无法继续进行合理的处理。

考虑到各种错误情况的出现以及合理处理，错误恢复的策略是一个需要认真考虑的折中。

有些编译器试图猜测程序员编程时的意图并修复错误。

#### 错误恢复策略

* **紧急方式恢复策略**-最容易实现的方法，适用于多数语法分析方法。当发现错误时，语法分析器开始抛弃输入符号，每抛弃一个记号，直到发现某个指定的同步记号(通常是界定符)，如分号或者end。必须恰当地设计选择同步记号，因为这种方法常常跳过大量的输入记号，而不检查是否有其他错误，并不会陷入死循环
* **短语级恢复策略**-发现错误时，对剩余的输入字符串做局部纠正，即用一个能使语法分析器继续工作的字符串来代替剩余输入
* **出错产生式策略**-如果对经常遇到的错误有很清楚的了解，可以扩充语言的文法，增加产生错误结构的产生式。然后用由这些错误产生式扩充的文法构造语法分析器。如果语法分析器
* **全局纠正策略**-有一些算法可以选择最小的修改序列，以获得全局代价最小的错误纠正。如果给定错误输入串x和文法G，这些算法会发现y的一棵分析树，以便使用最少的符号插入、删除和修改操作把x变换成正确的输入字符串y。

**最小代价纠正**的概念已经成为评价错误恢复技术的一种标准，并且已经被用于短语级恢复方法中最优替换字符串的选择

### 上下文无关文法

程序设计语言的许多结构都包含固有的递归结构，这种递归结构可以用上下文无关文法定义。例如

```
如果S1和S2是语句，E是表达式，则“if E then S1 else S2是语句”
```

这种形式的条件语句不能用正则表达式说明。使用**语法变量stmt表示语句类，expr表示表示类**,可以使用下面的文法产生式:

```
stmt -> if expr then stmt else stmt
```

**上下文无关由终结符、非终结符、开始符号和产生式组成**

* **终结符**是组成字符串的基本符号。在讨论设计语言的文法时，“记号”和“终结符”是同义词，在上述例子中，关键字`if`,`then`和`else`都是终结符
* 非终结符是表示字符串集合的语法变量。*stmt*和*expr*是非终结符。非终结符所定义的字符串集合有助于定义该文法所产生的语言。非终结符强加给语言一种层次结构，这种层次结构对语法分析和翻译都非常有用
* 在文法中，有一个非终结符被指定为开始符号。开始符号表示的字符串集合就是文法所定义的语言 
* 文法的产生式说明了终结符和非终结符组合成串的方式。每个产生式由非终结符开始，跟随一个箭头(有时用::=代替箭头)，然后是非终结符和终结符组成的串

```
expr -> expr op expr 
expr -> (expr)
expr -> -expr
expr -> id
op -> +
op -> -
op -> *
op -> /
```

在上述文法中，终结符包括id,+,-,\*,/,非终结符包括expr和op，*expr是开始符号*

#### 文法符号的使用约定

* **终结符**

1. 字母表中比较靠前的小写字母，如a,b,c等
2. 操作符，如+、-等
3. 标点符号，如括号、逗号等
4. 数字0,1,...,9
5. 黑体串，如**id**、**if**等

* **非终结符**

1. 字母表比较靠前的大写字母，如A,B,C等
2. 字母S,它常常代表开始符号
3. 小写斜体名字，如*expr*、*stmt*等

* 字母表中比较靠后的大写字母，如X,Y,Z等，表示文法符号，可以是非终结符也可以是终结符
* 小写希腊字母表示文法符号的串。因此，一个通用产生式可以写作A->α，箭头左边(产生式的左部)是一个非终结符A，箭头右边使文法符号串(产生式右部)
* 如果A—>α1,A->α2,...,A->αk是所有以A为左部的产生式(称为A产生式)，则可以把它们写成A->α1|α2|α3|...|αk,将α1,α2,α3,...,αk称为A的候选式
* 除非另有说明，否则第一个产生式左部的符号是开始符号。

```
E -> E A E | (E) | -E | id
A -> + | - | * | / | ↑
```

#### 推导

可以使用多种方法观察文法定义语言的过程。将该过程看成是分析树的建立过程，但推导也是描述文法定义语言过程的有用方法，其核心思想是把产生式看成重写规则，即用产生式右部的串来代替左部的非终结符。

例如，考虑下面的算术表达式文法:

```
E -> E + E | E * E | (E) | -E | id
```

其中，非终结符E表示一个表达式。产生式E->-E意味着前面带有减号的表达式仍然是表达式。这个产生允许用-E代替出现的任何E,以便从简单的表达式产生更复杂的表达式。如果用-E代替单个E，这个动作可以描述为

```
E -> -E
```

读为`“E推导出-E”`。产生式`E->(E)`表示可用`(E)`代替在文法符号串中出现的任何E。如`E*E=>(E)*E`或者`E*E=>E*(E)`

可以从E开始，不断地(以任何顺序)应用产生式，得到一个替换序列。例如：

```
E -> -E -> -(E) -> -(id)
```

抽象地，有`αAβ->αγβ`，如果`A->γ`是产生式，而且α和β是任意的文法符号的串。如果`α1->α2->...->αm`,则说α1推导出αm,符号->表示“一步推导”。通常用*->表示“零步或多步推导”。因此：
* 对任何串α，α*->α
* 如果α*->β，而且β->γ,则α*->γ

类似地，用+->表示“一步或多步推导”。对于开始符号为S的文法G，可以用+->关系来定义G所产生的语言L(G).L(G)中的字符串只包含G的终结符。当且仅当S+=>w时，说终结符w在L(G)中。终结符串w称为G的句子。由上下文无关文法产生的语言称为上下文无关语言。如果两个文法产生同样的语言，则称这两个文法等价。

对于开始符号为S的文法G，如果S*=>α，则称α为G的句型，其中α可能包含有非终结符。句子是不含非终结符的句型。

字符串`-(id+id)`是文法(4-3)的句子，因为存在如下推导

```
E -> -E -> -(E) -> -(E + E) -> -(id + E) -> -(id + id)  文法(4-3)
```

可以简单地用如下形式表示：
```
E *-> -(id + id)
```

按推导长度进行归纳，可以证明文法(4-3)产生的语言中的每个句子都是由二元操作符`+`和`*`、一元操作符`-`、括号以及运算对象id组成的算术表达式。同样，按算术表达式的长度进行归纳，也可以证明这样的算术表达式都可以由文法(4-3)产生。因此，文法(4-3)正好产生所有包括二元操作符`+`和`*`,一元操作符`-`、括号以及操作数id的算术表达式的集合。

在推导的每一步都有两个选择，首先需要选择被替换的非终结符，然后再选择用于替换该非终结符的候选式。

```
-(E + E) -> -(E + id) -> -(id + id)
```

为了理解语法分析器是怎样工作的，需要考虑每一步都替代最左非终结符的推导。这样的推导叫做**最左推导**,如果`α -> β`是最左推导，可以写成`α lm-> β`

每一步的最左推导都可以写成`wAγ lm-> wδγ`，其中`w`只含终结符，`A -> δ`是推导所用的产生式，`γ`是文法符号的串。为了强调`α`通过最左推导出`β`这一事实。写`α lm*-> β`。

如果`S lm*-> α`,则称`α`是该文法的左句型。

类似地可以定义最右推导，即每步推导都代替最右非终结符的推导。最右推导有时也称为规范推导。

#### 分析树和推导

分析树可以看成的图形表示，但它不能显示出替代顺序的选择。分析树的每个内节点都标以某个非终结符A。A的子节点从左到右分别被用来替换A所使用的产生式右部的各符号标记。分析树的叶节点用非终结符或终结符来标记，它们从左到右构成一个句型，称为树的边界或果实。

考虑任意推导`α1 -> α1 -> ... αn`,其中`α1`是单个非终结符A。对推导中的每个句型`αi`,构造产生`αi`的分析树。该过程是对i的归纳。`αi = A`对应的分析树是标有A的单个节点，是归纳的基础。为了完成这种归纳，假设已经构造了产生`αi = X1X2...Xk`的分析树，假设`αi`是用`β=Y1Y2...Yr`代替`αi-1`中的非终结符`Xj`所产生的，即在推导的第i步中，对`αi-1`应用产生式`Xj->β`，推导出`αi=X1X2...Xj-1βXj+1...Xk`

分析树忽略了句型中符号被代替的顺序。如果只考虑最左推导(或最右推导)，则可以消除推导过程中产生式应用顺序的不一致性。**每棵分析树都有一个与之对应的唯一的最左推导和唯一的最右推导**。可以用产生分析树方法来代替推导。

分析树可以反映一定的运算符优先级。比如`a+b*c`,习惯上*比+具有更高的优先级，因为表达式`a+b*c`被看成`a+(b*c)`而不是`(a+b)*c`

#### 二义性

给定一个文法G，如果L(G)中存在一个具有两棵或者两棵以上分析树的句子,则称G是二义性的。

还可以如下定义二义性文法：如果L(G)中存在一个具有两个或两个以上最左(或最右)推导的句子，则G是二义性文法。很多语法分析器要求所处理的文法是无二义的，否则对具有二义性的句子无法确定应该选择那颗分析树。

某些应用可能要求可以构造适应于二义性文法的语法分析器，不过，这种文法要具有*消除二义性*的规则,以便语法分析器能够“抛弃”不需要的分析树而为每个句子保留唯一一棵分析树。

### 文法的缩写

文法能够描述程序设计语言的大部分语法成分，但不能描述程序设计语言的全部语法成分。当**词法分析器**从输入字符串产生记号序列时，将完成一定量的语法分析工作。对输入字符串的某些限制(如标识符的声明必须先于它们的使用)不能用上下文无法文法来描述。**语法分析器接受的记号序列形成了程序设计语言的超集**。语法分析以后的各编译阶段必须分析语法分析器的输出，以保证输入字符串符合语法分析器无法检查的那些规则。

考虑词法分析器和语法分析器的分工。每种语法分析方法只能处理一种形式的文法。为了适应所选择的分析方法，常常不得不改写初始文法。**适于表达式的文法常常用结合律和优先级信息来构造**

#### 正则表达式和上下文无关文法的比较

正则表达式所描述的每一种结构都可以用上下文无关文法来描述。例如正则表达式`(a|b)*abb`和下述文法描述的语言皆为由a和b组成的以abb结尾的字母串：
```
A0 -> aA0 | bA0 | aA1
A1 -> bA2
A2 -> bA3
A3 -> e
```

可以机械地把一个不确定的**有穷自动机(NFA)**转换成一个等价的上下文无关文法，该文法可以按照下列规则构造:
* 对NFA的每个状态i，创建一个非终结符Ai
* 如果状态i遇见的输入符号a转换到状态j，则引入产生式Ai -> aAj
* 如果状态i遇见的输入符号e转换到状态j，则引入产生式Ai -> Aj
* 如果状态i是接受状态，则引入产生式Ai -> e
* 如果状态i是开始状态，则Ai是文法的开始符号

使用正则表达式而不用上下文无关文法定义语言的词法

* 语言的词法规则通常非常简单，不必用强大的文法来描述
* 对于记号，正则表达式比上下文无关文法提供了更简洁且易于理解的定义
* 从正则表达式可以自动地构造出有效的词法分析器，从任何文法都很难构造词法分析器
* 把语言的语法结构分成词法和非词法两部分为编译器前端的模块划分提供了方便的途径。

*注意：正则表达式对描述标识符、常数和关键字等词法结构时最常用。另一方面，文法在描述括号配对、begin-end配对、if-then-else对应等嵌套结构时最常用。正则表达式不能描述这些嵌套结构*

#### 验证文法所产生的语言

对“文法G产生语言L”的证明包括两个部分：必须证明由G产生的每个字符串都在L中，反之，L中的每个字符串都能由G产生。

如文法G`S->S(S)|e`能而且仅能产生所有配对的括号串，证明略.

#### 消除二义性

有些二义性文法可以通过改写来消除二义性。例子：消除“不匹配else”文法的二义性。

```
stmt -> if expr then stmt
    | if expr then stmt else stmt
    | other            
    (4-7)
```

这里，other代表任何其他语句。复合条件语句

```
if E1 then S1 else if E2 then S2 else S3
```

文法(4-7)具有二义性的，因为串`if E1 then if E2 then S1 else S2`有两棵分析树。而一般规则是，每个else和前面最近的没有配对的then配对，当然这条避免二义性的规则可以直接并入文法中。例如，可以把上述文法改写成下面的无二义性文法，其基本思想是：出现在then和else之间的语句必须是“配对”的，即它不能以一个未配对的then后面跟随任意的非else语句结束，于是else会被迫与这个未配对的then匹配。配对的语句是一个不包含不配对语句的if-then-else语句或者任何非条件语句。因此，按照上述思想改写后的文法如下：

```
stmt -> matched_stmt
    | unmatched_stmt
matched_stmt -> if expr then matched_stmt else matched_stmt
    | other
unmatched_stmt -> if expr then stmt 
    | if expr then matched_stmt else unmatched_stmt
```

#### 消除左递归

如果文法G具有一个非终结符A使得对某个字符串α存在推导`A +-> Aα`,则称G是左递归的。自顶向下语法分析法不能处理左递归文法，因此需要一种消除左递归的变换。

左递归产生式`A -> A α|β`可以由下面的非左递归产生式来代替:

```
A -> βA'    A' -> αA' | e
```

这种变换没有改变从A推导出的字符串集合。这条规则适用于很多文法。

例子：考虑下面的算术表达式文法
```
E -> E + T | T
T -> T * F | F
F -> (E) | id
```
消除E和T的直接左递归(形如`A -> Aα`的产生式)，可以得到
```
E -> TE'
E' -> +TE'| e
T -> FT'
T' -> *FT' | e
F -> (E) | id
```
无论有多少A产生式，都可以用下面的技术来消除直接左递归。首先，把A产生式放在一起：
```
A -> Aα1 | Aα2 | ... | Aαm | β1 | β2 | ... | βm 
```
其中，每个βi都不以A开头。然后用下面的产生式代替A产生式：
```
A  -> β1A' | β2A' | ... | βmA'
A' -> α1A' | α2A' | ... | αmA' | e 
```
变换后的非终结符A与变换前的非终结符A产生同样的字符串集合，但已经没有左递归了。这种方法可以从A产生式和A'产生式(假定αi都不等于e)消除直接左递归，但不能消除包括两步或多步推导的左递归。例如，考虑文法
```
S -> Aa | b
A -> Ac | Sd | e
```
非终结符S是左递归的，因为S -> Aa -> Sda,但不是直接左递归。

下面的算法4.1能够系统地消除文法中的左递归。该算法对于所有无循环推导(`A +-> A`的推导)和e产生式(形如`A -> e`的产生式)的文法都有效。循环推导和e产生式都可以系统地从文法中消除掉

**算法4.1** 消除左递归

```
输入：无循环推导和e产生式的文法G
输出：与G等价的无左递归文法
方法：对文法G应用如下算法。注意：得到的非左递归文法可能含有e产生式
1. 以某种顺序排列非终结符A1,A2,...,An
2. 
for i := 1 to n do begin
    for j := 1 to i - 1 do begin
        用产生式A -> δ1γ|δ2γ|...|δkγ代替每个形如A->Aiγ的产生式
        其中，Ai -> δ1|δ2|...|δk是所有的当前Aj的产生式
    end
    消除Ai产生式中的直接左递归
end
```

*注意：因为有e产生式，算法4.1不一定有效，但在这种情形天产生式A->e是无害的*

令非终结符的次序是S、A。在S产生式中没有直接左递归，对于i=1，什么也没做。i=2时，用S产生式替换A -> Sd中的S，得到下面的A产生式。
```
A -> Ac | Aad | bd | e
```
消除A产生式中的直接左递归，产生下面的文法
```
S  -> Aa | b
A  -> bdA' | A'
A' -> cA' | adA' | e
```

#### 提取左因子

提取左因子是一种对产生适合预测分析的文法非常有用的文法变换。提取左因子的基本思想是：当不清楚应该用两个选择中的哪一个来替换非终结符A时，可改写A产生式来推迟这种决定，制导看见足够多的输入能做出正确的选择为止

例如，有如下两个产生式：

```
stmt -> if expr then stmt else stmt
    | if expr then stmt
```

看到输入记号if时，不能立即立刻决定选择哪个产生式来扩展stmt。一般地，如果`A->αβ1|αβ2`是A的两个产生式，输入字符串从α导出的非空串开始，不知道是用`αβ1`来扩展A还是用`αβ2`。然而，可以通过先将A扩展到`αA'`来推迟这个决定。然后，扫描完由α导出的输入字符串后，再把`A'`扩展成`β1`或`β2`，亦即提取左因子。这样的变换以后，原来的产生式变为：
```
A -> αA'  A' -> β1 | β2
```

**算法4.2** 提取左因子
```
输入：文法G
输出：一个等价的提取了左因子的文法。
方法：对每个非终结符A，找出它的两个或者更多候选式的最长公共前缀α。如果α!=e,即有一个非平凡的公共前缀，则用下面的产生式代替所有A产生式A->αβ1|αβ2|...|αβn|γ,其中γ表示所有不以α开头的候选式:
A  -> αA' | γ
A' -> β1 | β2 | ... | βn
```

其中A'是一个新的非终结符。反复应用这种变换，直到任一非终结符都没有两个候选式具有公共前缀为止

#### 非上下文无关语言的结构

有些语言不能用任何文法产生。

例子：考虑抽象语言`L1 = {wcw|w属于(a|b)*}`。L1是所有由隔开的两个相同a、b串组成的字母串集合，例如`aabcaab`。这个语言是检查程序中标识符的声明应先于其应用的抽象，即wcw中的第一个w表示标识符w的声明，第二个w表示它的引用。可以证明该语言不是上下文无关语言。*因为它们要求标识符的声明先于引用，并且允许标识符任意长*

由于上述原因，描述Algol和Pascal语法的文法并不定义标识符中的字符，而只是用文法中id这样的记号代表所有的标识符。在这类语言的编译器中，语义分析阶段检查标识符的声明是否先于引用。

例子：语言`L2 = {a^nb^mc^nd^m | n >= 1 & m >= 1}`不是上下文无关语言。L2是由正则表达式`a*b*c*d*`所表示的语言的子集合，在它的每个句子中，a和c的个数相等，b和d的个数相等(a^n意味着a被写过n次)。它是“过程声明的形参个数和过程引用的实参个数和过程引用的实参个数应该一致”的抽象，a^n和b^m表示两个过程说明的形参表中分别有n和m个参数,c^n和d^m分别表示调用这两个过程的实参表

注意：过程定义和引用的语法并不涉及到参数的个数。例如，一个类似于Fortran语言的中的CALL语句的文法如下：
```
stmt -> call id (expr_list)
expr_list -> expr_list, expr
    | expr
```
其中带有expr的产生式。通常在语义分析阶段检查call中的实参个数是否正确。

例子：语言`L3 = {a^nb^nc^n | n >= 0}`是`L(a*b*c*)`子集合，每个串包括相等个数的a、b和c。L3不是上下文无关语言。下面是一个与L3相关的问题。设打字时用下划线标记的正文，排版输出时改用斜体。为了把在行式打印机的文本文件转换成适于在照相排版机上输出的文本，需要用斜体代替下划线。在打字机上打印一个用下划线标记的单词时，首先在键盘上敲打一串与这个单词对应的字母键，然后敲打相等数量的退格键，最后敲打相等数量的底线键。如用a表示任意的字母键，b表示退格键，c表示底线键，则L3可以表示所有用下划线标记的单词。但是，如果用`<`字母，退格，底线`>`三元组标识用下划线标记的单词，可以用正则表达式`(abc)*`表示用下划线标记的单词集合。

有些语言类似于L1,L2,L3,但却是上下文无关语言。例如，L1' = {wcw^R | w属于(a|b)*}是上下文无关语言，其中w^R表示w的逆序。
```
S -> aSa | bSb | c
```

### 自顶向下语法分析

无回溯自顶向下语法分析器也称为预测语法分析器。这种文法的预测语言分析器可以自动生成。关于预测语法分析器的讨论之外，只讨论非递归的预测语法分析器。

#### 递归下降语法分析器

自顶向下语法分析的目的是为了输入字符串寻找最左推导，从根节点(文法开始符号)开始，自上而下、从左到右地为输入串建立一棵分析树，并以预先确定的顺序创建分析树的节点。先前讨论了一种不需要回溯的特殊递归下降分析法，称为预测分析法。

考虑自顶向下分析的一般形式，称为**递归下降分析法**。它可能需要回溯，即需要重复地扫描输入。然而，需要回溯的语法分析器是不常见的，其原因是在分析程序设计语言的结构时很少需要回溯。即使在分析自然语言的情况下，回溯也不是非常有效的，并且列表的方法更可取。

下面是一个需要回溯的例子。当需要回溯时，建议使用一种记录输入轨迹的方法，考虑下述文法和输入字符串`w = cad`
```
S -> cAd
A -> ab | a
```
为了自顶向下地为w建立分析树，首先建立只具有标记为S的单个节点的树。输入指针指向w的第一个符号c。

最左边的叶子标记为c，匹配w的第一个符号。现在，将输入指针移到w的第二个符号a。考虑下一个标记为A的叶子。用A的第一个候选式扩展A，当已经匹配到了的哥输入符号a时，再将输入指针移到第三个输入符号d，把它和下一个标记为b的叶节点进行比较，因为b和d不匹配，报告失败，回到A，看是否还有别的候选式可试。

回到A时，必须将输入指针重置到第二个符号，即第一次进入A时的位置。这意味着A的程序必须将输入指针保存在一个局部变量中。现在尝试A的第二种候选式，得到图所示的分析树。叶子a匹配w的第二个符号，叶子d匹配w的第三个符号。因为已经产生了w的分析树，停止分析并宣告分析成功！

虽然递归下降语法分析器带有回溯能力，左递归文法也会使其进入无限循环，也就是说，当试图扩展A时，可能最终会发现：在不断试图扩展A，但输入指针并没有前移

#### 预测语法分析器

在许多情况下，通过仔细地编写文法，消除左递归，提取左因子，可以获得一个有效的文法，这个文法可以用不带回溯的递归下降语法分析器来分析。为了构造预测语法分析器，对给定的当前输入符号a和将要扩展的非终结符A，在A的所有可选产生式A -> α1 | α2 | ... | αn中，哪个候选式是唯一能推导出以a开头的串。预测语法分析器能够通过观察候选式所推导出的第一个符号，确定正确的候选式。这种方法可以检测出多数程序设计语言中具有不同关键字的控制流结构。
```
stmt -> if expr then stmt else stmt
    | while expr do stmt
    | begin stmt_list end
``` 
那么关键字if、while、begin告诉如果想找到一条语句哪个候选式是唯一可能成功的选择。

#### 预测分析器的状态转换图

对于词法分析器的设计者来说，状态转换图(transtion diagram)是非常有用的设计工具。也可以为预测语法分析器创建状态转换图。

词法分析器的状态转换图和预测语法分析器的状态转换图具有明显的区别。对于预测语法分析器，每个非终结符都对应一个状态转换图，边上的标记是记号和非终结符。记号(终结符)上的转换意味着如果该记号是下一个输入符号，就应进行该转换。非终结符A上的转换是对与A对应的过程的调用。

为了由文法构造预测语法分析器的状态转换图，首先需要消除文法中的左递归，然后提取左因子，并对每个非终结符A执行如下操作：
1. 创建一个开始状态和一个终态(返回状态)
2. 对每个产生式A->X1X2X...Xn,创建一条从开始状态到终止状态的路径，边上的标记分别为X1,X2,...,Xn

预测语法分析器以状态转换图为基础完成分析工作，其工作方式如下：开始，语法分析器进入状态图的开始状态，输入指针指向输入符号串的第一个符号。如果经过一些动作后，语法分析器进入状态s，且在状态图上从状态s到状态t的边上标记终结符a，而下一个输入符又正好是a，则语法分析器将输入指针向右移动一位指向下一个符号，语法分析器进入状态t。另一个方面，如果边上标记的是非终结符A，则语法分析器进入A的初始状态，但不移动输入指针。一旦语法分析器到达A的终止状态，则立刻进入状态t。事实上，语法分析器从状态s转移到状态t时，已经从输入符号串"读"了A。最后，如果从s到t有一条标记为e的边，那么语法分析器从状态s直接进入状态t而不移动输入指针。

基于状态转换图的预测分析程序试图进行终结符和输入的匹配，并且，当它经过标记为非终结符的边时，进行潜在的递归过程调用。一种非递归的实现方法是，当在状态s上有一个标记为非终结符的指向其他状态的转换时，则将状态s压入栈中，当到达该非终结符的终止状态时，将状态s弹出栈。下面将更详细地讨论状态转换图的实现。

如果给定的状态转换图是确定的，即一个状态对于一个输入仅有一个转换，则上述方法是有效的。如果出现二义性，就要消除，否则不能不够预测语法分析器。但是可以构造低估一下将语法分析器，用回溯的方法尝试所有可能的情况。

#### 非递归的预测分析

通过显式地维护一个状态栈，而不是通过隐式的递归调用，可以构造非递归的预测语法分析器。预测分析的关键问题就是确定用于扩展非终结符的产生式。

**非递归语法分析器**通过查分析表来选取产生式。表驱动的预测语法分析器有一个输入缓冲区、一个栈、一张分析表和一个输入流。输入缓冲区包含要分析的串，后面跟一个符号`$`,`$`是输入串的结束标记。栈用来存放文法符号序列。栈底符号是`$`。初始时，栈中含有文法符号序列及其下边的`$`。分析表是一个二维数组`M[A,a]`,A是非终结符，a是终结符或`$`

语法分析器由一个按如下方式工作的程序控制：程序根据栈顶当前的符号X和当前输入符号a决定语法分析器的动作：
* 如果`X = a = $`，则语法分析器宣告分析成功并停止
* 如果`X = a != $`，则语法分析器弹出栈顶符号X，并将输入指针移到下一个输入符号上。
* 如果X是非终结符,则程序访问分析表M的`M[X,a]`项。`M[X,a]`项是文法的一个X所产生或者出错信息。例如，如果`M[X,a] = {X -> UVW}`,则语法分析器用WVU(U在栈顶)代替栈顶符号X.

**算法4.3** 非递归的预测分析
```
输入：串w和文法G的分析表M
输出：如果w属于L(G),则输出w的最左推导，否则报告错误。
方法：开始时，语法分析器的格局是$在栈里(其中S是G的开始符号且在栈顶)，w$在输入缓冲区。下述程序是用预测分析表M分析输入串的程序

令ip指向w$的第一个符号；
repeat
    令X是栈顶符号，a是ip指向的符号；
    if X是终结符或者$ then
        if X = a then
            从栈中弹出X，ip指向下一个符号
        else 
            error()
    else
        if M[X,a] = X -> Y1Y2...Yk then begin
            总栈中弹出X;
            将Yk, Yk-1, ..., Y1 压入栈，Y1在栈顶
            输出产生式X -> Y1Y2...Yk
        end
        else 
            error()
until X = $  /* 栈空 */
```

#### FIRST和FOLLOW

构造文法G的分析表需要两个与G有关的函数FIRST和FOLLOW。可以用这两个函数来填写G的分析表的表项。由FOLLOW函数产生的记号集合还可用做紧急方式错误恢复期间的同步记号。

如果α是任意的文法符号串，则定义FIRST(α)是从α推导出的串的开始符号的终结符集合，即`FIRST(α) = {α | α *-> a..., a是终结符}`。如果`a *-> e`,则e也属于`FIRST(α)`

设A是一个非终结符，定义`FOLLOW(A)`是包含所有在句型中紧跟在A后面的终结符a的集合，即`FOLLOW(A) = {a | S *-> αAaβ, a是终结符}`。注意，在推导某一时刻，在A和a之间可能有符号，但如果是这样，它们将推导出e并消失。如果A是某个句型的最右符号，那么$属于FOLLOW(A)

为了计算文法符号X的FIRST(X),可以应用下列规则，直到没有终结符或e可加到某个FIRST集合为止：
* 如果X是终结符，则FIRST(X)是{X}
* 如果X->e是一个产生式，则将e加到FIRST(X)中
* 如果X是非终结符，且X->Y1Y2...Yk是一个产生式，则
1. FIRST(Yi)中的所有符号在FIRST(X)中
2. 若对于某个i，a属于FIRST(Yi)且e属于FIRST(Y1),...,FIRST(Yi-1),即`Y1...Yi-1 *-> e`,则将a加入FIRST(X)中。
3. 若对于所有的j=1,2,...,k,e在FIRST(Yj)中，则将e加到FIRST(X)中。

例如，FIRST(Y1)中的每个元素确实都存在FIRST(X)中，如果Y1不能导出e，则不再往FIRST(X)中增加新符号，如果`Y1*->e`,则将FIRST(Y2)加到FIRST(X)中，依次类推

```
FIRST(E) = FIRST(T) = FIRST(F) = {(, id}
FIRST(E) = {+, e}
FIRST(T) = {*, e}
FOLLOW(E) = FOLLOW(E') = {), $}
FOLLOW(T) = FOLLOW(T') = {+, ), $}
FOLLOW(F) = {+, *, ), $}
```

例如，根据计算FIRST的规则1，FIRST(id) = {id}且FIRST('(') = {(}。根据规则3与i=1,id和左括号被加入FIRST(F)中。再根据规则3与i = 1,产生式T->FT意味着id和左括号也在FIRST(T)中。另外，根据规则2，e属于FIRST(E')。

为计算FOLLOW集，根据计算FOLLOW的规则1将$放入FOLLOW(E)中。把规则2应用到产生式F->(E),右括号也在FOLLOW(E)。把规则3应用到产生式E->TE'意味着FIRST(E')中除e以外的所有字符都应该放入FOLLOW(T)。

#### 预测分析表的构造

**算法4.4** 构造预测分析表
```
输入：文法G
输出：分析表M
方法：
1. 对于文法中的每个产生式A->α，执行第2
2. 对FIRST(α)中每个终结符α，将A->α加入到M[A,a]中
3. 若e在FIRST(α)中，则对FOLLOW(A)的每个终结符b，将A->a加入到M[A,b]中，若e在FIRST(α)中，且$在FOLLOW(A)中，则将A->α加入到M[A,$]
4. 将M中每个没定义的表项均置为error
```

#### LL(1)文法

算法4.4应用于任何文法G可以产生分析表M。然而，对某些文法，M可能含有多重定义的表项。例如，若G是左递归的或二义性的，则M至少包含一个多重定义的表项。分析表项汇总没有多重定义表项的文法叫做LL(1)文法。LL(1)中的第一个L代表从左向右扫描输入，第二个L代表产生最左推导，1代表在决定语法分析器的每步动作时间向前扫描一个输入符。

可以证明：算法4.4可以为任何LL(1)文法G产生分析表。这个分析表能分析G的所有句子，而且只能分析G的句子

LL(1)文法有一些特殊的性质。它不是二义性的，也不含左递归。可以证明，G是LL(1)文法，而且仅当G的任何两个不容的产生式A->α|β满足下面的条件:
1. 不存在这样的终结符a，使得α和β导出的串都以a开始
2. α和β中至多有一个能导出空串
3. 如果`β * ->e`,那么α不能导出以FOLLOW(A)中的终结符开始的任何串。

消除分析表中含有的多重定义的方法：进行文法变换，消除左递归和提取所有可能的左因子，以期产生的新文法的分析表中没有多重定义的表项。不幸的是，有些文法不论怎么变换也不能产生LL(1)文法。一般来说，没有一个普遍适用的规则可以用来删除多重定义的表项，使其成为单值而不影响语法分析器所识别的语言。

使用预测分析的主要困难在于为源语言编写一个能构造出预测语法分析器的文法。虽然消除左递归和提取左因子都非常简单，但它们使得结果文法很难阅读而且不易于翻译。为降低上述难度，编译器中语法分析器常常同时使用两种方法，即使用预测分析方法分析控制结构，使用算符优先分析方法分析表达式。然而，如果LR语法分析器的生成器可用，则可以自动获得预测分析和算符优先分析的一切优点。

#### 预测分析的错误恢复

非递归预测语法分析器的栈使得语法分析器希望同剩余输入串进行匹配的终结符和非终结符变得十分清楚。因此，在下面的讨论中，将引用栈中符号。在预测分析过程中，如果栈顶的终结符和下一个输入符号不匹配或者栈顶是非终结符A，a是下一个输入符号，而`M[A,a]`是空白表项，则检测出一个错误。

**紧急方式错误恢复策略**主要基于以下思想：跳过一些输入符号，直到期望的同步记号中的一种出现为止。它的效果依赖于同步记号集合的选择。这个集合的选择应该使得语法分析器能迅速地从实际可能发生的错误中恢复过来。下面是一些启发式方法：

1. 开始，可以把FOLLOW(A)中的所有符号放入非终结符A的同步记号集合中。如果出现错误时栈顶元素是A，可以跳过一些记号，直到看见FOLLOW(A)中的元素，再把A弹出栈。这样我们就可以进行语法分析；
2. 仅使用FOLLOW(A)作为A的同步集合是不够的。例如，在C语言中分号用于表示语句结束，语句开始的关键字很可能不出现产生表达式的非终结符号的FOLLOW集合中。因此，赋值语句分号的遗漏会导致下一语句的开始关键字被跳过。语言的结构往往具有层次结构，如表达式出现在语句中，语句出现在程序块中，等等。我们可以把高层结构的开始符号加到低层结构的同步集合中。例如，可以把表示语句开始的关键字加入产生表达式的非终结符的同步集合中；
3. 如果FIRST(A)的符号加入非终结符A的同步集合，那么可以恢复关于A的分析，只要FIRST(A)的出现在输入中；
4. 如果非终结符能产生空串，则可以将产生空串的产生式作为默认选择。这样做会延迟某些错误的发现，但不会漏掉，而且这种方法可以减少错误恢复时要考虑的非终结符数
5. 如果栈顶的终结符不能被匹配，那么简单的办法就是弹出该终结符，并给出提示信息，说明输入中插入了该符号，然后继续进行分析。实际上，这种方式等于把所有其他的记号作为该记号的同步集合

如果语法分析器发现表项`M[A,a]`为空，则跳过输入符号a；如果表项是synch，则弹出栈顶的非终结符并试图恢复分析；如果栈顶的记号与输入符号不匹配，则从栈顶弹出该记号。

一般来说，出误信息必须由编译器的设计者提供。通过在预测分析表的空白表填上出错处理程序指针即可实现**短语级恢复**。这些程序可以修改、插入或删除输入符号并给出适当的出错信息。它们也可能弹出栈中的符号。如果允许替换栈顶符号或者将新的符号压入栈顶可能会出问题，因为这样会使得语法分析器执行的步骤跟语言中任何词的推导都不会对应。不管怎样，我们必须确保不会产生无限循环。有一种很好的方法可以防止这种循环，即确认所有的恢复动作最终都将会使剩余输入串缩短(或者，如果到了输入的末端，使栈缩短)

### 自底向上语法分析

比较常用的自底向上分析法，称为移动归约分析法。一种最易于实现的移动归约分析法，称为算符优先分析法。更一般的移动归约分析方法叫做LR分析法。LR分析法可用于许多自动的语法分析器的生成器。

移动归约分析法为输入串构造分析树时从叶节点(底端)开始，向根节点(顶端)前进。可以把该过程看成是把输入串w“归约”成文法开始符号的过程。在每一步归约(reduction)中，如果一个子串和某个产生式的右部匹配，则用该产生式的左部符号代替该子串。如果每一步都能恰当地选择子串，就可以得到最右推导的逆过程。

例子：考虑文法
```
S -> aABe
A -> Abc | b
B -> d
```
句子abbcde可按下述步骤归约到S
```
abbcde
aAbcde
aAde
aABe
S
```
首先扫描abbcde，寻找能够匹配某产生式右部的子串。子串b和d都可以匹配某产生式右部。选择最左边的b，用A代替b(因为A是产生式A->b的左部)，得到aAbcd。现在子串Abc、b和d都能匹配某产生式的右部。虽然b是匹配某产生式右部的最左子串，但我们用A代替子串Abc(因为A是产生式A->Abc的左部)，得到aAde。然后，因为B是产生式B->d的左部，所以用B代替d，得到aABe，再用S代替此串。于是，这四步归约将abbcde归约到S。事实上，这些归约与如下最右推导的逆过程相对应
```
S rm-> aABe rm-> aAde rm-> aAbcde -> abbcde
```

#### 句柄

非形式地，一个符号串的“句柄”是和一个产生式右部匹配的子串，而且把它归约到该产生式左部的非终结符代表了最右推导逆过程的一步。在很多情况下，匹配某个产生式A->β右部的最左输入子串β不是句柄，因为用这个产生式归约产生的串不能归约成开始符号。

形式地说，右句型(最右推导可得到的句型)γ的句柄是一个产生式A->β及γ的一个位置，在该位置可以找到串β，而且用A代替β可以的到γ的最右推导的前一个右句型，即如果`S *rm-> αAw rm->αβw`，那么紧跟在α后面的`A -> β`是`αβw`的句柄。

在上面的例子中，abbcde是右句型，句柄是在位置2的A->b。同样，aAbcde也是右句型，它的句柄是在位置2的A->Abc。如果能清楚地知道β的位置和产生式A -> β，有时也可以直接说"子串β是αβw的句柄"

例子，考虑文法
```
E -> E + E
E -> E * E
E -> (E)
E -> id
```
和最右推导
```
E *rm-> E + E
  *rm-> E + E * E
  *rm-> E + E *id3
  *rm-> E + id2 * id3
  *rm-> id1 + id2 *id3
```

#### 句柄裁剪

通过“句柄裁剪”可以得到最右推导的逆过程。从被分析的终结符串w开始。如果w是文法的一个句子，那么w=γn，其中γn是下面的未知最右推导的第n步右句型。
```
S = γ0 rm-> γ1 rm-> γ2 rm-> ... rm-> γn-1 rm-> γn - w
```
为构造这个推导的逆过程，需要在γn中找到句柄βn，并用产生式An->βn的左部代替βn，得到第n-1步的右句型。

重复此过程，即在γn-1中找到句柄βn-1,并对该句柄进行归约得到右句型γn-2。如果继续此过程将得到只包含开始符号S的右句型，那么就宣告分析成功并停止。在归约过程所用产生式序列的逆序就是输入串的最右推导。

#### 用栈实现移动归纳分析

两个问题：
1. 定位右句型中将要归约的子串，
2. 如果这个子串是多个产生式的右部，如何确定选择哪一个产生式。

**实现移动归约分析的一种简单方法是用栈来保存文法符号，用输入缓冲区来保存要分析的串w，用$来标记栈底，也用它标记输入串的右端。**

初始，栈是空的，串w在输入缓冲区中，如下所示：

栈|输入
-|-
$|w$

语法分析器将零个或多个输入符号压入栈，直到句柄β在栈顶出现为止，语法分析器再把β归约成某个恰当的产生式的右部。语法分析器重复此过程，直到它发现错误或者栈中只有开始符号并且输入串为空：

栈|输入
-|-
$$|$

进入这个格局以后，语法分析器停止并宣告分析成功！移动归约语法分析器的基本动作是移动和归约，但实际上有四种可能的动作：**移动**、**归约**、**接受**、**出错**

1. **移动**：把下一个输入符号移动到栈顶
2. **归纳**：语法分析器知道句柄的右端已在栈顶。它必须在栈中确定句柄的左端，并选择正确的非终结符替代句柄
3. **接受**：语法分析器宣告分析成功
4. **出错**：语法分析器发现了一个语法错误，并调用错误恢复程序进行出错处理

有一个重要的事实说明在移动归约分析中会用栈是有道理的：句柄最终总会出现在栈顶，而不是在栈的里面。如果考察任意最右推导中连续两步的可能形式，这个事实将是显而易见的。这两步可能的形式:
```
(1) S *->rm αAz *->rm αβByz *-> αβγyz
(2) S *->rm αBxAz *-> rm αBxyz *-> αγxyz
```
在(1)中，A被βBy代替，然后最右边的非终结符B由γ代替。在(2)中，A仍然先被替换，但这次只是由终结符串y来代替。下一个最右非终结符B将会在y左边的某个地方出现。

在这两种情况下，在执行了一步归约之后，语法分析器都必须移动零个或多个符号以便使下一个句柄进栈。语法分析器不需要深入到栈中去寻找句柄。由此可知，使用栈来实现移动归约语法分析器是非常有效的

#### 活前缀

出现在移动归纳语法分析器中的右句型的前缀集合称为**活前缀**。等价的定义为：活前缀是右句型的前缀，而且其右端不会超过该句型的最右边句柄的末端。根据该定义，可以把终结符加到活前缀的末尾得到右句型。因此，在给定时刻只要输入串中已分析过的那部分能归约成活前缀，就没有错误

#### 移动归约分析过程的冲突

有些上下文无关文法不能使用移动归约分析。这种文法的每一个移动归约语法分析器会形成这样的局面：根据栈中的内容和下一个输入符号不能决定是移动还是归约(移动-归约冲突),或不能决定按哪一个产生式进行归约(归约-归约冲突)。下面会给出属于这类文法的语法结构的例子。从技术上讲，这些文法不属于LR(k)类文法。称它们为非LR文法。LR(k)中的k代表超前搜索k个输入符号。编译中使用的文法通常都属于LR(1)类，即超前搜索一个输入符号。

例子：二义性文法一定不是LR文法:
```
stmt -> if expr then stmt
    | if expr then stmt else stmt
    | other
```
如果移动归约语法分析器处于格局
```
栈                      输入
...if expr then stmt  else...$
```
无论栈中`if expr then stmt` 下面是什么符号，都不能判断`if expr then stmt`是否为句柄，这里存在移动-归约冲突。根据输入中else后的内容，也许将`if expr then stmt`归约成stmt是正确的。或者也许移动else进栈，然后寻找另一个stmt来完成`if expr then stmt else stmt`的替换是正确的。因此，在这种情况下不能判断应该移动还是归约，所以这个文法不是LR(1)文法。

对移动归约分析方法进行简单的改造即可分析某些二义性文法，如上面的`if then else`文法。当为我们包含上面产生式的文法构造这样的语法分析器时，存在移动-归约冲突；对于else或者移动，或者用`stmt->if expr then stmt`归约。如果我们通过优先使用移动来解决这个冲突，语法分析器就能正常工作。

非LR出现的另一种常见的情况是：制导了句柄，但根据栈里的内容和下一个输入符号不足以判断在归约中使用哪个产生式。

例子：假设词法分析器对任何标识符都返回记号id，而不管它是如何使用的。假设语言通过给出过程的名字及用括号括起来的参数表来调用过程，而且数组元素的引用也采用同样的语法。因为数组引用中的下标和过程调用中的参数的翻译是不一样的，所以，用不同的产生式来产生实参数和下标表。文法应该具有下面一些产生式：
```
(1) stmt -> id(parameter_list) 
(2) stmt -> expr := expr
(3) parameter_list -> parameter_list, parameter
(4) parameter_list -> parameter
(5) parameter -> id
(6) expr -> id(expr_list)
(7) expr -> id
(8) expr_list -> expr_list, expr
(9) expr_list -> expr
```
以A(I,J)开始的语句可能以记号流id(id,id)的形式呈现给语法分析器。把前三个记号移进栈后，移动归约语法分析器的格局是：
```
栈           输入
...id(id      ,id)...
```
显然，必须对栈顶的id进行归约：如果A是过程，应按产生式(5)归约；如果A是数组，应按产生式(7)归约。但栈中的信息不能告诉应该按哪个产生式归约，必须使用符号表中有关A的信息。

解决上述问题的一种方法是把产生式(1)的记号改为procid，并使用更复杂一些的词法分析器，当它识别出作为过程名的标识符时返回记号procid。当然，这样做要求词法分析器在返回记号前要访问符号表。

这样修改后，处理A(i,j)时，语法分析器可能处于格局
```
栈               输入
...procid(id    .id)...
```
或处于前面的格局。前者用产生式(5)归约，后者用产生式(7)归约。注意，栈中的第三个符号用来决定归约的产生式，虽然它本身并不包含在这个归约中。移动归约分析可以利用栈深处的信息来指导分析。

### 算符优先分析法

LR文法是一大类适合移动归约语法分析器的文法。对于一小部分非常重要的文法，可以很容易地手工构造有效的移动归约语法分析器。这些文法具有下面的性质：所有产生式的右部都不是e或两个相邻的非终结符。具有第二个性质的文法称为算符文法。
```
E -> EAE | (E) | -E | id
A -> + | - | * | / | ^
```
它不是算符文法，因为右部EAE有2个（实际上是3个）连续的非终结符。然而，如果用A的每个候选式替代第一个产生式中的A，将得到下面的算符文法:
```
E -> E + E | E - E | E * E | E / E | E ^ E | (E) | -E | id    文法(4-17)
```
算符优先语法分析器最初是一种处理记号的技术，而这些记号不是建立在文法的基础上。实际上，一旦根据一个文法构造了一种算符优先语法分析器，就可以忽略该文法，栈中的非终结符仅仅作为与这些非终结符相关的属性的占位符。

作为通用的语法分析技术，算符优先分析法具有许多缺点。例如，它很难处理像减号这样的记号，因为减号有两个不同的优先级(取决于它是一元操作符`取负`还是二元操作符`减法`)。更糟糕的是，因为要分析的语言的文法和算符优先语法分析器本身的关系不是十分紧密的，所以不能肯定语法分析器接受的就是所期望的语言。

然而，由于算符优先分析技术比较简单，很多编译器的语法分析器经常采用算符优先分析技术对表达式进行分析，对于语句和高级结构的分析则采用**递归下降分析法**。有些编译器的语法分析器甚至对整个语言都采用算符优先技术进行语法分析。

在算符优先分析中，在某些终结符对之间定义如下三种优先关系：`<·`/`·=`/`·>`。这些优先关系可用于制导句柄的选取，它们的含义如右表所示。

关系|含义
-|-
`a <· b`|a的优先级低于b
`a ·= b`|a的优先级等于b
`a ·> b`|a的优先级高于b

注意：这些关系类似于算术关系“小于”、“等于”和“大于”，但优先关系具有不同的性质。例如，对于同一语言，`a <· b`和`a ·> b`可能同时成立，或者对于某两个终结符`a`和`b`，`a <· b`和`a ·= b`以及`a ·> b`均不成立。

有两种常用的方法确定终结符之间的优先关系。第一种方法是直觉主义方法，即基于习惯的操作符间的结合规则和运算优先关系。例如，如果`*`比`+`具有更高的优先级，可以令`+ <· *`和`* ·> +`成立。并且可以使用这种方法的算符优先语法分析器(虽然一元减会有问题)。

确定算符优先关系的第二种方法是首先为语言构造无二义性文法。该文法在分析树上反映了正确的结合规则和优先级。对于表达式来说，这项工作不难。对于二义性的其他来源，如else的不匹配。如果已经获得了无二义性文法，则存在一种从该文法构造算符优先关系的机械方法。这些关系可能是相交的，而且它们可能分析非该文法产生的语言，但是对于标准算术表达式来说，实际上很少遇到问题。

#### 使用算符优先关系

优先关系主要用于界定右句型的句柄。`<·`标记句柄的左端，`·=`出现在句柄的内部，`·>`标记句柄的右端。假设我们有一个算符文法的右句型，那么“没有相邻的非终结符出现在产生式右部”意味着“右句型不会有两个相邻的非终结符”。于是，可以用β0a1β1...anβn表示右句型，这里βi是e(空串)或单个非终结符，ai是单个终结符。

假设ai和ai+1之间只是满足`<·`/`·=`/`·>`中的某一种优先关系，用`$`标记符号串的两端，对所有的终结符b，定义`$ <· b`和`b ·> $`。现在假设我们从符号串移走非终结符，并在每两个终结符之间以及两端的终结符与$之间放上正确的优先关系`<·`/`·=`/`·>`，其中$标记符号串的两端。例如，假设开始时有右句型`id + id * id`和下表所示的优先关系，

\|id|+|*|$
-|-|-|-|-
id||·>|·>|·>
+|<·|·>|<·|·>
*|<·|·>|·>|·>
$|<·|<·|<·|

插入优先关系后的符号串为：
```
$ <· id ·> + <· id ·> * <· id ·> $
```

例如，由于`<·`是优先关系表中行为$列为id的表项，所以`<·`被插入在左端的`$`和`id`之间。应用下面的过程即可发现句柄:

* 从左端开始扫描串，直到遇到第一个`·>`为止。
* 向左扫描，跳过所有的`·=`,直到遇到一个`<·`为止，向左扫描到$
* 句柄包括从第2步遇到的`<·`的右部到一个`·>`的左部之间的所有符号，包括介于其间或者两边的非终结符。包括两边的非终结符是必要的，可以使两个相邻的非终结符不会出现在右句型中

如果正在处理文法(4-17)，就把id归约为E。这时，可以得到右句型E + id * id。按照同样的步骤将剩余的两个id归约为E之后，可以得到右句型E + E * E。现在考虑删除非终结符后的符号串`$+*$`。插入优先关系后，得到：
```
$ <· + <· * ·> $
```
可以看出，句柄的左端位于`+`和`*`之间，右端位于`*`和`$`之间。这些优先关系表明，在右句型`E + E * E`中，句柄是E * E。注意*两边的E也在句柄中。

因为非终结符不会影响语法分析，所以不需要考虑区分它们。可以吧一个标记“非终结符”保存在移动归约栈中，作为属性值的占位符。

为了找到句柄，每步都必须扫描整个右句型。用栈存储已看到的输入符号，并且用优先关系指导移动归约语法分析器的动作，情况就不同了。如果栈顶的终结符和下一个输入符之间的优先关系是`<·`或`·=`，则语法分析器移动，表示还没有发现句柄的右端；如果是`·>`关系，就调用归约。这时语法分析器已找到句柄的右端，而且优先关系还能用来在栈中找到句柄的左端。

如果一对终结符之间没有优先关系成立，则表示检测出了语法错误，须调用错误恢复例程。下面的算符可以形式化描述上述思想：

**算法4.5** 算符优先分析算法

```
输入：输入字符串w和优先关系表
输出：如果w是一个句子，则输出一个分析树架子，它的所有内节点均由占位非终结符E来标注；否则，指出错误。
方法：初始时，栈中放入$,输入缓冲区放入w$。为了进行语法分析。
```

#### 从结合律和优先级获得算符优先关系

可以以合适的方式创建算符优先关系，并希望由它们指导的算符优先分析算法能运行正常。类似于文法(4-17)产生的算术表达式语言，可以用下面的启发式方法产生正确的优先关系。注意：文法(4-17)是二义性的，右句型可能有多个句柄。设计规则是选择恰当的句柄来反映二元操作符的结合律和优先级

1. 如果操作符`o1`比`o2`具有更高的优先级，则`o1 ·> o2`和`o1 <· o2`都成立。例如，如果`*`比`+`具有更高的优先级，那么，`* ·> +`和`+ <· *`都成立。这些关系可以确保形如`E + E * E + E`的表达式，中间的`E * E`是先被归约的句柄。
2. 如果`o1`和`o2`是同优先级的操作符(可以是同一个操作符),那么当它们满足左结合律时,`o1 ·> o2`和`o1 <· o2`成立;当它们满足右结合律时，`o1 ·> o2`和`o1 <· o2`成立。例如,`+`和`-`满足左结合律,`+ ·> +`、`+ ·> -`、`- ·> -`、`- ·> +`同时成立。`^`满足右结合律，这些关系可以确保在`E - E + E`中，`E - E`会被选为句柄；而在`E ^ E ^ E`中，最后的`E ^ E`会被选为句柄
3. 对于所有的操作符o来说，`o <· id`、`id ·> o`、`o <· (`、`( <· o`、`) ·>o`、`o ·> )`、`o ·> $`、`$ <· o`均成立。`( ·= )`、`$ <· id`、`( <· (`、`id ·> $`、`) ·> $`、`( <· id`、`id ·> )`、`) ·> )`

这些规则可以确保`id`和`(E)`都会被归约为`E`,而且只要`$`作为左右两端的标记，就可能会促使在`$`之间找到句柄。

例子：对于算符`+`,`-`,`*`,`/`,`^`,`id`,`(`,`)`,`$`的算符优先关系：

* `^`具有最高优先级，满足右结合律
* `*`和`/``具有次最高优先级，满足左结合律
* `+`和`-`的优先级最低，满足左结合律

#### 处理一元操作符

如果有类似于`~`(逻辑非)的操作符，并且不是二元操作符，那么可以把它合并到上面的构造算符优先关系的方案中。假设`~`是一元前缀操作符，对于任何操作符`o`,无论是一元的还是二元的，均使`o ·< ~`成立。如果`~`比`o`的优先级高，则使`~ ·> o`成立，否则`~ ·< o`成立。例如，设`~`比`&`优先级更高，且`&`满足左结合律，通过这些规则可以看出`E & ~E & E`等价于`(E & (~E)) & E`。一元操作符的规则类似。

对于类似于减号这样的操作符(它既是一元前缀操作符又是二元中缀操作符)情况就不同了。即使给一元和二元的减号赋予同样的优先级，也无法区别一元或者二元。当它看到一元的减号时返回不同的记号。但是词法分析器不能通过超前扫描来区分两者，它必须记住前一个记号。例如，在Fortran中，如果前一个记号是操作符、左括号、逗号或赋值符号，则减号是一元的。

#### 优先函数

使用算符优先语法分析器的编译器不需要存储优先关系表。在大多数情况下，该表可以用两个优先函数f和g来表示。f和g把终结符映射为整数。对于符号a和b，选择f和g满足：

* f(a) < g(b),如果a <· b 
* f(a) = g(b),如果a ·= b 
* f(a) > g(b),如果a ·> b 

这样a和b之间的优先关系就可以通过f(a)和g(b)之间的数值比较来确定。但是，优先矩阵中的空白项是模糊的，因为无论f(a)和g(b)取何值，上面的1、2或3总有1项成立。错误检测的能力损失还没有严重到阻止使用有限函数的程度。如果在调用归约时没有发现句柄。仍然会发现错误。

注意：并不是所有的优先关系表都能用优先函数来表示；但是，在实际应用中，优先函数通常是存在的。

**算法4.6** 优先函数的构造
```
输入：算符优先表
输出：表示输入矩阵的优先函数，或指出它不存在
方法：
1. 为每个终结符a或$创建符号fa和ga
2. 把生成的符号按下面的方式分成尽可能多的组；如果a ·= b，则fa和gb在同一组。注意，即使某些符号之间没有 ·= 关系，也可能不得不把它们放在同一组。例如，如果a ·= b且c ·= b,那么fa和fc必在同一组，因为它们都和gb在同一组。此外，如果c ·= d,那么即使a ·= d不成立，fa和gd也可能在同一组
3. 构造一个以(2)中的符号组为节点的有向图。对任意的a和b，如果a <· b，则从gb所在的组引出一条边指向fa所在的组。如果a >· b,则从fa所在的组引一条边指向gb所在组。注意从fa到gb的边或路径意味着f(a)必超过g(b)，从gb到fa的路意味着g(b)必超过f(a).
4. 如果(3)中构造的图中有环路，则不存在优先函数。如果没有环路，则将f(a)设为从fa所在的组开始的最长路径的长度，g(a)设为从ga所在的组开始的最长路径的长度。
```

#### 算符优先分析中的错误恢复

算符优先分析器在语法分析的过程中，能发现以下两种情况下的语法错误：

* (1) 如果栈顶的终结符和当前输入之间没有优先关系
* (2) 如果发现句柄，但句柄不是任何产生式的右部

算符优先分析算法(算法4.5)似乎只归约由终结符组成的句柄。然而，虽然非终结符是匿名处理的，但它们仍在分析栈中占据位置。

然而，不能因为我们在栈中找到了一个符号序列`a <· b1 ·= b2 ·= ... ·= bk`,就认为b1b2...bk是某个产生式右部的终结符串。事实上，如果希望将语义规则和归约相关联，就必须这么做。以确定归约时哪个产生式是句柄。

##### 归约时的错误处理

可以把错误检测和恢复程序分成几部分。例子：当把符号弹出栈时，没有用于归约的产生式，所以没有语义动作，而只是打印诊断信息。为了确定打印什么诊断信息，处理情况(2)的程序必须确定被弹出的字符串与哪个产生式的右部相像。例如：假设abc被弹出，并且没有哪个产生式的右部由a，b，c和零个或多个非终结符组成，也许可以考虑是否删除a、b和c中的一个就可以产生一个合法的产生式右部(忽略非终结符)。例如，如果有一个右部为aEcE，则可以给出下面的诊断信息：
```
illegal b on line (包含b的行)
```
也可以考虑改变或插入一个终结符。如果abEdc是一个产生式的右部，则可以给出下面的诊断信息：
```
missing d on line (包含c的行)
```
也可能发现对于某个右部，终结符的顺序正确，但非终结符的模式不对。例如，abc被弹出栈并且在它的中间和两边均没有非终结符，而且abc不是某产生式的右部，而aEbc是，则可以给出下面的诊断信息：
```
missing E on line (包含b的行)
```
这里的E代表由非终结符E所表示的一个适当的语法类型。例如，如果a、b或c是操作符，则可能代表“表达式”；如果a是类似if这样的关键字，则可能代表“条件”。

*注意：在使用优先函数表示优先关系表的编译器中，这种错误源的检测可能不可用*

一般地，当没有发现的句柄不是任何产生式的右部时，要给出合适的诊断信息，其困难在于是否弹出有限或无限数目的字符串。相邻符号之间必须满足`·=`关系。如果算符优先表告诉仅由有限数目的终结符序列满足`·=`关系，则可以用枚举法处理这些串。对于每个这样的串x，可以事先确定一个具有最小距离的字符串y，y是某个产生式的右部，并给出诊断信息来暗示希望找到y时却找到了x。

确定上述过程能够弹出所有字符串是很容易的，其方法是构造一个有向图，图的节点表示终结符，当且仅当`a ·= b`时，从a到b有一条边。沿着图上各路径的节点标记所形成的字符串就是能够弹出的字符串。路径可能包含单个节点。然而，对某个输入，为了能够弹出`b1b2...bk`,必须有一个符号a(可能是$)使得`a <· b1`,`b1`称为起点；同时也必须有一个符号c(可能是$)使得`bk ·> c`，`bk`称为终点。只有这时才能调用归约，使`b1b2...bk`称为被弹出的符号序列。如果从起点到终点的路径中有环路存在，则有可能弹出无限个串，否则只能弹出有限个串。

例子：重新考虑文法(4-17)
```
E -> E + E | E - E | E * E | E / E | E ^ E | (E) | -E | id    文法(4-17)
```

检查程序进行如下检查：

* 1. 如果`+`、`-`、`*`、`/`或`^`被归约，则检查两边是否有非终结符出现。如果没有，输出诊断信息“missing operand”
* 2. 如果`id`被归约，检查两边是否有非终结符出现。如果有，输出警告“missing operator”
* 3. 如果`()`被归约，检查两个括号中间是否有非终结符出现。如果没有，输出警告“no expression between parentheses”

除此之外，还要检查是否有非终结符出现在括号对的任何一边，如果是，给出和(2)一样的信息。如果能够弹出无限个字符串，则错误信息不能用枚举法列出。可以使用通用程序来确定是否有某个产生式的右部与弹出的字符串接近(即距离是1或2，此处的距离根据插入、删除或修改的记号数而不是字符数来计算的)。如果有，则在“这个产生式是欲寻找的产生式”的假设下，给出一个特定诊断信息。如果没有产生式的右部与弹出的字符串接近，则给出一条一般的诊断信息“当前行有错误”。

##### 处理移动归约错误

下面讨论算符优先语法分析器检测错误的其他方法。如果根据优先矩阵决定符号移动还是归约，有时会发现栈顶符号和第一个输入符号间没有优先级关系。例如，假设a和b是两个相邻栈顶符号，b在栈顶，c和d是接下来的两个输入符号，且b和c之间没有优先关系。为恢复错误，必须修改栈、输入或者两者都修改。可以改变符号、在输入或栈中插入符号或者从输入或栈中删除符号。如果改变或插入符号，*注意：可以免陷入死循环*。例如，在输入的前端不断地插入符号而不能归约或移动任何插入的符号，就可能会造成死循环。

一种不会陷入死循环的方法是确保在恢复后能够把当前输入符号移动进栈(如果当前符号是$,确保不会往输入中插入符号，且栈最终会被缩短)。例如，假设ab在栈里，cd是输入，如果`a <=· c^2`,把b从栈里弹出。另一种选择方案是：如果`b <=· d`,从输入中删除c。第三种选择方案是找到某个符号e，使得`b <=· e <=· c`,在输入字符串中把e插到c的前面。更一般地，如果找不到单个符号插入，可以插入符合如下条件的一串符号：
```
b <=· e1 <=· e2 <=· ... <=· en <=· c
```

对于优先矩阵中的每个空白项，必须指定一个错误恢复程序，而且同一程序可用在多个地方。这样，当语法分析器在步骤(6)发现a和b之间没有优先关系时，就可以找到指向相应错误恢复程序的指针。

例子，错误处理机制如何处理错误输入字符串`id+`。语法分析器的第一个动作是把id移动进栈，并将其归约为E(还是用E作为栈中的匿名非终结符)，然后移进`+`,现在的格局是：
```
栈    输入
$E+    )$
```
因为`+·>)`,调用归约，句柄是`+`。错误检查程序将进行归约时的错误检测，检查`+`的左右是否有`E`,发现右边缺少`E`,给出诊断信息"missing operand",并进行归约，现在的格局为：
```
栈    输入
$E    )$
```
`$`和`)`之间没有优先关系，而且图中与这对符号对应的项是e2。程序e2被调用并给出诊断信息"unbalanced right parenthesis",然后从输入中删掉右括号，语法分析器最后的格局为
```
栈    输入
$E    $
```

### LR语法分析器

一种自底向上语法分析技术，它适用于一大类上下文无关文法的语法分析。这种技术叫做LR(k)分析法，L指的是从左向右扫描输入字符串，R指的是构造最右推导的逆过程，k指的是在决定语法分析动作时需要向前看的符号个数。(k)省略时，假设k是1。LR分析富有吸引力的原因有以下几点：

* LR语法分析器能识别几乎所有能用上下文无关文法描述的程序设计语言的结构
* LR分析法是已知的最一般的无回溯移动归约语法分析法，而且可以和其他移动归约分析法一样被有效地实现
* LR分析法分析的文本类是预测分析法能分析的文法类的真超集。
* 在自左向右扫描输入符号串时，LR语法分析器能及时发现语法错误。

这种分析方法的主要缺点是，对典型的程序设计语言文法，手工构造LR语法分析器的工作量太大，因而需要专门的工具，即LR语法分析器的生成器。

幸好有许多这样的生成器是可用的。比如Yacc的设计和使用。有了这种生成器，只要写出上下文无关文法，就可以用它自动生成该文法的语法分析器。如果文法有二义性或有其他难以自左向右分析的结构，这种生成器能够识别这些结构，并向编译器设计者报告。

在讨论完LR语法分析器的操作后，将给出三种构造LR分析表的方法。第一种方法称为简单LR方法(简称SLR)，它最容易实现，但功能也最弱。对某些文法，另外两种方法能成功地产生语法分析表，但用它却会失败。第二种方法称为规范的LR方法，它的功能最强，代价也最高。第三种方法叫做向前看的LR方法(简称LALR)，其功能和代价介于前两者之间。LALR方法可用于大多数程序设计语言的文法，并且可以高效地实现。以及还有LR语法分析表的压缩技术。

#### LR语法分析算法

LR语法分析器的模型如图所示，它是由输入、输出、栈、驱动程序以及包含动作(action)和转移(goto)两部分的语法分析表构成的。驱动程序对所有的LR语法分析器都是一样的，不同的语法分析器只是语法分析表有所不同。分析程序每次从输入缓冲区读入一个符号，并使用栈来存储形如`s0X1s1X2s2...Xmsm`的串，其中`sm`在栈顶,`Xi`是文法符号，`si`是称为状态的符号，每个状态符号概括了栈中位于它下面的信息。栈顶的状态符号和当前的输入符号用来检索语法分析表，以决定移动归约分析的动作。在实际实现中，文法符号不必出现在栈里。

**语法分析表由动作函数action和转移函数goto两部分组成**。驱动LR语法分析器的程序工作如下：它根据栈顶状态sm和当前输入符号ai访问`action[sm, ai]`,即sm和ai所对应的语法分析表项的动作部分，可能的动作如下：

* 移动状态s进栈 
* 按文法产生A->β归约
* 接收
* 出错

函数goto以状态和文法符号为参数，产生一个状态。将会看到，用SLR、规范的LR或LALR方法从文法G构造的语法分析表的goto函数是识别G的活前缀的确定有穷自动机的转换函数。回想一下，文法G的活前缀是右句型的前缀，并且它不会超过句柄的最右端，所以它可以出现在移动归约语法分析器的栈顶。这个确定有穷自动机的初始状态是初始时置于LR语法分析器栈中的状态。

LR语法分析器的格局是一个如下形式的二元组，它的第一个分量是栈的内容，第二个分量是尚未处理的输入：
```
(s0 X1 s1 X2 s2 ... Xm sm ai ai+1 ... an $)
```
这个格局代表下面的右句型:
```
X1 X2 ... Xm ai ai+1 ... an
```
由此可以看出，它本质上和一般的移动-归约分析器相同，只是栈中新加了一些状态。

语法分析器的下一个动作是用当前输入符号ai和栈顶状态sm查询语法分析表的表项`action[sm,ai]`。四种不同的移动所引起的格局变化如下：

* 1. 如果`action[sm,ai]=`"移动状态s进栈",语法分析器执行移动操作，进入下面的格局：
```
(s0 X1 s1 X2 s2 ... Xm sm ai ai+1 ... an $)
```
这里，语法分析器把当前输入符号ai和下一个状态s(它在`action[sm,ai]`中给出)都移动进栈；`ai+1`成为当前输入符号。
* 2. 如果`action[sm,ai]=`"按文法产生式`A->β`归约"，语法分析器执行归约操作，进入下面的格局：
其中，`s=goto[sm-r,A]`,r是产生式右部β的长度，在此，语法分析器首先从栈中弹出`2r`个符号，分别为r个状态符号和r个文法符号(这些文法符号刚好匹配产生式的右部β)，栈顶为状态`sm=r`。然后，语法分析器把产生式左边的符号A和`goto[sm-r,A] = s`压入栈。执行归约操作时，当前输入符号没有变化。对于要构造的LR语法分析器，从栈中弹出的文法符号序列`Xm-r,+1...Xm`总是能匹配归约式的右部β。LR语法分析器的输出由归约时执行的与归纳产生式有关的语义动作产生，现在，我们暂且认为输出就是打印归约中使用的产生式。
* 3. 如果`action[sm,ai]=`“接受”，分析完成。
* 4. 如果`action[sm,ai]=`“出错”，语法分析器发现错误，调用错误恢复程序。

所有的LR语法分析器都以这种方式工作，只是语法分析表的action和goto域的信息有所不同。

**算法4.7** LR分析算法
```
输入：文法G的LR语法分析表和输入串w
输出：如果w属于L(G),则输出w的自底向上分析，否则报错
方法：首先，把初始状态s0放在语法分析器栈顶，把w$放在输入缓冲区；然后，语法分析器执行下图的程序，直到遇见接受或出错动作为止.

令ip指向w$的第一个符号;
repeat forever begin
    令s是栈顶的状态，a是ip所指向的符号；
    if action[s, a] = "移动状态s'进栈" then begin
        把a和s'依次压入栈顶；
        让ip指向下一个输入符号
    end
    else if action[s,a] = "按文法产生式A->β归约" then begin
        从栈顶弹出2 * |β|个符号；
        令s'是现在的栈顶状态；
        把A和goto[s',A]依次压入栈；
        输出产生式A->β
    end
    end if action[s, a] = "接受" then
        return
    else error()
end
```

例子：下面是含二元操作符+和*的算术表达式的文法:

```
(1) E -> E + T
(2) E -> T
(3) T -> T * F
(4) T -> F
(5) F -> (E)
(6) F -> id
```

G的LR语法分析表，包括动作函数和转移函数。各个动作的编码的含义是：
* 1. si表示把当前输入符号和状态i压进栈
* 2. rj表示按第j个产生式归约
* 3. acc表示接受
* 4. 空白表示出错

注意：对于终结符a，状态转移动作`goto[s, a]`可以在表的动作表项`action[s, a]`中找到，所以转移域中仅给出非终结符A的`goto[s, A]`。

给定输入字符串`id * id + id`,栈和输入内容的变化序列。在第一行，LR语法分析器处于状态0，id是第一个输入符号。第0行和第id列对应的动作域是s5,其含义是id进栈，并把状态5压入栈顶。第二行给出了执行动作s5后的格局：第一输入记号id和状态5进栈，把id从输入字符串删除。

然后，`*`成为当前输入符号，状态5遇见输入`*`的动作是按`F->id`归约:弹出栈顶的两个符号(一个状态符号和一个文法符号)，栈顶为状态0。因为`goto[0, F]`是3，语法分析器把F和3压入栈顶，到达第3行所示的格局。

#### LR文法

给定文法G,如果我们能为G构造出LR语法分析表，则称G是LR文法。很多上下文无关文法不是LR文法。但是，典型的程序设计的结构一般都可以避免非LR文法。直观地，为了使一个文法是LR文法，只要保证在句柄出现在栈顶时，自左向右扫描的移动分析归约分析器能够及时地识别它。

LR语法分析器不需要扫描整个栈就可以知道什么时候句柄出现在栈顶。栈顶的状态符号包含了所需要的一切信息。一个非常重要的事实是：如果仅知道栈中的文法符号就可以识别句柄，则存在一个有穷动机，通过自顶向下读栈中的文法符号自动机就能确定栈顶的句柄(如果有的话)。LR语法分析表的goto函数实质上就是这样的有穷自动机。不过，这个有穷自动机不需要每次移动都读栈。如果识别句柄的有穷自动机自底向上读栈中的文法符号，栈顶所存的状态符号正好是这个自动机所进入的状态。于是，LR语法分析器从栈顶的状态即可确定它需要从栈中了解的一切。

能够用来帮助LR语法分析器作出移动归约决定的另一个信息源是下k个输入符号。实际上感兴趣的是k=0或k=1时的情况。每步需要向前看k个符号的LR语法分析器所分析的文法叫做LR(k)文法。

LL文法和LR文法之间有明显的区别。对于LR(k)文法，必须通过向前看k个输入符号就能够知道一个产生式的右部所能推导出的所有字符串，进而识别出这个产生式右部的出现。这个要求远不如LL(k)那么严格。LL(k)文法要求只要看到了产生式右部推出的前k个符号后就能是被出用于归约的产生式。所以LR文法比LL文法描述的语言更多。

#### 构造SLR语法分析表

由文法构造LR分析表的三种方法：其中一种是**简单LR**即SLR。SLR的功能最弱，但最容易实现。根据这种方法构造的语法分析表叫做SLR语法分析表。使用SLR语法分析表的LR语法分析器叫做SLR语法分析器。能够为之构造SLR语法分析器的文法叫做SLR文法。另外两种通过向前看信息增强了SLR语法。所以SLR方法是研究LR语法分析的理想起点。

文法G的LR(0)项目是在G的产生式右部的某处加点的产生式。例如，产生式`A->XYZ`可以生成如下四个项目：
```
A -> ·XYZ
A -> X·YZ
A -> XY·Z
A -> XYZ·
```

产生式`A->e`只生成一个项目`A->·`。项目可以用一对整数来表示：第一个数表示产生式的号码，第二个数表示点的位置。直观地，项目表示：在语法分析过程中的某一时刻，已经看见了一个产生式所能退出的字符串的多大部分。

SLR方法的主要思想是首先从文法构造识别活前缀的确定有穷自动机。我们把项目划分成一组集合，这些集合对应SLR语法分析器的状态。项目可以看成是识别活前缀的NFA的状态，而“项目分组”就是**子集构造法**。

被称为规范LR(0)项目集族的LR(0)项目集合族是构造SLR语法分析表的基础。为了构造文法规范LR(0)项目集族，需要定义拓广文法的概念，并引入闭包(closure)运算和转移函数(goto)

如果文法G的开始符号是S，那么G的拓广文法G'是在G的基础上增加一个新的开始符号S'和产生式`S'->S`。新产生式的目的使用来指示语法分析器什么时候应该停止分析并宣布接受输入，即当且仅当语法分析器执行归约S'->S时，分析成功。

##### 闭包运算closure

如果I是文法G的项目集，那么closure(I)是从I出发下面两条规则构造的项目集：

* 1. 初始时，把I的每个项目都加入到closure(I)中；
* 2. 如果`A->α·Bβ`在closure(I)中，且存在产生式`B->γ`不在closure(I)中，则将其加入closure(I)。反复运用这条规则，直到没有更过的项目可加入closure(I)为止。

`A->α·Bβ`在closure(I)中表示语法分析过程的某一时刻，下一步应该从输入中看见的是由Bβ推出的串。如果`B->γ`是一个产生式，希望在这个时刻，也应该从输入串中看见从γ推出的子串。基于这个原因，把`B->γ`加入到closure(I).

如果I是一个项目集合`{[E'->E]}`，那么closure(I)包含下列项目：

```
E' -> ·E
E -> ·E + T
E -> ·T
T -> ·T * F
T -> ·F
F -> ·(E)
F -> ·id
```

按规则(1),把`E'->·E`加入到closure(I)。因为E紧挨在点的右边，由规则(2)，把点在左端的E产生式，即`E->·E+T`和`E->·T`都加入到closure(I)。同样，把`T->·T*F`和`T·->F`也加入进去。最后,`T->·F`导致了`F->·(E)`和`F->·(id)`的加入。

计算函数closure的算法如下式所示。一种简单的实现方法是使用一个由G的非终结符作为索引的布尔数组added。当为每个`B->γ`产生式增加项目`B->·γ`时，将`added[B]`置为`true`。

注意，如果一个点在左端的B产生式被加入closure(I),则所有B产生式都将类似地加入closure(I)。事实上，并不需要列出如此加入项目`B->·γ`，而只要列出这样的非终结符B就足够了。因此，可以把感兴趣的项目分成两类：

```
function closure(I)
begin
    j := I
    repeat
        for J的每个项目A->α·Bβ和G的每个产生式
            B->γ，若B->·γ不在J中do
                把B->·γ加入J;
        until 没有新项目可加入J;
    return J
end
```

* 1. 核心项目：初始项`S'->S`和所有点不在左端的项目
* 2. 非核心项目：点在左端的非初始项目

感兴趣的每个项目集都可以通过求核心项目集的闭包得到。当然，加入闭包的项目绝不会是核心项目。这样，如果扔掉所有非核心项目，可以用较少存储空间来表示需要的项目集合，因为非核心项目可以通过求闭包来重新生成。

##### goto函数

第二个非常有用的函数goto(I, X),其中I是项目集，X是文法符号。goto(I,X)定义为所有项目集`[A->αX·β]`（`[A->αX·β]`在I中）的闭包。如果I是对某个活前缀γ的有效项目集，那么goto(I,X)第对活前缀`γX`有效的项目集。

例子：若I是两个项目的集合`|[E'->E·],[E->E·+T]|`，则`goto(I,+)`包含以下项目：
```
E -> E + ·T
T -> ·T * F
T -> ·F
F -> ·(E)
F -> ·id
```

通过考察I的项目，找到+紧挨在点右侧的项目来计算`goto(I,+)`.`E'->E·`不是这样的项目，但`E->E·+T`是这样的项目。把`E->E·+T`中的点移过`+`得到`|E->E+·T|`,然后取它的闭包。

##### 项目集的构造

给出拓广文法`·G'`的规范`LR(0)`项目集族(下面用C表示)的构造算法，如下式所示。

```
procedure items(G')
begin
    C := {closure({[S'->S]})};
    repeat
        for C的每个项目集I和每个文法符号X，
            若goto(I,X)非空且不再C中 do
                把goto(I,X)加入C中
    until 没有更多的项目可以加入C
end
```

如果D的每个状态都是终态且I0是初始状态，那么D识别的刚好是文法的活前缀。这不是偶然的。对每个文法G，规范项目集族的goto函数定义了一个确定的有穷自动机，识别G的活前缀。事实上，也可以想象一个识别活前缀的不确定的有穷自动机N，其状态就是项目本身。从`A->α·Xβ`到`A->αX·β`有一个标记为X的转换，从`A->α·Bβ`到`B->·γ`有一个标记为e的转换。于是，由N的状态集组成的项目集I的closure(I)恰好是之前定义的NFA的一个状态集的e闭包。在由N用子集构造法构造的DFA中，goto(I,X)定义了状态I遇见符号X时的转换。

**有效项目**-如果存在一个推导`S rm*-> αAw rm*-> αβ1β2w`，则说项目`A -> β1 · β2`对活前缀`αβ1`是有效的。一般而言，同一项目可能对多个活前缀有效。`A -> β1 · β2`对活前缀`αβ1`有效这个事实告诉我们，在发现`αβ1`在分析栈时是移进还是归约，特别是，如果`β2 != e`,它暗示句柄还没有完全进栈，动作应该是移进。如果`β2 = e`,那么`A -> β1`是句柄，应该用这个产生式归约。当然，同一个活前缀的两个有效项目可能告诉做不同的事情，有些这样的冲突可以通过向前看下一个输入符号来解决，其他一些冲突可以用下一节的方法解决。当LR方法用于构造任意文法的语法分析表时，不能保证所有语法分析动作的冲突都能被解决。

例：考虑文法(4-19)。它的项目集和goto函数为转换函数的DFA，串`E+T*`是(4-19)的活前缀。自动机读完`E+T*`之后。进入状态I7,状态I7包含下列项目:
```
T -> T *· F
F -> ·(E)
F -> ·id
```

##### SLR语法分析表

现在来说明怎样从识别活前缀的确定有穷自动机构造SLR语法分析表的动作(action)函数和转移(goto)函数。算法不能为所有的文法都产生唯一确定的分析动作表，但是可以成功地应用在许多程序设计语言的文法上。给定文法G,首先把G拓广到G',然后构造G',然后构造G'的规范项目集族C，最后使用下面的算法从C构造语法分析表的action函数和goto函数。

**算法4.8** SLR语法分析表的构造

```
输入：拓广文法G'
输出：G'的SLR语法分析表函数action和goto
方法：
1. 构造C = {I0,I1,...,In}
2. 从Ii构造状态i，它的分析动作确定如下：
a) 如果 [A->α·aβ]在Ii中，并且goto(Ii, a) = Ij,则置action[i,a]为“移动j进栈”，这里的a必须是终结符。
b) 如果 [A->α·]在Ii中，则对FOLLOW(A)中的所有a，置action[i, a]为“归约A->α”。这里的A不能是S'
c) 如果 [S''->S·]在Ii中，则置action[i,$]为“接受”
如果由上面的规则产生的动作有冲突，那么文法G就不是SLR(1)文法。在这种情况下，该算法构造不出G的语法分析器
3. 对所有的非终结符A，使用下面的规划构造状态i的goto函数；如果goto(Ii, A) = Ij,则goto[i, A] = j
4. 不能由规则(2)和规则(3)定义的表项都置为"出错"
5. 语法分析器的初始状态是从包含[S'->S]的项目集构造出的状态。

由算符4.8所确定的由action和goto函数组成的语法分析表叫做文法G的SLR(1)表。使用G的SLR(1)表的LR语法分析器。存在SLR(1)语法分析表的文法叫做SLR(1)文法。通常，省略SLR后面的(1)，因为不讨论向前看多个符号的分析器
```

例子：为文法(4-19)构造SLR表。它的规范LR(0)项目集族已在上图中给出，首先考虑项目集I0；
```
E' -> ·E
E -> ·E + T
E -> ·T
T -> ·T * F
T -> ·F
F -> ·(E)
F -> ·id
```

项目F->·(E)使得`action[0,(]`="移动4进栈"，项目`F->·id`使得`action[0,id]`=“移动5进栈”。I0中的其他项目不产生动作。现在考虑I1：
```
E' -> E·
E -> E·+T
```
第一项导致`action[1,$]`="接受"，第二项使得`action[1,+]`="移动5进栈"，I0中的其他项目不产生动作。现在考虑I1:
```
E' -> E·
E -> E·+T
```
第一个项导致`action[1,$]`="接受"，第二项使得`action[1,+]`="移动6进栈"。接下来考虑I2：
```
E -> T·
T -> T·*F
```
因为FOLLOW(E)={$,+,)},第一项使得`action[2,$]=action[2,+]=action[2,)]=`“归约E->T”，第二项使得`action[2,*]`="移动7进栈"。以这种方法继续下去即可得到图中的动作(action)表和转移(goto)表。归约动作中的产生式序号和它在原文法中出现的顺序是相同的，即`E->E+T`的序号是1,`E->T`的序号是2.

例：每个SLR(1)文法都不是二义的，但有很多非二义的文法不是SLR(1)文法。考虑其右下列产生式的文法:
```
S -> L = R
S -> R
L -> * R
L -> id
R -> L
文法(4-20)
```

可以把L和R想象成分别代表左值和右值，而*代表一个“取单元内容”的操作符。文法(4-20)的规范LR(0)项目集族。

考虑项目集I2。该集合的第一项使得`action[2, =]`为“移动6进栈”。因为FOLLOW(R)包含=（这里因为`S=>L=R=>*R=R`）,第二项使得`action[2,=]`为“归约R->L”。于是，`action[2,=]`有多重定义。因为其中既有移动进栈又有归约，所以状态2在输入符号为"="时存在移动-归约冲突。

文法(4-20)不是二义性的。移动-归约冲突的出现，说明SLR语法分析器的构造方法没有强制记住足够多的上下文，以决定在已经看见了可归约到L又面临=时，语法分析器应该采取什么动作。

但是，存在一些非二义文法，每种LR语法分析器构造方法都会为其产生包含冲突分析动作的语法分析动作表。程序设计语言中通常可以避免使用这样的文法。

#### 构造规范LR语法分析表

在SLR方法中，如果项目集Ii包含项目`[A->α·]`并且a在FOLLOW(A)中，则状态i调用`A->α`归约。然而，在某些情况下，当状态i出现在栈顶时，栈内的活前缀βα使得在任何右句型中，βA不能跟随a。因此，在这种情况下，用`A->α`进行归约时无效的。

可以令该状态蕴含更过的信息，使之能够剔除上述那些用A->α进行的无效归约。必要时，可以通过分裂状态，使LR语法分析器的每个状态能确切地支出句柄α后紧跟哪些终结符时才能把α归约为A。

通过重新定义项目，使之包含一个终结符作为第二个分量，可以把更多的信息并入状态中。项目的一般形式也就变成了`[A->α·β,a]`，其中`A->αβ`是产生式，a是终结符或$。这样的对象叫做LR(1)项目。1是第二个分量的长度，这个分量叫做项目的**搜索符**。**搜索符**对于β为非e的项目`[A->α·β,a]`没有影响。对于形如`[A->α·,a]`的项目，搜索符则表示只有下一个输入符号是a时该项目才能调用`A->α`归约。于是，只有`[A->α·,a]`是栈顶状态的LR(1)项目而且输入符号为a时，才能使用`A->α`进行归约。这样的a的集合总是FOLLOW(A)的一个子集，可能是真子集。

形式地，LR(1)项目`[A->α·β,a]`对话前缀γ有效，如果存在推导`S rm*-> δAw rm-> δαβw`,其中：

* 1. `γ=δα`
* 2. a是w的一个符号，或者w是e且a是$

规范构造有效的LR(1)项目集族的方法本质上和构造规范LR(0)项目集族的方法是一样的，只需要修改closure和goto两个过程。

为了理解closure运算的新定义，考虑对话前缀γ有效的项目集中的项目`[A->α·β,a]`,必定存在一个最右推导`S rm*-> δAax rm-> δaBβax`，其中`γ=δα`。假设`βax`能退出终结符串by，那么对每个形如`B->n`的产生式，存在推导`S *->rm γBby rm-> γnBy`，于是`[B->n，b]`对γ有效。注意，b可能是从β推出的一个终结符，或者在推导`βax *-> by`中，β推出e，b就成了a。总结这两种可能性，可以说b是FIRST(βax)中的任何终结符，其中FIRST的定义。注意，x不可能包含by的第一个终结符，所以FIRST(βax)=FIRST(βa)。

LR(1)项目集的构造算法：

**算法4.9** LR(1)项目的构造

```
输入：拓广文法G’
输出：LR(1)项目集，它们是对G'的一个或者多个活前缀有效的项目集
方法：构造项目集的过程closure和goto及主例程items

function closure(I);
begin
    repeat
        for I中的每个项目[A->α·Bβ,a],G'中的每个产生式B->γ和FIRST(βa)的每个终结符b，如果[B->·γ,b]不在I中do
            把[B->·γ,b]加入到I中；
    until 再没有项目可加到I中；
    return I
end

fuction goto(I,X)
begin
    对于I中的项目[A->α·Xβ,a],令J是项目[A->α·Xβ,a]的集合;
    return closure(J)
end

procedure items{G'};
begin
    C := {closure({[S' -> ·S, $]})};
    repeat 
        for C的每个项目I和每个文法符号X，若goto(I,X)
            非空且不在C中 do
                把goto(I,X)加入C中
    until 再没有项目集可以加入C中
end
```

首先计算`{[S'->S·,$]}`的闭包。为计算闭包，用项目`[S'->S·,$]`来匹配过程closure中的项目`[A->αB·β,a]`,即令`A=S'`,`α=e`,`B=S`,`β=e`,`a=$`.在函数closure中，要求对每个产生式`B->γ`只能是`S->CC`,而且因为`β=e`,`a=$`,`b`也只能是`$`,因此将`[S->·CC,$]`加入到闭包中。

接下来，对于FIRST(C$)中的b，将项目`[C->·γ,b]`加入闭包。也就是说，用项目`[S->·CC,$]`匹配项目`[A->αB·β,a]`,其中`A=S`,`a=e`,`B=C`,`β=C`,`a=$`。因为C不会推导出空串，所以FIRST(C$)=FIRST(C)。又因为FIRST(C)包含终结符c和d，所以将以下项目加入闭包：`[C->·cC,c]`,`[C->·cC,d]`,`[C->·d,c]`,`[C->·d,d]`

**算法4.10** 规范LR语法分析表的构造

```
输入：拓广文法G'
输出：文法G'的规范LR语法分析表action和goto
方法：
1. 构造G'的LR(1)项目集规范族C = {I0, I1, ..., In}
2. 从Ii构造语法分析器的状态i，状态i的分析动作确定如下：
a) 如果 [A->α·aβ,a]
b) 如果 [A->α·,a]在Ii中且goto(Ii,a)=Ij,则置action[i,a]为sj,即“移动j进栈”，这里要求a必须是终结符
c) 如果[S'->S·,$]在Ii中，则置action[i,$]=acc,表示接受。
如果用上面的规则构造语法分析表时出现冲突，那么该文法就是LR(1)的，该算法对此文法失败。
3. 状态i的转移按下面的方法确定：如果goto(Ii, A) = Ij,那么goto[i,A] = j
4. 用规则(2)和规则(3)中未能定义的所有表项都置为"出错"
5. 语法分析器的初始状态是由包含[S'->S,$]的项目集构造出的状态
```

由算符4.10产生的动作函数和转移函数所构成的表叫做规范LR(1)语法分析表，使用这种表的LR语法分析器叫做规范LR(1)分析器。如果动作函数没有多重定义的表项，那么这个文法叫做LR(1)文法。

#### 构造LALR语法分析表

LALR(lookahead-LR)技术。在实践中经常使用这种方法，因为由它产生的语法分析表比规范LR语法分析表要小得多，而大多数普通的程序设计语言的结构又都可以方便用LALR文法来表示。同样的结论对SLR文法几乎也是对的，但是有少数结构不能方便地用SLR技术进行处理。

就语法分析器的大小而言，SLR表和LALR表对同一个文法具有同样多的状态，而同样大小的语言的规范LR表则有几千个状态，所以构造SLR表和LALR表比构造规范LR表要经济的多。

考虑文法(4-21),取一对看起来类似的状态，如I4和I7，它们都只有一个项目，并且第一分量都是C->d,I4搜索符是c或d，I7中搜索符是$。

来看一下语法分析器中I4和I7的不同作用。注意，文法(4-21)产生的是正则集`c*dc*d`.当读入串`cc...cdcc..cd`时，语法分析器把第一组c及其后面的d移进栈中，进入状态4。如果下一个输入符号是c或d，语法分析器将按产生式`C->d`归约。要求c或d跟随是合乎情理的，因为它们属于串`c*d`的开始符号。如果跟在第一个d后的下一个输入符号`$`,例如，输入符号串`ccd`,因为该符号串不在此正则集内，因此分析器将报错(由状态4正确的指出错误)。

语法分析器在读入第二个d之后进入状态7。下一个输入符号必须是`$`，否则输入串就不是`c*dc*d`的形式。所以合理的做法是，面临`$`时状态7应按`C->d`归约，面临c或d时报告错误。

现在，让我们把状态I4和I7合并为I47，把它们的搜索符合起来，成为`[C->d·,c/d/$]`。从I0,I2,I3和I6到达I4或I7的在d上的转移现在都进入I47,状态I47的动作是对任何输入符号都进行归约。修改后的语法分析器的行为本质上和原来的一样，但它会把某些情况下的d归约成C，而原来的语法分析器对这些情况是报错的，如输入为ccd或cdcdc时。值得庆幸的是，这些错误最终会被捕获，而且是在移进下一个输入符号前被捕获。

更一般地讲，可以寻找同心的(即第一分量相同)LR(1)项目集，并把这些同心的项目集合并成一个项目集。一般而言，心是相应文法的一个LR(0)项目集；另外,LR(1)文法可能产生多个同心的项目集合。

因为goto(I,X)的心只依赖于I的心，所以LR(1)项目集合合并后的转移函数可以通过goto(I,X)自身的合并而得到，这样，在合并项目集时不必同时考虑修改转移函数的问题。动作函数应作相应修改，使得它能反映各个被合并集合的既定动作。

假设有一个LR(1)文法，即它的LR(1)项目集中不存在分析动作冲突。如果把通信的项目集合并为一，就可能导致冲突，但是这种冲突不会是移动-归约冲突。因为如果存在这种冲突。如果把同心的项目集合并为一，就可能导致冲突，但是这种冲突不会是移动-归约冲突。因为如果存在这种冲突，则意味着对当前输入符号a，有一个项目`[A->α·,a]`要求以`A->α`进行归约，同时又有另一个项目`[B->β·αγ,b]`要求把a移进。这两个项目既然同处于合并之后的项目集中，则意味着在合并前，必有某个c使得`[A->α·,a]`和`[B->β·αγ,c]`同处于合并前的某一集合中。然而，这又意味着原来的LR(1)项目集就已经存在着移动-归约冲突。从而文法不是LR(1)的，这与假设不符。事实上移动-归约冲突不依赖于搜索符号而只依赖于其心，因此，同心集的合并不会引起新的移动-归约冲突。

*注意：同心集的合并有可能产生新的归约-归约冲突。*

如下文法

```
S' -> S
S -> aAd | bBd | aBe | bAe
A -> c
B -> c
```

它只产生四个串：`acd`,`ace`,`bcd`和`bce`。通过构造该文法的LR(1)项目集，可以看出没有冲突，它是LR(1)文法。在它的项目集中，对活前缀`ac`有效的项目集为`{[A->c·,d],[B->c·,e]}`，对`bc`有效的项目集`{A->c·,e],[B->c·,d]}`,这两个集合都没有产生冲突且是同心的。然而，它们合并后
```
A -> c·, d/e
B -> c·, d/e
```
产生归约-归约冲突。因为当面临输入符号d或e时，不知道应该用哪个产生式进行归约。

**算法4.11** 一个简易但耗空间的LALR表构造法

```
输入：拓广文法G'
输出：G'的LALR语法分析表的action函数和goto函数
方法：
1. 构造文法的LR(1)项目集规范族C={I0,I1,...,In}
2. 对出现在LR(1)项目集中的每个心，找出所有与之同心的项目集，用它们的并集代替它们。
3. 令C'={J0,J1,...,Jm}是合并后的LR(1)项目集族。按照算法4.10中的方式从Ji来构造状态i的动作。如果分析动作出现冲突，算法无法产生分析表，说明该文法不是LALR(1)文法。 
4.goto表的构造如下：如果J是一个或多个LR(1)项目集的并，即J=I1∪I2∪...∪Ik,那么goto(I1,X),goto(I2,X),...,goto(Ik,X)也是同心，因为I1,I2,...,Ik都同心。记K为所有与goto(I1,X)同心的项目集的并，则goto(J,X)=K
```

由算法4.11产生的表称为G的LALR分析表。如果分析动作没有冲突，则该文法称为LALR(1)文法。在第(3)步构造的项目集族叫做LALR(1)项目集族。

当输入串为`c*dc*d`时，无论是哪种LR语法分析器，都给出了同样的移动归约序列。其差别只是状态名不同而已，即如果LR语法分析器把I3或I6压进栈，LALR语法分析器就把I36压进栈。对于正确的输入串，LR语法分析器和LALR语法分析器就非常相像。

但是，当输入串存在错误时，LALR语法分析器可能比LR语法分析器多做了一些不必要的归约，而LR语法分析器则能立即报错。但LALR语法分析器在LR语法分析器报错之后绝不会移进更多的符号。例如，若输入串是ccd并跟随以`$`时，LR语法分析器将把
```
0 c 3 c 3 d 4
```
压入栈，并在状态4发现错误，因为状态4面临$的动作是“出错”。对于同一输入串，LALR语法分析器将产生相应的动作，即把
```
0 c 36 c 36 d 47
```
压入栈，但状态47面临$的动作是归约C->d,栈的内容成为:
```
0 c 36 c 36 C 89
```
现在状态89面临$的动作是归约`C->cC`,这时栈的内容改为：
```
0 c 36 C 89
```
再经一次类似的归纳，获得的栈为：
```
0 C 2
```
最后，状态2面临$的动作是“出错”，语法分析器这时发现错误。

#### LALR语法分析表的有效构造方法

可以对算法4.11进行一些修改，以避免在创建LALR(1)语法分析表时包含全部的LR(1)项目集族，首先，注意到可以用项目集I的核来表示I，可以用初态项目`[S'->·S,$]`或那些圆点不在右部最左端的项目来表示I。

其次，只需要利用项目集I的核就能计算I所产生的动作。除非`a=e`,否则任何调用`A->α`进行归约的项目都在该核中。当且仅当存在核项目`[B->γ·Cδ,b]`,使得对某些η及FIRST(ηδb)中的a有`C rm*-> Aη`时，对输入a才可以用`A->e`进行归约。对每个非终结符C，满足`C rm*-> Aη`的所有非终结符A都可以预先计算出来。

由I产生的移进动作可以通过下列方法由I的核来确定。如果存在核项目`[B->γ·Cδ,b]`,其中`C *rm-> ax`,且这个推导的最后一步不使用e产生式，则可以将输入符号a移进。对于每个C，满足`C *rm-> ax`的所有终结符a也是可以预先计算出来的。

下面来看如何通过核来计算goto转换。如果`[B->γ·Xδ,b]`也在`goto(I,X)`的核中。如果`[B->γ·Cδ,b]`在I的核中，并且对于某个η有`C *rm-> Aη`,那么`[A->X·β,a]`也在`goto(I,X)`的核中。如果对每对非终结符C和A都能预先确定对某个η而言是否有关系`C *rm-> Aη`,那么，从核计算项目集这一工作仅比从闭包计算项目集的工作在效率上稍差一点而已。

为了计算拓广文法G'的LALR(1)项目集，先从初态项目集I0的核S'->S开始，然后，按上述方法计算出从I0出发的转移转换的核。继续计算出每一个新生成的核转移转换直到拥有全部LR(0)项目集的核为止。

例子：考虑下面的拓广文法：

```
S' -> S
S -> L = R | R
L -> * R | id
R -> L
```
该文法的LR(0)项目集的核如下式所示：
```
I0: S' -> S
I1: S' -> S
I2: S -> L· = R
    R -> L·
I3: S -> R·
I4: L -> *·R
I5: L -> id·
I6: S -> L =·R
I7: L -> *R·
I8: R -> L·
I9: S -> L=R·
文法(4-20)的LR(0)的项目集的核
```
现在为LR(0)项目集的核的每一个项目都配上适当的搜索符(第二个分量)。为了了解搜索符是如何从一个项目集I传播到`goto(I,X)`

假设计算的LR(1)项目而不是LR(0)项目，并且`[B->γ·Cδ,b]`属于I，那么对于哪些a的值，`[A->X·β,a]`将在`goto(I,X)`中呢？当然，如果a属于`FIRST(ηδ)`，那么由推导`C *->rm Aη`可知`[A->X·β,a]`一定在goto(I,X)之中。在这种情况下，b的值是无关的，称a(作为A->X·β的一个搜索符)是自生的。由此定义可知，作为初态项目集中的项目`S'->·S`的一个搜索符，$是自生的。

但是项目`A->X·β`的搜索符的产生还有另一种途径。如果`ηδ *-> e`,那么`[A->X·β,b]`也将在`goto(I,X)`中，这时称搜索符从`B->γ·Cδ`传播到`A->X·β`。下面的算法用来确定上述两种方式所产生的搜索符。

**算法4.12** 确定搜索符

```
输入：一个LR(0)项目集I的核K和一个文法符号X。
输出：对于`goto(I,X)`中的核项目，由I中的项目自生的搜索符，以及对于I中的项目，搜索符从这些项目将会传播到goto(I,X)中核项目中。
方法：算法如下所示，使用一个哑搜索符#来检测出超前扫描符号传播的情形。

for K中每一项B -> γ·δ do begin
    J := closure({[B -> γ·δ, #]});
    if [A -> αX·β,a]∈J' 其中a不是# then
        对于goto(I,X)中的核项目A -> aX·β,搜索符a是自生的；
    if [A -> αX·β,#]∈J' then
        搜索符从I中的B -> γ·δ传播到goto(I,X)中的A->αX·β
end
```

现在来考虑如何找到与LR(0)项目集的核中的每个项目相关的搜索符。$是LR(0)初态项目集的项目`S'->·S`的搜索符,用算法4.12可以为每个核的所有项目列出其全部自生搜索符。然后，让这些自生搜索符进行传播，直到不能再传播为止。有许多不同的传播方法，这些方法在某种意义上记录已经传播到一个项目的“新”搜索符，但这些“新”的搜索符没有再继续传播出去，下面的算法描述了一种将搜索符传播到全部项目的技术。

**算法4.13** 计算LALR(1)项目集族的核。

```
输入：拓广文法G'
输出：文法G'的LALR(1)项目集族的核
方法：
1. 利用上述方法，构造G的LR(0)项目集的核
2. 对每个LR(0)项目集的核和文法符号X应用算法4.12，确定出哪些搜索符对于goto(I,X)中的核项目是自生的，并确定出从哪些I中的项目出发搜索符可以传播到在goto(I,X)中的核项目中
3. 对于每个项目集的每个核项目，初始化一个表，使之给出与之相联系的各个搜索符。开始时，与每一个项目相联系的搜索符仅是那些在(2)中确定的自生搜索符
4. 反复遍历所有集合中的核项目。当访问一个项目i时，利用(2)中所建立的信息来查看i能将它的搜索符传播到哪些核项目。把i的当前搜索符集合附加到已经与i相关联的各个项目中去，即附加到i已将其搜索符传播到达的那些项目中去。继续遍历核项目，直到没有新的搜索符被传播为止。
```

例：下面为上例中的文法构造LALR(1)项目集的核，该文法的LR(0)项目集的核是文法(4-20)的LR(0)的项目集的核时，计算`{[S'->·S,#]}`的闭包，结果是：
```
S' -> ·S, #
S -> ·L = R, #
S -> ·R, #
L -> ·*R, #/=
L -> ·id, #/=
R -> ·L, # 
```
在该闭包中有两项可导致搜索符的自生，项目`[L->·*R, =]`使得`=`是I4中的核项目`L->*·R`的自生搜索符，而项目`[L->id, =]`使得`=`是I5中的核项目`L->id·`的自生搜索符。

标有“初始”的每一列给出了每个核项目的自主搜索符。在第1遍，搜索符$有I0的S'->·S传播列出的6个项目。搜索符由I4中的L->*R·和I8中的R->L·。但这些搜索符已经出现过了。在2遍和第3遍，仅有的可被传播的新搜索是$，这是在第2遍的I2和I4的后继和第3遍的I6的后续中发现的。在第4遍就没有新的搜索符可传播了，所以搜索符的最后集合最右一列所示。

*注意：利用SLR方法所出现的移动-归约冲突在这里运用LALR技术时已经不存在了，原因是只有搜索符$与I2中的S->L·相关，所以，对I2中的项目S->L·=R产生的=执行移进时不会产生冲突*

#### LR语法分析表的压缩

一个典型程序设计语言的文法有50-100个终结符和100个产生式，它的LALR语法分析表可能有几百个状态，它的action函数或许有20000个输入项，每项至少需要8位进行编码。显然，寻找一种比二维数组更有效的编码非常重要，简要介绍几种用于压缩LR语法分析表的action域和goto域的技术。

压缩action域的一种有用技术是基于这样一点，即action表中经常有许多行是相同的。状态0和状态3就具有相同的action表项，状态2和6也是，于是就能节省很大的空间，时间开销也很少。如果对每个状态建立一个指向一维数组的指针，则相同表项的指针指向同一个位置。为存取这个数组的信息，给每个终结符分配一个从0到终结符总数减1的整数，并把这个数作为对于每个状态的指针值的偏移量。给定一个状态，第i个终结符的分析动作保存在那个状态指针值下的第i个位置上。

为每个状态的动作创建一个列表可进一步提高空间的利用效率，但要以轻微降低语法分析器的速度为代价。列表由(终结符，动作)对组成。频繁发生的动作放在列表的尾部，并可用符号`any`代替一个终结符。这意味着如果当前输入符号没有在列表中发现，则不管输入是什么都将执行这个动作。此外，对一行上的错误表项可用归约动作安全取代。以后在移进之前，错误将会被检测到。

例子：考虑上述的语法分析表，首先注意到状态0，4，6和7的动作相同，因此可以用如下列表描述它们：
```
符号   动作
id     s5
(      s4
any   error
```
状态1也有一个类似的列表：
```
符号   动作
+      s6
$      acc
any    error
```
在状态2，可以用r2替代error(错误)表项，故对任一除*以外的输入，都将用产生2进行归约，所以状态2的列表是：
```
符号   动作
*      s7
any    r2
```
状态3只有error表项和r4，可以用后者代替前者，所以状态3的列表仅由(any,r4)组成，状态5，10，11可以类似地进行处理。状态8的列表是：
```
符号   动作
+      s6
)      s11
any    error
```
而状态9的列表为：
```
符号   动作
*      s7
any    r1
```
通过列表也可以对goto表进行编码，但在此为每个非终结符A构造序对列表看起来效率更高。A的列表中序对的格式为(current_state,next_state),含义为：
```
goto[current_state,A] = next_state
```
因为goto表的任一列只有很少的状态，所以这个方法很有用。原因是非终结符A的goto项只能从这样的项目集导出的状态，在这些项目集的项中，A在点的左边。如果`X!=Y`,则点左边为X和Y的项不会出现在同一个项目集中。因此每个状态最多出现在一个goto列中。要进一步节省空间，注意到在goto表中的错误表项从来没有被考虑过，因而，可以用最常用的非错误表项替换这些错误表项，使该常用表项称为默认值，并把当前的状态替换为`any`.

例子：F列对应状态7的表项为10，其他表项或者是3，或者是error。可以用3替换error表项从而为F列创建如下列表：
```
current_state     next_state
7                 10
any               3
```
同样，T列相应的列表为：
```
current_state   next_state
6               9
any             2
```

对E列可以选择1或8作为默认值，不管哪种情况都需要两个表项。例如，可以为E列创建下述列表:
```
current_state    next_state
4                8
any              1
```

*对有穷自动机的表压缩方法也可以用于LR语法分析表*

### 二义文法的应用

任何二义文法都不是LR文法，因而不属于前一节所讨论的任何一类文法，这是一条定理。但是，正如在本节将要看到的，某些二义文法对语言的说明和实现非常有用。对于像表达式这样的语言结构，二义文法比任何等价的非二义文法提供的说明都要更短、更自然。另外，为了便于对一些特例语法结构进行优化，需要将它们从一般语法结构中分离出来。通过使用二义文法，往文法中增加新的产生式，就能标识这些特例结构，这是二义文法的另一种应用。

虽然使用的文法是二义性的，但在所有情况下都说明了消除二义的规则，以保证对每个句子只有一棵分析树。这样，整个语言的说明仍然是二义性的。另外，应该慎用二义结构，并在严格控制的方式下使用。否则不能保证语法分析器将识别什么样的语言。

#### 使用优先级和结合规则来解决分析动作的冲突

考虑程序设计语言中的表达式。下面包含操作符`+`和`*`的算术表达式文法是二义的，因为它没有指出操作符`+`和`*`的结合规则和优先级：

```
E -> E + E | E * E | (E) | id
```
下面的无二义文法产生同样的语言，但赋予了`+`一个比`*`低的优先级，并且两个操作符都是左结合的。
```
E -> E + T | T
T -> T * F | F
F -> (E) | id
```
正如将要看到的那样，可以方便地改变操作符`+`和`*`的结合规则及优先级而无需修改文法中的产生式及结果及结果与语法分析器中的状态数。其次，文法的语法分析器要花一部分时间来完成产生式E->T和T->F的归约，它们的作用只是突出结合规则和优先级。文法的语法分析器不会将时间消耗在归约这样的单产生式(右部只有一个非终结符的产生)上。

用`E->E'`拓广后的文法的LR(0)项目集，因为文法是二义的，如果试图从这些项目集生成LR语法分析表，语法分析动作会有冲突。与项目集I7和I8对应的状态会产生这些冲突。假设我们用SLR方法来构造分析动作表，I7产生的归约E->`E+E`与面临`+`和`*`进行移进之间的冲突不能解决，因为`+`和`*`都在FOLLOW(E)中；令一个由I8产生的冲突在归约`E->E*E`与面临`+`和`*`进行移进之间。事实上，用任何一种LR语法分析表的构造方法都会产生这些冲突。

但是,这些问题可以用`+`和`*`的优先级和结合信息来解决。考虑输入`id=id*id`，它使得形成如下格局:
```
栈              输入
0 E 1 + 4 E 7  * id $
```

如果`*`的优先级高于`+`,语法分析器应该把*移进栈，准备将`*`和它两边的id归约成一个表达式。这正是识别相同语言的SLR语法分析器要做的。另一方面，如果`+`的优先级高于`*`，语法分析器应该将`E+E`归约成E。这样，根据`+`和`*`的相关优先级就可以解决状态7中用`E->E+E`归约和面临`*`进行移进之间的冲突。

如果输入是`id+id+id`的话，语法分析器处理完`id+id`后仍将到达栈内容为`0e1+4E7`的格局。在状态7面临`+`时仍有移动`-`归约冲突，现在是由操作符`+`的结合规则来决定应如何解决冲突。如果`+`是左结合的，正确的动作是用`E->E+E`归约，即第一个+前后的id应看成一组。

总之，假如`+`是左结合的，在状态7面临`+`时应该用`E->E+E`归约；如果`*`的优先级高于`+`,在状态7面临`*`时应该移进。可以类似地讨论状态8，最后得出如下结果：如果*是左结合的且优先级高于`+`,那么不论面临`+`还是面临`*`，语法分析器在状态8的动作都是用`E->E*E`进行归约。原因是面临`+`时,`*`的优先级高于`+`,面临`*`时，`*`是左结合的。

#### 悬空的else二义性

考虑下面的条件语句文法：
```
stmt -> if expr then stmt else stmt
    | if expr then stmt
    | other
```
这个文法是二义的，因为它没有解决悬空else的二义性。为了简化讨论，考虑上述文法的抽象,用i代表`if expr then`，用e代表else，并用a代表所有其他产生式，然后加上拓广的产生式`S'->S`,重写文法如下:
```
S'->S
S->iSeS | iS | a
文法 (4-24)
```

当`if expr then stmt`在栈顶并且else是第一个输入符号时，究竟是移进else(移进e)还是将`if expr then stmt`归约成`stmt`(按S->iS归约)呢？答案是移进else。因为它要和前面一个then配对。用文法(4-24)的术语，输入为e(代表else)时，智能让它成为以栈顶的iS开始的右部的一部分。如果e后面的输入不能分析成S而形成右部iSeS，那么，分析将无法继续。

结论：要解决I4中的移动归约冲突，应该首先移进e。按照这个解决办法，由图4-84的项目集构造的SLR语法分析表。产生式1~3分别是`S->iSeS`,`S->iS`和`S->a`。

例如，若输入是`iiaea`,它正确地解决了悬空else问题，面临e时，状态4选择移进；面临$时，状态4按`S->iS`进行归约。

#### 特例产生式引起的二义性

二义文法最后一个用途：即引入一个额外的产生式来标识语法结构的特例，这比用其余的产生式来标识更自然一些，但如果加入这个额外的产生式就会引起分析动作的冲突。这种冲突的解决需要消除二义性规则，这个规则指出，如果出现归约-归约冲突，按特例产生式归约。这样，和特例产生式相联的语义动作允许用更专门的措施来处理这些特例。

#### LR语法分析中的错误恢复

LR语法分析器在访问动作表时若遇到出错表项，就检测出一个错误，但它在访问转移表时决不会检测出出错。与算符优先语法分析器不同的是，LR语法分析器只要发现已扫描的输入出现一个不正确的后继就会立即报告错误。规范LR语法分析器在报告错误之前不会进行任何无效归约。SLR语法分析器和LALR语法分析器在报告错误前可能执行几步归约，但它们绝不会把出错点的输入符号移进栈。

在LR分析中，可以采用下面的方法实现紧急方式的错误恢复：从栈顶开始退栈，直至发现在特定非终结符A上具有转移的状态s为止；然后丢弃零个或多个输入符号，直至找到符号a为止，它是A的合法后随符号；接着，语法分析器把状态`goto[s, A]`压进栈，并恢复正常分析。A的选择可能不唯一，一般A应是代表主要程序结构的非终结符，如表达式、语句或程序块。例如，若A是非终结符stmt,那么a可以是分号或end。

这种恢复方法实质是试图将含有语法错误的短语分离出来。语法分析器认为由A推导出的串含有一个错误，该串的一部分已经处理过，处理的结果是处于栈顶的状态序列，该串的剩余部分仍在输入中。语法分析器试图跳过该串的剩余部分，在输入中找到一个符号，它是A的合法后随符号。通过从栈中移出一些状态，跳过若干输入符号，并把`goto[s, A]`推进栈，语法分析器加装已发现了A的一个实例，并恢复正常分析。

短语级恢复的实现是通过检查LR分析表的每个出错表项，并根据语言的使用情况确定最可能引起该错误的最容易犯的错误，然后为该表项编一个适当的错误恢复例程。该例程大概会采用一种适合于相应出错表项的方式来修改栈顶符号和(或)第一个输入符号。

与算符优先语法分析器相比，设计LR语法分析器的专门错误处理例程要容易一些。尤其是，不必担心不正确的归约，LR语法分析器所执行的归约保证是正确的。于是，可以在语法分析表动作域的每个空白项上填上一个指针，它指向编译器设计者为之设计的出错处理例程。该例程的动作可能包括从栈顶和(或)输入中插入或删除符号，改变或变换输入符号，就像算符优先语法分析器那样，所做的选择不应使LR语法分析器陷入死循环。保证至少有一个输入符号被移走或最终被移进，或者保证在到达输入的末尾时保证栈最终会缩短，这样的策略足以防止上述问题的发生。要避免从栈中弹出覆盖一个非终结符的状态，因为这种修改从栈中删除掉了已经成功分析的一个结构。

### 语法分析器的生成器

#### 语法分析器的生成器Yacc

一个翻译器可用Yacc的方式构造出来。首先，准备一个包含翻译器的Yacc说明的文件，如`translate.y`。UNIX系统的命令
```cmd
yacc translate.y
```
把文件translate.y翻译成名为y.tab.c的C程序，使用的是算法4.13中描述的LALR方法。程序y.tab.c中包含用C语言编写的LALR语法分析器和其他用户准备的C语言例程。为节省空间，用之前的方法对LALR语法分析表进行了压缩.命令
```cmd
cc y.tab.c -ly
```
对y.tab.c进行编译，其中，ly表示使用LR分析程序的库。编译后得到目标程序a.out，它完成Yacc源程序指定的翻译。如果需要其他过程，它们可以和y.tab.c一起编译或装入，就像使用普通的C程序一样。

Yacc源程序由3部分组成:
```y
声明
%% 
翻译规则
%%
用C语言编写的支持例程
```

例子：构造一个简单的台式计算器，读入一个算术表达式，计算并打印它的值。计算器的算术表达式文法:
```
E -> E + T | T
T -> T * F | F
F -> (E) | digit
```
记号digit是0~9的单个数字。由该文法得到的Yacc台式计算器程序如下式所示：
```y
%{
#include <ctype.h>
%}

% token DIGIT

%%
line  :  expr  '\n'  {printf("%d\n", $1); }
      ;  
expr  :  expr  '+'  term { $$ = $1 + $3; }
      :  term
      ;
term  :  term  '+'  factor  { $$ = $1 + $3; }
      :  factor
      ;
%% 
yylex() {
    int c;
    c = getchar();
    if (isdigit(c)) {
        yylval = c - '0';
        return DIGIT;
    }
    return c;
}
```
* **(1) 声明部分**-Yacc程序的声明部分由可任选的两节组成。第一节处于分界符%{和%}之间，它是一些普通的C语言声明。第二部分和第三部分的翻译规则或过程所使用的所有临时声明都放在这里。
```y
#include <ctype.h>
```
它使得C的预处理程序包含标准头文件`<ctype.h>`,该文件含有谓词`isdigit`。声明部分的第二节是文法记号的声明，语句：

```y
%token DIGIT
```

* **(2) 翻译规则部分**-这一部分位于第一个%%后面，用于放置翻译规则，每条规则由一个文法产生式和有关的语义动作组成。产生式集合:
```
<left side> -> <alt 1> | <alt 2> | ... | <alt n>
```
在Yacc中写成:
``` 
<left side>  :  <alt 1>  ;语义动作1}
             :  <alt 2>  ;语义动作2}
             ...
             :  <alt n>  ;语义动作n}
             ;
```
在Yacc产生式中，单引号括起来的字符`c`是由终结符号c组成的记号；没有引号的字母数字串若没有声明为记号，则是非终结符。右部的各个选择之间用竖线隔开，最后一个右部的后面用分号，表示该产生式集合的结束。第一个左部非终结符是开始符号。

Yacc的语义动作是C语句序列。在语义动作中，符号`$$`表示左部非终结符的属性值，而`$i`表示右部第i个文法符号(终结符或非终结符)的值。每当归约一个产生式时，就执行与之相关联的语义动作，所以语义动作一般是根据`$i`的值计算`$$`的值。在这个Yacc说明中，两个E产生式.
```
E -> E + T | T
```
及与它们有关的语义动作写成:
```
expr  :  expr  '+'  term  { $$ = $1 + $3; }
      :  term
      ;
```

注意：第一个产生式的非终结符term是右部的第三个文法符号，`+`是第二个文法符号。第一个产生式的语义动作把右部的expr和term的值相加，把结果赋给左部的非终结符expr作为它的值。省略了第二个产生式的语义动作，因为右部只有一个文法符号时，值的复写是默认的语义动作，即它的语义动作是 { $$ = $1; }

注意，将一个新的开始产生式:
```
line  :  expr '\n'  {printf("%d\n", $1); }
```
加到了这个Yacc说明中。该产生式的意思是，这个台式计算器的输入是一个表达式后面跟一个换行字符，它的语义动作是打印表达式的十进制值并且换行。

* **(3) 支持例程部分**-Yacc说明的第三部分是一些用C语言编写的支持例程。必须提供名字为`yylex()`的词法分析器。其他的过程，如错误恢复例程，如果需要的话，也可以加上。

词法分析器`yylex()`返回二元组(记号，属性值)。返回的记号，如`DIGIT`，必须在Yacc说明的第一部分声明。属性值必须通过Yacc定义的变量yylval传给语法分析器。

#### 用Yacc处理二义文法

改进上一节的Yacc说明。首先，允许台式计算器计算表达式序列，每行一个，还允许表达式之间有空白行。为做到这一点，将第一条规则改为：
```
lines  :  lines  expr  '\n'  {printf("%g\n", $2);}
    :   lines  '\n'
    :
    ;
```

其次，扩大表达式的类，使之包含由多个数字组成的数字，包括操作符`+`，`-`(一元和二元)，`*`，`/`。说明这类表达式的最简单的方法是使用下面的二义文法：
```
E -> E + E | E - E | E * E | E / E | (E) | -E | number
```
LALR算法将产生语法分析动作冲突。Yacc会报告产生的语法分析动作冲突的数目。
项目集合语法分析动作冲突的描述可以通过在调用Yacc时加-v选项来获得。该选项
产生一个附加的文件`y.output`,它包含语法分析时发现的项目集的核、由LALR算法
产生的语法分析动作冲突的描述以及LR语法分析表的可读表示，该可读表示显示出语法
分析动作冲突是怎样解决的。当Yacc报告它发现语法分析动作冲突时，明智的做法
是建立和查阅文法`y.output`,以了解为什么出现分析动作冲突以及它们是否
已经被正确解决。

* 1. 归约-归约冲突的解决是从冲突产生式中选择在Yacc说明中最先出现的那个产生式。因此，只要把产生式放在产生式前面就足够了。
* 2. 移动-归约冲突的解决是移进优先。这条规则正确地解决了悬空else二义所带来的移动-归约冲突

更高级的台式计算器的Yacc说明
```
%{
#include <ctype.h>
#include <stdio.h>
#define YYSTYPE double
%}

%token NUMBER
%left '+' '-'
%left '*' '/'
%right UMINUS

%%
lines   :   lines  expr  '\n'   {printf("%g\n", 2$); }
    : lines '\n'
    : /* e */
    ;
expr    :   expr  '+'  expr  { $$ = $1 + $3; }
        :   expr  '+'  expr  { $$ = $1 - $3; }
        :   expr  '+'  expr  { $$ = $1 * $3; }
        :   expr  '+'  expr  { $$ = $1 / $3; }
        :   '('  expr  ')'   { $$ = $2;  }
        :   '-'  expr  %prec UMINUS  { $$ = - $2; }
        :   NUMBER
        ;
%%
yylex() {
    int c;
    while ( (c = getchar()) == '' );
    if ( (c == '.') || (isdigit(c)) ) {
        ungetc(c, stdin);
        scanf("%1f", &yylval);
        return NUMBER;
    } 
    return c;
}
```

Yacc提供了解决移动-归约冲突的一般方法。在声明部分，可以为终结符指定优先级和结合规则。声明:
```
%left '+'  '-'
```
使得`+`和`-`具有同样的优先级和左结合规则。声明：
```
%right '^'
```
使得操作符`^`为右结合的。还可以用声明限制二元操作符为不可结合的(即该操作符的两个相邻出现根本不能组合)，如
```
%nonassoc  '<'
```
记号的优先级按它们在声明部分出现的次序来确定，先出现的记号的优先级低，同一声明中的记号有相同的优先级。
```
%right UMINUS
```
使得`UNIMUS`的优先级高于前面5个终结符。

Yacc通过为与冲突有关的每个产生式赋予优先级和结合规则来解决移动-归约冲突。如果Yacc必须在移进输入符号a和按产生式`A->α`归约这两个动作之间进行选择，那么，当这个产生式的优先级高于a，或者优先级相同但产生式是左结合的时，执行归约动作，否则选择移进。

通常，产生式的优先级和它最右边的终结符号的优先级一致。给定产生式
```
E -> E + E | E * E
```
若搜索符是`+`,归约产生式是`E->E+E`,那么归约优先，因为右部的+和搜索符具有同样的优先级，而+是左结合的；但如果搜索符是`*`,那么选择移进，因为搜索符的优先级高于这个产生式中+的优先级。

如果最右终结符不能给产生式以适当的优先级，可以通过给产生式附加标记
```
%prec <terminal>
```
来强制它的优先级，它的优先级，它的优先级和结合规则同这个标记的终结符一样。该终结符大概需在声明部分定义。Yacc不会报告用优先级和结合规则解决了的移动-归约冲突。

该终结符可以是一个占位符，如`UMINUS`那样，它不由词法分析器返回，只是用来决定一个产生式的优先级。声明:
```
%right UMINUS
```
给记号`UMINUS`指定高于`*`和`/`的优先级。在翻译规则部分，标记
```
%prec UNIMUS
```
出现在产生式
```
expr    :  '-'  expr
```
的后面，这使得该产生式中的一元减操作符的优先级高于其他任何操作符

#### 用Lex建立Yacc的词法分析器

Lex产生的词法分析器可以用于Yacc。Lex库将提供名为`yylex()`的驱动程序，这个名字就是Yacc所需要的词法分析器的名字。如果用Lex产生词法分析器，那么Yacc说明中的第三部分的例程`yylex()`应由语句
```c
#incldue "lex.yy.c"
```
来代替。使用这条语句，程序`yylex()`可以访问Yacc中记号的名字，因为Lex的输出文件是作为Yacc输出文件的一部分被编译的，所以每个Lex动作都返回Yacc知道的终结符。

在UNIX系统中，如果Lex说明在文件`first.l`中，Yacc说明在`second.y`中，可以用命令
```
lex first.l
yacc second.y
cc y.tab.c -ly -ll
```
来获得所需的编译器。最后一个模式`\n|`，因为在Lex中匹配除换行以外任何字符。

#### Yacc的错误恢复

在Yacc中，可以通过使用出错产生式的形式进行错误恢复。首先，用用户决定哪些“主要的”非终结符会与错误恢复有关，典型的选择是用于产生表达式、语句、程序块和过程的那些非终结符。然后用户把形如`A->error α`的出错产生式加到文法中，其中A是主要非终结符，α是文法符号串，也可能是空串，error是Yacc保留字。Yacc将从这样的说明产生语法分析器，并把出错产生式当做普通产生式来处理。

但是，当Yacc产生的语法分析器遇到错误时，会用一种特定的方式来处理项目集中含有出错产生式的状态。遇到错误时，Yacc从栈中弹出状态，直到发现一个能恢复正常处理的输入符号为止。

如果α为e时，立即归约为A并执行产生式`A->error`的语义动作(可能是用户说明的错误恢复例程)，然后语法分析器丢弃若干输入符号，直到发现一个能恢复正常处理的输入符号为止。

如果α非空，Yacc在输入串上向前寻找能够归约为α的子串。如果α包含的都是终结符，那么它在输入上寻找这样的终结符串，并把它们移进栈，这时，语法分析器的栈顶为error α，语法分析器把error α归约成A，并恢复正常语法分析。

例如，出错产生式
```
stmt -> error;
```
要求衣服啊分析器看见错误时跳过下一个分号，好像该语句已经被看完一样。这个出错产生式的语义例程不需要处理输入，只需产生诊断信息并设置禁止生成目标代码的标记。

例子：带有下列出错产生式的Yacc台式计算器：
```
lines :  error  '\n'
```
当输入行有语法错误时，语法分析器从栈中弹出符号，直至碰到一个含有移进记号error动作的状态为止。该例中，状态0是唯一的这种状态，因为它的项目包含：
```
lines -> ·error '\n'
```
而且状态0总是在栈顶。语法分析器把记号error移进栈，并跳过输入符号，直至发现换行符为止。这时语法分析器把换行符移进栈，把error '\n'归约成lines，输出诊断信息“reenter last line：”。专门的Yacc例程yyerrok用于将语法分析器恢复正常操作模式。

## 第五章：语法制导翻译

主要研究上下文无关文法所产生的语言的翻译。通过把属性附加到代表语法结构的文法符号上，可以将语义信息和程序设计语言的结构联系起来。属性的值是用与文法产生式相关联的"语义规则"来计算的。

把语义规则同产生式联系起来要涉及两个概念，即**语法制导定义**和**翻译模式(translation scheme)**。语法制导定义是关于语言翻译的高层次规格说明，它隐蔽了许多具体实现细节，使用户不必显式地说明翻译发生的顺序。翻译模式则指明了语义规则的计算顺序，以便说明某些实现细节。

从概念上讲，不论是语法制导定义还是翻译模式，都要首先对输入符号串进行语法分析，建立分析树，然后根据需要遍历分析树，并在分析树的节点处计算语义规则。语义规则的计算可以生成代码、在符号表中保存信息、发出错误信息或完成其他活动。这样，对输入符号串的翻译过程就是对语义规则求值的过程。

```
输入符号串->分析树->依赖图->语义规则的计算顺序
```

在某些情况下，语法制导定义可以在单遍扫描中实现，即在语法分析期间计算语义规则，而不用显式地构造分析树或属性间的依赖图。因为单遍扫描的实现方式对提高编译的效率非常重要，所以本章主要致力于研究这种情况。有一个重要的子类称为“L-属性”定义，实际上它包含了所有不必显式构造分析树即可完成的翻译。

#### 语法制导定义(Syntax-Directed Definition, SDD)

语法制导定义是对上下文无法文法的推广，其中每个文法符号都有一个相关的属性集。属性分为两个子集，分别称为该文法符号的综合属性和继承属性。如果把分析树中对应该文法符号的节点看成是一条记录，其中包含若干存储信息的域，那么属性就相当于一个域的名字。

属性可以代表任何对象：字符串、数字、类型、内存单元或其他对象。分析树节点上属性的值由该节点所用产生式的语义规则来定义。节点的综合属性值是通过分析树中其子节点的属性值计算出来的。

语义规则建立了属性间的依赖关系，可以用图来表示。从依赖图中可以得到语义规则的计算顺序。语义规则的计算定义了输入符号串在分析树节点上的属性值。语义规则还可能具有副作用，如打印一个值或修改全局变量等。当然，具体实现时可能不必显式地构造分析树或依赖图，只需对每个输入串产生相同的输出即可。

将每个节点都带有属性值的分析树称为注释分析树，而计算节点属性值的过程则称为注释或装饰分析树。

#### 语法制导定义的形式

在语法制导定义中，每个产生式`A->α`都有一个形如`b:=f(c1,c2,...,ck)`的语义规则集合与之相关联，其中f是函数，并且满足下面两种情况之一：

* 1. b是A的一个综合属性，且c1,c2,...,ck是该产生式文法符号的属性；
* 2. b是产生式右部某个文法符号的一个继承属性，且c1,c2,...,ck也是该产生式文法符号的属性。

对这两种情况都称为属性b依赖于属性c1,c2,...,ck.。**属性文法**是一个语法制导定义，其中语义规则中的函数不能有副作用。

语义规则中的函数通常被写成表达式的形式。有时，语法制导定义中某个规则的目的就是为了产生幅作用。这种语义规则一般被写成过程调用或程序段。在这种情况下，可以把它看作是定义产生式左部非终结符的虚综合属性值，但这种语义规则中的虚属性和符号`:=`都不给出来。

例5.1 下述是一个台式计算器程序的语法制导定义。该定义将一个整数值综合属性val与每个非终结符E,T和F联系起来。对每个以E,T和F联系起来。对每个以E,T和F为左部的产生式，语义规则从产生式右部非终结符的val值计算出产生式左部非终结符的val值。

记号`digit`具有综合属性lexval，其值由词法分析器提供，而产生式L->En（其中L是文法开始符号）所对应的语义规则只是一个打印E所产生的算术表达式的值的过程，可以认为该规则为非终结符L定义了一个虚属性

在语法制导定义中，假设终结符只具有综合属性，因为定义没有为终结符提供任何语义规则。终结符的属性值通常由词法分析器提供。此外，假设开始符号不具有任何继承属性，除非另有说明。

#### 综合属性

综合属性在实践中具有广泛的应用。将仅仅使用综合属性的语法制导定义称为**S属性定义**。在S属性定义的分析树中，可以自底向上地在每个节点用语义规则来计算综合属性值，即从叶节点到根节点进行计算。

S属性定义详细说明了一个台式计算器，它读入包含数字、括号、运算符`+`和`*`的算术表达式(表达式后面跟有换行符n)，并打印表达式的值。例如，输入表达式`3*5+4`，后跟一个换行符n,该程序将打印出值19。下面是输入`3*5+4n`的注释分析树，树根结点输出的是第一个子节点的E.val值。

为弄清楚属性值是如何计算的，先考虑最左边最底层的内部节点，它所对应的产生式是`F->digit`。相应的语义规则为`F.val := digit.lexval`。因为其子节点的digit.lexval值是3，所以该节点的属性F.val的值也为3。同样地，F节点的父节点的属性T.val的值也为3。

现在考虑产生式`T->T * F`所对应的节点，其属性值T.val的值由产生式`T->T1 * F`的语义规则T.val := T1.val * F.val来定义。对此节点应用语义规则：从左子节点可以得到T1.val的值为3，从右子节点可以得到F.val的值为5，故求得在这一节点T.val的值为15。

与产生式`L->En`相关联的语义规则打印由E生成的表达式的值。

#### 继承属性

在分析树中，一个节点的继承属性值是由该节点的父节点和(或)兄弟节点的属性决定的。用继承属性来表示程序设计语言上下文结构的依赖性是很方便的。例如，可以使用继承属性来跟踪一个标识符，看它是出现在赋值号的左边还是右边来确定是需要它的地址还是它的值。虽然总是可以只用综合属性来改写语法制导定义，但是使用带有继承属性的语法制导定义会更为自然。

例：在下表所示的语法制导定义中，非终结符D所产生的声明由关键字`int`或`real`后跟一个标识符表所组成的。非终结符T有一个综合属性type，其值由声明中的关键字来确定。与产生式`D->TL`相关联的语义规则`L.in := T.type`用来将继承属性`L.in`置为
所声明的类型。语义规则适用继承属性`L.in`把该类型信息沿分析树向下传递。与L产生相关联的语义规则调用过程addtype，该过程将各标识符的类型填加到符号表的相应表项中(由属性entry指向)

产生式|语义规则
-|-
D -> T L | L.in := T.type
T -> Int | T.type := integer
T -> real | T.type := real
L -> L1, id | L1.in := L.in   addtype(id.entry, L.in)
L -> id | addtype(id.entry, L.in)

下面给出了语句real id1,id2,id3的**注释分析树**。3个L节点的L.in值分别给出了标识符id1,id2和id3的类型。这些值是按下面的方法确定的：首先计算根的左子节点的属性值T.type，然后在根的右子树中自上而下计算3个L节点的L.in值。在每个L节点处，还调用过程addtype，它在符号表中记下相应的标识符类型(即该结点的右子节点上的标识符类型为real)

```json
{
    "value" : "D",
    "child" : [
        {
            "value" : "T.type = real",
            "child" : [
                {
                    "value" : "D",
                    "child" : null
                }
            ]
        },
        {
            "value" : "L.in = real",
            "child" : [
                {
                    "value" : "L.in = real",
                    "child" : [
                        {
                            "value" : "L.in = real",
                            "child" : [
                                {
                                    "value" : "id1",
                                    "child" : null
                                }
                            ]
                        },
                        {
                            "value" : ",",
                            "child" : null
                        },
                        {
                            "value" : "id2",
                            "child" : null
                        }
                    ]
                },
                {
                    "value" : ",",
                    "child" : null
                },
                {
                    "value" : "id3",
                    "child" : null
                }
            ]
        }
    ]
}
```

#### 依赖图

如果分析树中某个节点的属性b依赖于属性c，那么在该节点处b的语义规则必须在c的语义规则之后计算。分析树中各节点的继承属性和综合属性问的依赖关系可以用有向图来描述，这种有向图称为依赖图。

在构造分析树的依赖图之前，为每个包含过程调用的语义规则引入一个虚综合属性b，以便把每条语义规则都变成`b:=f(c1,c2,...,ck)`的形式。依赖图的每个节点表示一个属性，边表示属性间的依赖关系，如果属性b依赖于属性c，那么从c到b就有一条有向边。更详细地说，给定一棵分析树，其依赖图是按照下面的步骤构造出来的。

```
for 分析树的每个节点n do
    for 与节点n对应的文法符号的每个属性a do
        在依赖图中为a构造一个节点
for 分析树的每个节点n do
    for 节点n所用产生式对应的每条语义规则b:=f(c1,c2,...,ck)do
        for i:= 1 to k do
            从节点ci到结点b构造一条有向边
```

例如，假设`A.a:=f(X.x,Y,y)`是产生式`A->XY`的一条语义规则，该规则定义了一个依赖于属性X.x和Y.y的综合属性A.a。如果分析树中含有该产生式，那么在依赖图中将有3个节点A.a,X.x和Y.y，而且由于A.a依赖于X.x,所以从X.x到A.a的有向边，由于A.a也依赖于Y.y，所以还有一条从Y.y到A.a的边。

如果产生式A->XY所关联的语义规则还有X.i:=g(A.a,Y.y),那么图中还应有一条从A.a到X.i的边，以及一条从Y.y到X.i的边，因为X.i依赖于A.a和Y.y

#### 计算顺序

无环有向图的拓扑排序是图中节点m1,m2,...,mk的这样一种排序：若mi->mj是从mi到mj的边，那么在此排序中mi先于mj。依赖图的任何拓扑排序都给出了一个分析树各节点语义规则计算的正确顺序，即在计算f之前，语义规则b:=f(c1,c2,...,ck)中依赖属性c1,c2,...,ck都是已知的。

语法制导定义所说明的翻译可以像下面这样精确给出。最基本的文法用于构造输入串的分析树；依赖图像上面所讨论的那样建立；从依赖图的拓扑排序可以得到语义规则的计算顺序；按该顺序计算语义规则即可得到输入串的翻译。

计算语义规则的方法：

* **分析树法**-在编译时，这种方法从分析树所构成的依赖图的拓扑排序中得到语义规则的计算顺序。若所考虑的特定的分析树的依赖图中含有环路，则这种方法将会失败。
* **基于规则的方法**-基于规则的方法。在编译器构造时，与产生式相关联的语义规则是用手工或专门的工具来分析的。对于每一个产生式，计算该产生式所关联的属性的顺序在编译器构造时已经预先确定好了。
* **忽略规则的方法**-这种方法选择计算顺序时不考虑语义规则。例如，如果翻译是在语法分析过程中进行的，那么计算顺序的选择就由语法分析方法来确定，而跟语义规则无关。这种方法限制了能被实现的语法制导定义的种类。

基于规则的方法和忽略规则的方法在编译时都不必显式地构造依赖图，因此它们使编译的时空效率更高。

如果某个文法所产生的某些分析树的依赖图中存在环路，则其语法制导定义是循环的。

### 语法树的构造

将说明如何应有语法制导定义来完成语法树的构造以及语言结构的其他图形表示。

用语法树作为中间表示，可以把翻译从语法分析中分离出来。在语法分析期间完成翻译固然有很多优点，但也存在一些问题。如在分析期间调用翻译子程序受到两个限制。首先，适于语法分析的文法可能并不反映语言成分的自然层次结构。例如，Fortran的文法可能把子程序看成只是简单地由语句序列组成的，没有反映出DO循环的嵌套。如果能够反映DO循环嵌套的树形表示，那么子程序的语法分析将会更容易一些。其次，语法分析方法限制了分析树中各节点的考察顺序，该顺序可能和各语法成分的信息变为可用的顺序不匹配。

#### 语法树

（抽象）语法树是分析树的压缩形式，它对表示语言的结构很有用。如产生式`S->if B then S1 else S2`在语法树中可能出现为：

```json
{
    "value" : "if-then-else",
    "child" : [
        {
            "value" : "B",
            "child" : null
        },
        {
            "value" : "S1",
            "child" : null
        },
        {
            "value" : "S2",
            "child" : null
        }
    ]
}
```

在语法树中，运算符和关键字不再是叶节点，而是作为内部节点称为分析树中叶节点的父节点。语法树的另一个简化是单产生式(形如A->B)链可能消失，分析树将变成下面的语法树:

```json
{
    "value" : "+",
    "child" : [
        {
            "value" : "*",
            "child" : [
                {
                    "value" : "3",
                    "child" : null
                },
                {
                    "value" : "5",
                    "child" : null
                }
            ]
        },
        {
            "value" : "4",
            "child" : null
        }
    ]
}
```

语法制导翻译可以基于语法树，也可以基于分析树，其方法都是一样的。就像在分析树中那样，也可以给语法树的节点附加属性。

#### 构造表达式的语法树

构造表示式的语法树类似于把表达式翻译成后缀表示。通过为每个运算符和运算对象建立节点来为子表达式构造子树。运算符节点的子节点分别是表示运算符各运算对象的子表达式组成的子树的根。

语法树的每个节点都是可以用带有几个域的记录来表示。对于运算符节点，记录中的一个域用来标识该运算符。其余的域包含指向运算符对象的指针。常常将运算符称为该节点的标记(label)。在翻译时，语法树的节点可能还有一些其他域用来保存附加在该节点上的属性值(或指向属性值的指针)。在本节中，用下列函数建立带有二元运算符的表达式的语法树节点，每个函数都返回一个指向新建节点的指针：

* **mknode(op, left, right)**。它建立一个标记为op的运算符节点，其两个域left和right是指向其左右运算符对象的指针。
* **mkleaf(id, entry)**。它建立标记为id的标识符节点，其域entry是指向该标识符在符号表中相应表项指针。
* **mkleaf(num, val)**。它建立标记为num的数节点，域val保存该数的值。

例：下面的函数调用序列用来建立图5-8中表达式`a-4+c`的语法树。在该序列中p1,p2,...,p5是指向节点的指针，entrya和entryc分别指向符号表中标识符a和c对应的表项。

* (1) p1 := mkleaf(id, entrya);
* (2) p2 := maleaf(num, 4);
* (3) p3 := mknode('-', p1, p2);
* (4) p4 := mkleaf(id, entryc);
* (5) p5 := mknode('+', p3, p4);

该树是自底向上构造的，函数调用meleaf(id, entrya)和mkleaf(num, 4)分别为a和4建立叶子节点，指向这两个节点的指针保存在p1和p2中；然后，函数调用mknode('-', p1,p2)构造一个内部节点，其子节点为叶节点a和4；再经过两步即可建立起语法树，p5指向根节点。

#### 构造语法树的语法制导定义

为包含+和-的表达式的构造语法树的S属性定义。它通过为文法的基本产生式安排函数mknode和mkleaf的调用来构造语法树。E和T的综合属性nptr用来记住函数调用返回的指针。

产生式`T->id`和`T->num`所对应的语义规则将属性T.nptr定义为指向标识符和数的新建叶节点的指针。属性id.entry和num.val是词法值，假设词法分析器将这些值连同记号id和num一起返回。

在图中，当表达式E是一个单个项时，即使用产生式E->T时,属性E.nptr得到T.nptr的值。当使用产生式`E->E1-T`所对应的语义规则`E.nptr:=mknode('-', E1.nptr, T.nptr)`时，先前的规则已经把`E1.nptr`和`T.nptr`分别置成指向叶节点a和4的指针。

对图的解释关键要认识到，由记录形成的底层树才是构成输出的“真正的”语法树，而上层虚线形成的树分析树，在此处只具有象征意义。

#### 表达式的无环有向图

表达式的**无环有向图(diected acyclic gragh，简称dag)**可以识别表达式中的公共子表达式。和语法树一样，在dag中，表达式中的每一个子表达式都有一个节点与之对应。内部节点代表运算符，子节点代表其运算对象。不同的是，在dag中，代表公共子表达式的节点具有多个“父节点”，而在语法树中，公共子表达式由重复的子树表示，所以它只有一个父节点。

表示式`a+a*(b-c)+(b-c)*d`的dag。其叶节点a具有两个父节点，因为a是两个子表达式a和`a*(b-c)`的公共子表达式。类似地，公共子表达式`b-c`的两次出现也由同一个节点表示，相应地亦拥两个父节点。

如果修改构造节点的函数，语法制导定义即可用于构造dag而不是语法树：只要在构造节点之前先检查是否存在相同节点，就可以得到dag。例如，在以标记op和指向left和right的指针的域构造新节点之前。mknode(op,left,right)先检查是否已经存在这样的节点。如果存在的话，mknode(op,left,right)可以返回一个指向先前已经构造好了的节点的指针，叶节点构造函数mkleaf可以采用类似的修改。

例子：如果mknode和mkleaf仅在必要时才建立新节点，而且尽量返回指向具有正确标记和子节点的现存节点的指针。a，b，c和d分别指向符号表中标识符a,b,c和d的表项。

```
(1) p1 := mkleaf(id, a);
(2) p2 := mkleaf(id, a);
(3) p3 := mkleaf(id, b);
(4) p4 := mkleaf(id, c);
(5) p5 := mknode('-', p3, p4);
(6) p6 := mknode('+', p2, p5);
(7) p7 := mknode('+', p1, p6);
(8) p8 := mkleaf(id, b);
(9) p9 := mkleaf(id, c);
(10) p10 := mknode('-', p8, p9);
(11) p11 := mknode(id, d);
(12) p12 := mknode('*', p10, p11);
(13) p13 := mknode('+', p7, p12);
```

在第(2)行重复调用mkleaf(id, a)时，前一个mkleaf(id, a)调用所构造的节点将被返回，所以p1=p2。类似地，第8行和第9行返回的节点分别与第(3)行和第4行返回的节点相同。因此，第(10)行返回的节点和第(5)行调用mknode所构造的节点是相同的。

如图5-13所示，在许多应用中节点都被实现为记录保存在数组中。图中每个记录都有一个标记域，它决定节点的性质。可以通过节点在数组中的下标或者位置来引用节点。由于历史原因，节点的整数索引通常被称为值编号(value number)。例如，使用值编号，可以说节点3的标记为+，其左子节点为节点1，右节点为节点2。下面的算法可用来为表达式的dag表示创建节点。

算法5.1 构造dag节点的值编号法

假设节点保存在一个数组中，而且每个节点通过其值编号来引用。令运算符节点的签名(signature)为一个三元组`<op, l, r>`，其中op为标记，l为左子节点，r为右子节点。

```
输入：标记op、节点l及节点r。
输出：带有签名`<op, l, r>`的节点
方法：搜索数组，寻找具有标志op，且左子节点为l，右子节点为r的节点m。如果存在，则返回m；否则，创建一个新节点n。将其标记域置为op，左子节点置为r，并返回n。
```

确定节点m是否已经存在于数组中的一个简单方法是将前面建立的所有节点保存在列表中，然后依次查看列表中的每个节点，看其是否具有所要求的签名。使用k个称为桶的列表可以提高查找节点m的效率，而散列函数h用来确定要搜索的桶。

散列函数h根据op，l和r值来计算散列桶的序号。给定相同的参数，总是返回相同的桶号。如果节点m不在散列桶h(op,l,r)中，就创建一个新节点n，并将其加入该散列桶中，所以接下来的搜索将会发现它已经在该桶中了。不同的签名可能会被散列到同一个散列桶中，但实际上希望每个桶只包含少数节点。

可以用链表实现每个散列桶。链表中的每个单元代表一个节点。散列桶的首部是指向链表中第一个单元的指针，将其保存在数组中。由散列函数h(op,l,r)返回桶序号是该数组的一个下标。

对于非顺序存储的节点，可以修改此算法。在许多编译器中，为避免预分配一个大部分时间保存太多节点而有时又没有保存足够节点的数组，节点是按照需要进行分配的。在这种情况下，就不能假定节点是顺序存放的了，此时必须用指针来访问节点。如果可以设计一个能根据标记值和指向子节点的指针来计算散列桶号的散列函数，那么可以使用指向节点的指针而不是值编号。否则，可以以任何方式对节点进行编号并用这些编号作为节点的值编号。

由于dag可以有多个根节点，因此dag可以用来表示表达式的集合。

#### S属性定义

给定一个SDD，很难判定是否存在一棵其依赖图包含环的语法分析树。在实践中，翻译过程可以使用某些特定类型的SDD来实现。这些类型的SDD通常有一个特定的求值顺序，因为它们不允许产生带有环的依赖图

第一种类型的S属性的定义：如果一个SDD的每个属性都是综合属性，它就是S属性的，那么可以按照语法分析树结点的任何自底向上顺序来计算它的各个属性值。对语法分析树进行后序遍历并对属性求值常常会非常简单，当遍历最后一次离开某个结点N时计算出N的各个属性值。也就是说，可以把下面定义的postorder函数应用到语法分析树的根上：

```
postorder(N)
{
    for (从左边开始，对N的每个子结点C) postorder(C);
    对N关联的各个属性求值；
}
```

S属性的定义可以在自底向上语法分析的过程中实现，因为一个自底向上的语法分析过程对应一次后序遍历。特别地，后序顺序精确地对应于一个LR分析器将一个产生式规约成为它的头的过程。这个性质将在LR语法分析过程中的综合属性求值工作，这些值将存放在分析栈中。这个过程不会显式地创建语法分析树的结点。

#### L属性的定义

第2种SSD称为L属性定义，这类SSD的思想是是在一个产生式体所产生的关联的各个属性之间，依赖图的边总是从左到右，而不能从右到左(因此被称为L属性)。更准确地讲，每个属性只能是以下两个属性中的一种：

* 综合属性，
* 继承属性，但是规则有如下限制。假设存在一个产生式`A->X1X2...Xn`,并且有一个通过这个产生式所关联的规则计算得到的继承属性`Xi.a`,那么这个规则只能使用：

1. 和产生式头`A`相关联的继承属性
2. 位于`Xi`左边的文法符号实例X1,X2,...,Xi-1相关的继承属性或者综合属性
3. 和这个Xi本身实例相关的的继承属性或者综合属性，但是在由这个Xi的全部属性组成的依赖图中不存在环

#### 具有受控副作用的语义规则

实践中，翻译过程通常会出现一些副作用。对于SDD，在属性文法和翻译方案之间找到一个平衡点。属性文法没有副作用，并支持任何与依赖图一致的求值顺序。翻译方案要求要求按从左到右的顺序求值，并允许语义动作包含任何程序片段。

按照如下方法之一控制SDD中的副作用：

* 支持那些不会对属性求值产生约束的附带副作用
* 对允许的求值顺序添加约束

### 语法制导翻译的应用

主要应用是抽象语法树(AST)的构造。因为一些编译器使用抽象语法树作为一种中间表示形式，所以一种常见的SDD形式将它的输入串转换成一棵树。完成到中间代码的翻译，编译器接下来可能使用一种规则来编译这棵语法树。这些规则实际上是建立于语法树之上的SDD。

考虑两个为表达式构造语法树的SDD。第一个是一个S属性定义，它适合在自底向上语法分析过程中使用。第二个是一个L属性定义，它适合在自顶向下的的语法分析过程中使用。

#### 抽象语法树AST的构造

一棵语法树中的每个结点代表一个程序构造，这个结点的子结点代表这个构造的有意义的组成部分。表示表达式`E1+E2`的语法树结点的标号为`+`,且两个子结点分别代表表达式`E1`和`E2`。

将使用具有适当数量的字段的对象来实现一棵语法树的各个结点。每个对象将有一个`op`字段，也就是这个结点的标号。这些对象将具有如下所述的其他字段：

* 如果结点是一个叶子，那么对象将有一个附加的域来存放这个叶子结点的词法值。构造函数`Leaf(op,val)`创建一个叶子结点对象。也可以把结点看作记录，那么Leaf就会返回一个指向于与叶子结点对应的新记录的指针。
* 如果结点是内部结点，那么它的附加字段的个数和该结点在语法树中的子结点的个数相同。构造函数`Node`带有两个或多个参数：`Node(op,c1,c2,...,ck)`,该函数创建一个对象，第一个字段的值为`op`,其余k个字段为`c1`到`ck`。

例：下述表格的S属性定义为一个简单的表达式文法构造出语法树。这个文法只包含二目运算符`+`和`-`。通常，这两个运算符都具有相同的优先级，并且都是左结合的。所有的非终结符号都有一个综合属性`node`,该属性表示相应的抽象语法树结点。

每当使用第一个产生式`E->E1+T`,它的语义规则就创建出一个结点，创建时使用`+`作为`op`,使用`E1.node`和`T.node`作为代表子表达式的两个子结点。第二个产生式也有类似的规则。

产生式|语义规则
-|-
1) E->E1+T|E.node = new Node('+', E1.node, T.node)
2) E->E1-T|E.node = new Node('-', E1.node, T.node)
3) E->T|E.node = T.node
4) T->(E)|T.node = E.node
5) T->id|T.node = new Leaf(id, id.entry)
6) T->num|T.node = new Leaf(num, num.val)

产生式3，即`E->T`,没有创建任何结点，因为E.node和T.node是一样的。类似地，产生式4，即`T->(E)`,也没有创建任何结点。T.node的值和E.node的值是相同的，因为括号仅仅用于分组。它们会影响语法分析树和抽象语法树的构造，但是一旦分组完成，就不需要在抽象语法树中保留这些括号了。

最后两个T产生式的右部是一个终结符号。使用构造函数Leaf来创建合适的结点。这些结点就成为T.node的值。

如果这些规则是在对语法分析树的后序遍历过程中求值的，或者是在自底向上分析过程中和归约动作一起求值的，那么当一系列步骤结束时，指针指向构造得到的AST的根结点。

如果使用一个自顶向下语法分析而设计的文法，那么得到的AST仍然相同，其构造的步骤也相同，虽然语法分析树的结构和抽象语法树的结构有着极大的不同。

#### 类型的结构

当语法分析树的结构和输入的抽象语法树结构不同时，继承属性是很有用的。这种情况下，继承属性可以用来将信息从语法分析树的一部分传递到另一部分。下一个例子显示了这种结构上的不匹配可能是由语言设计引起的，而不是由语法分析的方法的约束引起的。

例：C语言中，类型`int[2][3]`可以读作“由两个数组组成的数组，子数组中有三个整数”。相应的类型表达式`array(2, array(3, integer))`可以使用如下的树表示。运算符array有两个参数，一个数字，另一个是类型。如果使用树来表示类型，那么这个运算符返回一个标号为array的结点，该结点具有两个子结点，分别表示数字和类型。

```json
{
    "node" : "array",
    "child" : [
        {
            "node" : "2",
            "child" : "null"
        },
        {
            "node" : "array",
            "child" : [
                {
                    "node" : "3",
                    "child" : "null"
                },
                {
                    "node" : "integer",
                    "child" : "null"
                }
            ]
        }
    ]
}
```

使用如下的SDD，非终结符号T生成的是一个基本类型int和float之一。当T推导出BC且C推导出e时，T生成一个基本类型。否则，C就生成一个由整数序列组成的数组描述分量，其中的每个整数用方括号括起。

产生式｜语义规则
-|-
T -> B C|T.t = C.t, C.b = B.t
B -> int|B.t = integer
B -> float|B.t = float
C -> `[num]`C1|C.t = array(num.val, C1.t), C1.b = c.b
C -> e|C.t = C.b

非终结符号B和T有一个表示类型的综合属性t。非终结符号C有两个属性：一个继承属性b和一个综合属性t。继承属性b将一个基本类型沿着树向下传播，而综合属性t则收集最终得到的结果。

输入串`int[2][3]`的注释语法分析树如下述所示，相应表达式的构造过程如下：首先类型integer从B开始，沿着C组成的链通过继承属性b向下传递。最后的数组类型是沿着C组成的链,通过属性t不断向上传递并综合得到的。

更详细地讲，在产生式`T->BC`对应的根结点上，非终结符号C使用继承属性C.b从B那里继承类型。在最右边的C结点上的产生式是C->e,因此C.t等于C.b。产生式`C->[num]C1`的语义规则将运算符array作用到运算分量num.val和C1.t上，得到C.t的值。

### 语法制导的翻译方案

语法制导的翻译方案是语法制导定义的一种补充。

**语法制导翻译方案(syntax directed translation scheme, SDT)**是在其产生式中嵌入了程序片段的一个上下文无关文法。这些程序片段称为语义动作，它们可以出现在产生式中的任何地方。按照惯例，我们这些动作两边加上花括号。如果花括号要作为文法符号出现，则要给它们加上引号。

任何SDT都可以通过下面的方法实现：首先建立一棵语法分析树，然后按照从左到右的深度优先顺序来执行这些动作，也就是说在一个前序遍历过程中执行。

SDT是在语法分析过程中实现的，不会真的构造一棵语法分析树。在本节中，主要关注如何使用SDT来实现两类重要的SDD：

* 基本文法可以用LR技术分析，且SDD是S属性的。
* 基本文法可以用LL技术分析，且SDD是L属性的。

在这两种情况下，一个SDD中的语义规则是如何被转换成一个带有语义动作的SDT的。这些动作将在适当的时候执行。在语法分析过程中，产生式体中的一个动作在它左边的所有文法符号都被匹配之后立即执行。

可以在语法分析过程中实现的SDT可以按照如下的方式识别：将每个内嵌的语义动作替换为一个独有的标记非终结符号(marker nonterminal)。每个标记非终结符M只有一个产生式`M->e`。如果带有标记非终结符号的文法可以使用某个方法进行语法分析，那么这个SDT就可以在语法分析过程中实现。

#### 后缀翻译方案

至今为止，最简单的实现SDD的情况是文法可以用自底向上方法来分析且该SDD是S属性定义。在这种情况下，可以构造出一个SDT，其中的每个动作都放在产生式的最后，并且在按照这个产生式将产生式体规约为产生式头的时候执行这个动作。所有动作都在产生式最右端的SDT称为后缀翻译方案。

#### 后缀SDT的语法分析栈实现

后缀SDT的语法可以在LR语法分析过程中实现，当规约发生时执行相应的语义动作。各个文法符号的属性值可以放到栈中某个位置，使得执行归约的时候可以找到它们。最好的方法是将属性和文法符号(或者表示文法符号的LR状态)一起放在栈中的记录里。

语法分析栈包含的记录中有一个字段，该字段用于存放文法符号(或语法分析器的状态)，并且在这个字段之下有一个字段用于存放属性。三个文法符号X Y Z位于栈的顶部，可能它们即将按照这一个产生式，比如A->X Y Z，进行规约。这里，用X.x表示X的一个属性，等等。一般来说，可以支持多个属性，方法是使记录变的足够大，或者在栈中的记录里放上指针。对于小型的属性，将记录变得足够大可能是比较简单的方法，即使有些时候有些字段不会被用到也没有太大关系。然而，如果一个或多个属性的大小没有限制，比如它们是字符串，那么最好把一个指针放到栈记录的属性值中，并把实际的值存放在栈之外的某个比较大的共享存储区域中。

如果所有属性都是综合属性，并且所有动作都位于产生式的末端，那么可以把产生式体归约成产生式头的时候计算各个属性的值。如果我们使用`A->XYZ`这样的产生式进行归约。此时X，Y和Z的所有属性值都是可用的，并且都位于已知的位置上，在这个动作之后，A和它的属性都位于栈的顶部，即现在存放X记录的位置上。

例：重写桌上计算器SDT的动作，使它们显示地操作语法分析栈。这样的栈操作通常是由语法分析器自动完成的

假设语法分析栈存放在一个被称为`stack`的记录数组中，而`top`是指向栈顶的游标。这样，`stack[top]`指向这个栈的栈顶记录，`stack[top-1]`指向栈顶记录的下一个记录，依次类推。还可以假设每个记录有一个被称为`val`的字段，该字段存放了这个记录所代表的文法符号的属性值。这样，可以使用`stack[top-2].val`来指向出现在栈中第三个位置上的属性`E.val`。完整的SDT如下所示。

产生式|语义动作
-|-
L -> E n|print(stack[top - 1].val);top = top - 1;
E -> E1 + T|stack[top - 2].val = stack[top - 2].val + stack[ top ].val;top = top - 2;
E -> T|
T -> T1 * F|stack[top - 2].val = stack[top - 2].val * stack[ top ].val;top = top - 2;
T -> F|
F -> (E)|stack[top - 2].val = stack[top - 1].val;top = top - 2
F -> digit|

#### 产生式内部带有语义动作的SDT

动作可以放置在产生式体中的任何位置上。当一个动作的左边的所有符号都被处理过后，该动作立即执行。因此，如果有一个产生式`B->X{a}Y`，当识别到X（如果X是终结符号）或者从X推导出的终结符号（如果X是非终结符号）之后，动作a就会执行。更准确地讲

* 如果语法分析过程是自底向上的，那么在X的此次出现位于语法分析栈的栈顶时，立刻执行动作a；
* 如果语法分析过程是自顶向下的，那么试图展开Y的本次出现（如果Y是非终结符号）之前执行语义动作a。

可以在语法分析过程中实现的SDT包括后缀SDT和即将实现的一类SDT，这类SDT实现了L属性定义。不是所有的SDT都可以在语法分析过程中实现。

任何SDT都可以按照下列方式实现

1. 忽略语义动作，对输入进行语法分析，并产生一个语法分析树；
2. 然后检查每个内部结点N，假设它的产生式是`A->α`，将α中的各个动作当作Nde附加子结点加入，使得N的子结点从左到右和α中的符号和动作完全一致；
3. 对这棵语法树进行前序遍历，并且当访问到一个以某动作为标点de结点时立刻执行这个动作。

#### 从SDT中消除左递归

因为带有左递归的文法不能按照自顶向下的方式确定进行语法分析，所以有时需要消除左递归。

首先考虑简单的情况，即只需要关心一个SDT中的动作的执行顺序的情况。比如，如果每个动作只打印一个字符串，就只关心这些字符串的打印顺序。在这种情况下，可以应用下面的原则完成这个转化

* 当转换文法的时候，将动作当成终结符号处理。

消除左递归的“技巧”是对两个产生式`A->Aa|b`进行替换。这两个产生式生成的串包含一个b和任意数量的a。它们将被替换为下面的产生式。新的产生式使用了一个新非终结符号R（代表“其余部分”）来生成同样的串。

```
A->bR
R->aR | e
```

如果b不以A，那么A就不再有左递归的产生式。按照正则定义的表示法，在两组产生式中A都被定义为b（α）*

如果对E应用标准的左递归消除转换，左递归产生式的余部为`a=+T{print('+');}`

而b（即另一个产生式的体）是T。如果引入R来表示E的余部，就得到如下的产生式集合

```
E -> T R
R -> +T {print('+');} R
R -> e
```

当一个SDD的动作是计算属性的值，而不是仅仅是打印输出时，必须更加小心地考虑如何消除文法中的左递归。然而，如果这个SDD属性是S属性的，那么我们总是可以通过将计算属性的值的动作放在新产生式中的适当位置上来构造出一个SDT。

将给出一个通用的解决方案，以解决只有单个递归产生式，单个非递归产生式并且该左递归非终结符号只有单个属性的情况。将这个方案推广到多个递归/非递归产生式的情况并不困难，但是写起来非常麻烦。假设这两个产生式分别为
```
A -> A1Y {A.a = g(A1.a,Y.y)}
A -> X {A.a = f(X,x)}
```
这里A.a是左递归非终结符号A的综合属性，而X和Y是单个文法符号，分别有综合属性X.x和Y.y。因为这个方案在递归的产生式中用任意的函数g来计算A.a，而在第二个产生式中用任意的函数f来计算A.a的值，所以这两个符号可以代表由多个文法符号组成的串，每个符号都有自己的属性。在每种情况下，f和g可以把它们能够访问的属性当作它们的参数，只要这个SDD是S属性的。

要把基础文法改成
```
A -> X R
R -> Y R | e
```

为了完成这个翻译，使用下列SDT：
```
A -> X {R.i = f(X,x)}  R {A.a = R.s}
R -> Y {R1.i = g(R.i,Y.y)}  R1 {R.s = R1.s}
R -> e {R.s = R.i}
```

*注意：继承属性R.i在产生式体中R的一次使用之前完成求值，而综合属性A.a和R.s在产生式的结尾完成求值。因此，计算这些属性时需要de任何值都已经在左边计算完成，变成了可用的值*

#### L属性定义的SDT

只要基础文法是LR的，后缀SDT就可以按照自底向上的方式进行语法分析和翻译。

考虑更一般化的请情况，即L属性的SDD。假设基础文法将以自顶向下的方式进行语法分析，因为如果不是这样，那么翻译过程常常无法和一个LL或者LR语法分析器一起完成。对于任何文法，只需将动作附加到一棵语法分析树中，并在对这棵树进行前序遍历时执行这些动作，便可以实现下面的技术。

将一个L属性的SDD转换为一个SDT的规则如下：

* 把计算某个非终结符A的继承属性的动作插入到产生式体中紧靠在A的本次出现之前的位置上
* 将计算一个产生式头的综合属性的动作放置在这个产生式体的最右端

例：一个产生式`S -> while(C)S1`。这里，S是生成各种语句的非终结符号，假设这些语句包括if语句，赋值语句和其他类型的语句；C表示一个条件表达式（一个值为真或假的布尔表达式）

在这个关于语句控制流的例子中，只需要生成多个标号。假设其他的中间代码指令都由这个SDT的未显示部分生成。更明确地讲，生成显示的形如`label L`的指令，其中`L`是一个标示符。这个指令表明后一条指令的标号是L。假设中间代码和之前的类似

这个while语句的含义是首先对条件表达式C求值。如果它为真，控制就转向S1的代码的开始处。如果C的值为假，那么控制就转向跟这个while代码之后的代码。必须设计S1的代码，使得它在结束的时候能够跳转到这个代码的开始处。使用下面的属性来正确地生成中间代码：

1. 继承属性`S.next`是必须在S执行结束之后执行的代码的开始处的标号；
2. 综合属性`S.node`是中间代码的序列，实现了语句S，并且最后有一条跳转到`S.next`的指令；
3. 继承属性`C.true`是必须在C为真时执行的代码开始处的标号；
4. 继承属性`C.false`是必须在C为假时执行的代码开始处的标号；
5. 综合属性`C.node`是一个中间代码序列，它实现了条件表达式C，并根据C的值为真或假跳转到`C.true`或`C.false`

计算while语句的这些属性的SDD显示在下述代码中：

```
S -> while(C)S1  L1 = new();
                 L2 = new();
                 S1.next = L1;
                 C.false = S.next;
                 C.true = L2;
                 S.code = label || L1 || c.code || label || L2 || S1.code 
```

*注意：使用`||`作为连接各个中间代码片段的符号。因此，S.node的值以标号L1开始，然后是条件表达式C的代码，然后是另一个标号L2，然后是S1的代码*

这个SDD是L属性的。当我们把它转换为SDT时，还需要考虑如何处理标号L1和L2L2，它们是变量而不是属性。如果我们把语义动作当作哑非终结符号来处理，那么这样的变量可以当作哑非终结符号的综合属性来处理。因为L1和L2L2不依赖于其他属性，它们可以被分配到产生式的第一个语义动作中。实现这个L属性定义带有内嵌语义动作的SDT显示在下面：

```
S -> while ( { L1 = new(); L2 = new(); C.false = S.next; C.true = L2; }
    C )  { S1.next = L1;}
    S1   { S.code = label || L1 || C.code || label || L2 || S1.code; }
```

### 实现L属性的SDD

因为很多翻译应用可以用L属性定义来解决，所以将在这一节中详细地考虑它们的实现。下面的方法通过遍历语法分析树来完成翻译工作。

* **建立语法分析树并注释**-这个方法对于任何非循环定义的SDD都有效；
* **构造语法分析树，加入动作，并按照前序顺序执行这些动作**-这个方法可以处理任何L属性定义。在之前的章节中讨论了如何把一个L属性SDD转变为SDT，还特别讨论了如何根据这样的SDD语义规则把语义动作嵌入到产生式中；
* **使用一个递归下降的语法分析器**-它为每个非终结符号都建立一个函数。对应于非终结符号A的函数以参数的方式接受A的继承属性，并返回A的综合属性；
* **使用一个递归下降的语法分析器**-以边扫描边生成的方式生成中间代码
* **与LL语法分析器结合，实现一个SDT**-属性的值存放在语法分析栈中，而各个规则从栈中的已知位置获取需要的属性值
* **与LR语法分析器结合，实现一个SDT**-这个方法会让人觉得惊讶，因为一个L属性SDD的SDT通常有一些动作位于产生式的中间，而在一个LR语法分析过程中，只有在构造出一个产生式体的全部符号之后才能肯定确实可以使用这个产生式。然而，如果基础文法是LL的，总是可以按照自底向上的方式来处理语法分析和翻译过程。

#### 在递归下降语法分析过程中进行翻译

一个递归下降的语法分析器对每个非终结符号A都有一个函数A。可以按照如下方法把这个语法分析器扩展为一个翻译器：

* 函数A的参数是非终结符号A的继承属性。
* 函数A的返回值是非终结符号A的综合属性的集合。

在函数A的函数体中，要进行语法分析并处理属性：

* 决定用哪个产生式来展开A
* 当需要读入一个终结符号时，在输入中检查这些符号是否出现。假设分析过程不需要进行回溯，但是只要出现在语法错误时恢复输入位置，就可以把这个方法扩展到带回溯的递归下降语法分析技术
* 在局部变量中保存所有必要的属性，这些值将用于计算产生式体中非终结符号的继承属性，或者产生式头部的非终结符号的综合属性
* 调用对应于被选定产生式体中的非终结符号的函数，向它们提供正确的参数。因为基础的SDD是L属性的，所以必然已经计算出了这些属性并且把它们存放到了局部变量中。

例：考虑上一个例子中while语句的SDD和SDT。下述代码显示了S函数相关部分的伪代码。

显示的这个函数S需要存储并返回很长的字符串。在实践中，更有效率的做法是让像S和C这样的函数返回一个指针，指向表示这些字符串的记录。那么函数S中的返回语句将不会真的把各个组成部分连接起来，而是构造出一个记录或记录树。这个记录或记录树表示了将Scode，Ccode，标号L1和标号L2以及文字串“label”的两次出现全部连接起来而得到的串。

```cpp
string S(label next) {
    string Scode, Ccode; /* 存放代码片段的局部变量 */
    label L1, L2;  /* 局部标号 */
    if (当前输入 == 词法单元while) {
        读取输入;
        检查‘(’是下一个输入符号，并读取输入；
        L1 = new();
        L2 = new();
        Ccode = C(next, L2);
        检查‘)’是下一个输入符号，并读取输入；
        Scode = S(L1);
        return ("label" || L1 || Ccode || "label" || L2 || Scode);
    }
    else {
        /* 其他语句类型 */
    }
}
```

#### 边扫描边生成代码

使用属性来表示代码并构造出很长的串不能满足我们的要求，原因是多方面的，比如拷贝和移动这些串字符时需要很长的时间。在通常情况下，比如在我们的代码生成例子中，可以通过执行一个SDT中的语义动作，逐步把各个代码片段添加到一个数组或输出文件中。要保证这项技术能够正确应用，下列要素必不可少：

* 存在一个（一个或多个非终结符号的）主属性。为方便起见，假设主属性都以字符串为值。在上述例子中，属性`S.code`和`C.code`是主属性，而其他属性不是主属性；
* 主属性是综合属性；
* 对主属性求值的规则保证；

1. 主属性是将相关产生式体中的非终结符号的主属性值连接起来得到的。连接时也可能包括其他非主属性的元素，比如字符串label和标号L1及L2的值
2. 各个非终结符号的主属性值在连接运算中出现的顺序和这些非终结符号在产生式体中的出现顺序相同。

上面这些条件使得在构造主属性时只需要在适当的时候发出这个连接运算中的非主属性元素。可以依靠对一个产生式体中的非终结符号的对应函数的递归调用，以增量方式生成它们的主属性。
d
可以修改S函数，使得它生成主属性`S.code`的各个元素，而不是把它们保存起来，再连接得到`S.code`的一个返回值。经过修改的函数S显示在下面：

```cpp
void S(label next) {
    label L1, L2;  /* 局部标号 */
    if (当前输入 == 词法单元while) {
        读取输入;
        检查‘(’是下一个输入符号，并读取输入；
        L1 = new();
        L2 = new();
        print("lable", L1);
        C(next, L2);
        检查‘)’是下一个输入符号，并读取输入；
        print("lable", L2);
        Scode = S(L1);
    }
    else {
        /* 其他语句类型 */
    }
}
```

#### L属性的SDD和LL语法分析

假设一个L属性SDD的基础文法是一个LL文法，并且我们已经按照上述描述的方法把它转换成一个SDT，其语义动作被嵌入到各个产生式中。然后，就可以在LL语法分析过程中完成翻译过程，其中的语法分析栈需要进行扩展，以存放语义动作和属性求值所需的某些数据项。一般来说，这些数据项是属性值的拷贝。

除了那些代表终结符号和非终结符号的记录之外，语法分析栈中还保存**动作记录(action-record)**和**综合记录(synthesize-record)**，其中动作记录表示即将被执行的语义动作，而综合记录保存非终结符号的综合属性值。使用下列两个原则来管理栈中的属性：

* 非终结符号A的继承属性放在表示这个非终结符号的栈记录中。对这些属性求值的代码通常使用紧靠在A的栈记录之上的动作记录来表示。实际上，从L属性的SDD到SDT的转换方法保证了动作记录将紧靠在A的上面。
* 非终结符号A的综合属性放在一个单独的综合记录中，它在栈中紧靠在A的记录之下。

这个策略在语法分析栈中放置了多种类型的记录，这些不同的记录类型将被当作“栈记录”的子类进行正确管理。在实践中，可能把几个记录组合成一个记录，但是如果要解释这个方法的基本思想，最好还是把用于不同目的的数据分别存放在不同的记录中。

动作记录包含指向将被执行的动作代码的指针。动作可能出现在综合记录中，这些动作通常把其他记录中的综合属性拷贝到栈中更低的地方。在这个综合属性所在的记录被弹出栈之后，语法分析程序需要在这个较低的位置上找到该属性的值。

一个通过分析表驱动的LL语法分析器模拟了一个最左推导过程。如果w是至今为止已经匹配完成的输入，那么栈中就包含了一个文法符号序列a，使得`S lm*-> wa`，其中S是开始符号。当语法分析器按照一个产生式`A -> B C`展开的时候，它把栈顶的`A`替换为`B C`。

假设非终结符号C有一个继承属性`C.i`。对于产生式`A -> B C`，继承属性`C.i`可能不仅仅依赖于`A`的继承属性，还可能依赖于B的所有属性。因此，可能需要在计算`C.i`之前完成对B的处理。因此，需要计算`C.i`所需的所有属性值的临时拷贝存放到计算`C.i`的动作记录之中。否则，当语法分析器把栈顶的A替换为BC的时候，A的继承属性就和它的栈记录一起消失了。

因为基础SDD是L属性的。可以肯定当A位于栈顶时，A的继承属性的值是可用的。因此当需要把这些值拷贝到对C的继承属性求值的动作记录中时，这些值也是可用的。不仅如此，用于存放A的综合属性的空间也不成问题，因为这个空间位于A的综合记录中，而这个记录在语法分析器使用`A -> B C`进行展开时还保持在分析栈中（位于B和C之下）。

当处理B时，如果需要，可以执行一个动作，将它的继承属性拷贝给C使用。在处理完B之后，如果需要，B的综合记录也可以拷贝它的综合属性供C使用。类似地，也可能需要一些临时变量来计算A的综合属性的值。这些值可以在先后处理B和C的时候被拷贝到A的综合记录中。所有这些属性的拷贝工作能够正确进行原理是：

* 所有拷贝都发生在对某个非终结符号的一次展开时创建的不同记录之间。因此，这些记录中的每一个都知道其他各个记录在栈中离它有多远，因此可以安全地把值写到它下面的记录中。

#### L属性的SDD的自底向上语法分析 

可以使用自底向上的方法来完成任何可以用自底向下方式完成的翻译过程。更准确地说，给定一个以LL文法为基础的L属性SDD，可以修改这个文法，并在LR语法分析过程中计算这个新文法之上的SDD。这个“技巧”包括三个部分：

* 先得到SDT的起点。这样的SDT在各个非终结符号之前放置语义动作来计算它的继承属性，并且在产生式后端放置一个动作来计算综合属性；
* 对每个内嵌的语义动作，向这个文法中引入一个标记非终结符号来替换掉它，每个这样的位置都有一个不同的标记，并且对于任意一个标记M都有一个产生式`M -> e`；
* 如果标记非终结符号M在某个产生式`A -> a{a}b`中替换了语义动作a，对a进行修改得到a‘，并且将a'关联到`M -> e`上。这个动作a‘：

1. 将动作a需要的A或a中符号的任何属性作为M的继承属性进行拷贝
2. 按照a中的方法计算各个属性，但是将计算得到的这些属性作为M的综合属性

这个变换看起来是非法的，因为通常和产生式`M -> e`相关的动作将不得不访问某些没有出现在这个产生式中的文法符号的属性。然而，将在LR语法分析栈上实现各个语义动作。因此必要的属性总是可用的，它们位于栈顶之下的已知属性上。

例：假设一个LL文法中存在一个产生式`A -> B C`,而继承属性`B.i`是根据继承属性`A.i`按照某个公式`B.i = f(A.i)`计算得到的。也就是说，关心的SDT片段是`A -> {B.i = f(A.i)} B C`

引入标记M，M有继承属性M.i和综合属性M.s。前者是A.i的一个拷贝，而后者将成为B.i。这个SDT将被写作

```
A -> M B C
M -> {M.i = A.i; M.s = f(M.i);}
```

*注意：M的规则中不可以使用A.i*，但是实际上将设法安排分析栈，使得如果即将执行一个到A的归约，那么A的每个继承属性都将出现在栈中这个执行归约的位置下方，从该处就可以读到这些继承属性。因此，当我们将e归约为M时，直接在它的下方找到A.i,在那里读取到它的值。另外，当我们将e规约为M时，直接在它的下方找到A.i，在那里读取到它的值。

例：把之前的while SDT修改成基于经过修改的LR文法的SDT，新的SDT可以和LR语法分析器一起完成翻译。在C之前引入标记M，在S1之前引入标记N，因此基础文法变成

```
S -> while (M C) N S1
M -> e
N -> e
```

现在跟踪一个while语句的语法分析过程。假设一个保存S.next的记录出现在栈顶，并且下一个输入是终结符号while，把这个终结符号移入栈中。此时识别出的产生式肯定是while产生式，因此LR语法分析器可以移入`(`并确定下一步把e归约为M。此时的栈显示在下式中。创建出L1和L2的值，它们被存放在M的记录的域中，同处这个记录还有`C.true`和`C.false`的域。这些属性必定在这个记录的第二个域或第三个域中。这是为了和可能在不同上下文出现于C之下，且需要为C提供这些属性的其他栈记录保持一致。这个动作最后把两个值赋给C.true和C.false。其中de第一个值来自于刚刚生成的L2，另一个从栈下方存放S.next的地方获取。

继续识别while语句，语法分析器下一步将在输入中发现`)`，把它放在该符号自己的记录中，并压入栈中。因为文法是LL的，因此语法分析器在该点上已经知道它在处理一个while语句。语法分析器将把e归约为N。和N相关联的唯一数据是继承属性S1.next。请注意，需要将这个属性存放在此记录中的原因是这个记录将恰好位于S1的记录之下。计算S1.next的值代码时

```
S1.next = stack[top - 3].L1
```

这个动作从N之下三个记录的地方获取了L1的值。当这个代码执行的时候，N的记录位于栈顶。

接下来，语法分析器将其余输入的某个前缀规约为S。一直把它称为S1，以便和产生式头的S区分开。S1.node的值计算完成并放在S1的栈记录中。

此时，语法分析器将把从while到S1的全部内容归约为S。在这一次的归约为S。在这一次归约中，执行的代码是

```
tempCode = label || stack[top - 4].L1 || stack[top - 3].code || label || stack[top - 4].L2 || stack[top].code;
top = top - 6;
stack[top].code = tempCode;
```

也就是说，在变量tempCode中构造出S.code的值。该代码也是由两个标号L1和L2，C的代码和S1的代码组成。这个栈执行了一些弹出操作，因此S出现在while原来出现的地方。S的代码值存放在该记录的code字段中。它在那里被解释为综合属性S.code。请注意，在这次讨论中没有显示对LR状态的操作，实际上这些状态必须出现在栈中，其所在的字段就是存放文法符号的字段。

### 第五章总结

* **继承属性和综合属性**-语法制导定义可以使用两种属性。一棵语法分析树结点上的综合属性根据该结点的子结点的属性计算得到。一个结点上的继承属性根据它的父结点和/或兄弟结点的属性计算得到。
* **依赖图**-给定一棵语法分析树和一个SDD，在各个语法分析树结点所关联的属性实例上面画上边，以指明位于边的头部属性值要根据位于边的尾部的属性值计算得到。
* **循环定义**-在一个有问题的SDD中，发现存在一些语法分析树，无法找到一个顺序来计算所有结点上的所有属性的值。这些语法分析树关联的依赖图中存在环。确定一个SDD是否存在这种带环的依赖图是非常困难的。
* **S属性定义**-在一个S属性的SDD中，所有的属性都是综合的。
* **L属性定义**-在一个L属性的SDD中，属性可能是继承的，也可能是综合的。然而，一个语法分析树结点上的继承属性和位于它左边的兄弟结点的（任意）属性。
* **抽象语法树**-一棵抽象语法树中的每个结点代表一个构造；某个结点的子结点表示该结点所对应的构造的有意义的组成部分。
* **实现S属性定义的SDD**-一个S属性定义可以通过一个动作都在产生式尾部的SDT（后缀SDT）来实现。这些动作通过产生式体中的各个符号的综合属性来计算产生式头的综合属性。如果基础文法是LR的，那么这个SDT可以在一个LR语法分析栈上实现。
* **从SDT中消除左递归**-如果一个SDT只有副作用（即不计算属性值），那么消除文法左递归的标准方法允许把语义动作当作终结符号移动到新文法当中。计算属性时，如果这个SDT是后缀SDT，那么仍然可以消除左递归。
* **用递归下降语法分析实现L属性的SDD**-如果有一个L属性定义，且其基础文法可以用自顶向下方法进行语法分析。就可以构造出一个不带回溯的递归下降语法分析器来实现这个翻译。继承属性变成了非终结符号对应函数的参数，而综合属性由该函数返回。
* **实现LL文法之上的L属性的SDD**-每个以LL文法为基础文法的L属性定义可以在语法分析过程中实现。用于存放一个非终结符号的综合属性的记录被放在栈中这个非终结符号之下，而一个非终结符号的继承属性和这个非终结符号存放在一起。栈中还放置了动作记录，以便在适当的时候计算属性值。
* **以自底向上的方式实现一个在LL文法之上的L属性SDD**-一个以LL文法为基础文法的L属性定义可以转换成一个以LR文法为基础文法的翻译方案，且这个翻译可以和自底向上的语法分析过程一起执行。文法的转换过程中引入了“标记”的非终结符号。这些符号出现在自底向上语法分析栈中，并保存了栈中位于它上方的非终结符号的继承属性。在栈中，综合属性和它的非终结符号放在一起。

## 第六章：中间代码生成

## 第七章：运行时环境

## 第八章：中间代码生成

## 第九章：代码生成

## 第十章：代码优化

<!-- 龙书第2版看到了第229页 page：244 >
<!-- 龙书第3版看到了第...页 >
