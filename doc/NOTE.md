


# 《编译原理》《Principles of Compiler Design》(龙书)笔记

主要包括词法分析、语法分析、语法制导分析、类型检查、运行环境、中间代码生成、代码生成、代码优化等

## 第一章：编译简介

编译器的编写涉及到程序设计语言，计算机体系结构、语言理论、算法和软件工程等学科。

编译器是一个程序，读入某种语言(**源语言**)编写的程序并将其翻译成一个与之等价的另一种语言(**目标语言**)编写的程序。作为这个翻译过程的一个重要部分，编译器能够将用于报告被编译的源程序中出现的错误。

不同的语言需要不同的编译器。根据编译器的构造方法或者要实现的功能，编译器被分为**一遍编译器**、**多遍编译器**、**装入并执行编译器**、**调试编译器**、**优化编译器**等多种类别。实际上，任何编译器所要完成的基本任务都是相同的。通过理解这些任务，可以利用同样的基本技术为各种各样的源语言和目标机器构建编译器。

编译器的早期工作主要集中在如何把算术表达式翻译成机器代码。

编译的组成：

* **分析**-分析部分将源程序切分成一些基本块并形成源程序的中间表示
* **综合**-综合部分把源程序的中间表示转换为所需的目标程序

在分析期间，源程序所蕴含的操作将被确定下来并被表示成一个称为**语法树**的分层结构。语法树的每个节点表示一个操作，该节点的子节点表示这个操作的参数。

首先完成某种类型分析的软件工具

* **结构编辑器**-结构编辑器将一个命令序列作为输入来构造一个源程序。如可以检查输入的格式是否正确，自动地提供关键字，自动匹配括号
* **智能打印机**-智能打印机能够对程序进行分析，打印出结构清晰的程序。
* **静态检查器**-读入一个程序并分析，不运行的情况下发现程序的潜在错误。如可以检查出源程序永远不能被执行的语句，也可以查出变量在被定义前被引用。
* **解释器**-解释器不是通过翻译来产生目标程序，而是直接执行源程序中蕴含的操作。

当然编译器不一定用于编译程序到汇编，还可以用于:

* **文本格式器**-文本格式器输入是一个字符流。输入字符流中的多数字符串是需要排版输出的字符串
* **硅编译器**-输入是一个源程序，输出是一个以适当语言书写的电路设计
* **查询解释器**-查询解释器把含有关系和布尔运算的谓词翻译成数据库命令，在数据库中查询满足该谓词的记录。

### 编译器的前驱和后继

源程序->预处理器->编译器->目标汇编程序->汇编器->可重定位机器代码->装载器->绝对机器代码

预处理器可以将存储在不同文件中的程序模块哦集成为一个完整的源程序，也能够把源程序中称为宏的缩写语句展开为原始语句加入到源程序中。

**源程序的分析过程**

* **线性分析**-从左到右地读构成源程序的字符流，而且把字符流分组为多个**记号(token)**,而记号是具有整体含义的字符序列
* **层次分析**-在层次分析中，字符串或记号在层次上划分为具有一定层次的多个嵌套组，每个嵌套组具有整体的含义
* **语义分析**-进行某些检查，以确保程序各个组成部分确实是有意义的组合在一起的。

1. 词法分析：在编译器中，线性分析被称为词法分析或者扫描。

例如，在词法分析中，一下赋值语句的字符串将被分组为以下记号token组

```
position := initial + rate * 60
```
 
* 标识符 `position`
* 赋值符号 `:=`
* 标识符 `initial` 
* 加号 `+`
* 标识符 `rate`
* 乘号 `*`
* 数字 `60`

2. 语法分析：层次分析被称为**语法分析(parsing或者syntax analysis)**,他把源程序的记号进一步分组，产生被编译器用于生成代码的语法短语。通常，源程序的语法短语用分析树来表示。比如

```
position := initial + rate * 60
```

可以被表达为如下**分析树**

```json
{
"赋值语句 := " : {
    "left" : "标识符 position", 
    "right" : {
        "表达式 + " : {
            "left" : "表达式-标识符 initial",
            "right" : {
                "表达式 * " : {
                    "left" : "表达式-标识符 rate", 
                    "right" : "表达式-数字 60"
                }
            }
        }
    }
}
}
```

程序的层次结构通常是通过**递归规则**来表达的，可能把下述规则作为**表达式定义**的一部分：

* 任何一个标识符(identifier)都是表达式
* 任何一个数(number)都是表达式
* 如果ex1和ex2都是表达式,那么ex1 + ex2; ex1 * ex2; (ex1)也是表达式

类似地，许多序言用下列规则来递归得定义**语句**:

* 如果id1是标识符，ex1是表达式,那么id1 := ex1 是一个语句
* 如果ex1是表达式，state1是一个语句，则下述代码也是语句
```
while (ex1) do state1
if (ex1) then state1
```

*注意：词法分析和语法分析的界限在某种程度上是不确定的。决定词法分析和语法分析的界限的因素是源语言是否具有递归结构，词法结构不要递归，而语法结构常常需要递归*

上下文无关法是递归规则的一种形式化，可以用来指导语法分析

例如:在识别源语言的标识符(由字母开头的字母和数字串)时，不需要递归，只需要简单扫描输入流就可以完成标识符的识别。一般地，直到遇见一个既不是字母也不是数字的字符为止，在这之前扫描到的数字和字母归结为一个**标识符记号(identifier)**,被分组的字符存储到**符号表中**

另一方面，这种线性扫描不具有分析源语言的表达式或语句的能力。

**语法树**是**分析树**的一种压缩表示

```json
{
":=" : {
    "left" : "position", 
    "right" : {
        "+" : {
            "left" : "initial",
            "right" : {
                "*" : {
                    "left" : "rate", 
                    "right" : "toreal 60"
                }
            }
        }
    }
}
}
```

3. 语义分析

语义分析阶段检测源程序的语义错误，并收集代码生成阶段要用到的类型信息。语义分析利用语法分析阶段确定的层次结构来识别表达式和语句中的操作符和操作数

语义分析的一个重要组成部分是类型检查。类型检查负责检验每个操作符的操作数是否满足源语言的说明。例如：很多程序设计语言都要求每当一个实数用于数组的索引时都要报错。程序设计语言可能允许一些操作数的强制类型转换。例如：一个二元算术操作符的操作数可以是一个整数和一个实数。这种情况下，编译器把整数强制转换成实数

4. 文本格式器中的分析

将文本格式器的输入看成是由多个盒子构成的层次结构的说明是有益的。一个盒子是一个用某种位模式填充的矩形区域，填充的位模式表明该区域被输出设备打印成浅黑像素还是黑像素

### 编译器的各阶段

编译器是分阶段执行的，除了部分编译过程，还包括**符号表管理器**和**错误处理器**

符号表是一种数据结构，每个标识符在符号表中都有一条记录，这种数据结构允许我们快速地找到每个标识符的记录

编译的每个阶段都可能遇到错误。在编译过程中遇到错误后，必须以恰当的方式进行错误处理，使编译器能继续运行，以检测出源程序中的更多错误。发现错误即停止运行的编译器不是一个好的编译器。

**语法分析**和**语义分析**阶段通常能够处理编译器所能检测到的大部分错误。词法分析阶段能够检测出输入中不能形成源语言任何记号的错误字符串。语法分析阶段可以确定记号流中违反源语言结构（语法）规则的错误。语义分析阶段试图检测出具有正确的语法结构但对操作无意义的部分。

**源程序->词法分析器->语法分析器->语义分析器->中间代码生成器->代码优化器->代码生成器**

中间代码可以看成某种抽象机的程序。源程序的中间表示应该具有两个重要性质。一是易于产生，而是易于翻译成目标程序。

比如用**三地址码**表示，类似于某种机器的汇编语言，这种机器的每个存储单元的作用类似于寄存器。三地址码由指令序列组成，每个指令最多有三个操作数。

不同编译器产生的代码的优化程度差别很大。

编译的最后一个阶段是目标代码生成，生成可重定位的机器代码或者汇编代码。这一阶段的一个关键问题是变量的寄存器分配。

### 编译器的伙伴：预处理器

预处理产生编译器的输入，一般具有以下功能

* 宏处理：预处理器允许用户在源程序中定义宏。宏是被经常使用的较长结构的缩写。
* 文件包含：预编译器可以把头文件包含到程序正文中。例如：C语言的预处理器能够用`<global.h>`文件的内容替代源程序中的语句 `#include <global.h>`
* \"理性\"预处理器：这些处理器能把现代控制流和数据结构化机制添加到比较老式的语言中。
* 语言扩充：通过大量的内部宏定义来增强语言的能力

有些编译器能够完成汇编器的工作，产生可重定位的机器代码，交给装配器(loader)或者连接编辑器(link-editor)处理。

*汇编代码*：机器代码的容易记忆的形式。汇编代码使用名称而不是二进制代码来表示操作

汇编语言也使用宏工具，汇编语言的宏工具与前面讨论过的那些宏预处理器类似。

**两遍汇编**-最简单的汇编器对输入汇编源程序文件进行两遍扫描，每遍读入文件一次。第一遍扫描中，表示存储单元的所有标识符都被识别出来并存入符号表。在第二遍扫描中，汇编器再一次从头扫描输入文件。这一次将每个操作符翻译成机器语言中代表相应操作的二进制位序列，将代表存储单元的每个标识符翻译成符号表中该标识符的地址。

第二遍扫描的输出是可重定位的机器代码。

汇编器把汇编指令翻译成的机器代码。

装配器完成程序的装入和连接编辑两项功能。

### 编译器各阶段的分组

编译的多个阶段可以分为**前端**和**后端**两个大的阶段。前端包括依赖源语言并在很大程度上独立于目标机器的某些阶段或者某些阶段的某些部分。前端一般包括词法分析、语法分析、符号表的建立、语义分析、中间代码生成以及相关的错误处理。相当一部分代码优化工作也在前端完成。

后端包括编译器中依赖于目标机器的阶段或某些阶段的某些部分。一般来说，后端完成的任务不依赖于源语言而只依赖于中间语言。后端主要包括代码优化、代码生成以及相关的错误处理和符号表的操作。

为不同的机器编写相同源语言的编译器时，通常采用如下方法：首先为所有的机器编写相同的编译器前端或者已有的编译器前端，然后为每个机器编写编译器的后端。

还可以将不同的源语言编译成同一种中间语言，对不同的前端使用相同的后端，从而得到同一机器上的不同编译器。

**编译器的遍**

编译器的若干个阶段通常是以一遍来实现的，每遍读一次输入文件、产生一个输出文件。编译器的阶段组合为遍的方式千差万别，因此我们趋向于按阶段而不是按遍来讨论编译器。

例如词法分析、语法分析、语义分析以及中间代码生成可以被组合为一遍。这样，词法分析形成的记号流可以被直接翻译成中间代码。语法分析器根据读到的记号token识别语法结构，当需要下一个记号时，通过调用词法分析器获得所需的记号。一旦语法结构找出来了，语法分析器就调用中间代码生成器完成语义分析并生成中间代码的一部分。

**减少编译的遍数**

如果编译的遍数越少，读写中间文件的时间开销就小。但是如果将多个阶段组合为一遍，就不得不将这个程序保存在内存中，但是这样消耗的空间就急剧提高。

一般词法分析器和语法分析器之间的接口通常被限制于**单个记号token**

所以在某些情况下，可以为某些尚不知晓的信息留下空白位置，待获得这些信息后再填上这些空白位置。通过**回填**技术，把中间代码和目标代码划归到一遍中。

#### 编译器的构造工具

编译器的编写者使用*调试器*、*版本管理器*、*描述器(profiler)*等软件工具是十分有益的。

当第一批编译器被编写出来不久，用于辅助编译器编写过程的系统就出现了。这些系统常被称为编译器的编译器、编译器生成器或者翻译器编写系统。

所有语言的词法分析器除了对特殊的关键字和符号识别以外基本上都是一样的。

* 分析器生成器：这类工具生成的语法分析器一般都以上下文无关文法为基础
* 扫描器生成器：这类工具一般都根据正规表达式为基础的说明自动生成词法分析器
* 语法制导翻译引擎：产生一系列的翻译程序
* 自动代码生成器：这类工具以一个规则集合为输入。
* 数据流引擎：完成高质量代码优化所需要的很多信息都包含*数据流分析*

## 第二章：简单的一遍编译器

这章是词法分析、语法分析、语法制导翻译、类型检查、运行时环境、中间代码生成章节的内容简介。重点是编译器的前端部分：词法分析、语法分析和中间代码生成。

程序设计语言描述的两方面定义：程序模式(语言的语法)、程序含义(语言的语义)

表示法：**上下文无关**文或者BNF(Backus-Naur范式)。使用现有的表示法描述语言的语义要比描述语言的语法难的多。因此，在定义语言的语义时，使用非形式化方法和启发性实例。

**上下文无关**除了可以用于定义语言的语法之外，还可用于指导源程序的翻译。面向语法的编译技术，如**语法制导翻译技术**，对于组织编译器的前端十分有用

在语法制导翻译技术中，将构造一个把**中缀表达式**转换成**后缀表达式**的编译器

例如中缀表达式`9+5-2`的后缀表达形式为`95-2+`，可以使用一个堆栈把后缀表达式直接转换成计算该表达式的计算机代码

字符流->词法分析器->记号流->语法制导翻译器->中间表示

词法分析将每个输入字符变成一个个包含数字、标识符、关键字等复杂的词法结构

语法制导翻译器有一个语法分析器和一个中间代码生成器构成

### 语法定义

一个语法非常自然地描述了许多程序设计语言结构的层次结构。例如C语言中的if-else语句具有如下形式:

```
if (表达式) 语句 else 语句
```

整个语句是由一个关键字if、一个左括号、一个表达式、一个右括号、一条语句、关键字else和另外一条语句组成的序列。如果使用变量`expr`来标识表达式，使用变量`stmt`来标识一条语句

```
stmt -> if (expr) stmt else stmt
```

这里，箭头可以读作“可以具有形式”。这样的规则称为**产生式(production)**。在一个产生式中，像关键字if和括号这样的词法元素称为**记号(token)**,像expr和stmt这样的变量表示一个记号序列，并称之为**非终结符(nonterminal)**

**上下文无关文法**包含如下四个部分:
* 一个记号集合，称为终结符号
* 一个非终结符集合
* 一个产生式集合：每个产生式具有一个左部和右部，左部和右部由箭头连接，左部是一个非终结符，右部是记号和(或)非终结符序列
* 一个开始符号。开始符号是一个指定的非终结符

约定，定义语法时只需列出文法的产生式，并把以开始符号为左部的产生式列在最前面。数字、类似于<=的符号、类似于**while**的黑体关键字均为终结符，斜体名字表示非终结符，任何非斜体的名字或者符号都是**记号token**。为了表示上的方便，常把具有相同左部的产生式合并，写成一个产生式，其左部为所有产生式共有的那个非终结符，右部为所有产生式右部的组合，每个右部用'|'分隔，'|'读作'或'

对于表达式`9-5+2`,下面的文法描述了这些表达式的语法,产生式为：

```
list -> list + digit
list -> list - digit
list -> digit
digit -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```

左部的非终结符皆为*list*(列表)的按个产生式的右部可以合并为:

```
list -> list + digit | list - digit | digit
```

文法的记号是下列符号

```
+ - 0 1 2 3 4 5 6 7 8 9
```

斜体词*list*和*digit*是非终结符，*list*是开始非终结符，因为它所对应的产生式列在最前面。

如果一个非终结符出现在一个产生式的左部，该产生式称为该非终结符的产生式。记号串是零个或多个记号的序列。一个包含零个记号的记号串称为空串，记为**e**

从开始符号出发，反复代替产生式中的非终结符(用该非终结符的产生式的右部)，一个文法可产生一个串。由一个文法的开始符号产生的记号串形成了该文法定义的语言。

例子：Pascal语言的begin-end语句块(block)是由分号分隔的语句序列。begin-end语句块的文法结构与上述列表的差别仅在于**begin**和**end**之间允许有空语句。
begin-end语句块的文法:

```
block begin opt_stmt end

opt_stmt -> stmt_list | e
stmt_list -> stmt_list ; stmt | stmt
```

### 分析树

分析树描绘了如何从文法的开始符号开始推导出它的语言中的一个语句。如果非终结符A具有一个产生式A->XYZ,则A的一棵分析树如右图所示，内节点标记为A，A的三个子节点从左到右分别标记为X,Y和Z。

形式地说，给定一个上下文无关文法，分析树是具有如下特性的树：

1. 树根标记为开始符号
2. 每个叶节点由**记号token**或者**空串e**标记
3. 每个内节点由一个非终结符标记
4. 如果A是某个内节点的非终结符号标记，X1,X2,...,Xn是该节点从左到右排列的所有子节点的标记，则A->X1X2...Xn是一个产生式。这里，X1,X2,...,Xn是一个终结符或非终结符。对于A->e,分析树中标记为A的节点只有一个标记为e的子节点

```json
{
    "node" : "A", 
    "childrens" : [
        "X", 
        "Y",
        "Z"
    ]
}
```

一棵分析树从左到右的叶节点是这棵分析树生成的结果。分析树生成的结果是由根节点的非终结符生成或导出的串。

任何树的叶节点都满足从左到右都满足从左到右排列的自然顺序，即如果a和b具有相同的父节点，且a在b的左部，则a和a的所有后代都在b和b的所有后代的左部。

一个文法生成的语言是它的某个分析树生成的串的集合。为给定的记号串找到一个分析树的过程称为这个串的**语法分析(parsing)**

### 二义性

一棵分析树读完它的叶节点只能生成唯一的一个串，但是一个文法可能有多棵分析树生成相同的记号串。这样的文法称为具有*二义性*的文法。

判断一个文法是否具有二义性，只需检查是否存在一个具有多棵分析树的记号串。在构造程序设计语言及其编译器时，需要设计无二义性文法，或者使用增加了额外的规则解决二义性问题的二义性文法。

### 操作符operator的结合规则

在大多数的程序设计语言中，加、减、乘、除四种算术操作符都是左结合的。

某些常用操作符是右结合的，如指数操作。C语言中的赋值运算操作符‘=’号也是右结合的。

例如，在C语言中，表达式`a=b=c`等价于`a=(b=c)`

由右结合的操作符构成的串，如a=b=c,可以由如下文法产生:

```
right -> letter = right | letter
```

下述两个树给出了左结合操作符‘-’和右结合操作符‘=’的分析树的比较。可以看到‘-’分析树向左下端延伸，‘=’分析树向右下端延伸

```json
{
    "node" : "list",
    "child" : [
        {
            "node" : "list", 
            "child" : [
                {
                    "node" : "list",
                    "child" : [
                        {
                            "node" : "digit",
                            "child" : [
                                {
                                    "node" : "9",
                                    "child" : "null"
                                }
                            ]
                        }
                    ]
                },
                {
                    "node" : "-",
                    "child" : "null"
                },
                {
                    "node" : "digit",
                    "child" : "null"
                }
            ]
        },
        {
            "node" : "-",
            "child" : "null"
        },
        {
            "node" : "digit",
            "child" : [
                {
                    "node" : "2",
                    "child" : "null"
                }
            ]
        }
    ]
}
```

```json
{
    "node" : "-",
    "child" : [
        {
            "node" : "letter",
            "child" : [
                {
                    "node" : "a",
                    "child" : "null"
                }
            ]
        },
        {
            "node" : "=",
            "child" : "null"
        },
        {
            "node" : "right",
            "child" : [
                {
                    "node" : "right",
                    "child" : [
                        {
                            "node" : "letter",
                            "child" : [
                                {
                                    "node" : "b",
                                    "child" : "null"
                                }
                            ]
                        },
                        {
                            "node" : "=",
                            "child" : "null"
                        },
                        {
                            "node" : "right",
                            "child" : [
                                {
                                    "node" : "right",
                                    "child" : [
                                        {
                                            "node" : "letter",
                                            "child" : [
                                                {
                                                    "node" : "c",
                                                    "child" : "null"
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}
```

### 操作符的优先级

当不止一种操作符操作出现的时候，需要确定操作符之间的优先关系。比如乘法`*`比`+`具有更高的优先级。

在优先级表中，操作符按照优先级递增的次序排列，相同优先级的操作符出现在同一行上

```
左结合：+ -
左结合：* /
```

考虑表达式`9+5*2`

使用两个非终结符*expr*和*term*分别表示两个不同的优先级层次，使用另一个非终结符*factor*产生表达式中的基本单元。表达式中的基本单元是数字和带括号的表达式。*factor*的产生式如下：

```
factor -> digit | (expr)
```

现在考虑具有最高优先级的二元操作符`*`和`/`。由于这些操作符是左结合的。其产生式和左结合的*list*的产生式类似：

```
term -> term * factor | term / factor | factor
```

类似地，expr生成由其他操作符分隔的*term*表

```
expr -> expr + term | expr - term | term
```

所以算术表达式的最终文法为：

```
expr -> expr + term | expr - term | term
term -> term * factor | term / factor | factor
factor -> digit | (expr)
```

*语句的语法*：在多数语言中，可以使用关键字识别语句。除了赋值语句和过程调用语句以外，所有的Pascal语句都由一个关键字开始。一些Pascal语句可以用下面的二义性文法来定义，其中id表示一个标识符:

```
stmt -> id := expr
| if expr then stmt
| if expr then stmt else stmt
| while expr do stmt
| begin opt_stmts end
```

### 语法制导翻译

为了翻译程序设计语言的某个结构，除了为该结构生成的代码以外，编译器还需要保存许多信息。例如：编译器可能需要知道这个结构的类型、目标代码中第1条指令的位置、生成的指令的个数。

属性可以表示任意的信息，如类型、串、内存位置等。

### 后缀表示

表达式E的后缀形式可以归纳地定义如下：

1. 如果E是一个变量或者常量，则E的后缀表示是E本身
2. 如果E是形如`E1 op E2`的表达式，其中op是一个二元操作符，则E的后缀表示是E1'E2'op，这里E1'和E2'分别是E1和E2的后缀表示
3. 如果E是形如`(E1)`的表达式，则E1的后缀表示是E的后缀表示。

因为一个表达式的操作符的位置和每个操作符的操作个数(参数数量)只允许后缀表达式的一种解码方式，所以在后缀表示中不需要括号。例如,`(9 - 5) + 2`的后缀表示是`95-2+`,
`9 - (5 + 2)`的后缀表示是`952+-`

一个数字记号的后缀形式是该数字本身。

#### 语法制导定义

语法制导定义使用上下文无关文法来说明输入的语法结构。它通过每个文法符号和一个属性集合相关联，通过每一个产生式和一个语义规则集合相关联。

文法和语义规则集合构成了语法制导定义

翻译是一个输入到输出的映射。首先构建x的分析树。假定分析树的节点n用文法符号X标识。用X.a表示节点n上X的属性a的值。节点n上的X.a的值是使用与X产生式相关联的属性a的语义规则来计算的。每个节点都具有属性值的分析树称为注释分析树。

**综合属性**-分析树的某个节点的属性值是由其子节点的属性值确定的。一棵分析树的所有综合属性值的计算只需要分析树的一次自底向上遍历。

**注释分析树**

```json
{
    "val" : "95-2+",
    "child" : [
        {
            "val" : "expr.t = 95-",
            "child" : [
                {
                    "val" : "expr.t = 9",
                    "child" : [
                        {
                            "val" : "term.t = 9",
                            "child" : []
                        }
                    ]
                },
                {
                    "val" : "-",
                    "child" : []
                },
                {
                    "val" : "term.t = 5",
                    "child" : []
                }
            ]
        },
        {
            "val" : "+",
            "child" : []
        },
        {
            "val" : "term.t = 2",
            "child" : []
        }
    ]
}
```

#### 树的深度优先遍历DFS

本章所有的翻译都是通过按照一种预订的顺序对分析树属性的语义规则进行计算来实现的。树的遍历是指从根开始，以某种顺序访问树的每一个节点。DFS从根开始，从左到右递归访问每个节点的子节点。

一旦给定节点的所有后代都被访问，则该节点的语义规则将被计算。之所以称之为“深度优先”遍历，是因为它尽可能地访问一个节点的未访问的子节点。于是它尽可能访问离根最远的节点。

#### 翻译模式

一个翻译模式是一个上下文无关文法，其中被称为语义动作的程序段被嵌入到产生式右部。

一个翻译模式类似于语法翻译制导定义，只是语义规则的计算顺序是显式给出的。一个语义动作的执行位置通过用括号把语义动作括起来并将其放在产生式的右部来表示。

当给一个翻译模式画一棵分析树的时候，通过为语义动作构造一个特殊的子节点来指出语义动作，并使用虚线连接到其产生式的节点。

翻译模式的语义动作把翻译的输出以一次一个字符或一个字符串的形式写入一个文件。例如通过每次写`9-5+2`中一个字符的方式把表达式`9-5+2`翻译成`95-2+`，而不需要额外的空间存储子表达式的翻译。当输出按照这种方式递增地被创建时，写字符的顺序变得很重要。

作为一般规则，多数分析方法都以一种“贪心”的方式从左到右地处理输入

语法分析时决定一个记号串是否能由一个**文法**产生的过程。语法分析器应该具有构造分析树的能力，否则，不能保证翻译的正确性。

可以为任何文法构造语法分析器。实际中使用的文法一般都具有特定的形式。对于任意上下文无关文法，可以构造一个时间复杂性为`O(n^3)`的语法分析器，即在`O(n^3)`时间内完成对具有n个记号的串的语法分析，通常可以构造一个可快速分析的文法。*线性时间复杂性算法*足以分析实际中出现的所有程序设计语言

程序设计语言语法分析器总是从左到右扫描输入，每次超前扫描一个记号。

语法分析方法可以分为两类：自顶向下方法和自底向上方法。这些术语是指构造分析树节点的顺序。前者按照从根节点到叶节点的顺序构造分析树，后者按照从叶节点到根节点的顺序构造分析树。

自顶向下分析器是常用的语法分析器，其原因在于这种语法分析器可以很容易地通过自顶向下的方法手工构造出来。然而，自底向上分析方法可以处理大量文法和翻译模式，所以直接从文法产生语法分析器的软件工具通常使用自底向上的方法。

#### 自顶向下语法分析

```
type -> simple | id | array [ simple ] of type
simple -> integer | char | num dotdot num
```

为了自顶向下地构造一个分析树，从标有开始非终结符的根节点开始，反复执行下面两步

1. 在标有非终结符A的节点n，选择A的一个产生式，用该产生式右部的符号构造节点n的子节点。
2. 寻找下一个要构造子树的节点。

对于某些文法，上面的步骤可以通过一次从左到右扫描输入串来实现。输入中当前被扫描的记号通常是被称为**超前扫描符号(lookahead symbol)**。最初，扫描超前符号是输入串的第一个记号，即最左端的记号。

``` 
array [num .. num] of integer
```

```json
{
    "name" : "type",
    "child" : [
        {
            "name" : "array",
            "child" : []
        },
        {
            "name" : "[",
            "child" : []
        },
        {
            "name" : "..",
            "child" : []
        },
        {
            "name" : "simple",
            "child" : [
                {
                    "name" : "num",
                    "child" : []
                },
                {
                    "name" : "dotdot",
                    "child" : []
                },
                {
                    "name" : "num",
                    "child" : []
                }
            ]
        },
        {
            "name" : "]",
            "child" : []
        },
        {
            "name" : "of",
            "child" : []
        },
        {
            "name" : "integer",
            "child" : []
        }
    ]
}
```

如果当前被考察的分析树的节点是一个终结符，而且该终结符与超前符号匹配，则分析树的箭头和输入的箭头都进一步。输入的下一个记号称为新的超前扫描符号，分析树的下一个子节点将被考察。

#### 预测分析法

**递归下降分析法**是一种自顶向下的语法分析方法，在这种方法中，我们执行一组递归过程来处理输入串。每一个过程都唯一地与分发的一个非终结符相关联。

在预测分析法中，超前扫描符号无二义性地确定了为每个非终结符选择的过程。处理输入时调用的过程序列隐式地定义了输入串的分析树。

下面的与**预测语法分析器**由非终结符type的过程、非终结符simple的过程和一个称为match的过程组成。用match过程来简化type过程和simple过程的代码。如果变量t和超前扫描符号匹配，输入符号串的箭头将前进一步，指向下一个输入记号。

match过程改变了当前被扫描的输入记号lookahead变量的值。

```
match(array);match('[');simple;match(']');match(of);type
```

示例预测语法分析器的伪代码

```
procedure match(t : token);
begin
    if lookhead == t then
        lookhead := nexttoken;
    else error
end;

procedure type;
begin
    if lookahead is in {integer, char, num} then
        simple;
    else if lookahead == '↑' then begin
        match('↑');
        match(id);
    end
    else if lookahead == array then begin
        match(array); 
        match('[');
        simple;
        match(']');
        match(of);
        type;
    end
    else error
end

procedure simple;
begin
    if lookahead == integer then
        match(integer);
    else if lookahead == char then
        match(char);
    else if lookahead == num then begin
        match(num);
        match('..');
        match(num);
    end
    else error
end
```

在`array`和`[`匹配之后，超前扫描符号是`num`。这时，过程simple被调用

超前扫描符号指导产生式的选择。如果产生式的右部由一个记号开始，则当该记号与超前扫描符号匹配的时候这个产生式被选用

预测分析依赖于产生式右部产生的第一个符号是什么。更精确地说，令a是非终结符A的某产生式的右部。定义FIRST(a)是作为由a产生的一个或多个串的第一个符号出现的集合。
如果a是e或者可以产生e，则e也属于FIRST(a)

例如
```
FIRST(simple) = {integer, char, num}
FIRST(↑id) = {↑}
FIRST(array [ simple ] of type) = {array}
```

实际上，许多产生式的右部都由记号开始，从而简化了FIRST集合的构造。

如果有两个产生式A->a和A->b可供选用，则必须考虑相应的**FIRST集合**。无回溯的递归下降分析方法要求FIRST(a)和FIRST(b)不相交。这样超前扫描符号就可以选择正确的过程去执行。如果超前扫描符号在FIRST(a)集合中，则使用a，否则，如果超前扫描符号在FIRST(b)中，则使用b

右部是e的产生式称为e产生式，需要特殊处理。当没有其他产生式可用的时候，递归下降语法分析器把e产生式作为默认产生式使用。例如

```
stmt -> begin opt_stmts end
opt_stmts -> stmt_list | e
```

当分析到opt_stmts时，如果超前扫描符号没有在FIRST(stmt_list)集合中，则使用e产生式。如果超前扫描符号时end，这种选择是正确的，除了end之外的任何超前扫描符号都将导致一个错误，可以在stmt的语法分析中检测到。

预测语法分析器是一个由多个过程组成的程序，每个过程对应一个非终结符。每个过程完成如下两项任务

* 检查超前扫描符号，决定使用哪个生产式。如果超前扫描符号在FIRST(a)中，则选择使用右部为a的生产式。对于任何超前扫描符号，如果产生式右部存在冲突，那么我们不能在这种文法上使用这种分析方式。如果超前扫描符号不在任何其他右部的FIRST集合中，右部具有e的产生式将被使用。
* 过程通过模仿其右部来使用一个产生式。一个非终结符号导致该非终结符对应的过程被调用。一个与超前扫描符号匹配的记号导致下一个输入记号被读入。如果在某个点上，产生式的记号与超前扫描符号不匹配，则报告出错。

#### 左递归

递归下降语法分析器可能会造成无限循环。当出现下面这样一个左递归产生式时，无限循环就会出现:
```
expr -> expr + term
```
在这里，产生式右部的最左边符号和产生式左部的非终结符是相同的。假定expr对应的过程要使用这个产生式。因为右部是由expr开始的，所以expr过程被递归调用，出现了无限循环。

*注意：只有右部终结符与超前扫描符号匹配时，超前扫描符号才会发生改变*：因为产生式是以非终结符expr开始的，输入符号在递归调用期间没有机会改变，所以导致无限循环。

通过重写与递归相关的产生式，可以消除左递归产生式：

```
A -> Aa | b
```

同样的结果可以通过如下方式改写产生式得到:

```
A -> bR
R -> aR | e
```

这里R是一个新的非终结符。产生式R->aR以R自身作为产生式右部最后一个符号，因而是右递归的。

向右下侧延伸的分析树使得包含左结合操作符表达式的翻译变得困难。通过基于右递归文法的翻译模式的仔细设计，可以将表达式正确翻译成后缀形式。

### 简单表达式的翻译器

可以由C语言编写一个语法制导翻译器，这个翻译器可以把算术表达式翻译成后缀形式

先从最简单的表达式开始，即由加号和减号分隔的由数字构成的表达式，在随后的两节中将其扩展为包括数字、标识符和其他操作符。

一个语法制导翻译模式可以作为一个翻译器的规范。通常，一个给定翻译模式的文法在能够被预测语法分析器分析之前需要加以修改。预测语法分析器不能处理左递归文法，可以通过消除左递归得到一个适用于预测递归下降编译器的文法。

#### 抽象语法与具体语法。

**抽象语法树**-在一个抽象语法树中，每个节点表示一个操作符，该节点的子节点表示操作数。与此相对应的，分析树称为具体语法树，相应的文法为具体语法。

希望的翻译模式所基于的文法的分析树尽可能与语法树相同。然而有时文法是左递归的，不适用于预测分析。所以产生矛盾：一方面需要一个便于分析的文法，另一方面为了便于翻译，又需要一个不同的文法。最明显的解决方法是消除左递归。

#### 非终结符expr、term和rest的过程。

match函数把给定的记号与超前扫描符号进行匹配，然后读取输入串中的下一个符号，并将其作为新的超前扫描符号

```cpp
static char lookahead;

inline bool isdigit(char c) {
    return '0' <= c && 'c' <= '9';
}

inline bool isalpha(char c) {
    return ('a' <= c && 'c' <= 'z') || ('A' <= c && 'c' <= 'Z');
}

inline bool isidenfierchar(char c) {
    return isalpha(c) || c == '_';
}

void expr() {
    term();
    rest();
}

void rest() {
    if (lookahead == '+') {
        match('-');
        term();
        putchar('+');
        rest();
    } 
    else if (lookahead == '-') {
        match('-');
        term();
        putchar('-');
        rest();
    }
}

void term() {
    if (isdigit(lookahead)) {
        putchar(lookahead);
        match(lookahead);
    }
    else 
        error();
}

void match(char c) {

}

void error() {

}
```

#### C语言和其他Algol派生语言(如Pascal语言)之间的区别

操作|C语言|Pascal语言
-|-|-
赋值|=|:=
相等测试|==|=
不等测试|!=|<>

#### 翻译器的优化

*某些递归可以用循环替换*,如果一个过程中执行的最后一条语句是对该过程的递归调用，则该调用称为是尾递归的。

可以使用循环代替尾递归来加速程序。对于没有参数的过程，可以用一个专一到过程开始位置的跳转语句来替换尾递归。

```cpp
void rest_override() {
    L : 
    if (lookahead == '+') {
        match('+'); term(); putchar('+'); goto L;
    } 
    else if (lookahead == '-') {
        match('-'); term(); putchar('-'); goto L;
    }
}
```

```cpp
void expr_override() {
    term();
    while (1) {
        if (lookahead == '+') {
            match('+'); term(); putchar('+'); goto L;
        } 
        else if (lookahead == '-') {
            match('-'); term(); putchar('-'); goto L;
        }
    }
}
```

函数match检查记号是否匹配。如果超前扫描符号匹配，match读入下一个输入，否则调用出错例程，报告错误信息

### 词法分析

可以为上面的翻译器增加一个词法分析器。词法分析器读入输入串，将其转换成将被语法分析器分析的记号流。

一个语言的语句是由记号串构成的。构成一个记号的输入字符序列称为词素。词法分析器和记号的词素(当然词素所对应的字节数由文件的编码决定)表示分隔开来。

#### 删除空白符和注释

许多语言允许空白符(空格、制表符、换行符)出现在记号之间。源程序中的注释一般都将被语法分析器和翻译器忽略，所以也可以看成空白符

如果词法分析器消除了空白符，语法分析器就不必再考虑空白符.修改文法使得语法中包含空白符的做法实现起来很难。

#### 常数

在一个表达式中，任何一个允许单个数字出现的位置都应该允许任何整型常数出现。因为整型常数是一个数字序列。可以通过在文法中添加产生式或者创建常数的记号使整型常数成为合法的。由于翻译器件把数作为一个单元来处理

令`num`是表示整数的记号。当一个数字序列出现在输入流中时时，词法分析器将把`num`传递给语法分析器。整数的值作为记号`num`的属性值传递给语法分析器。

如`31+28+59`就可以写成`<num, 31>` `<op, +>` `<num, 28>` `<op, +>` `<num, 59>`

### 标识符和关键字

程序设计语言使用标识符作为变量名、数组名、函数名和其他一些语言对象名。程序设计语言的文法常把标识符作为记号处理。基于这类文法的语法分析器在输入中每遇到一个标识符都赋予它们相同的记号`id`

例如词法分析器将`count = a + b`转换成记号流`<id, count>` `<op, =>` `<id, a>` `<id, b>` 

当标记为`id`的实例词素`count`,`a`,`b`时，翻译器需要某种机制来决定该词素是否出现过

## 第三章：词法分析

## 第四章：语法分析

## 第五章：语法制导翻译

## 第六章：类型检查

## 第七章：运行时环境

## 第八章：中间代码生成

## 第九章：代码生成

## 第十章：代码优化

# c4.c代码学习

[链接](https://github.com/Peefy/PeefyCompiler)

# Lua编译器源码学习

[链接](https://github.com/lua/lua)

