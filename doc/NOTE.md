
# 《编译原理》《Principles of Compiler Design》(龙书)笔记

主要包括词法分析、语法分析、语法制导分析、类型检查、运行环境、中间代码生成、代码生成、代码优化等

## 第一章：编译简介

编译器的编写涉及到程序设计语言，计算机体系结构、语言理论、算法和软件工程等学科。

编译器是一个程序，读入某种语言(**源语言**)编写的程序并将其翻译成一个与之等价的另一种语言(**目标语言**)编写的程序。作为这个翻译过程的一个重要部分，编译器能够将用于报告被编译的源程序中出现的错误。

不同的语言需要不同的编译器。根据编译器的构造方法或者要实现的功能，编译器被分为**一遍编译器**、**多遍编译器**、**装入并执行编译器**、**调试编译器**、**优化编译器**等多种类别。实际上，任何编译器所要完成的基本任务都是相同的。通过理解这些任务，可以利用同样的基本技术为各种各样的源语言和目标机器构建编译器。

编译器的早期工作主要集中在如何把算术表达式翻译成机器代码。

编译的组成：

* **分析**-分析部分将源程序切分成一些基本块并形成源程序的中间表示
* **综合**-综合部分把源程序的中间表示转换为所需的目标程序

在分析期间，源程序所蕴含的操作将被确定下来并被表示成一个称为**语法树**的分层结构。语法树的每个节点表示一个操作，该节点的子节点表示这个操作的参数。

首先完成某种类型分析的软件工具

* **结构编辑器**-结构编辑器将一个命令序列作为输入来构造一个源程序。如可以检查输入的格式是否正确，自动地提供关键字，自动匹配括号
* **智能打印机**-智能打印机能够对程序进行分析，打印出结构清晰的程序。
* **静态检查器**-读入一个程序并分析，不运行的情况下发现程序的潜在错误。如可以检查出源程序永远不能被执行的语句，也可以查出变量在被定义前被引用。
* **解释器**-解释器不是通过翻译来产生目标程序，而是直接执行源程序中蕴含的操作。

当然编译器不一定用于编译程序到汇编，还可以用于:

* **文本格式器**-文本格式器输入是一个字符流。输入字符流中的多数字符串是需要排版输出的字符串
* **硅编译器**-输入是一个源程序，输出是一个以适当语言书写的电路设计
* **查询解释器**-查询解释器把含有关系和布尔运算的谓词翻译成数据库命令，在数据库中查询满足该谓词的记录。

### 编译器的前驱和后继

源程序->预处理器->编译器->目标汇编程序->汇编器->可重定位机器代码->装载器->绝对机器代码

预处理器可以将存储在不同文件中的程序模块哦集成为一个完整的源程序，也能够把源程序中称为宏的缩写语句展开为原始语句加入到源程序中。

**源程序的分析过程**

* **线性分析**-从左到右地读构成源程序的字符流，而且把字符流分组为多个**记号(token)**,而记号是具有整体含义的字符序列
* **层次分析**-在层次分析中，字符串或记号在层次上划分为具有一定层次的多个嵌套组，每个嵌套组具有整体的含义
* **语义分析**-进行某些检查，以确保程序各个组成部分确实是有意义的组合在一起的。

1. 词法分析：在编译器中，线性分析被称为词法分析或者扫描。

例如，在词法分析中，一下赋值语句的字符串将被分组为以下记号token组

```
position := initial + rate * 60
```
 
* 标识符 `position`
* 赋值符号 `:=`
* 标识符 `initial` 
* 加号 `+`
* 标识符 `rate`
* 乘号 `*`
* 数字 `60`

2. 语法分析：层次分析被称为**语法分析(parsing或者syntax analysis)**,他把源程序的记号进一步分组，产生被编译器用于生成代码的语法短语。通常，源程序的语法短语用分析树来表示。比如

```
position := initial + rate * 60
```

可以被表达为如下**分析树**

```json
{
"赋值语句 := " : {
    "left" : "标识符 position", 
    "right" : {
        "表达式 + " : {
            "left" : "表达式-标识符 initial",
            "right" : {
                "表达式 * " : {
                    "left" : "表达式-标识符 rate", 
                    "right" : "表达式-数字 60"
                }
            }
        }
    }
}
}
```

程序的层次结构通常是通过**递归规则**来表达的，可能把下述规则作为**表达式定义**的一部分：

* 任何一个标识符(identifier)都是表达式
* 任何一个数(number)都是表达式
* 如果ex1和ex2都是表达式,那么ex1 + ex2; ex1 * ex2; (ex1)也是表达式

类似地，许多序言用下列规则来递归得定义**语句**:

* 如果id1是标识符，ex1是表达式,那么id1 := ex1 是一个语句
* 如果ex1是表达式，state1是一个语句，则下述代码也是语句
```
while (ex1) do state1
if (ex1) then state1
```

*注意：词法分析和语法分析的界限在某种程度上是不确定的。决定词法分析和语法分析的界限的因素是源语言是否具有递归结构，词法结构不要递归，而语法结构常常需要递归*

上下文无关法是递归规则的一种形式化，可以用来指导语法分析

例如:在识别源语言的标识符(由字母开头的字母和数字串)时，不需要递归，只需要简单扫描输入流就可以完成标识符的识别。一般地，直到遇见一个既不是字母也不是数字的字符为止，在这之前扫描到的数字和字母归结为一个**标识符记号(identifier)**,被分组的字符存储到**符号表中**

另一方面，这种线性扫描不具有分析源语言的表达式或语句的能力。

**语法树**是**分析树**的一种压缩表示

```json
{
":=" : {
    "left" : "position", 
    "right" : {
        "+" : {
            "left" : "initial",
            "right" : {
                "*" : {
                    "left" : "rate", 
                    "right" : "toreal 60"
                }
            }
        }
    }
}
}
```

3. 语义分析

语义分析阶段检测源程序的语义错误，并收集代码生成阶段要用到的类型信息。语义分析利用语法分析阶段确定的层次结构来识别表达式和语句中的操作符和操作数

语义分析的一个重要组成部分是类型检查。类型检查负责检验每个操作符的操作数是否满足源语言的说明。例如：很多程序设计语言都要求每当一个实数用于数组的索引时都要报错。程序设计语言可能允许一些操作数的强制类型转换。例如：一个二元算术操作符的操作数可以是一个整数和一个实数。这种情况下，编译器把整数强制转换成实数

4. 文本格式器中的分析

将文本格式器的输入看成是由多个盒子构成的层次结构的说明是有益的。一个盒子是一个用某种位模式填充的矩形区域，填充的位模式表明该区域被输出设备打印成浅黑像素还是黑像素

### 编译器的各阶段

编译器是分阶段执行的，除了部分编译过程，还包括**符号表管理器**和**错误处理器**

符号表是一种数据结构，每个标识符在符号表中都有一条记录，这种数据结构允许我们快速地找到每个标识符的记录

编译的每个阶段都可能遇到错误。在编译过程中遇到错误后，必须以恰当的方式进行错误处理，使编译器能继续运行，以检测出源程序中的更多错误。发现错误即停止运行的编译器不是一个好的编译器。

**语法分析**和**语义分析**阶段通常能够处理编译器所能检测到的大部分错误。词法分析阶段能够检测出输入中不能形成源语言任何记号的错误字符串。语法分析阶段可以确定记号流中违反源语言结构（语法）规则的错误。语义分析阶段试图检测出具有正确的语法结构但对操作无意义的部分。

**源程序->词法分析器->语法分析器->语义分析器->中间代码生成器->代码优化器->代码生成器**

中间代码可以看成某种抽象机的程序。源程序的中间表示应该具有两个重要性质。一是易于产生，而是易于翻译成目标程序。

比如用**三地址码**表示，类似于某种机器的汇编语言，这种机器的每个存储单元的作用类似于寄存器。三地址码由指令序列组成，每个指令最多有三个操作数。

不同编译器产生的代码的优化程度差别很大。

编译的最后一个阶段是目标代码生成，生成可重定位的机器代码或者汇编代码。这一阶段的一个关键问题是变量的寄存器分配。

### 编译器的伙伴：预处理器

预处理产生编译器的输入，一般具有以下功能

* 宏处理：预处理器允许用户在源程序中定义宏。宏是被经常使用的较长结构的缩写。
* 文件包含：预编译器可以把头文件包含到程序正文中。例如：C语言的预处理器能够用`<global.h>`文件的内容替代源程序中的语句 `#include <global.h>`
* \"理性\"预处理器：这些处理器能把现代控制流和数据结构化机制添加到比较老式的语言中。
* 语言扩充：通过大量的内部宏定义来增强语言的能力

有些编译器能够完成汇编器的工作，产生可重定位的机器代码，交给装配器(loader)或者连接编辑器(link-editor)处理。

*汇编代码*：机器代码的容易记忆的形式。汇编代码使用名称而不是二进制代码来表示操作

汇编语言也使用宏工具，汇编语言的宏工具与前面讨论过的那些宏预处理器类似。

**两遍汇编**-最简单的汇编器对输入汇编源程序文件进行两遍扫描，每遍读入文件一次。第一遍扫描中，表示存储单元的所有标识符都被识别出来并存入符号表。在第二遍扫描中，汇编器再一次从头扫描输入文件。这一次将每个操作符翻译成机器语言中代表相应操作的二进制位序列，将代表存储单元的每个标识符翻译成符号表中该标识符的地址。

第二遍扫描的输出是可重定位的机器代码。

汇编器把汇编指令翻译成的机器代码。

装配器完成程序的装入和连接编辑两项功能。

### 编译器各阶段的分组

编译的多个阶段可以分为**前端**和**后端**两个大的阶段。前端包括依赖源语言并在很大程度上独立于目标机器的某些阶段或者某些阶段的某些部分。前端一般包括词法分析、语法分析、符号表的建立、语义分析、中间代码生成以及相关的错误处理。相当一部分代码优化工作也在前端完成。

后端包括编译器中依赖于目标机器的阶段或某些阶段的某些部分。一般来说，后端完成的任务不依赖于源语言而只依赖于中间语言。后端主要包括代码优化、代码生成以及相关的错误处理和符号表的操作。

为不同的机器编写相同源语言的编译器时，通常采用如下方法：首先为所有的机器编写相同的编译器前端或者已有的编译器前端，然后为每个机器编写编译器的后端。

还可以将不同的源语言编译成同一种中间语言，对不同的前端使用相同的后端，从而得到同一机器上的不同编译器。

**编译器的遍**

编译器的若干个阶段通常是以一遍来实现的，每遍读一次输入文件、产生一个输出文件。编译器的阶段组合为遍的方式千差万别，因此我们趋向于按阶段而不是按遍来讨论编译器。

例如词法分析、语法分析、语义分析以及中间代码生成可以被组合为一遍。这样，词法分析形成的记号流可以被直接翻译成中间代码。语法分析器根据读到的记号token识别语法结构，当需要下一个记号时，通过调用词法分析器获得所需的记号。一旦语法结构找出来了，语法分析器就调用中间代码生成器完成语义分析并生成中间代码的一部分。

**减少编译的遍数**

如果编译的遍数越少，读写中间文件的时间开销就小。但是如果将多个阶段组合为一遍，就不得不将这个程序保存在内存中，但是这样消耗的空间就急剧提高。

一般词法分析器和语法分析器之间的接口通常被限制于**单个记号token**

所以在某些情况下，可以为某些尚不知晓的信息留下空白位置，待获得这些信息后再填上这些空白位置。通过**回填**技术，把中间代码和目标代码划归到一遍中。

#### 编译器的构造工具

编译器的编写者使用*调试器*、*版本管理器*、*描述器(profiler)*等软件工具是十分有益的。

当第一批编译器被编写出来不久，用于辅助编译器编写过程的系统就出现了。这些系统常被称为编译器的编译器、编译器生成器或者翻译器编写系统。

所有语言的词法分析器除了对特殊的关键字和符号识别以外基本上都是一样的。

* 分析器生成器：这类工具生成的语法分析器一般都以上下文无关文法为基础
* 扫描器生成器：这类工具一般都根据正规表达式为基础的说明自动生成词法分析器
* 语法制导翻译引擎：产生一系列的翻译程序
* 自动代码生成器：这类工具以一个规则集合为输入。
* 数据流引擎：完成高质量代码优化所需要的很多信息都包含*数据流分析*

## 第二章：简单的一遍编译器

这章是词法分析、语法分析、语法制导翻译、类型检查、运行时环境、中间代码生成章节的内容简介。重点是编译器的前端部分：词法分析、语法分析和中间代码生成。

程序设计语言描述的两方面定义：程序模式(语言的语法)、程序含义(语言的语义)

表示法：**上下文无关**文或者BNF(Backus-Naur范式)。使用现有的表示法描述语言的语义要比描述语言的语法难的多。因此，在定义语言的语义时，使用非形式化方法和启发性实例。

**上下文无关**除了可以用于定义语言的语法之外，还可用于指导源程序的翻译。面向语法的编译技术，如**语法制导翻译技术**，对于组织编译器的前端十分有用

在语法制导翻译技术中，将构造一个把**中缀表达式**转换成**后缀表达式**的编译器

例如中缀表达式`9+5-2`的后缀表达形式为`95-2+`，可以使用一个堆栈把后缀表达式直接转换成计算该表达式的计算机代码

字符流->词法分析器->记号流->语法制导翻译器->中间表示

词法分析将每个输入字符变成一个个包含数字、标识符、关键字等复杂的词法结构

语法制导翻译器有一个语法分析器和一个中间代码生成器构成

### 语法定义

一个语法非常自然地描述了许多程序设计语言结构的层次结构。例如C语言中的if-else语句具有如下形式:

```
if (表达式) 语句 else 语句
```

整个语句是由一个关键字if、一个左括号、一个表达式、一个右括号、一条语句、关键字else和另外一条语句组成的序列。如果使用变量`expr`来标识表达式，使用变量`stmt`来标识一条语句

```
stmt -> if (expr) stmt else stmt
```

这里，箭头可以读作“可以具有形式”。这样的规则称为**产生式(production)**。在一个产生式中，像关键字if和括号这样的词法元素称为**记号(token)**,像expr和stmt这样的变量表示一个记号序列，并称之为**非终结符(nonterminal)**

**上下文无关文法**包含如下四个部分:
* 一个记号集合，称为终结符号
* 一个非终结符集合
* 一个产生式集合：每个产生式具有一个左部和右部，左部和右部由箭头连接，左部是一个非终结符，右部是记号和(或)非终结符序列
* 一个开始符号。开始符号是一个指定的非终结符

约定，定义语法时只需列出文法的产生式，并把以开始符号为左部的产生式列在最前面。数字、类似于<=的符号、类似于**while**的黑体关键字均为终结符，斜体名字表示非终结符，任何非斜体的名字或者符号都是**记号token**。为了表示上的方便，常把具有相同左部的产生式合并，写成一个产生式，其左部为所有产生式共有的那个非终结符，右部为所有产生式右部的组合，每个右部用'|'分隔，'|'读作'或'

对于表达式`9-5+2`,下面的文法描述了这些表达式的语法,产生式为：

```
list -> list + digit
list -> list - digit
list -> digit
digit -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```

左部的非终结符皆为*list*(列表)的按个产生式的右部可以合并为:

```
list -> list + digit | list - digit | digit
```

文法的记号是下列符号

```
+ - 0 1 2 3 4 5 6 7 8 9
```

斜体词*list*和*digit*是非终结符，*list*是开始非终结符，因为它所对应的产生式列在最前面。

如果一个非终结符出现在一个产生式的左部，该产生式称为该非终结符的产生式。记号串是零个或多个记号的序列。一个包含零个记号的记号串称为空串，记为**e**

从开始符号出发，反复代替产生式中的非终结符(用该非终结符的产生式的右部)，一个文法可产生一个串。由一个文法的开始符号产生的记号串形成了该文法定义的语言。

例子：Pascal语言的begin-end语句块(block)是由分号分隔的语句序列。begin-end语句块的文法结构与上述列表的差别仅在于**begin**和**end**之间允许有空语句。
begin-end语句块的文法:

```
block begin opt_stmt end

opt_stmt -> stmt_list | e
stmt_list -> stmt_list ; stmt | stmt
```

### 分析树

分析树描绘了如何从文法的开始符号开始推导出它的语言中的一个语句。如果非终结符A具有一个产生式A->XYZ,则A的一棵分析树如右图所示，内节点标记为A，A的三个子节点从左到右分别标记为X,Y和Z。

形式地说，给定一个上下文无关文法，分析树是具有如下特性的树：

1. 树根标记为开始符号
2. 每个叶节点由**记号token**或者**空串e**标记
3. 每个内节点由一个非终结符标记
4. 如果A是某个内节点的非终结符号标记，X1,X2,...,Xn是该节点从左到右排列的所有子节点的标记，则A->X1X2...Xn是一个产生式。这里，X1,X2,...,Xn是一个终结符或非终结符。对于A->e,分析树中标记为A的节点只有一个标记为e的子节点

```json
{
    "node" : "A", 
    "childrens" : [
        "X", 
        "Y",
        "Z"
    ]
}
```

一棵分析树从左到右的叶节点是这棵分析树生成的结果。分析树生成的结果是由根节点的非终结符生成或导出的串。

任何树的叶节点都满足从左到右都满足从左到右排列的自然顺序，即如果a和b具有相同的父节点，且a在b的左部，则a和a的所有后代都在b和b的所有后代的左部。

一个文法生成的语言是它的某个分析树生成的串的集合。为给定的记号串找到一个分析树的过程称为这个串的**语法分析(parsing)**

### 二义性

一棵分析树读完它的叶节点只能生成唯一的一个串，但是一个文法可能有多棵分析树生成相同的记号串。这样的文法称为具有*二义性*的文法。

判断一个文法是否具有二义性，只需检查是否存在一个具有多棵分析树的记号串。在构造程序设计语言及其编译器时，需要设计无二义性文法，或者使用增加了额外的规则解决二义性问题的二义性文法。

### 操作符operator的结合规则

在大多数的程序设计语言中，加、减、乘、除四种算术操作符都是左结合的。

某些常用操作符是右结合的，如指数操作。C语言中的赋值运算操作符‘=’号也是右结合的。

例如，在C语言中，表达式`a=b=c`等价于`a=(b=c)`

由右结合的操作符构成的串，如a=b=c,可以由如下文法产生:

```
right -> letter = right | letter
```

下述两个树给出了左结合操作符‘-’和右结合操作符‘=’的分析树的比较。可以看到‘-’分析树向左下端延伸，‘=’分析树向右下端延伸

```json
{
    "node" : "list",
    "child" : [
        {
            "node" : "list", 
            "child" : [
                {
                    "node" : "list",
                    "child" : [
                        {
                            "node" : "digit",
                            "child" : [
                                {
                                    "node" : "9",
                                    "child" : "null"
                                }
                            ]
                        }
                    ]
                },
                {
                    "node" : "-",
                    "child" : "null"
                },
                {
                    "node" : "digit",
                    "child" : "null"
                }
            ]
        },
        {
            "node" : "-",
            "child" : "null"
        },
        {
            "node" : "digit",
            "child" : [
                {
                    "node" : "2",
                    "child" : "null"
                }
            ]
        }
    ]
}
```

```json
{
    "node" : "-",
    "child" : [
        {
            "node" : "letter",
            "child" : [
                {
                    "node" : "a",
                    "child" : "null"
                }
            ]
        },
        {
            "node" : "=",
            "child" : "null"
        },
        {
            "node" : "right",
            "child" : [
                {
                    "node" : "right",
                    "child" : [
                        {
                            "node" : "letter",
                            "child" : [
                                {
                                    "node" : "b",
                                    "child" : "null"
                                }
                            ]
                        },
                        {
                            "node" : "=",
                            "child" : "null"
                        },
                        {
                            "node" : "right",
                            "child" : [
                                {
                                    "node" : "right",
                                    "child" : [
                                        {
                                            "node" : "letter",
                                            "child" : [
                                                {
                                                    "node" : "c",
                                                    "child" : "null"
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}
```

### 操作符的优先级

当不止一种操作符操作出现的时候，需要确定操作符之间的优先关系。比如乘法`*`比`+`具有更高的优先级。

在优先级表中，操作符按照优先级递增的次序排列，相同优先级的操作符出现在同一行上

```
左结合：+ -
左结合：* /
```

考虑表达式`9+5*2`

使用两个非终结符*expr*和*term*分别表示两个不同的优先级层次，使用另一个非终结符*factor*产生表达式中的基本单元。表达式中的基本单元是数字和带括号的表达式。*factor*的产生式如下：

```
factor -> digit | (expr)
```

现在考虑具有最高优先级的二元操作符`*`和`/`。由于这些操作符是左结合的。其产生式和左结合的*list*的产生式类似：

```
term -> term * factor | term / factor | factor
```

类似地，expr生成由其他操作符分隔的*term*表

```
expr -> expr + term | expr - term | term
```

所以算术表达式的最终文法为：

```
expr -> expr + term | expr - term | term
term -> term * factor | term / factor | factor
factor -> digit | (expr)
```

*语句的语法*：在多数语言中，可以使用关键字识别语句。除了赋值语句和过程调用语句以外，所有的Pascal语句都由一个关键字开始。一些Pascal语句可以用下面的二义性文法来定义，其中id表示一个标识符:

```
stmt -> id := expr
| if expr then stmt
| if expr then stmt else stmt
| while expr do stmt
| begin opt_stmts end
```

### 语法制导翻译

为了翻译程序设计语言的某个结构，除了为该结构生成的代码以外，编译器还需要保存许多信息。例如：编译器可能需要知道这个结构的类型、目标代码中第1条指令的位置、生成的指令的个数。

属性可以表示任意的信息，如类型、串、内存位置等。

### 后缀表示

表达式E的后缀形式可以归纳地定义如下：

1. 如果E是一个变量或者常量，则E的后缀表示是E本身
2. 如果E是形如`E1 op E2`的表达式，其中op是一个二元操作符，则E的后缀表示是E1'E2'op，这里E1'和E2'分别是E1和E2的后缀表示
3. 如果E是形如`(E1)`的表达式，则E1的后缀表示是E的后缀表示。

因为一个表达式的操作符的位置和每个操作符的操作个数(参数数量)只允许后缀表达式的一种解码方式，所以在后缀表示中不需要括号。例如,`(9 - 5) + 2`的后缀表示是`95-2+`,
`9 - (5 + 2)`的后缀表示是`952+-`

一个数字记号的后缀形式是该数字本身。

#### 语法制导定义

语法制导定义使用上下文无关文法来说明输入的语法结构。它通过每个文法符号和一个属性集合相关联，通过每一个产生式和一个语义规则集合相关联。

文法和语义规则集合构成了语法制导定义

翻译是一个输入到输出的映射。首先构建x的分析树。假定分析树的节点n用文法符号X标识。用X.a表示节点n上X的属性a的值。节点n上的X.a的值是使用与X产生式相关联的属性a的语义规则来计算的。每个节点都具有属性值的分析树称为注释分析树。

**综合属性**-分析树的某个节点的属性值是由其子节点的属性值确定的。一棵分析树的所有综合属性值的计算只需要分析树的一次自底向上遍历。

**注释分析树**

```json
{
    "val" : "95-2+",
    "child" : [
        {
            "val" : "expr.t = 95-",
            "child" : [
                {
                    "val" : "expr.t = 9",
                    "child" : [
                        {
                            "val" : "term.t = 9",
                            "child" : []
                        }
                    ]
                },
                {
                    "val" : "-",
                    "child" : []
                },
                {
                    "val" : "term.t = 5",
                    "child" : []
                }
            ]
        },
        {
            "val" : "+",
            "child" : []
        },
        {
            "val" : "term.t = 2",
            "child" : []
        }
    ]
}
```

#### 树的深度优先遍历DFS

本章所有的翻译都是通过按照一种预订的顺序对分析树属性的语义规则进行计算来实现的。树的遍历是指从根开始，以某种顺序访问树的每一个节点。DFS从根开始，从左到右递归访问每个节点的子节点。

一旦给定节点的所有后代都被访问，则该节点的语义规则将被计算。之所以称之为“深度优先”遍历，是因为它尽可能地访问一个节点的未访问的子节点。于是它尽可能访问离根最远的节点。

#### 翻译模式

一个翻译模式是一个上下文无关文法，其中被称为语义动作的程序段被嵌入到产生式右部。

一个翻译模式类似于语法翻译制导定义，只是语义规则的计算顺序是显式给出的。一个语义动作的执行位置通过用括号把语义动作括起来并将其放在产生式的右部来表示。

当给一个翻译模式画一棵分析树的时候，通过为语义动作构造一个特殊的子节点来指出语义动作，并使用虚线连接到其产生式的节点。

翻译模式的语义动作把翻译的输出以一次一个字符或一个字符串的形式写入一个文件。例如通过每次写`9-5+2`中一个字符的方式把表达式`9-5+2`翻译成`95-2+`，而不需要额外的空间存储子表达式的翻译。当输出按照这种方式递增地被创建时，写字符的顺序变得很重要。

作为一般规则，多数分析方法都以一种“贪心”的方式从左到右地处理输入

语法分析时决定一个记号串是否能由一个**文法**产生的过程。语法分析器应该具有构造分析树的能力，否则，不能保证翻译的正确性。

可以为任何文法构造语法分析器。实际中使用的文法一般都具有特定的形式。对于任意上下文无关文法，可以构造一个时间复杂性为`O(n^3)`的语法分析器，即在`O(n^3)`时间内完成对具有n个记号的串的语法分析，通常可以构造一个可快速分析的文法。*线性时间复杂性算法*足以分析实际中出现的所有程序设计语言

程序设计语言语法分析器总是从左到右扫描输入，每次超前扫描一个记号。

语法分析方法可以分为两类：自顶向下方法和自底向上方法。这些术语是指构造分析树节点的顺序。前者按照从根节点到叶节点的顺序构造分析树，后者按照从叶节点到根节点的顺序构造分析树。

自顶向下分析器是常用的语法分析器，其原因在于这种语法分析器可以很容易地通过自顶向下的方法手工构造出来。然而，自底向上分析方法可以处理大量文法和翻译模式，所以直接从文法产生语法分析器的软件工具通常使用自底向上的方法。

#### 自顶向下语法分析

```
type -> simple | id | array [ simple ] of type
simple -> integer | char | num dotdot num
```

为了自顶向下地构造一个分析树，从标有开始非终结符的根节点开始，反复执行下面两步

1. 在标有非终结符A的节点n，选择A的一个产生式，用该产生式右部的符号构造节点n的子节点。
2. 寻找下一个要构造子树的节点。

对于某些文法，上面的步骤可以通过一次从左到右扫描输入串来实现。输入中当前被扫描的记号通常是被称为**超前扫描符号(lookahead symbol)**。最初，扫描超前符号是输入串的第一个记号，即最左端的记号。

``` 
array [num .. num] of integer
```

```json
{
    "name" : "type",
    "child" : [
        {
            "name" : "array",
            "child" : []
        },
        {
            "name" : "[",
            "child" : []
        },
        {
            "name" : "..",
            "child" : []
        },
        {
            "name" : "simple",
            "child" : [
                {
                    "name" : "num",
                    "child" : []
                },
                {
                    "name" : "dotdot",
                    "child" : []
                },
                {
                    "name" : "num",
                    "child" : []
                }
            ]
        },
        {
            "name" : "]",
            "child" : []
        },
        {
            "name" : "of",
            "child" : []
        },
        {
            "name" : "integer",
            "child" : []
        }
    ]
}
```

如果当前被考察的分析树的节点是一个终结符，而且该终结符与超前符号匹配，则分析树的箭头和输入的箭头都进一步。输入的下一个记号称为新的超前扫描符号，分析树的下一个子节点将被考察。

#### 预测分析法

**递归下降分析法**是一种自顶向下的语法分析方法，在这种方法中，我们执行一组递归过程来处理输入串。每一个过程都唯一地与分发的一个非终结符相关联。

在预测分析法中，超前扫描符号无二义性地确定了为每个非终结符选择的过程。处理输入时调用的过程序列隐式地定义了输入串的分析树。

下面的与**预测语法分析器**由非终结符type的过程、非终结符simple的过程和一个称为match的过程组成。用match过程来简化type过程和simple过程的代码。如果变量t和超前扫描符号匹配，输入符号串的箭头将前进一步，指向下一个输入记号。

match过程改变了当前被扫描的输入记号lookahead变量的值。

```
match(array);match('[');simple;match(']');match(of);type
```

示例预测语法分析器的伪代码

```
procedure match(t : token);
begin
    if lookhead == t then
        lookhead := nexttoken;
    else error
end;

procedure type;
begin
    if lookahead is in {integer, char, num} then
        simple;
    else if lookahead == '↑' then begin
        match('↑');
        match(id);
    end
    else if lookahead == array then begin
        match(array); 
        match('[');
        simple;
        match(']');
        match(of);
        type;
    end
    else error
end

procedure simple;
begin
    if lookahead == integer then
        match(integer);
    else if lookahead == char then
        match(char);
    else if lookahead == num then begin
        match(num);
        match('..');
        match(num);
    end
    else error
end
```

在`array`和`[`匹配之后，超前扫描符号是`num`。这时，过程simple被调用

超前扫描符号指导产生式的选择。如果产生式的右部由一个记号开始，则当该记号与超前扫描符号匹配的时候这个产生式被选用

预测分析依赖于产生式右部产生的第一个符号是什么。更精确地说，令a是非终结符A的某产生式的右部。定义FIRST(a)是作为由a产生的一个或多个串的第一个符号出现的集合。
如果a是e或者可以产生e，则e也属于FIRST(a)

例如
```
FIRST(simple) = {integer, char, num}
FIRST(↑id) = {↑}
FIRST(array [ simple ] of type) = {array}
```

实际上，许多产生式的右部都由记号开始，从而简化了FIRST集合的构造。

如果有两个产生式A->a和A->b可供选用，则必须考虑相应的**FIRST集合**。无回溯的递归下降分析方法要求FIRST(a)和FIRST(b)不相交。这样超前扫描符号就可以选择正确的过程去执行。如果超前扫描符号在FIRST(a)集合中，则使用a，否则，如果超前扫描符号在FIRST(b)中，则使用b

右部是e的产生式称为e产生式，需要特殊处理。当没有其他产生式可用的时候，递归下降语法分析器把e产生式作为默认产生式使用。例如

```
stmt -> begin opt_stmts end
opt_stmts -> stmt_list | e
```

当分析到opt_stmts时，如果超前扫描符号没有在FIRST(stmt_list)集合中，则使用e产生式。如果超前扫描符号时end，这种选择是正确的，除了end之外的任何超前扫描符号都将导致一个错误，可以在stmt的语法分析中检测到。

预测语法分析器是一个由多个过程组成的程序，每个过程对应一个非终结符。每个过程完成如下两项任务

* 检查超前扫描符号，决定使用哪个生产式。如果超前扫描符号在FIRST(a)中，则选择使用右部为a的生产式。对于任何超前扫描符号，如果产生式右部存在冲突，那么我们不能在这种文法上使用这种分析方式。如果超前扫描符号不在任何其他右部的FIRST集合中，右部具有e的产生式将被使用。
* 过程通过模仿其右部来使用一个产生式。一个非终结符号导致该非终结符对应的过程被调用。一个与超前扫描符号匹配的记号导致下一个输入记号被读入。如果在某个点上，产生式的记号与超前扫描符号不匹配，则报告出错。

#### 左递归

递归下降语法分析器可能会造成无限循环。当出现下面这样一个左递归产生式时，无限循环就会出现:
```
expr -> expr + term
```
在这里，产生式右部的最左边符号和产生式左部的非终结符是相同的。假定expr对应的过程要使用这个产生式。因为右部是由expr开始的，所以expr过程被递归调用，出现了无限循环。

*注意：只有右部终结符与超前扫描符号匹配时，超前扫描符号才会发生改变*：因为产生式是以非终结符expr开始的，输入符号在递归调用期间没有机会改变，所以导致无限循环。

通过重写与递归相关的产生式，可以消除左递归产生式：

```
A -> Aa | b
```

同样的结果可以通过如下方式改写产生式得到:

```
A -> bR
R -> aR | e
```

这里R是一个新的非终结符。产生式R->aR以R自身作为产生式右部最后一个符号，因而是右递归的。

向右下侧延伸的分析树使得包含左结合操作符表达式的翻译变得困难。通过基于右递归文法的翻译模式的仔细设计，可以将表达式正确翻译成后缀形式。

### 简单表达式的翻译器

可以由C语言编写一个语法制导翻译器，这个翻译器可以把算术表达式翻译成后缀形式

先从最简单的表达式开始，即由加号和减号分隔的由数字构成的表达式，在随后的两节中将其扩展为包括数字、标识符和其他操作符。

一个语法制导翻译模式可以作为一个翻译器的规范。通常，一个给定翻译模式的文法在能够被预测语法分析器分析之前需要加以修改。预测语法分析器不能处理左递归文法，可以通过消除左递归得到一个适用于预测递归下降编译器的文法。

#### 抽象语法与具体语法。

**抽象语法树**-在一个抽象语法树中，每个节点表示一个操作符，该节点的子节点表示操作数。与此相对应的，分析树称为具体语法树，相应的文法为具体语法。

希望的翻译模式所基于的文法的分析树尽可能与语法树相同。然而有时文法是左递归的，不适用于预测分析。所以产生矛盾：一方面需要一个便于分析的文法，另一方面为了便于翻译，又需要一个不同的文法。最明显的解决方法是消除左递归。

#### 非终结符expr、term和rest的过程。

match函数把给定的记号与超前扫描符号进行匹配，然后读取输入串中的下一个符号，并将其作为新的超前扫描符号

```cpp
static char lookahead;

inline bool isdigit(char c) {
    return '0' <= c && 'c' <= '9';
}

inline bool isalpha(char c) {
    return ('a' <= c && 'c' <= 'z') || ('A' <= c && 'c' <= 'Z');
}

inline bool isidenfierchar(char c) {
    return isalpha(c) || c == '_';
}

void expr() {
    term();
    rest();
}

void rest() {
    if (lookahead == '+') {
        match('-');
        term();
        putchar('+');
        rest();
    } 
    else if (lookahead == '-') {
        match('-');
        term();
        putchar('-');
        rest();
    }
}

void term() {
    if (isdigit(lookahead)) {
        putchar(lookahead);
        match(lookahead);
    }
    else 
        error();
}

void match(char c) {
    lookahead == c ? lookahead = getchar() : error();
}

void error() {
    // 打印错误信息
    printf("syntax error\n");
    // 停止
    exit(1);
}
```

#### C语言和其他Algol派生语言(如Pascal语言)之间的区别

操作|C语言|Pascal语言
-|-|-
赋值|=|:=
相等测试|==|=
不等测试|!=|<>

#### 翻译器的优化

*某些递归可以用循环替换*,如果一个过程中执行的最后一条语句是对该过程的递归调用，则该调用称为是尾递归的。

可以使用循环代替尾递归来加速程序。对于没有参数的过程，可以用一个专一到过程开始位置的跳转语句来替换尾递归。

```cpp
void rest_override() {
    L : 
    if (lookahead == '+') {
        match('+'); term(); putchar('+'); goto L;
    } 
    else if (lookahead == '-') {
        match('-'); term(); putchar('-'); goto L;
    }
}
```

```cpp
void expr_override() {
    term();
    while (1) {
        if (lookahead == '+') {
            match('+'); term(); putchar('+'); goto L;
        } 
        else if (lookahead == '-') {
            match('-'); term(); putchar('-'); goto L;
        }
    }
}
```

函数match检查记号是否匹配。如果超前扫描符号匹配，match读入下一个输入，否则调用出错例程，报告错误信息

### 词法分析

可以为上面的翻译器增加一个词法分析器。词法分析器读入输入串，将其转换成将被语法分析器分析的记号流。

一个语言的语句是由记号串构成的。构成一个记号的输入字符序列称为词素。词法分析器和记号的词素(当然词素所对应的字节数由文件的编码决定)表示分隔开来。

#### 删除空白符和注释

许多语言允许空白符(空格、制表符、换行符)出现在记号之间。源程序中的注释一般都将被语法分析器和翻译器忽略，所以也可以看成空白符

如果词法分析器消除了空白符，语法分析器就不必再考虑空白符.修改文法使得语法中包含空白符的做法实现起来很难。

#### 常数

在一个表达式中，任何一个允许单个数字出现的位置都应该允许任何整型常数出现。因为整型常数是一个数字序列。可以通过在文法中添加产生式或者创建常数的记号使整型常数成为合法的。由于翻译器件把数作为一个单元来处理

令`num`是表示整数的记号。当一个数字序列出现在输入流中时时，词法分析器将把`num`传递给语法分析器。整数的值作为记号`num`的属性值传递给语法分析器。

如`31+28+59`就可以写成`<num, 31>` `<op, +>` `<num, 28>` `<op, +>` `<num, 59>`

### 标识符和关键字

程序设计语言使用标识符作为变量名、数组名、函数名和其他一些语言对象名。程序设计语言的文法常把标识符作为记号处理。基于这类文法的语法分析器在输入中每遇到一个标识符都赋予它们相同的记号`id`

例如词法分析器将`count = a + b`转换成记号流`<id, count>` `<op, =>` `<id, a>` `<id, b>` 

当标记为`id`的实例词素`count`,`a`,`b`时，翻译器需要某种机制来决定该词素是否出现过。符号表就是这样一种机制。词素存储在符号表的一个表项中，而指向该表项的指针则称为记号`id`的一个属性

许多程序设计语言使用固定的字符串(如`begin`、`end`、`if`)作为标点符号标志或者某种结构的标识。这些字符串称为**关键字**，通常也满足形成标识符的规则。

需要一种机制来决定一个词素何时形成关键字何时形成标识符。

一般将关键字作为保留标识符，也就是说，只有字符串不是关键字时它才形成标识符。

如果相同的字符出现在多个记号的词素中，又会遇到记号分割的问题。例如，Pascal中的`<`,`<=`和`<>`中都包含`<`

### 词法分析器的接口

词法分析器介于语法分析器和输入流之间，并与这两者交互。词法分析器从输入串读字符并形成词素，然后将词素生成的记号及其属性值传递给编译器的下一个阶段。在某些情况下，词法分析器在把记号传给语法分析器之前，需要从输入串超前地读入一些字符，以确定需要传递给语法分析器的正确记号。

词法分析器一次从输入字符串中多读取若干个字符，多读入的字符经过分析后必须退回给输入流，因为它可能是下一个词素的开始符号。

词法分析器和语法分析器形成`生产者-消费者`对。词法分析器产生记号，语法分析器消费记号。产生的记号在被消费之前保存在记号缓冲区中。两者的交互仅受缓冲区大小的限制。原因是：当缓冲区满时，词法分析器不能继续产生记号；当缓冲区空时，语法分析器不能继续分析。通常，缓冲区只能存储一个记号。在这种情况下，二者之间的交互可以通过下面的方式简单地实现：使词法分析器称为被语法分析器调用并为语法分析器返回所需的记号的过程。

**输入缓冲技术**-读入字符和退回字符操作一般都通过建立一个输入缓冲区来实现。编译器每次把一组字符读入缓冲区，用一个指针指向当前已经被分析的输入部分。如果需要退回字符，只需将指针向回移动。为了能够给出详细的错误报告信息(如，必须给出错误出现在输入串的位置)，我们需要保存输入字符。输入字符的缓冲可以提高编译器的效率，每次读一组字符比每次读一个字符的效率高。

### 词法分析器例子

可以为之前的表达式翻译器构造一个简单的词法分析器。词法分析器的目的是使表达式中只允许出现空白字符和由多个数字组成的数

例如使用C语言，可以使用`<stdio.h>`中已经实现了的输入串的缓冲处理，分别调用`getchar`和`ungetc`来实现读入字符和推回字符。设c是字符变量，语句c=getchar()和ungetc(c, stdin)来实现读入字符和推回字符

使用词法分析器函数`lexan()`返回记号的整数编码(比如C语言里面的枚举)。对于num这样的记号，其编码可以用大于任何单个字符的整数编码的整数进行编码，即256。同时把全局变量tokenval设置成这串数字的值。例如：输入串中7后面跟着6，则tokenval变量的值是76

为了允许数出现在表达式中，需要对文法做一点修改。用终结符factor代替，并引入下面的产生式和语义动作：

```
factor -> (expr) | num { print(num.value) }
```

```c
void factor() {
    if (lookahead == '(') {
        match('('); expr(); match(')');
    }
    else if (lookahead == NUM) {
        printf(" %d ", tokenval); match(NUM);
    }
    else {
        error();
    }
}
```

下述给出了lexan函数的实现，每次读入一个字符到变量t。如果字符是空格或者制表符(即`'\t'`),则没有记号返回给语法分析器，只是再进行一次while循环。如果字符是一个换行符`'\n'`,仍然没有记号返回给语法分析器，只是将全局变量lineno加1。lineno用来记录输入的行数，在报错时用来指示出错行号以帮助程序调试者定位错误。

文件`<ctype.h>`中的函数`isdigit(t)`用来判定一个输入字符t是否是数字。如果是数字，其整型值由表达式t-'0'给出。对于其他字符集，该转换可能有些不同。该词法分析器将被加入到表达式翻译器。

```c
int lexan() {
    int t;
    while (1) { 
        // 从输入流中获取一个字符的ASCII码
        t = getchar();
        // 去除空格和制表符
        if (t == ' ' || t == '\t')
            ;
        // 换行符
        else if (t == '\n' || t == '\r')
            lineno += 1;
        else if (isdigit(t)) {
            tokenval = CHAR_TO_NUM(t);
            t = getchar();
            while (isdigit(t)) {
                tokenval = tokenval * 10 + CHAR_TO_NUM(t);
            }    
            ungetc(t, stdin);
            return NUM;
        } 
        else { 
            tokenval = NONE;
            return t;
        } 
    }  
} 
```

### 符号表

符号表示一种数据结构，通常用于保存源语言结构的各种信息。编译器分析阶段收集信息放入符号表，在综合阶段使用符号表中的信息生成目标代码。例如，在词法分析阶段，形成标识符的字符串或词素被存储在符号表的一个表项中。编译器的以后各阶段会在这个表项上逐步添加其他信息，如标识符的类型、用处(如用作过程名、变量名或标号)以及存储位置。在代码生成阶段，编译器使用这些信息生成存取这些变量的正确代码。

#### 符号表接口

与符号表有关的例程的功能主要是存取词素，当一个词素被保存时，也保存与该词素相关的记号。下边是在符号表上执行的操作：

* **insert(s, t)**-将字符串s和记号表td的插入符号表，返回相应表项的索引
* **lookup(s)**-到符号表中查找字符串s，如果找到则返回相应表项的索引，否则返回0

词法分析器使用lookup操作确定某个词素相关的记号。下边是在符号表上执行的操作：

* **insert(s, t)**-将字符串s和记号t的插入符号表，返回相应表项的索引
* **lookup(s)**-到符号表中查找字符串s，如果找到哦啊则返回相应表项的索引，否则

词法分析器使用lookup操作确定某个词素的项在符号表中是否已经存在。如果不存在，它使用insert操作在符号表中建立一个新表项存储该词素及相关信息。

#### 处理保留的关键字

上述符号表子程序能够处理任何保留的关键字的集合。例如，考虑具有div和mod词素的两个记号`div`和`mod`。用下面的调用来初始化符号表：

```
insert("div", div);
insert("mod", mod);
```

符号表如此初始化后，调用lookup("div")将返回记号`div`,于是div不能再被用作标识符。

*任何保留关键字的集合都可以通过适当地初始化符号表而得到正确的处理*

### 符号表的实现方法

首先不希望预留固定的大小的空间来保存形式标识符的词素，因为固定大小可能不足以保存长标识符，而对于短标识符(如i)又会造成空间的浪费。

可以使用单独的数组lexemes存储形成标识符的字符串。每一个字符串用一个字符串终结符EOS结束。EOS不会出现在任何标识符。符号表数组symtable中的每个表项都是一个包含两个域的记录：一个域是指向词素开始位置的指针域lexptr，另一个域是存储记号的token域。符号表可以更多的域以存储属性值，不作详细讨论

下面列出了处理标识符的词法分析器的伪代码

```
function lexan : integer
var lexbuf : array[0..100] of char;
    c : char;
begin
    loop begin
        读一个字符到c
        if c是空格或制表符 then
            什么也不做
        else if c是换行符 then
            lineno := lineno + 1
        else if c是一个数字 then begin
            该数字和其后数字的所表示的数的值存入tokenval
            return NUM
        end
            else if c是一个字母 then begin
                将c和其后的连续字母和数字存入lexbuf
                p := lookup(lexbuf)
                if p = 0 then
                    p := insert(lexbuf, ID);
                tokenval := p
                return 表项p的token域
            end
            else begin
                将tokenval置为NONE;
                return 字符c的整数编码
            end
        end
end
```

### 抽象堆栈机

编译器可以划分为前端和后端两部分。前端构造源程序的中间表示，后端从中间生成目标代码。一种流行的中间表示是**抽象堆栈机代码**。编译器划分为前端和后端可以使之经简单修改就可以运行在一台新机器上。

**抽象堆栈机**把*指令存储器*和*数据存储器*分开,并且所有的算术操作都在堆栈上执行。指令个数非常有限，可以分为三类：整型算术、堆栈操作和控制流

#### 算术指令

抽象机必须用中间语言实现每一个操作符。抽象机直接支持像加法和减法这样的简单操作。更复杂的操作需要由一个抽象机指令系列来实现。

为简化堆栈机的描述，假定每个算术操作对应一条指令。

一个算术表达式的抽象机代码用堆栈模拟该后缀表达式的计算。这个计算过程从左到右处理后缀表达式，遇见操作数，就将其压入**堆栈**,当遇到一个k元操作符时，它的最左面的参数在栈顶下面k-1的位置，最右面的参数在栈顶。在栈顶的k个元素上应用这个k元操作符：弹出操作数，并将结果压入堆栈。例如，对*后缀表达式*`13+5*`进行计算时，需要执行下面的动作

* 1入栈
* 3入栈
* 将栈顶的两个元素相加，从栈中弹出这两个元素，并将结果4压入堆栈
* 5入栈
* 将栈顶的两个元素相乘，从栈中弹出这两个元素，将结果20压入堆栈

最后栈顶元素20是整个表达式的最终结果。

在中间语言中，所有的值都是整数，0可以对应于布尔值false，非0值可以对应于布尔值true。布尔型操作符and和or要求其两个参数都已计算完毕

#### 左值和右值

赋值表达式左部和右部的标识符的含义是不一样的。如赋值语句
```
i := 5
i := i + 1
```
表达式的右部是一个整型值，左部是值要存放的位置。与此相似，如果p和q是指向字符的指针，表达式`q↑ := q↑`中，右部`q↑`表示一个字符，左部`p↑`表示这个字符该存储的位置。术语*左值*和*右值*分别指赋值表达式左部和右部对应的值。也就是说，右值是平常意义上的值，而左值是一个位置。

#### 堆栈操作

几个访问数据内存的指令:

* **PSH v**-将v压入栈顶
* **RVALUE l**-将存储器位置l上的数据内容压入栈
* **LVALUE l**-将存储器位置l的地址压入栈
* **POP**-弹出栈顶元素
* **:=**-栈顶元素的右值被存放到栈顶的下一个元素的左值中，且二者均被弹出
* **COPY**-把栈顶元素的副本压入栈顶

#### 表达式的翻译

**使用堆栈机计算表达式的代码与表达式的后缀表示密切相关**

根据定义，计算E+F的堆栈机代码是计算E的代码、计算F的代码以及将它们的值相加的指令的连接。因此，将表达式翻译成堆栈机代码可以通过修改翻译器得到

本节生成的表达式堆栈机代码中，数据位置是用符号地址表示的。表达式a+b翻译成

```
RVALUE a
RVALUE b
+
```

即把a和b位置上的数据压入栈顶，然后将栈顶的两个数据弹出，将其相加，把结果压入栈顶。

赋值表达式翻译成堆栈机代码的过程时：被赋值的标识符的左值压入栈顶，计算表达式，将结果的右值赋给标识符。例如，赋值语句：

```
day := (1461 * y) div 4 + (153 * m + 2) div 5 + d
```

被翻译成如下形式的代码

```
LVALUE day   
PUSH 1464
RVALUE y
*
PUSH 4
div
PUSH 153
RVALUE m

*
PUSH 2
+ PUSH 5
div
+
RVALUE d
+
:= 
```

赋值语句可以形式化地表示如下：

```
stmt -> id := expr { stmt.t := 'lvalue' || id.lexeme || expr.t || ':=' }
```

每个非终结符具有属性t,t给出这个非终结符的翻译。标识符id的属性lexeme给出了标识符的字符串表示。

#### 控制流

堆栈机是顺序执行指令的，除非碰到条件指令或者无条件转移语句。说明转移目标地址方法有如下几种：

* 转移指令的操作数给出转移的目标地址
* 转移指令操作数给出转移的相对地址(正数或负数)
* 用符号表示转移的目标地址，即机器所支持的标号

在前两种方法中，操作数有可能从栈顶获得。

例如，堆栈机的控制流指令如下:

* **LABEL l**-说明转移的目标l
* **GOTO l**-从标有l的指令开始执行下一条指令
* **GOFALSE l**-弹出栈顶值，如果是0，则转移到l
* **GOTRUE l**-弹出栈顶值，如果非0，则转移到l
* **HALT**-停止执行程序

#### 语句的翻译

条件语句和while语句的代码框架

*if*

```
expr 代码
GOFALSE out
stmt1代码
LABEL out
```

*while*

```
LABEL test
expr 代码
GOFALSE out
stmt1代码
GOTO test
LABEL out
```

在源程序的翻译中，只允许有一个`LABEL out`指令，否则，执行到`GOTO out`语句时将产生冲突而不知道将控制转到何处。因此，当翻译if语句时，需要采取某些机制，用唯一的标号替换代码框架中的out

假设newlabel是一个过程，每次调用它时，返回一个新标号。

```
stmt -> if expr then stmt1 {
    out := newlabel;
    stmt.t = expr.t ||
        'gofalse' out ||
        stmt1.t ||
        'label' out
}
```

#### 输出一个翻译

上述的表达式翻译器使用print语句逐渐生成一个表达式的翻译。类似的print语句也可以用于产生一个语句的翻译。此处不再使用print语句而使用emit过程来隐藏输出细节

```
stmt -> if 
    expr { out := newlabel; emit('GOFALSE', out); }
    then
    stmt1 { emit('label', out); }
```

当产生式中出现语义动作时，按照从左到右的顺序考虑产生式右部的每一个元素。在上面的产生式中，语义动作的顺序如下：在分析expr指令时out设置成newlabel返回的标号，然后输出`GOFALSE`指令，在分析stmt1语句时，执行语义动作，最后label指令被输出。假设在分析expr和stmt1的过程中，语义动作输出了这些非终结符的代码。

语句序列的翻译是简单地将各个语句连接起来。

多数单入口单出口的语法结构的翻译都和while语句的翻译相似。这一点将通过考虑表达式中的控制流来说明

```
procedure stmt;
var test, out: interger; /* 标号 */
begin
    if lookahead = id the begin
        emit('LVALUE', tokenval); match(id); match(':='); expr;
    end
    else if lookahead = 'if' then begin
        match('if');
        expr;
        out := newlabel;
        emit('GOFALSE', out);
        match('then');
        stmt;
        emit('LABEL', out);
    end
    else error;
end
```

表达式
```
expr1 or expr2
```
可以实现为
```
if expr1 then ture else expr2
```
下面的代码可以实现or的操作
```
COPY
GOTURE out
POP
expr2
LABEL out
```

`GOTRUE`和`GOFALSE`指令弹出栈顶数值来简化条件语句和while语句的代码生成。通过备份expr1的值，如果`GOTRUE`指令产生转移，则栈顶值为真。

用于构建一个编译器前端的语法制导技术。可以给出一个C语言的编写的翻译器，它把用分号分隔的中缀表达式序列翻译为相应的后缀表达式序列。表达式由数字、标识符、操作符(+,-,*,/,div,mod)构成。

### 翻译器的描述

记号`id`用来表示一个由字母开始的非空字母数字序列，num是一个数字序列，eof是一个表示文件结束的字符。记号由空格、制表符和换行符("空白符")分隔：记号`id`的属性lexeme给出了形成该记号的字符串。`num`的属性值value给出了由`num`表示的整型数。

#### 词法分析器模块lexer.c

词法分析器是一个`lexan()`的程序，语法分析器调用`lexan()`程序获取记号。lexan()每次读入一个字符，并将它发现的记号返回给语法分析器。与记号关联的属性的值被赋给全局变量tokenval.

下列记号是语法分析器所需要的：

```
+ - * / DIV MOD (  ) ID NUM DONE
```
ID表示一个标识符, NUM是一个数字, DONE是文件末尾字符。空白符已经被词法分析器去除。

词法分析器使用符号表程序lookup判定一个标识符词素是否曾经出现过。insert程序将新词素存储到符号表中。每当读到一个换行符，全局变量lineno加1.

#### 语法分析器模块parser.c

首先上述的翻译模式消除左递归，以使文法可以由递归下降语法分析器进行语法分析。转换后的翻译模式如下述所示.

```
start -> list eof
list -> expr; list | e
expr -> term moreterms
moreterms -> + term {print('+')} moreterms 
           | - term {print('+')} moreterms 
           | e
term -> factor morefactors
morefactors -> * factor {print('+')} morefactors 
             | / factor {print('/')} morefactors 
             | div factor {print('DIV')} morefactors 
             | mod factor {print('MOD')} morefactors 
             | e
factor -> { expr }
        | id {print(id.lexeme) }
        | num {print(num.value) }
```

函数`parse()`实现文法的启示符号，在它需要一个新的记号时调用`lexan`函数。语法分析器使用`emit`函数产生输出并用`error`函数报告语法错误

#### 输出模块emitter.c

输出模块由单个函数emit(t, tval)组成，它为具有属性值tval的记号t产生输出

#### 符号表模块symbol.c和init.c

符号表的数组symtable的每一项由一个指向lexemes数组的指针和一个表示记号的整数编码组成。insert(s, t)操作返回词素s(词素s构成记号t)在symtable中的索引。lookup(s)函数返回词素s在symtable中项的索引，如果s不存在，返回0.

init.c模块用于为符号表symtable预加载关键字。所有关键字的词素和记号表示都保存在keywords数组中，keywords数组与symtable数组有相同的类型。init()函数顺序地扫描keywords数组，利用insert()操作将关键字插入符号表。这种组织方式使得关键字的记号表示容易改变。

#### 错误处理模块error.c

错误处理模块负责错误的报告，这是极为基本的。一旦语法错误被发现，编译器将显示一条消息说明当前输入行出现错误，并停止分析。

*一种较好的错误恢复技术是使编译器跳过出错的语句，继续进行语法分析*

#### 编译器的建立

global.h

```c
#ifndef _GLOBAL_H_
#define _GLOBAL_H_

#include <stdio.h>    // 输入/输出
#include <ctype.h>    // 加载字符测试程序
#include <string.h>

#define BSIZE 128     // 缓冲区大小
#define NONE  -1
#define EOS   '\0'

#define NUM  256
#define DIV  257
#define MOD  258
#define ID   259
#define DONE 260

#ifndef pass
#define pass
#endif

extern int tokenval;  // 记号的属性值
extern int lineno;    // 行号

// 符号表的表项格式
typedef struct entry {
    char * lexptr;
    int token;
} entry;

entry symtabel[];

/* function declare  */

void error(const char* m);  // 生成所有的出错信息
void emit(int t, int tval);  // 生成输出
int lookup(char s[]); // 返回s符号表项的位置
int insert(char s[], int tok); // 插入符号表，返回s表项的位置
int lexan();  // 词法分析器 或者记号 token 
void parse(); // 分析并翻译表达式列表
void init();

#endif

```

emtter.c

```c

#include "global.h"

// 打印输出模块

// 生成输出
void emit(int t, int tval) {
    switch (t)
    {
    case '+': case '-': case '*': case '/':
        printf("%c\n", t);
        break;
    case DIV:
        printf("DIV\n"); break;
    case MOD:
        printf("MOD\n"); break;
    case NUM:
        printf("%d\n", tval); break;
    case ID:
        printf("%s\n", symtabel[tval].lexptr); break;
    default:
        printf("token %d, tokenval %d\n", t, tval); break;
    }
}
```

error.c

```c

#include "global.h"

// 错误处理模块

// 生成所有的出错信息
void error(const char* m) {
    fprintf(stderr, "line: %d : %s\n", lineno, m);
    exit(1);  /* 非正常终止 */
}

```

init.c

```c

#include "global.h"

// 初始化模块

// 关键字
entry keywords[] = {
    {"div", DIV},
    {"mod", MOD},
    {"0", 0},  // 关键字结尾
};

// 将关键字填入符号表
void init() {
    entry * p;
    for (p = keywords;p->token;p++) {
        insert(p->lexptr, p->token);
    }
}

void main() {
    init();
    parse();
    exit(0);
}

```

lexer.c

```c

#include "global.h"

// 词法分析器模块

char lexbuf[BSIZE];
int tokenval = NONE;  // 记号的属性值
int lineno = 1;    // 行号

// 词法分析器 或者记号 token 
int lexan() {
    int t;
    for (;;) {
        t = getchar();  // 从字节流获取一个字符
        if (t == ' ' || t == '\t' || t == '\v') // 去除空白符
            pass;
        else if (t == '\n' || t == '\r')  // 检测换行符
            lineno = lineno + 1;
        else if (isdigit(t)) {
            ungetc(t, stdin);
            scanf("%d", &tokenval);
            return NUM;
        }
        else if (isalpha(t)) {
            int p, b = 0;
            while (isalnum(t)) {
                lexbuf[b] = t;
                t = getchar();
                b = b + 1;
                if (b > BSIZE)
                    error("compiler error");
            }
            lexbuf[b] = EOS;
            if (t != EOF)
                ungetc(t, stdin);
            p = lookup(lexbuf);
            if (p == 0)
                p = insert(lexbuf, ID);
            tokenval = p;
            return symtabel[p].token;
        }
        else if (t == EOF)
            return DONE;
        else {
            tokenval = NONE;
            return t;
        }
    }
}

```

parse.c

```c

#include "global.h"

// 词法翻译器模块

int lookahead;

static void expr();
static void term();
static void factor();
static void match(int t);

// 分析并翻译表达式列表
void parse() {
    lookahead = lexan();
    while (lookahead != DONE) {
        // 匹配表达式
        expr(); 
        // 每个表达式结尾要匹配句尾;
        match(';');
    }
}

static void expr() {
    int t;
    term();
    while (1) {
        switch (lookahead)
        {
        // + - 优先级比* / ( ) 低，最后匹配
        case '+': case '-':
            t = lookahead;
            match(lookahead); term(); emit(t, NONE);
            break;
        default:
            return;
        }
    }
}

static void term() {
    int t;
    factor();
    while (1) {
        switch (lookahead)
        {
        case '*': case '/': case DIV: case MOD:
            t = lookahead;
            match(lookahead); factor(); emit(t, NONE);
            break;  
        default:
            return;
        }
    }
}

static void factor() {
    switch (lookahead)
    {
    case '(':
        match('('); expr(); match(')'); 
        break;
    case NUM:
        emit(NUM, tokenval); match(NUM); 
        break;
    case ID:
        emit(ID, tokenval); match(ID); 
        break;
    default:
        break;
    }
}

static void match(int t) {
    if (lookahead == t)
        lookahead = lexan();
    else 
        error("syntax error!");
}

```

symbol.c

```c

#include "global.h"

// 符号模块

#define STRMAX 999    // lexemes数组的大小
#define SYMMAX 1000   // symtable的大小

char lexemes[STRMAX];
int lastchar = -1;   // lexemes中最后引用的位置
entry symtabel[SYMMAX];
int lastentry = 0;   // symtable中最后引用的位置

// 返回s符号表项的位置
int lookup(char s[]) {
    int p = 0;
    for (p = lastentry;p > 0; p = p - 1) {
        if (strcmp(symtabel[p].lexptr, s) == 0)
            return p;
    }
    return 0;
}

// 插入符号表，返回s表项的位置
int insert(char s[], int tok) {
    int len;
    len = strlen(s);
    if (lastentry + 1 >= SYMMAX) {
        error("symbol table full!");
    }
    if (lastchar + len + 1 >= STRMAX) {
        error("lexemes array full!");
    }
    lastentry = lastentry + 1;
    symtabel[lastentry].token = tok;
    symtabel[lastentry].lexptr = &lexemes[lastchar + 1];
    lastchar = lastchar + len + 1;
    strcpy(symtabel[lastentry].lexptr, s);
    return lastentry;
}

```

## 第三章：词法分析

实现简单词法分析的简单方法包括两步：首先建立一张描述源语言记号的结构的图。然后，手工地把这张图翻译成能够识别源语言记号的程序。用这种方法可以产生有效的词法分析器。

这种词法分析器的技术也经常用于其他领域，如查询语言与信息检索系统。在每个应用中，最基本的问题是如何设计与说明一种特殊的程序，它能够完成由字符串中的模式触发的动作。

还有一些语言是用正则表达式描述模式(识别正则表达式的有穷自动机识别器)。例如，模式扫描语言AWK利用正则表达式来选择输入行进行处理，UNIX系统的shell允许用户通过正则表达式指定一组文件名，如UNIX命令`rm *.o`用来删除所有文件名以`.o`结尾的文件。

词法分析器的自动生成工具可以使具有不同背景的人员在他们各自的应用领域中使用匹配的模式。

词法分析器的生成器的最大优点是它能利用最著名的模式匹配算法为哪些不精通模式匹配技巧的人产生有效的词法分析器。

### 词法分析器的作用

词法分析(lexer)时编译的第一阶段。词法分析器的主要任务是读入输入字符，产生记号序列，提交给语法分析使用。这种交互通常可以通过使词法分析器作为语法分析器的子程序或协作程序来实现。当词法分析器收到语法分析器发出的“取下一个记号”的命令时，词法分析器读入输入字符，直到识别出下一个记号。

词法分析器是编译器中读入源程序的部分，因此它还可以完成一些相关的辅助任务。一个任务是滤掉源程序中的注释、空格、制表符、换行符；另一个任务是使编译器能将发现的错误信息与源程序的出错位置联系起来。

例如，词法分析器负责记录遇到的换行符，以便将行号与出错位置联系起来。在某些编译器中，词法分析器负责拷贝一份源程序，并将出错信息加入其中。如果源语言支持宏处理功能，可以在词法分析阶段完成这些预处理功能。

词法分析器可以分为两个阶段:第一个阶段是扫描阶段，第二个阶段是词法分析阶段。
扫描程序负责完成一些简单的任务，词法分析器要完成比较复杂的任务。
例如，Fortran编译器可以使用扫描程序从输入中清楚空格。

#### 词法分析中问题

* 词法分析和语法分析分离可以简化两者的设计
* 提高编译器的效率。编译器的大部分时间消耗在读源程序并将其切分为记号方面。采用专门的缓存技术来进行输入字符串的读取和记号的处理可以显著提高编译器的性能
* 增强编译器的可移植性。

#### 记号、模式、词素

记号|词素示例|模式的非形式描述
-|-|-
const|`const`|const
if|`if`|if
relation|`<`,`<=`,`=`,`<>`,`>`,`>=`|`<`或`<=`或`=`或`<>`或`>`或`>=`
id|`pi`,`count`,`i`,`j`,`D2`,`val_sudu`|字母打头的字母数字串(可包含下划线)
num|`3.1416`,`0`,`6.2`,`0x32`,`2e4`|任何数字常数(科学计数法、小数点、其他十进制、二进制等)
literal|`"core dumped"`|在"与"之间除"以外的任何字符(注意转移字符)

把记号作为源语言文法的终结符，用黑体名字表示记号。由记号的模式所匹配的词素表示源程序的字符串，它们是词法单位。

在多数程序设计语言中，关键字、操作符、标识符、常量、文字串和标点符号(如括号、逗号、分号)被处理为`记号token`.

记号的返回通常是通过传递代表这个记号的整数来实现的，一般是枚举或者常量，或者记号本身的ascii码

`模式` 是描述源程序中表示特定记号的词素的规则。如上述表格的`const`的模式是一个字符串const,它是一个关键字。记号`relation`的模式是6个Pascal关系操作符的集合，为了能精确地描述`id`(表示标识符)和`num`(表示数)这样更复杂的记号，将使用`正则表达式`

某些语言的约定给词法分析带来了困难。例如Fortran语言要求某些结构出现在输入行的固定位置，于是`词素对准(alignment)`对确定源程序的正确性非常重要。现代语言设计的倾向是自由格式输入，允许各种结构出现在输入行的任何地方。

不同语言在空格的处理上有较大差别。在一些语言中，空格无意义(字符串中的空格除外)。在程序中可以随意加入空格来改善其可读性。对空格的约定增加了识别`记号`的复杂性。

很多语言规定某些字符串是保留的，即它们的含义是预定义的，不能由用户改变。如果关键字不是保留的，那么词法分析器必须能区分出关键字和用户自定义的标识符。

在PL/I语言中关键字不是保留的，因而把关键字从标识符区别出来的规则相当复杂。

比如
```PL
IF THEN THEN THEN = ELSE; ELSE ELSE = THEN;
```

#### 记号的属性

如果不止一个记号的模式能匹配到一个词素，词法分析器必须为这个记号提供附加的关于匹配的特殊词素的信息。例如，模式`num`既能匹配到字符串0，也能匹配到字符串1，此时代码生成器需要知道num到底匹配了哪一个字符串。

词法分析器把与记号有关的信息收集到记号的属性中。记号影响语法分析，而属性影响记号的翻译。在实际的实现的时候，记号通常只有一个属性，即指向符号表中一个表项的指针，与记号有关的信息保存在这个对应的表项中。

为了诊断错误，不仅需要知道匹配标识符的词素，而且还需要知道这个词素第一次出现的行号。这些信息都可以存储在符号表中该标识符对应的表项内。

例如，Fortran语句`E = M * C ** 2`，可以用记号和它们的属性值组成的二元组序列表示如下
```
<id, 指向符号表中与E相关的表项的指针>
<assign_op,>
<id, 指向符号表中与M相关的表项的指针>
<multi_op,>
<id, 指向符号表中与C相关的表项的指针>
<exp_op,>
<num,整数值2>
```

注意，某些二元组不需要属性值，它的第一个分量足以标识词素。记号`num`的属性是一个整数值。当然，编译器也可以把形成数的字符串存入符号表中，并让记号`num`的属性是指向符号表中相应表项的指针。

#### 词法错误

因为词法分析器不能从全局的角度考察源程序，所以能在词法层发现的错误是有限的。如果词法分析器在如下的C程序第一遇到fi

```
fi (a == f(x))
```

它无法区别fi究竟是关键字if的错误拼写还是一个未声明的函数标识符。由于fi是合法的标识符，词法分析器必须返回该标识符的记号，而让编译器的其他阶段去处理这种错误。

有时会出现由于剩余输入的前缀不能和任何记号的模式匹配而使词法分析器无法处理的情况。此时，最简单的错误恢复策略也许是“紧急方式”恢复，即反复删掉剩余输入最前面的字符，直到词法分析器能发现一个正确的记号为止。这种恢复技术可能会给语法分析带来一些麻烦，但在交互计算中是非常有效的。

其他错误恢复动作包括:

* 删除一个多余的字符
* 插入一个遗漏的字符
* 用一个正确的字符代替一个不正确的字符
* 交换两个相邻的字符

这样的错误变换可以用于对输入错误的修补。最简单的策略是看一下剩余输入的前缀能否通过上面的一个变换变成一个合法的词素。这种策略假设大多数词法是多、漏或错一个字符或者相邻的两个字符错位的结果。

在程序中发现错误的一种方法是计算把一个错误程序转换成一个语法上正确的程序所需要的错误变换个数的最小值。

当把一个错误程序转换成一个正确程序所需的最短错误变换序列长度为k时，我们说这个程序有k个错误。最小距离错误校正是一种理论上的标准，但是因为其实现起来代价太高，实际上并不常用。然而一些试验性的编译器在进行局部校正时确实用到了最小距离标准

### 输入缓冲

**双缓冲输入方案**，为识别记号而需要进行超前扫描的情况下非常有用。

**标志(sentinel)**标记缓冲区边界

实现词法分析器最常用的三种方案：

* 使用词法分析器生成器(如Lex编译器),从基于正则表达式的说明自动产生一个词法分析器。在这种情况下，由生成器提供子程序实现输入流的读取和缓冲。
* 使用传统的程序设计语言编写词法分析器，并使用该语言提供的I/O功能对输入流进行读取
* 使用汇编语言编写词法分析器，并显示地控制输入流的读取

构造的词法分析器效率越高，构造的难度就越大。

但由于词法分析器是编译器中唯一的逐个字符读取源程序的阶段，所以它可能会耗费大量的时间。因此，在设计编译器时，词法分析器的速度是一个关键因素。

利用自动生成器自动生成词法分析器的方案

#### 双缓冲区

对很多语言来说，在一个词素被一个模式匹配上之前，词法分析器往往需要超前扫描该词素后面的若干字符。

把一个缓冲区分成两个部分，每部分能容纳N个字符，一般来说，N是一个磁盘块中字符的个数，如1024或者4096.

每次用一个系统读命令向缓冲区的每半部分读入N个字符，而不是每读入一个字符调用一次读命令。如果剩余的输入数据不足N个字符，则在缓冲区中最后一个输入字符后面会读进来一个特殊字符`eof`,`eof`不同于任何其他的输入字符，它用于标识源文件的结尾。

输入缓冲区包括两个指针，在两个指针之间的字符串就是当前的词素。一开始，两个指针都指向下一个要识别的词素的第一个字符上。
然后，其中一个指针(即向前forward指针)向前扫描，直至发现一个与某个模式匹配的词素为止。一旦一个词素被确定，向前指针将指向它的最右字符。在处理完这个词素后，两个指针同时定位到这个词素的一个字符。在这种策略中，注释和空白符可以由不生成的记号的模式来匹配。

如果向前指针将要移过缓冲区的中间标记，则往缓冲区的右半部读入N个新字符。如果向前指针将要移过缓冲区的右端，则往左半部读入N个新字符，且将向前指针绕回到缓冲区的头部继续处理。

这种缓冲机制在多数情况下都非常有效，但限制了超前扫描的数量。在超前扫描时，若向前指针需要移动的距离超过了缓冲区的长度，词法分析器就无法识别出记号。

#### 标志(sentinel)

如果采用双缓冲的模式，在每次移动向前指针时都必须检查是否到了缓冲区某半部分的末尾，若是，则需重装缓冲区的另半部分，

```
if forward在缓冲区第一部分末尾 then begin
    重装缓冲区第二部分;
    forward := forward + 1
end
else if forward在缓冲区第二部分末尾 then begin
    重装缓冲区第一部分
    将forward移到缓冲区第一部分开始
end
else 
    forward := forward + 1
```

如果先前指针不在缓冲区某半部分的末尾，上述代码每次移动向前指针时都需要做两次测试。如果我们在缓冲区两部分的结尾处各设置一个标志字符，则可以减少一次测试。

这个“标志”必须是源语言词素集合的特殊字符。一个比较自然的选择就是eof,

在大部分情况下，算法只需测试一次，以判断forward指针是否已经指向eof。只有当到达缓冲区半部分的末尾或源文件尾时，算法才需要进行更多的测试。由于在两个eof之间有N个字符。每个输入字符的平均检查次数近似于1.

还需要确定如何处理向前指针当前所指的字符。该字符可能是一个记号的结尾标志，也可能正被识别的关键字的一部分，还可能是其他各种情况。

如果所选的实现语言支持case语句。则可以用它来完成这些测试。例如。可用case语句的一个分支来实现测试。

### 记号的描述

正则表达式是表示模式的一种重要方法，每个模式匹配一个字符串集。因此正则表达式将作为字符串集的名字。

#### 串和语言

术语**字母表**和**字符类**表示有限符号的集合。符号的典型例子是字母和字符。集合{0,1}是二进制字母表。ASCII和EBCDIC是两个计算机字母表实例。

字母表上的**字符串**是该字母表中符号的有穷序列。在语言理论中，术语句子和字常作为“符号串”的同义词。符号串s的长度是出现在s中的符号的个数，通常记作|s|。例如，banana是长度为6的符号串。空字符串是长度为0的特殊字符串，用e表示。

术语|定义
-|-
s的前缀|去掉串s尾部的0个或多个符号后得到的字符串。例如ban是banana的前缀
s的后缀|去掉串s头部的0个或多个符号后得到的字符串。例如nana是banana的一个子串。
s的子字符串|去掉上的一个s前缀和一个后缀得到的字符串。例如，nan是banana的一个子串。s的每个前缀和后缀都是s的一个子串，但子串并不总是s的前缀或后缀。对于每个字符串s，s和e是s的前缀、后缀和子串
s的真前缀|如果非空串x是串s的前缀(后缀、子串)，而且s!=x,则称x是s的真前缀
s的子序列|从串s中删除0个或多个符号后得到的串(这些被删除的符号可以不相邻)。例如，baaa是banana的子序列

*语言*是给定字母表上的任意一个字符串的集合。这个定义是广义的。像空集和仅包含空符号串的集合{e}这样的抽象语言也符合这个定义。所有语法正确的pascal程序的集合和所有语法正确的英语句子的集合也都符合这个定义，当然，要描述后两个集合要难的多。

字符串的连接和乘积`a+b=ab`,`s^2=ss`

#### 语言上的运算

有一些重要的运算可以应用到语言中。对词法分析而言，感兴趣的是`并`、`连接`和`闭包运算`.

例：令L由大小写字母组成的字母表={A,B,...,Z,a,b,...,z},D由10个数字组成的字母表表示集合{0,1,...,9}

* L∪D是字母和数字的集合
* LD是一个字母后随一个数字的符号串的集合
* L4是由四个字母构成的符号串的集合
* L*是所有字母构成的串(包括e)的集合（L的克林Kleene）
* L(L∪D)是所有以字母开头的字母数字串的集合
* D+是由一个或多个数字构成的数字串的集合（L的正闭包）

#### 正则表达式

在Pascal语言里，标识符是一个字母后跟随零个或多个字母或数字组成的符号串，即一个标识符是例子中所定义的集合中的元素。

使用正则表达式，可以将Pascal的标识符集可以定义为：

```
letter(letter|digit)*
```

其中竖线的含义是“或”，括号用于把子表达式组在一起，星号的含义是“零个或多个”括号中的表达式，`letter和(letter|digit)*`的并列表示两者的连接

建立正则表达式时，可以先定义简单的正则表达式，然后用它们构造出更复杂的正则表达式。每个正则表达式r表示一个语言L(r)。这些定义规则说明L(r)是怎样由r的子表达式所表示的语言以不同的方式组合形成的。

下面是定义**字母表∑**上的正则表达式的规则，每一条规则后带有所定义的正则表达式所表示语言的一个说明：

* **规则1**：e是正则表达式，它表示{e},即包含空串的集合
* **规则2**：如果a是∑上的符号，那么a是正则表达式，表示{a},也就是包含符号串a的集合。虽然，我们使用相同的表示法，但正则表达式a、符号串a和符号a这三者的含义是不同的，可以从上下文中清楚地区分出所谈到的a的具体含义
* **规则3**：假定r和s都是正则表达式，分别表示语言L(r)和L(s),则：
1. `(r)|(s)`是正则表达式，表示`L(r)∪L(s)`
2. `(r)(s)`是正则表达式，表示`L(r)L(s)`
3. `(r)*`是正则表达式，表示`(L(r))*`
4. `(r)`是正则表达式，表示`L(r)`

正则表达式表示的语言叫做`正规集`

正则表达式的说明是一种递归定义。规则1、2是定义的基础。把e和出现在正则表达式中的∑中的符号称为*基本符号*，规则3提供了归纳的步骤.

1. 一元运算符`*`具有最高的优先级，并且是左结合的
2. 连接的优先级次之，也是左结合的
3. `|`的优先级最低，同样是左结合的

那么在正则表达式中可以避免一些不必要的括号。在此约定下,`(a)|((b)*(c))`等价于`a|b*c`。这两个表达式都表示由单个a构成的符号串或者由0个或多个b后面跟着一个c组成的符号串集合。

令`∑={a,b}`

1. 正则表达式`a|b`表示集合`{a,b}`
2. 正则表达式`(a|b)(a|b)`表示`{aa,bb,ba,bb}`,即由a和b组成的长度为2的符号串的集合。表示同样集合的另一正则表达式是`aa|ab|ba|bb`
3. 正则表达式`a*`表示由零个或多个a组成的所有串的集合`{e,a,aa,aaa,...}`
4. 正则表达式`(a|b)*`表示由零个或多个a或b构成的符号串集合，即由a和b构成的所有符号串的集合。这个集合也可用另一个正则表达式`(a*b*)*`来表示
5. 正则表达式`a|a*b`表示串a和零个或多个a后跟随一个b构成的符号串的集合。

如果两个正则表达式r和s表示同样的语言，则称r和s等价，记作`r=s`。例如，`(a|b)=(b|a)`.正则表达式遵循一些代数定律，它们可以用于正则表达式的等价变换。

下表示正则表达式r,s和t遵循的代数定律

公理|描述
-|-
`r|s=s|r`|`|`是可交换的
`r|(s|t)=(r|s)|t`|`|`是可结合的
`(rs)t=r(st)`|连接是可结合的
`r(s|t)=rs|rt`或`(s|t)r=sr|tr`|连接对`|`是可分配的
`er=r`或`re=r`|空串`e`是连接的单位元
`r*=(r|e)*`|`*`和`e`的关系
`r**=r*`|`*`是幂等的

#### 正则定义

为表示方便，希望为正则表达式命名，并用这些名字来定义正则表达式，就如同它们也是符号一样。如果∑是基本符号的字母表，那么正则定义是如下形式的定义序列：
```
d1->r1
d2->r2
...
dn->rn
```
其中，每个di都是一个名字，并且它们各不相同，每个ri是∑∪{d1,d2,...,dn-1}(即基本符号和前面定义的名字)中符号上的正则表达式。由于限制了每个ri中只含∑中的符号和在它之前定义的名字，所以可以通过反复地用名字所代表的正则表达式替代该名字的方法为任何一个ri构造∑上的正则表达式。如果ri用到了dj，并且j>=i,则ri是递归定义的，而且这个替换过程不会中止。

例子：如前面所述，Pascal语言的标识符集合是以字母开头的字母数字串的集合，这个集合的正则定义时

```
letter -> A | B | ... | Z | a | b | ... | z
digit -> 0 | 1 | ... | 9
id -> letter(letter|digit)*
```

Pascal语言中的无符号数是形如`5280`、`39.37`、`6.336e4`、`1.849E-4`这样的符号串，下面的正则表达式定义给出了这类符号串的精确说明
```
digit -> 0|1|···|9
digits -> digit digit*
optional_fraction -> .digtis|e
optional_exponent -> (E(+|-|e)digits)|e
num -> digits optional_fraction optional_exponent
```
在这个定义中，optional_fraction是空串(空缺)或小数点后再上一个或多个数字。注意，小数点后至少要有一个数字，所以num不能匹配1.,但能匹配1.0

#### 缩写表示法

在正则表达式中，某些结构出现频繁，为方便起见，我们可以用缩写形式表示它们。

* **一个或多个实例**-一元后缀操作符*的意思是“一个或过个实例”。如果`r`是表示语言`L(r)`的正则表达式，那么`(r)*`是表示语言`(L(r))*`的正则表达式。正则表达式`a+`表示由一个或多个a构成的所有串的集合。操作符`+`和操作符`*`具有同样的优先级和结合。代数恒等式`r*=r+|e`与`r+=rr*`表达了克林闭包和正闭包`+`这两个操作符间的关系。
* **零个或一个实例**-一元后缀操作符`?`的意思是“零个或者多个实例”。`r?`是`r|e`的缩写式。如果r是正则表达式，则`(r)?`是表示语言`L(r)U{e}`的正则表达式。例如，使用`+`和`?`操作符，可以重写上述的例子
```
digit -> 0|1|···|9
digits -> digit*
optional_fraction -> (.digits)?
optional_exponent -> (E(+|-)?digits)?
num -> digits optional_fraction optional_exponent
```
* **字符类**-`[abc]`(其中a、b和c是字母表中的符号)表示正则表达式`a|b|c`.缩写的字符类`[a-z]`表示正则表达式`a|b|···|z`。使用字符类，可以用下述正则表达式描述标识符：`[A-Za-z][A-Za-z0-9]`

#### 非正规集

某些语言不能用正则表达式描述。
* 正则表达式不能用于描述均衡或者嵌套结构。例如，具有配对括号的符号串集合不能用正则表达式描述，但它们可以用上下文无关文法来描述
* 重复符号串不能用正则表达式表示。集合{wcw|w是a和b组成的串}不能用正则表达式描述，也不能用上下文无关法来说明
* 正则表达式只能表示固定次数的重复或给定结构的没有指定次数的重复。由于正则表达式不能比较任意两个数是否相等，因此不能用正则表达式描述早期Fortran语言中形如nHa1a2...an的Hollerith字符串，因为H后面的字符数目要等于H前面的十进制数

### 记号的识别

考虑下述文法片段
```
stmt -> if expr then stmt
    | if expr then stmt else stmt
    | e
expr -> term relop term
    | term
term -> id
    | num
```

其中，终结符if、then、else、relop、id和num产生由以下正则定义给出的串的集合：
```
if -> if
then -> then
else -> else
relop -> < | <= | = | <> | > | >=
id -> letter(letter|digit)*
num -> digit+(.digit)?(E(+|-)?digit+)?
```
其中，letter和digit的定义与前面相同。

对这个给定的语言，词法分析器将识别关键字if、then、else和由relop(关系操作符)、id(标识符)和num(数)表示的词素。为简单起见，假定关键字是保留的，也就是说，它们不能作为标识符使用。类似于例3.5，这里的num表示Pascal中的无符号整数和实数。

此外，我们还假定词素由空白符分隔。空白符是空格、制表符、换行符组成的非空序列。词法分析器还要完成去掉空白符的任务。这个任务通过把输入串与如下的ws正规定义相比较来完成：
```
delim -> blank | tab | newline
ws -> delim+
```
如果发现了与ws匹配的字符串，则词法分析器不返回记号给语法分析器，继续识别空白符后面的记号，然后把它返回给语法分析器。

记号的正则表达式模式

正则表达式|记号|属性值
-|-|-
`ws`|-|-
`if`|`if`|-
`then`|`then`|-
`else`|`else`|-
`id`|`id`|指向符号表表项的指针
`num`|`num`|指向符号表表项的指针
`<`|`relop`|LT
`<=`|`relop`|LE
`=`|`relop`|EQ
`<>`|`relop`|NE
`>`|`relop`|GT
`>=`|`relop`|GE

目标是构造一个词法分析器，这个词法分析器能利用上表在**输入缓冲区**中识别出下一个记号的词素，产生该词素相应的记号和属性值的二元组。关系操作符的属性值由符号常量`LT`,`LE`,`EQ`,`NE`,`GT`和`GE`给出

#### 状态转移图(状态转移图)

作为构造词法分析器的中间步骤，先构造**状态转移图(transition diagram)**状态转移图描绘语法分析器为得到下一个记号而调用词法分析器时词法分析器要做的动作。

假设输入缓冲区为长度1024，并且词素开始(*lexeme-beginning*)指针指向上次发现的词素后面的字符。当向前指针扫描输入流字符时，用状态转换图来记录所读信息的轨迹，方法是在读字符的过程中不断地在状态转移图的各位置之间移动。

状态转换图的位置用圆圈表示，叫做*状态*,状态间由箭头连接，称为边。由状态s到状态r的边上标记的字符表示使状态r的输入字符。标记`other`表示任意一个未被离开状态s的边所标定字符。

假设状态转换图是*确定的*，即没有一个符号可以同时离开一个状态的两条以上的边的标记匹配。使词法分析器的设计更加简单。如果使用恰当的工具，词法分析器的实现会更加容易。

状态转换图中具有一个状态标记为`start状态`,这个状态称为`初始状态`。识别记号时，将从这个状态开始。有些状态可以具有动作，当控制流到达一个具有动作的状态时，将执行这些动作。当进入一个状态时，需要读入下一个输入字符。若存在一个离开当前状态的边，其标记和读入字符匹配，控制就转到有这条边指向的状态，否则表示失败。

通常可能有多个状态转移图，每个图说明一组记号。如果沿着一个状态转换图识别输入字符串失败，需要把前向指针回退到进入该图开始状态时该指针所指向的输入字符串位置，并启动下一个状态转换图。因为在状态转换图的开始状态，词法分析器的词素开始指针和向前指针都指向同一个位置，所以向前指针被回退到词素开始指针所指向的位置。

*注意：如果在所有状态转换图上都失败了，则意味着输入字符串有词法错误。这时，需要调用错误恢复程序进行错误处理*

例：因为关键字是字母序列，所以它们也符合标识符的规则，即由字母开头的字母和数字的序列。一般来说，不为关键字单独构造状态转换图，而是把关键字看成特殊的标识符。

**把关键字从标识符中分离出来的一种简单技术是适当地初始化符号表**:将关键字再一开始就存入符号表。

对于上表中的记号，需要在开始扫描输入字符之前把字符串if、then和else填入符号表。这些符号的记号也将被记录在符号表中，以便它们在输入字符串中被识别出来，返回它们的记号。使用return语句分别使用gettoken()和install_id()来获得要返回的记号和属性值。过程install_id()访问缓冲区，标识符词素被定位在其中，并用该词素查符号表，如果在符号表找到了该词素，当它被标记为关键字时，install_id()返回0，当它是程序变量时,install_id()返回返回指向相应符号表表项的指针。如果在符号表中没有找到该词素，则把该词素作为变量填入符号表中，并返回指向新建表项的指针。

过程gettoken()也以类似的方式在符号表中查找词素。如果该词素是个关键字，则返回相应的记号，否则返回记号`id`.

**如果有要增加的关键字，无需修改状态转换图，只需将新增关键字对应的字符串和记号填入符号表即可**

如果不把关键字预先放入符号表，一个典型的程序设计语言的词法分析器的状态数会达到几百个。如果使用这种技术，需要的状态数可能不到一百个

```
num -> digit+(.digit)?(E(+|-)?digit+)?
```
一个给定记号的词素必须是最长的。例如，当输入串是`12.3E4时`，词法分析器不应该在发现`12`或`12.3`后就停止。这里假设`12.3E4`后面是一个非数字的字符。

一种避免多余匹配的方法是将这些状态转换图合并成一张图，一般来说这个任务比较艰巨。另一种方法是改变对失败的响应策略。

#### 状态转换图的实现

状态转换图序列可以变换成程序，用来识别该序列所定义的记号。我们将采用对所有状态转换图都适用的系统化方法来构造程序，该程序的大小与图中状态数和边数成正比。

每个状态对应一个代码段。如果一个状态具有出边，该状态的代码便读一个字符并选择应跟随的边。函数nextchar()用来从输入缓冲区中读入下一个字符，每次调用都向前移动指针，并返回读入的字符。如果存在标记为该字符的边，或标记为包含该字符的字符类的边，则控制转给这条边指向的状态所对应的代码。如果不存在这样的边，而且当前状态不是接收状态，调用fail()程序，把向前指针撤回到开始指针指向的位置，气动下一个状态转换图对应的代码继续匹配。如果不存在下一个状态转换图。fail()调用错误恢复程序，进行错误处理。

用全局指针变量lexical_value返回记号。当识别出一个标识符或一个数时，lexical_value被赋值为install_id()和install_num()过程返回的指针。记号类由词法分析器的主过程nexttoken()返回。

使用case语句查找下一个状态转换图的开始状态。在下述的实现中，两个变量state和start分别用来保存当前转换图的当前状态和起始状态。

```c
int state = 0, start = 0;
int lexical_value; /* 返回记号的第二个分量 */
int fail()
{
    forward = token_beginning;
    switch (start) {
        case 0: start = 9; break;
        case 9: start = 12; break;
        case 12: start = 20; break;
        case 20: start = 25; break;
        case 25: recover(); break;
        default: /* 编译错误 */
    }
    return start;
}
```

下述给出了状态0对应的代码,在状态转换图中一条边一条边地往下匹配的过程是通过不断地选择一个状态对应的代码段来执行，以确定出下一个状态，并将控制转到该状态对应的代码段去执行。

```c
token nexttoken()
{
    while(1) {
        switch (state) {
            case 0:
                /* c是超前扫描字符 */ 
                c = nexychar();
                if (c == blank || c == tab || c == newline) {
                    state = 0;
                    lexeme_beginning++;
                    /* 词素开始指针的前移 */
                }
                else if (c == '<') state = 1;
                else if (c == '=') state = 5;
                else if (c == '>') state = 6;
                else state = fail();
                break;
            case 9:
                if (isletter(c)) state = 10;
                else state = fail();
                break;
            case 10:
                if (isletter(c)) state = 10;
                else if (isdigit(c)) state = 10;
                else state = 11;
                break;
            case 11:
                retract(1);
                install_id();
                return gettoken();
            case 25:
                if (isdigit(c)) state = 26;
                else state = fail();
                break;
            case 26:
                c = nextchar();
                if (isdigit(c)) state = 26;
                else state = 27;
                break;
            case 27:
                retract(1);
                install_num();
                return NUM;
        }
    }
}
```

C代码while(1) `stmt` 会不断地重复执行`stmt`，直到遇见一个return为止。由于C语言不允许同时返回记号和属性值，所以`install_id()`和`install_num()`用全局变量来存放对应于**id**和**num**表项的属性值

如果实现状态转换图的语言没有case语句，可以为每个状态创建一个数组，用字符作下标。如果state1是这样的数组，则当超前扫描的字符是c时，`state1[c]`是指向需要执行的程序段的指针。这些代码段一般以转到下一个状态的代码段的goto语句结束。状态s的数组可以看成是s的间接状态转换表

### 词法分析器描述语言

目前有很多基于正则表达式从特定表示法构建词法分析器的工具。可以用正则表达式来描述记号模式，也可把正则表达式转换成模式匹配程序的算法之前。

Lex编译器广泛用于各种语言的词法分析器的描述，Lex编译器的输入称为Lex语言。讨论现有的工具的目的在于说明如何把*正则表达式*描述的模式与行为(如在符号表创建表项，这是词法分析器需要做的动作)结合起来。

Lex的使用方法

* 首先使用Lex语言写一个定义词法分析器的源程序lex.l
* 然后利用Lex编译器将lex.l转换成C语言程序lex.yy.c。它包括从lex.l的正则表达式构造的状态转换图的表格形式以及使用该表格识别词素的标准子程序。与lex.l中正则表达式相关联的动作是C代码段，这些动作可以直接加到lex.yy.c中。
* 最后，lex.yy.c通过C编译器生成目标程序a.out,a.out就是把输入流转换成记号序列的词法分析器

#### Lex说明

一个Lex程序由如下三部分组成:

* **声明部分**
* **转换规则**
* **辅助过程**

声明部分包括变量声明、符号常量声明和正则定义。（符号常量是被声明来表示常数的标识符。）

Lex程序的转换规则是如下形式的语句：

```
p1 {action_1}
p2 {action_2}
...
pn {action_n}
```

其中每个p是一个正则表达式，每个action表示当模式p匹配上一个词素后词法分析器所要执行的程序段。在Lex中，这些action是用C语言编写的，当然也可以用其他语言来实现。

Lex程序的第三部分包含action所需要的辅助过程。这些过程可以单独翻译，并与词法分析器一起装载。

由Lex创建的词法分析器与语法分析器协同工作的方式如下：词法分析器被语法分析器调用后，从尚未扫描的输入字符串读字符，每次读入一个字符，直到发现能与某个正则表达式pi匹配的最长前缀。然后，词法分析器执行action。通常action会将控制返回给语法分析器。然而，如果不讲控制交给语法分析器，词法分析器可以继续发现更多的词素，直到某个操作将控制返回给语法分析器。词法分析器的这种不断查找词素，直到以显式的return调用结束工作的方式，使其可以方便地处理空白符和注释。

词法分析器只返回记号给语法分析器，带有与词素相关信息的属性值是通过全局变量yylval传递的。

Lex的特点：在声明部分，可以看到转换规则所使用的符号常量的声明。这些声明被一对特殊括号%（和%）括在一起。所有出现在括号内的内容都直接复制到词法分析器lex.yy.c中。它们不作为正则定义或转换规则的一部分。对第三部分的辅助过程也进行同样的处理。

在声明部分还包含一些正则定义。每个定义有一个名字和这个名字所代表的正则表达式组成。例如，第一个名字定义为delim，它代表字符类`[\t\n]`,即空格、制表符(由`\t`表示)、换行符(由`\n`表示)三者之一。第二个是关于空白符定义，由名字ws表示。空白符是一个或多个分隔符组成的序列。注意：在Lex中词delim必须由大括号括起来以便与包含delim这五个字符的模式区别开。

在`letter`的正则定义中使用了字符类.`[A-Za-z]`表示大写字母A到Z或小写字母a-z中的任何一个。在id的定义(第5个定义)中使用了圆括号，圆括号是Lex语言的元符号，与通常情况下的含义相同，表示包括。类似，竖也是Lex语言的元符号，表示并。

在number的正则定义中可以看到更多的细节。？是元符号，表示出现过0次或一次。反斜杠被当成转义字符，使得Lex的元符号能表示它的本来意义。在number的定义中，小数点表示成`"\."`,因为在Lex和很多UNIX系统的处理正则表达式的程序中，单独的一个点表示除了换行符以外的所有字符的字符类。在字符类`[+\-]`中，减号前面的反斜杠是为了避免与减号表示范围的用法混淆.如`[A-Z]`

```lex
%{
    /* 符号常量定义
    LT, LE, EQ, NE, GT, GE,
    IF, THEN, ELSE, TD, NUMBER, RELOP  */
%}

/* 正则定义 */
delim    [ \t\n]
ws       [delim]+
letter   [A-Za-z]
digit    [0-9]
id       {letter}({letter}|{digit})*
number   {digit}+(\.{digit}+)?(E[+\-]?{digit}+)?

%%

{ws}     {/* 没有动作和返回值 */}
if       {return(IF);}
then     {return(THEN);}
else     {return(ELSE);}
{id}     {yylval = install_id(); return(ID);}
{number} {yylval = install_num(); return(NUMBER);}
"<"      {yylval = LT; return(RELOP);}
"<="     {yylval = LE; return(RELOP);}
"="      {yylval = EQ; return(RELOP);}
"<>"     {yylval = NE; return(RELOP);}
">"      {yylval = GT; return(RELOP);}
">="     {yylval = GE; return(RELOP);}

install_id() {
    /* 往符号表中填入词素的过程。yy_text 指向词素的第一个字符，yyleng表示词素的长度。将词素填入符号表，返回指向该词素所在表项的指针 */
}

install_num() {
    /* 与填词素的过程类似，只不过词素是一个数 */
}
```

还有一种方法能使字符保持本来的意义，即使他们是Lex的元符号。这种方法就是用引号把字符括起来。在转换规则部分，使用了这种方法来表示六个关系操作符。

现在，在考虑跟在第一个%%后面的转换规则。第一条规则表示如果发现ws(任何由空格、制表符和换行符组成的最长序列)则不做任何动作，控制也不返回给语法分析器，词法分析器继续识别记号，直到与某一个记号关联的动作调用的return语句。

第二条规则表示如果识别出`if`,则返回记号IF,它是表示某个整数的符号常量，语法分析器将这个整数理解为记号**if**。类似地，接下来的两条规则用来识别关键字then和else。

在**id**的规则中，关联动作的有两条语句。第一条语句将过程install_id的返回值赋给变量yylval，该过程的定义在第三部分给出。变量yylval是在Lex的输出lex.yy.c中定义的。语法分析器也可以访问这个变量。使用yylval的目的是保存词素的属性值，因为return (ID)语句(即第二个语句)只能返回记号类。

install_id的详细代码，Lex使用两个变量yytext和yyleng来保证第三部分的程序能够访问匹配的词素。变量yytext就是前面介绍的词素lexeme_beginning(开始指针)，即指向词素的第一个字符位置的指针。变量yyleng存放词素的长度。如果install_id在符号表中没有找到这个词素，则为它创建一个新的表项，输入流中从yytext开始的yyleng个字符被复制到一个字符数组中，并以一个字符串结尾符做结束标记，在符号表的新表项中填入一个指向这个字符起始位置的指针。

接下来的一条规则以类似的方式处理数。在最后的操作符六条规则中，yylval用来返回识别出的关系操作符对应的代码，而实际上对这个六个关系操作符返回的都是记号relop的代码。

一按一个匹配的词素是if。模式if和{id}均匹配这个词素，并且没有能匹配更长串的模式。匹配关键字if的模式先于匹配标识符的模式执行，所以if被匹配为关键字。

**采用将匹配关键字的模式置于匹配标识符的模式之前的策略，可以简单有效地保留关键字**

例子：假设读入的头两个字符是`<=`.模式`<`匹配上第一个字符，但它不是能匹配输入字符串的最长前缀的模式。Lex采用**选择最长匹配前缀的策略**方便地解决了`<`和`<=`之间的冲突。这里，当然`<=`被选择作为下一个记号。

#### 超前扫描操作

对于某些程序设计语言结构，词法分析器需要超前扫描词素后面的若干字符来确定一个记号

词法分析器在输入缓冲区超前地扫描一串字母或数字，接着扫描等号以及后面的一串字母或数字，最后扫描到逗号才能够判断出这不是一个赋值语句。但只有超前扫描符前面的D和O才是与模式匹配的词素的部分。经过成功的匹配，yytext指针指向字符D并且yyleng=2。注意，这个简单的超前扫描模式使得当DO后面跟着一些无意义的符号

在Lex中，可以把模式写成`r1/r2`的形式，其中r1和r2都是正则表达式。它的意思是当一个字符串与r1匹配时，还需其后的字符串与r2匹配，这样才算该字符串与r1匹配成功。在超前扫描操作符`/`，还需要其后的字符串与`r2`匹配，这样才算该字符串与`r1`匹配成功。在超前扫描操作符`/`后面的正则表达式`r2`表示需要进一步匹配的内容，这里它只是匹配模式的一个限制，而不是匹配的一部分。

```
DO/({letter}|{digit})* * ({letter}|{digit})*
```

超前扫描操作符还可以用来解决Fortran词法分析中的另一个难题：区别关键字和标识符。例如：`IF(I, J) = 3`是一个正确的赋值语句，而不是一个逻辑判断if语句。使用Lex描述关键字IF的一种方法是使用超前扫描操作符定义IF右边的正文。

识别关键字IF的模式可以写为(连带匹配其后的括号):

```
IF / \( .* \) {letter}
```

其中的圆点表示除了换行符以外的任何字符，而括号前面的反斜杠表示括号取其本来的意思，而不是正则表达式中的元符号

处理Fortran的if语句问题的另外一种方法是：当看到字符串`IF(`,先确定IF是否被声明为数组。如果是，才去匹配上面给出的整个模式。这样的检查使得由Lex说明自动实现一个`词法分析器`变得很难，而且它们在运行时可能耗费更多的时间，因为要由模拟状态转化图的程序频繁地判断是否要进行这样的检查。

### 有穷自动机

语言的`识别器`是一个程序，它以字符串x作为输入，当x是语言的句子时，回答“是”，否则回答“不是”。可以通过构造有穷自动机把正则表达式翻译成识别器。有穷自动机是更一般化的状态转换图，它可以是确定的或不确定的，其中“不确定”的含义是：对于某个输入符号，在同一个状态上存在不止一种转换。

确定和不确定的有穷自动机都能而且仅能识别正则集，即它们能够识别正则表达式所表示的语言。但是，它们之间有着**时空的权衡**,确定的有穷自动机导出的识别器比不确定的有穷自动机导出的识别器快得多，但确定的有穷自动机可能比与之等价的不确定的有穷自动机的方法。由于变成不确定的自动机更直接一些。

例如，表示所有以`.o`结尾的文件名的正则表达式是(.|o|c)*.o,其中c代表除.和o以外的任何字符。又如，C语言的注释是由开括号`/*`之后以`*/`结尾的任意字符序列组成的，其任何真前缀都不以`*/`结尾

#### 不确定的有穷自动机

不确定的有穷自动机(简写为NFA)是有个有以下几部分组成的数学模型：

* 一个状态的有穷集合S
* 一个输入符号集合∑，即输入符号字母表
* 一个转换函数move，它把由状态和符号组成的二元映射到状态集合
* 状态s0是唯一的*开始*或者*初始*状态
* 状态集合F是接收(或终止)状态集合

NFA可以用带标记的有向图表示，称为**转换图(transtion graph)**,其节点是状态，有标记的边表示转换函数。这种转换图和前面所讲的**状态转换图(transtion diagram)**很类似，但略有区别：同一个字符可以标记始于同一个状态的两个或多个转换，边可以由输入字符符号，也可以由特殊符号e标记。

可以在计算机上使用不同的方法实现NFA的转换函数。最简单的办法是使用转换表。转换表的每个状态占一行，每个输入符号占一列。表中第i行a列对应的表项是当输入为a时从状态i所能到达的状态的集合(实际上它很可能是指向状态集合的指针)

转换表表示的优点是能够快速地确定给定状态在给定字符上的转换。它的缺点是：当输入字母表较大而且大多数转换是空集时，需要耗费大量空间。转换函数的**邻接表表示法**能提供较紧凑的实现，但在确定一个给定的转换时速度较慢。

例：识别语言`(a|b)*abb`的NFA状态转换图，这个NFA的状态集合是{0,1,2,3}

当且仅当对应的转换图存在从开始状态到某个接受状态的路径，使得该路径的边上的标记恰好连城字符串x时，一个NFA接收输入字符串x。上述的NFA可以接受输入串`abb`,`aabb`,`babb`,`aaabb`,...例如，从状态0开始，沿着标记为a的边再回到状态0，然后沿着标记分别为a,b,b的边进入状态1,2,3.

一条路径可以用状态转换序列表示，其中的状态转换叫做移动。

#### 确定的有穷自动机

确定的有穷自动机(DFA)是不确定的有穷自动机的特例，其中：

* 没有一个状态有e换换，即在输入e上的转换
* 对每个状态s和输入符号a，最多只有一个标记为a的边离开s

确定的有穷自动机在任何状态下，对任一输入符号，最多只有一个转换。如果用转换表表示DFA的转换函数，那么表中的每个表项最多只有一个状态。因而，很容易确定DFA是否接受某输入字符串，因为从开始状态起，最多只有一条到达接受状态的路径可由这个符号串标记。

下边的算法说明怎样在一个输入串上模拟DFA的行为。

```
s := s0
c := nextchar
while c != eof do
end
if s is in F then
    return "yes"
else return "no"
```

输入以文件结束符eof结尾的串x，一个DFA D，其开始状态为s0，接受状态集合为F。输出：如果D接受x，则回答“yes”，否则回答“no”。方法：把图3-22的算法应用于输入字符串x。函数move(s, c)给出状态s上遇到的输入字符c时应该转换到的下一个状态。函数nextchar返回输入串x的下一个字符。

#### 从NFA到DFA的转换

多值转换函数使得很难用计算机程序模拟NFA。“接受”的定义仅仅是说必然存在一条从开始状态到某个接受状态的路径，该路径的标记是输入字符串。如果有很多路径其边上的标记都可以连成同样的输入字符串，则在找到一条接受路径或发现没有路径可到达接受状态前，可能不得不考虑所有这些路径

从NFA构造识别同样语言的DFA算法：这个算法通常被称为子集构造算法，有利于使用计算机程序模拟NFA。一个和它紧密相关的算法在下一章构造LR语法分析器时将起到重要作用

在NFA的转换表中，每个表项是一个状态集；而在DFA的转换表中，每个表项只有一个状态。从NFA变换到DFA的基本思想是让DFA的每个状态对应NFA的一个状态集。这个DFA用它的状态去记住NFA在读输入符号后到达的所有状态。这个子集T是从NFA的开始状态沿着那些标有a1a2...an的路径能达到的所有状态的集合。DFA的状态数有可能是NFA状态数的指数。

**子集构造算法**

输入：一个NFA N

输出：一个接受同样语言的DFA D

方法：为D构造转换表Dtram，DFA的每个状态是NFA的状态集，D将“并行”地模拟N对输入串的所有可能的移动

用下表的操作来记录NFA的状态集的轨迹(是代表NFA的状态，T代表NFA的状态集)

在读入一个输入符号前，N可以处于集合e-closure(s0)中的任何状态上，其中s0是N的开始状态。假定从s0出发经过输入字符串上的一系列移动，N到达集合T中的状态。令a是下一个输入符号。遇到a时，N可以移动到集合move(T,a)中的任何状态。由于由于e转换，遇到a以后，N可以处于e-closure(move(T, a))中的任何状态

操作|描述
-|-
e-closure(s)|从NFA状态s只经过e转换可以到达的NFA状态集
e-closure(T)|从T中的状态只经过e转换可以到达的NFA状态集
move(T,a)|从T的状态s

```
初始时，e-closure(s0)是Dstates中唯一的状态且未被标记；
while Dstates中存在一个未标记的状态T do begin
    标记T：
    for 每个输入符号a do begin
        U := e-closure(move(T, a))
        if U 没在Dstates中 then
            将U作为一个未标记的状态添加到Dstate中；
        Dtran[T,a] := U
    end
end
```

```
将T中所有的状态压入栈stack中；
将e-closure(T)初始化为T；
while 栈stack不空 do begin
    将栈顶元素t弹出栈；
    for 每个这样的状态u：从1到u有一条标记为e的边 do
        if u 不在e-closure(T) do begin
            将u添加到e-closure(T);
            将u压入栈stack中
        end
end
```

按上述的方法构造D的状态集合Dstates和D的转换表Dtram。D的每个状态对应于NFA的一个状态集，它是N读了某个输入符号序列后所能到达的全部状态，包括所有的e转换。D的开始状态是e-closure(s0)。使用上述的算法构造D的状态和转换。如果D的某个状态是至少包含一个N的接受状态的NFA的状态集，那么它是D的一个接受状态。

e-closure(T)是一个典型的从给定节点集合出发在转换图上搜索可达节点集的过程。这里，T的状态是给定的节点集合，转换图中只包含NFA中由e标记的边。计算e-closure(T)的简单算法是用栈来保存其边还没有完成e转换检查的状态。

例子：接受语言`(a|b)*abb`的另一个NFA N

这里的输入符号表是{a,b}。图中给出的算法告诉我们要先标记A，然后计算e-closure(move(A,a)).让我们首先计算move(A,a)，即对输入a从A状态可以转换到的N的状态集。在状态0，1，2，4和7中只有2和7有a上的转换，分别到达状态3和8.

e-closure(move({0,1,2,4,7}, a)) = e-closure({3,8}) = {1,2,3,4,6,7,8}

我们称这个集合为B。于是，`Dtran[A, a] = B`

在A中只有状态4对输入b有一个转换(转换到状态5)，所以DFA对输入b有一个从A到C的转换，其中C=e-closure({5}) = {1,2,4,5,6,7}.因此`Dtran[A,b] = C`

对新的没标记过的集合B和C继续这个过程，最终会使得所有的集合(即DFA的状态)都已标记过。因为包含11个状态的集合其不同子集“只有”2^11个，而且一个集合一旦被标记就永远是标记的，所以这个过程肯定能终止。最终，实际构造出的5个不同的状态集合是：
```
A = {0, 1, 2, 4, 7}
B = {1, 2, 3, 4, 6, 7, 8}
C=  {1, 2, 4, 5, 6, 7}
D = {1, 2, 4, 5, 6, 7, 9}
E = {1, 2, 4, 5, 6, 7, 10}
```

### 从正则表达式到NFA

从正则表达式建立其识别器的策略很多，各有优劣。其中有一个策略常用语文本编辑程序，该策略先使用本节将要介绍的算法从正则表达式构造NFA，然后利用算法NFA在输入串上的行为，若想提高运行速度，可以利用子集构造法把NFA变成DFA，

本节介绍一种直接由正则表达式构造DFA而无需建立过渡的NFA的方法。本节还将讨论基于NFA和DFA的识别器的实现在时间与空间复杂性的权衡问题。

#### 从正则表达式构造NFA

语法制导算法，该算法使用正则表达式的语法结构来制导构造过程。算法的分支遵循正则表达式定义的分支。首先构造自动机使其能够识别e和字母表中的任何符号，然后由此构造自动机来识别包含一个交换、一个连接或一个`克林闭包(closure)`运算符的正则表达式。例如，对于正则表达式r|s,可以从r和s的NFA构造出它的NFA。

在构造过程中，每步最多引入两个新的状态，于是，为一个正则表达式构造的最终NFA的状态数最多两倍于该正则表达式中符号和操作符数

算法 **(Thompson构造法)**，从正则表达式构造NFA

输入：字母表∑上的一个正则表达式r

输出：接受L(r)的NFA N

方法：首先，分析r并将其分解成最基本的子表达式，然后使用下面的规则1和规则2为r中的每个基本符号(e或字母表中的符号)构造NFA。基本符号对应正则表达式定义的1和2两部分。请注意，如果符号a在r中出现多次，则要为它的每次出现构造一个NFA。

然后，由正则表达式r的语法结构制导，用下面的规则3逐步地组合前面构造的NFA。直到获得整个正则表达式的NFA为止。在构造过程中所产生的中间NFA（与r的子表达式对应）有几个重要的性质：只有一个终态；开始状态无入边，终态无出边。

1. 对e，构造NFA，其中,i是新的开始状态，f是新的接受状态。很明显这个NFA识别{e}.

2. 对于∑中的每个符号a，构造NFA。同样，i是新的开始状态，f是新的接受状态。

3. 如果N(s)和N(t)是正则表达式s和t的NFA

对于正则表达式s|t,可构造复合的NFA N(s|t)如下：

这里i是新的开始状态，f是新的接收状态。从i到N(s)和N(t)的开始状态有e转换，从N(s)和N(t)的接受状态到f也有e转换。N(s)和N(t)的开始和接受状态不是N(s|t)的开始和接受状态。这样，从i到f的任何路径必须独立完整地通过N(s)或N(t),因此这个复合的NFA识别L(s)∪L(t).

这里，N(s)的开始状态称为复合后的NFA的开始状态，N(t)的接收状态称为复合后的NFA的接受状态。N(s)的接受状态和N(t)的开始状态合并，也就是说N(t)的开始状态上的所有转换现在变成了N(s)的接受状态上的转换。合并后的状态不作为复合后的NFA的接受或开始状态。从i到f的路径必须首先经过N(s)，然后经过N(t),所以路径上的标记是L(s)L(t)中的串。因为没有边进入N(t)的开始状态或离开N(s)的接受状态，所以从i到f的路径不能从N(t)回到N(s)，因此复合的NFA识别L(s)L(t)

(c) 对于正则表达式s*,可构造复合的NFA N(s*)如下：

在此，i和f分别是新的开始状态和接受状态。在这个复合的NFA中，可以沿着一条标记了e边直接从i到达f，这表示e属于(L(s))*。我们还可以从i经过一次或多次N(s)到达f。显然，这个复合的NFA识别(L(s))

(d) 对于括起来的正则表达式(s),使用N(s)本身作为它的NFA

上述算法构造的每一步都产生识别对应语言的NFA。此外，产生的NFA具有下列性质：

* N(r)的状态数最多是r中符号和运算符个数的两倍
* N(r)只有一个开始状态和一个接受状态，接受状态没有出边。作为构成成分的每个自动机也具有这一性质
* N(r)的每个状态或者有一个用∑中的符号标记的出边，或者至多有两个标记为e的出边

#### NFA的双堆栈模拟

算法每次从输入字符串读取一个字符，然后计算自动机N在读入输入字符串的每个前缀后可能进入的所有状态的集合。这个算法利用算法3.3生成的NFA的一些特殊性质，有效地计算非确定的状态集合。这个算法的运行时间与N*x成正比，其中|N|表示N的状态数，|x|表示串x的长度

算法3.4  模拟NFA

```
S := e-closure({s0})
a := nextchar
while a != eof do begin
    S := e-closure(move  )
end
if s ∩ F != ∅ then
else return "no"
```

输入：由算法3.3生成的NFA N和输入串x。假定输入串x由字符eof做结束标记，N以状态s0为开始状态，F是接受状态集

输出：如果N接收x，则返回"yes"，否则返回"no".

方法：把上述算法应用到输入串x。这个算法在运行时执行了*子集构造算法*。它分两步计算从当前的状态集到下一个状态集的转换。第一步，它先求move(S,a),即状态S在输入a(当前输入字符)上经过一个转换能到达的所有状态集合。第二步求出move(S,a)在经过0个或多个e转换后能到达的状态集。算法每次使用函数nextchar从输入字符串x读入下一个字符。当x中的所有字符都读完后，如果接受状态在当前集合S中，则返回“yes”，否则返回“no”。

算法3.4可以使用两个堆栈和由NFA状态做索引的位向量来有效地实现。一个堆栈用于跟踪非确定状态的当前集合的轨迹，另一个堆栈用于计算下一个非确定状态集。

使用位向量可以在常数时间内判断一个非确定状态是否已在堆栈中，以防重复加入。一旦已经在第二个栈求出了下一个状态，则两个栈的角色互换。由于每一个非确定状态至多有两个输出边，因此每个状态在一个转换中至多会增加两个新状态。我们用M表示N的状态数。因为一个栈中至多有|N|个状态，所以计算当前状态集的下一个状态集的时间与|N|成正比。因此，模拟N在输入字符串x上的行为需要的时间正比于|N|*|x|

注意：算法3.4是在运行时执行子集构造算法的。例如，比较上述的转换的NFA苟傲的DFA状态图。开始状态集和读a后可达到的状态集对应着DFA的A和B状态。

#### 时间空间的权衡

给定一个正则表达式r和输入字符串x，算法3.3为r构造一个NFA N。这种构造法的时间复杂性是O(|r|)，其中|r|是r的长度。N至多具有两倍于|r|的状态，每一个状态至多有两个转换，因此N的转换表的空间复杂性是O(|r|).使用算法3.4判断N是否接受字符串x，其时间复杂性是O(|r|*|x|).使用这种方法判断x是否在L(r)中的时间代价正比于r的长度和x长度的乘积。在很多文本编辑器中，当目标字符串x不是很长时，可以用这种方法寻找正则表达式模式。

第二种方法是先用Thompson构造法(算法3.3)从正则表达式r构造其NFA，然后再用子集构造法（算法3.2）构造NFA。我们利用转换表实现状态转换函数，并使用算法3.1模拟DFA在输入串x上的动作。这个算法时间代价与x的长度成正比，但与DFA的状态数无关。这种方法经常用于在文本文件中寻找正则表达式模式的模式匹配程序。一旦有穷自动机创建成功，查找的速度非常快。当目标串非常长时，这种方法是很有利的。

然而，存在一些正则表达式，它们的最小DFA也有很多状态，其状态数是正则表达式大小的指数。例如，若正则表达式`(a|b)*a(a|b)(a|b)...(a|b)`包含n-1个(a|b),则识别该正则表达式的任意DFA的状态数不可能少于2^n。这个正则表达式表示a和b的字符串，这个字符串的倒数第n个字符是a。

另一种方法是使用DFA，但通过利用“惰性转换计算”技术来避免创建整个状态的转换表。转换是在运行时计算的，只有在真正需要的时候才去计算给定状态在给定输入上的转换。计算的转换存储在cache中。每次要进行状态转换时，先检查cache。如果需要的转换步子cache中，我们才去计算它，并将其存入cache。如果cache满了，可以清除一些旧的转换，为新的转换腾出空间。

下标总结了用从NFA和DFA构造的识别器判断输入字符串x是否在由正则表达式r表示的语言中所需的最坏的时间、空间复杂性。“惰性”技术结合了NFA的空间需求小和DFA的时间需求小的特点。它的空间需求是正则表达式的大小加上cache的大小。它的运行时间几乎与DFA识别器相同。在某些应用中，“惰性”技术比DFA方法还要快，因为它没有计算不必要的状态转换。

自动机|空间|时间
-|-|-
NFA|`O(|r|)`|`O(|r|*|x|)`
DFA|`O(2^|r|)`|`O(|x|)`

### 设计词法分析器的生成器

构造一个在输入缓冲区中查找词素的识别器。如果有多个模式匹配成功，识别器将选择与最长词素匹配的模式。如果有多个模式与最长词素匹配，则选择第一个与最长词素匹配的模式。

有穷自动机是一种创建词法分析器的自然模型。由Lex编译器构造出的**词法分析器**由一个**输入缓冲区**，缓冲区有两个指针，其中一个是词素的**开始指针**，另一个是词素的**向前指针**。

Lex编译器根据使用Lex说明书写的正则表达式模式为有穷自动机构造转换表。词法分析器本身包括一个有穷自动机模拟器，这个模拟器使用转换表在输入缓冲区中查找正则表达式模式。

#### 基于NFA的模式匹配

一种基于NFA的模式匹配方法是为模式p1,p2,...,pn的NFA N构造状态转换表。为此，可以先使用算法3.3为每个模式pi构造NFA N(pi)，然后加入一个新的开始状态s0，并用e转换将s0和每个N(pi)的开始状态相连。

NFA修改必须保证该NFA能识别输入字符串中被匹配的最长前缀。在这个NFA中，每一个模式pi都有一个接受状态。当使用算法模拟NFA时，构造一个状态集序列，其中每个状态集都是NFA看到每个输入字符后能够进入的状态集。即使在一个状态集中包括了一个接受状态，但为了实现最长的匹配，仍需继续模拟NFA,穷尽当前输入符上的所有转换，即到达一个终止。

通常，所写的Lex说明总能使某个模式（也可以是错误模式）匹配成功。如果没有一个模式能匹配成功，则意味着没有把错误情况考虑周全，此时词法分析器需要把控制转给某个默认的错误恢复程序。

#### 词法分析器的NFA

从Lex说明构造词法分析器的另一种方法是使用DFA完成模式匹配。这种方法与上面描述的对NFA的模拟完全类似，知识在确定正确的模式匹配时有一些细微的差别。当使用子集构造算法进行NFA到DFA的转换时，在一个非确定状态的子集中可能会有多个接收状态。在这种情况下，在Lex说明中位置靠前的模式对应的接受状态具有优先权。类似于模拟NFA，在穷尽对当前的输入符号的转换之前，还需要继续进行状态转换。为了找到匹配的词素，需要将缓冲区的向前指针返回到DFA最后一次进入道接受状态时的位置上。

#### 实现超前扫描操作

由于在某些情况下表示特定记号的模式可能需要描述实际词素后面的一部分正文，所以需要使用超前扫描操作符`/`。将一个含有`/`的模式转换成NFA时，可以将l看成e，使得不用真正地在输入字符串中查找`/`.然而，当由这样的正则表达式表示的字符串在输入缓冲区被识别出来时，词素的末尾并不在NFA的接受状态的位置上，而是在最后一个在（假想的）`/`上具有转换的状态上

### 基于DFA的模式匹配器的优化

构建算法能小化DFA的状态数，所以可用于减小基于DFA的模式匹配器的大小。这个算法是高效的，其运行时间O(nlgn),n是NFA中的状态数。

#### NFA的重要状态

如果一个NFA状态有一个标记为非e的出边，则称这个状态是重要状态。子集构造在确定e-closure(move(T,a))时只使用了子集合T中的重要状态。仅当状态s是重要的，集合move(s,a)才是非空的。在构造过程中，两个子集可以被认为是等同的，如果它们的重要状态相同并且两者同时包含或不包含NFA的接受状态。

当子集构造法被应用由正则表达式经算法3.3生成的NFA时，可以利用NFA的特殊性质来将两种构造方法合二为一。合并的构造法把NFA的重要状态与出现在正则表达式中的符号相关联。只有字母表上一个符号出现在正则表达式中时，Thompson构造法才创建一个重要状态。例如，对于`(a|b)*abb`,Thompson构造法为每个a和b创建重要状态

结果NFA有且只有一个接受状态，但该接受状态不是重要的，因为它没有出边。通过在正则表达式r右端连接一个唯一的结束符`#`，我们给r的接受状态增加一个`#`上的转换，使它成为NFA的重要状态。换句话说，通过使用扩展的正则表达式`(r)#`，在子集构造过程中可以忽略接受状态。当构造结束时，任何在`#`上有转换的DFA的状态都是接受状态。

用语法树表示扩展的正则表达式。语法树的叶结点表示基本符号，内节点表示操作符。如果一个内节点被标记为连接1或*操作符，则分别称其为cat-节点、or-节点或star-节点。

正则表达式语法树的叶节点由符号表中的符号或e标记。对于每一个非e标记的叶节点，分配一个唯一的整数，这个整数表示叶节点的位置，同时也表示对应符号的位置。一个重复出现的符号会有多个位置。位置标记在符号的下边。NFA中被编号的状态对应着叶节点的位置。这些状态是NFA的重要状态，非重要状态用大写字母来表示

#### 从正则表达式到DFA

从扩展的正则表达式`(r)#`构造DFA。首先为正则表达式`(r)#`构造一个语法树T，然后通过遍历这棵语法树计算*nullable*,*firstops*,*lastops*和*followpos*四个函数。最后由`followpos`构造DFA.函数*nullable*,*firstops*和*lastops*定义在语法树的节点上，用于计算函数followpos，而函数followops定义在位置集合上

利用NFA的重要状态和正则表达式语法树的叶节点的等价性，可以绕过NFA的构造而直接构造一个其装填对应语法树的位置集合的DFA。NFA的e转换表示相当复杂的位置结构。特别地，它包含了这样的信息：什么时候一个位置可以跟随另一个位置，即输入到DFA的字符串中的每一个符号都可以被一个位置匹配。一个输入符号c只能由具有符号c的位置匹配，但不是每一个具有符号c的位置都一定匹配输入字符串中c的一次出现

一个位置匹配一个输入符号的概念将由函数followpos定义。如果i是一个位置，那么followpos(i)是满足如下条件的位置j的集合：对于某个输入字符串...cd...,位置i对应着c的出现，位置j对应着d的出现

算法 从正则表达式r构造DFA

输入：正则表达式r

输出：识别L(r)的DFA D

方法:
* 构造扩展的正则表达式`(r)#`的语法树T、其中#是附加在(r)后面的唯一结束标志
* 通过对T进行深度优先遍历计算函数nullable、firstops、lastpos和followpos的值
* 利用下述过程构造Dstates（D的状态集），生成D的状态转换表Dtran。Dstates中的状态是位置集，初始情况下，每一个状态都是“未标记的”，只有我们开始考虑其出边时，这个状态才变成“标记的”。D的开始状态是firstpos(root),接受状态是包含与结束符`#`相关位置的状态。

```
初始时，Dstates中唯一未标记的节点是firstpos(root),root是(r)#语法树的根节点：
while Dstates 中㛮一个未标记的状态T do begin
    标记T;
    for 每个输入符号a do begin
        令U是followpos(p)中的位置的集合，p是T中的某个位置，位置p的符号为a;
        if U非空而且不在Dstates中 then
            将U作为一个未标记的状态加入到Dstates中；
        Dtran[T,a] := U
    end
end
```

#### 最小化DFA的状态数

理论上的一个重要结论是：每一个正规集都可以由一个状态数最少的DFA识别，这个DFA是唯一的(状态名不同的同构情况除外)。

假定有一个DFA M，其状态合集是S，输入符号表是∑，每个状态对每个输入符号都有转换。如果不是这样，可以引入一个“死状态”d，d在所有输入符号上都转换到d。如果s在符号a上没有转换，加上一个在a上从s到d的转换。

字符串w区别状态s和t，如果：DFA M从状态s出发，对输入串w进行状态转换，最后停在某个接受状态；从t出发，对输入串w进行状态转换，停在一个非接受状态；反之亦然。

极小化DFA的状态数的算法是把DFA状态分成一些不相交的组，同一个组中的状态都是不可区别的，而不同组的状态则可以由某个输入串的区别。把每个状态组合并成一个状态。该算法先把所有状态划分为两个组，然后逐步将这个划分精细化。在一个划分中，如果两个状态处于同一分组，然后逐步将这个划分精细化。在一个划分中，如果两个状态处于同一分组则说明它们还没有被任何串区别出来，反之如果两个状态处于不同分组则说明它们已经被某个串区别出来。

初始划分包含两个组：接受状态组合非接受状态组。算法的基本步骤是从当前划分中取一个状态组。如果这些转换所到达的状态落入当前划分的两个或更多不同的状态组，那么A必须进一步划分，使得划分后的每个子集在a上的转换能落入当前划分的同一个状态组中。在当前划分中重复上述划分组的过程，直到没有任何一组需要再分裂为止。

算法3.6 最小化DFA的状态数

输入：DFA M(其状态集合为S)，输入符号集为∑，转换函数为f：S*∑->S,开始状态为s0，接受状态集为F

输出：一个DFA M，它和M接受同样的语言，且状态数最少。

方法：
* 构造具有两个组的状态集合的初始划分π；接受状态组F，非接受状态组S-F
* 对π采用下述的过程来构造新的划分π
* 如果π_{new} = π,零π_{final} = π，再执行步骤4；否则，令π = π_{new},重复步骤2
* 在划分π_{final}的每个状态组中选一个状态作为该组的代表。这些代表构成了简化后DFA M‘的状态。令s是一个代表状态，而且假设：在DFA M中，在输入a上有从s到t的转换。令t所在组的代表是r(r可能就是t)，那么在M'中有一个从s到r的a上的转换。令包含s0的状态组的代表是M'的开始状态，并令M'的接受状态是那些属于F集的状态所在组的代表。注意，π_{final}的每个组或者仅含F中的状态，或者不含F中的状态。
* 如果M'含有死状态(即一个对所有输入符号都有到自身的转换的非接受状态d)，则从M'中去掉它；删除从开始状态不可到达的状态；取消从任何其他状态的死状态的转换定义

```
for π中的每个组 do begin
    当且仅当对任意输入符号a，状态s和t在a上的转换到达π的同一组中的状态时，才把G划分成小组，以便G的两个状态s和t在同一小组中；
    /* 最坏情况下，一个状态就可能成为一个组 */
    用所有新形成的小组代替π中的G
end
```

#### 词法分析器的状态最小化

开始运行算法3.6，必须对识别不同记号的状态进行分组，以得到一个厨师划分

#### 表压缩方法

可以有多种方法来实现有穷自动机的状态转换函数。因为词法分析器是编译器中唯一逐个处理输入字符流的过程，所以它占用了编译器可观的时间。因此词法分析器需要最小化它对每一个输入字符所执行的操作个数。如果用DFA来实现词法分析器，则需要对状态转换函数进行有效的表示。

一个高度压缩但速度相比比较慢的方案是使用一个链表来存储每个状态的出边所表示的转换。在链表的最后存放一个默认的转换。这个默认的转换应该是最经常用到的转换

*表压缩方法*:既有数组表示法访问速度快的特点，又有链表结构占用空间小的优点。使用4个数组组成的数据结构，这些数组由状态做索引。base数组用于决定存储在next和check数组中的与每个状态相关的表项的基位置。default数组用于确定当前基位置无效情况下可选的基位置。为了计算状态s在遇到字符a后要进入的状态nextstate(s,a)，首先查看next和check这对数组。特别地，要从这两个数组中找到对应于状态s的表项所在位置`l=base[s]+a`,其中a可以看成整数。如果`check[l]=s`,取`next[l]`为s在输入a上的下一个状态。如果`check[l]!=s`,则令`q=default[s]`,然后用q代替s并递归地重复整个过程。该过程描述如下：
```
procedure nextstate(s,a):
    if check[base[s] + a] then
        return next[base[s] + a]
    else
        return nextstate(default[s],a)
```

## 第四章：语法分析

### 语法分析器的作用

语法分析器接收词法分析器提供的记号串，检查它们是否能由源程序语言的文法产生。希望语法分析器能用于易于理解的方式提示语法错误信息，并能从常见的错误中恢复出来，以便后面的输入能继续处理下去。

典型的文法的语法分析器有三类：

* **通用的语法分析方法**：如Cocke-Younger-Kasami算法和Earley算法，这些方法能分析任何文法。然而这些方法在生成编译器效率太低。
* **自顶向下方法**：沿着从顶向底的方向建立分析树
* **自底向上方法**：沿着从叶向根的方向建立分析树

无论哪一种方法，语法分析器都是自左向右地扫描输入字符串，每次读一个符号

最有效的自顶向下和自底向上分析方法智能处理文法的一些子类。然而，这些子类中的某些文法，如LL文法和LR文法，足以描述程序设计语言的大部分语法结构。LL文法的语法分析器常由手工实现

假设语法分析器的输出是对词法分析器产生的记号流的分析树的某种表示。实际上在分析过程中编译器还可以完成许多其他任务。例如，把与各种记号有关的信息收集到符号表中、进行类型检查和其他一些语义分析检查、如产生中间代码等。

语法错误的性质和两种错误恢复策略：**紧急方式恢复策略**和**短语级恢复策略**

#### 语法错误的处理

如果编译器只处理正确程序，它的设计和实现就可以大大简化。好的编译器应该能帮助程序员识别和定位错误。大多数程序设计语言的说明都没有描述编译器应该怎样响应语法错误，而是把它留给了编译器的设计者来处理。

* **词法错误**，如标识符、关键字或操作符的拼写错误
* **语法错误**，如算术表达式的括号不配对
* **语义错误**，如操作符作用于不相容的操作数
* **逻辑错误**，如无限的递归调用

源程序的多数错误诊断和恢复都集中在语法分析阶段。原因之一是多数错误都是语法错误，或者当来自词法分析器的记号流违背定义程序设计语言的文法规则时才暴露出来。另一个原因是现代语法分析方法的准确性使得它们能非常有效地检查出程序中的语法错误。在编译阶段准确地诊断语义和逻辑错误是非常困难的。

语法分析器中出错处理程序的基本目标是：
* 清楚而准确地报告错误的出现
* 迅速地从每个错误中恢复出来，以便能继续检查后面的错误
* 不能过分降低正确程序的处理速度

但是，有些情况下，错误的发生远远先于发现它的位置，而且很难诊断出这种错误的准确性质。更困难的是，出错处理程序可能需要猜测程序员编程时的意图

有些分析方法，如LL方法和LR方法，可以尽快地检查出语法错误。它们具有**萌发前缀性(viable-prefix property)**,即当它们一旦发现一个输入字符串的前缀不是该语言任何字符串的前缀时就能检查出错误。

例：多数错误可以简单地分为以下几类：60%是标点符号错，20%是操作符或运算对象错，15%是关键字错，剩下的5%是其他类型的错误

一种常见的标点错误是在函数说明的参数表中出现的标点，分号错误普遍出现的原因是不同语言在分号的用法上有很大区别。如在Pascal语言中，分号是语句的分隔符；在PL/1和C语言中，分号则是语句的结束符。研究表明，后一种用法较少出错

操作符错误的典型例子是漏写了`:=`中的冒号。关键字拼写错误通常比较少见，其典型的例子是writeln中的i

然而，另一类常见的错误是很难正确修复的，比如漏写了begin或end。多数编译器都不能修复这类错误。

出错处理程序的错误报告：应该报告源程序的错误被检测到的位置，比如显示出错的程序行，用指针指出检测到错误的位置。比如显示“此处遗漏了分号”

通常，一些语法分析器试图将自己恢复到某一状态，以便能够继续分析输入字符串或正确地处理出现的错误。

不充分地恢复程序可能会引起大量令人烦恼的“伪”错误的出现，这些错误不是程序设计人员造成的，而是由于错误恢复时改变了语法分析器的状态而引起的。同样，语法错误的恢复也可能引起语义伪错误，这些错误会在语义分析或代码生成阶段被检查出来。例如，错误恢复时，语法分析器可能跳过某个变量的声明，如变量zap。以后在表达式中碰到变量zap时，虽然语法上没有错，但由于符号表中没有变量zap的表项，会产生“zap没有定义”的出错信息。

编译器的一个保守的策略是：如果在输入流中查到某个错误，并且它离前一个错误非常近，则抑制这个错误信息的出现，即在发现一个语法错误后，编译器应该在成功地分析几个记号之后才报告下一个错误信息。然而，在某些情况下，可能会有太多的错误，以至于编译器无法继续进行合理的处理。

考虑到各种错误情况的出现以及合理处理，错误恢复的策略是一个需要认真考虑的折中。

有些编译器试图猜测程序员编程时的意图并修复错误。

#### 错误恢复策略

* **紧急方式恢复策略**-最容易实现的方法，适用于多数语法分析方法。当发现错误时，语法分析器开始抛弃输入符号，每抛弃一个记号，直到发现某个指定的同步记号(通常是界定符)，如分号或者end。必须恰当地设计选择同步记号，因为这种方法常常跳过大量的输入记号，而不检查是否有其他错误，并不会陷入死循环
* **短语级恢复策略**-发现错误时，对剩余的输入字符串做局部纠正，即用一个能使语法分析器继续工作的字符串来代替剩余输入
* **出错产生式策略**-如果对经常遇到的错误有很清楚的了解，可以扩充语言的文法，增加产生错误结构的产生式。然后用由这些错误产生式扩充的文法构造语法分析器。如果语法分析器
* **全局纠正策略**-有一些算法可以选择最小的修改序列，以获得全局代价最小的错误纠正。如果给定错误输入串x和文法G，这些算法会发现y的一棵分析树，以便使用最少的符号插入、删除和修改操作把x变换成正确的输入字符串y。

**最小代价纠正**的概念已经成为评价错误恢复技术的一种标准，并且已经被用于短语级恢复方法中最优替换字符串的选择

### 上下文无关文法

程序设计语言的许多结构都包含固有的递归结构，这种递归结构可以用上下文无关文法定义。例如

```
如果S1和S2是语句，E是表达式，则“if E then S1 else S2是语句”
```

这种形式的条件语句不能用正则表达式说明。使用**语法变量stmt表示语句类，expr表示表示类**,可以使用下面的文法产生式:

```
stmt -> if expr then stmt else stmt
```

**上下文无关由终结符、非终结符、开始符号和产生式组成**

* **终结符**是组成字符串的基本符号。在讨论设计语言的文法时，“记号”和“终结符”是同义词，在上述例子中，关键字`if`,`then`和`else`都是终结符
* 非终结符是表示字符串集合的语法变量。*stmt*和*expr*是非终结符。非终结符所定义的字符串集合有助于定义该文法所产生的语言。非终结符强加给语言一种层次结构，这种层次结构对语法分析和翻译都非常有用
* 在文法中，有一个非终结符被指定为开始符号。开始符号表示的字符串集合就是文法所定义的语言 
* 文法的产生式说明了终结符和非终结符组合成串的方式。每个产生式由非终结符开始，跟随一个箭头(有时用::=代替箭头)，然后是非终结符和终结符组成的串

```
expr -> expr op expr 
expr -> (expr)
expr -> -expr
expr -> id
op -> +
op -> -
op -> *
op -> /
```

在上述文法中，终结符包括id,+,-,\*,/,非终结符包括expr和op，*expr是开始符号*

#### 文法符号的使用约定

* **终结符**

1. 字母表中比较靠前的小写字母，如a,b,c等
2. 操作符，如+、-等
3. 标点符号，如括号、逗号等
4. 数字0,1,...,9
5. 黑体串，如**id**、**if**等

* **非终结符**

1. 字母表比较靠前的大写字母，如A,B,C等
2. 字母S,它常常代表开始符号
3. 小写斜体名字，如*expr*、*stmt*等

* 字母表中比较靠后的大写字母，如X,Y,Z等，表示文法符号，可以是非终结符也可以是终结符
* 小写希腊字母表示文法符号的串。因此，一个通用产生式可以写作A->α，箭头左边(产生式的左部)是一个非终结符A，箭头右边使文法符号串(产生式右部)
* 如果A—>α1,A->α2,...,A->αk是所有以A为左部的产生式(称为A产生式)，则可以把它们写成A->α1|α2|α3|...|αk,将α1,α2,α3,...,αk称为A的候选式
* 除非另有说明，否则第一个产生式左部的符号是开始符号。

```
E -> E A E | (E) | -E | id
A -> + | - | * | / | ↑
```

#### 推导

可以使用多种方法观察文法定义语言的过程。将该过程看成是分析树的建立过程，但推导也是描述文法定义语言过程的有用方法，其核心思想是把产生式看成重写规则，即用产生式右部的串来代替左部的非终结符。

例如，考虑下面的算术表达式文法:

```
E -> E + E | E * E | (E) | -E | id
```

其中，非终结符E表示一个表达式。产生式E->-E意味着前面带有减号的表达式仍然是表达式。这个产生允许用-E代替出现的任何E,以便从简单的表达式产生更复杂的表达式。如果用-E代替单个E，这个动作可以描述为

```
E -> -E
```

读为`“E推导出-E”`。产生式`E->(E)`表示可用`(E)`代替在文法符号串中出现的任何E。如`E*E=>(E)*E`或者`E*E=>E*(E)`

可以从E开始，不断地(以任何顺序)应用产生式，得到一个替换序列。例如：

```
E -> -E -> -(E) -> -(id)
```

抽象地，有`αAβ->αγβ`，如果`A->γ`是产生式，而且α和β是任意的文法符号的串。如果`α1->α2->...->αm`,则说α1推导出αm,符号->表示“一步推导”。通常用*->表示“零步或多步推导”。因此：
* 对任何串α，α*->α
* 如果α*->β，而且β->γ,则α*->γ

类似地，用+->表示“一步或多步推导”。对于开始符号为S的文法G，可以用+->关系来定义G所产生的语言L(G).L(G)中的字符串只包含G的终结符。当且仅当S+=>w时，说终结符w在L(G)中。终结符串w称为G的句子。由上下文无关文法产生的语言称为上下文无关语言。如果两个文法产生同样的语言，则称这两个文法等价。

对于开始符号为S的文法G，如果S*=>α，则称α为G的句型，其中α可能包含有非终结符。句子是不含非终结符的句型。

字符串`-(id+id)`是文法(4-3)的句子，因为存在如下推导

```
E -> -E -> -(E) -> -(E + E) -> -(id + E) -> -(id + id)  文法(4-3)
```

可以简单地用如下形式表示：
```
E *-> -(id + id)
```

按推导长度进行归纳，可以证明文法(4-3)产生的语言中的每个句子都是由二元操作符`+`和`*`、一元操作符`-`、括号以及运算对象id组成的算术表达式。同样，按算术表达式的长度进行归纳，也可以证明这样的算术表达式都可以由文法(4-3)产生。因此，文法(4-3)正好产生所有包括二元操作符`+`和`*`,一元操作符`-`、括号以及操作数id的算术表达式的集合。

在推导的每一步都有两个选择，首先需要选择被替换的非终结符，然后再选择用于替换该非终结符的候选式。

```
-(E + E) -> -(E + id) -> -(id + id)
```

为了理解语法分析器是怎样工作的，需要考虑每一步都替代最左非终结符的推导。这样的推导叫做**最左推导**,如果`α -> β`是最左推导，可以写成`α lm-> β`

每一步的最左推导都可以写成`wAγ lm-> wδγ`，其中`w`只含终结符，`A -> δ`是推导所用的产生式，`γ`是文法符号的串。为了强调`α`通过最左推导出`β`这一事实。写`α lm*-> β`。

如果`S lm*-> α`,则称`α`是该文法的左句型。

类似地可以定义最右推导，即每步推导都代替最右非终结符的推导。最右推导有时也称为规范推导。

#### 分析树和推导

分析树可以看成的图形表示，但它不能显示出替代顺序的选择。分析树的每个内节点都标以某个非终结符A。A的子节点从左到右分别被用来替换A所使用的产生式右部的各符号标记。分析树的叶节点用非终结符或终结符来标记，它们从左到右构成一个句型，称为树的边界或果实。

考虑任意推导`α1 -> α1 -> ... αn`,其中`α1`是单个非终结符A。对推导中的每个句型`αi`,构造产生`αi`的分析树。该过程是对i的归纳。`αi = A`对应的分析树是标有A的单个节点，是归纳的基础。为了完成这种归纳，假设已经构造了产生`αi = X1X2...Xk`的分析树，假设`αi`是用`β=Y1Y2...Yr`代替`αi-1`中的非终结符`Xj`所产生的，即在推导的第i步中，对`αi-1`应用产生式`Xj->β`，推导出`αi=X1X2...Xj-1βXj+1...Xk`

分析树忽略了句型中符号被代替的顺序。如果只考虑最左推导(或最右推导)，则可以消除推导过程中产生式应用顺序的不一致性。**每棵分析树都有一个与之对应的唯一的最左推导和唯一的最右推导**。可以用产生分析树方法来代替推导。

分析树可以反映一定的运算符优先级。比如`a+b*c`,习惯上*比+具有更高的优先级，因为表达式`a+b*c`被看成`a+(b*c)`而不是`(a+b)*c`

#### 二义性

给定一个文法G，如果L(G)中存在一个具有两棵或者两棵以上分析树的句子,则称G是二义性的。

还可以如下定义二义性文法：如果L(G)中存在一个具有两个或两个以上最左(或最右)推导的句子，则G是二义性文法。很多语法分析器要求所处理的文法是无二义的，否则对具有二义性的句子无法确定应该选择那颗分析树。

某些应用可能要求可以构造适应于二义性文法的语法分析器，不过，这种文法要具有*消除二义性*的规则,以便语法分析器能够“抛弃”不需要的分析树而为每个句子保留唯一一棵分析树。

### 文法的缩写

文法能够描述程序设计语言的大部分语法成分，但不能描述程序设计语言的全部语法成分。当**词法分析器**从输入字符串产生记号序列时，将完成一定量的语法分析工作。对输入字符串的某些限制(如标识符的声明必须先于它们的使用)不能用上下文无法文法来描述。**语法分析器接受的记号序列形成了程序设计语言的超集**。语法分析以后的各编译阶段必须分析语法分析器的输出，以保证输入字符串符合语法分析器无法检查的那些规则。

考虑词法分析器和语法分析器的分工。每种语法分析方法只能处理一种形式的文法。为了适应所选择的分析方法，常常不得不改写初始文法。**适于表达式的文法常常用结合律和优先级信息来构造**

#### 正则表达式和上下文无关文法的比较

正则表达式所描述的每一种结构都可以用上下文无关文法来描述。例如正则表达式`(a|b)*abb`和下述文法描述的语言皆为由a和b组成的以abb结尾的字母串：
```
A0 -> aA0 | bA0 | aA1
A1 -> bA2
A2 -> bA3
A3 -> e
```

可以机械地把一个不确定的**有穷自动机(NFA)**转换成一个等价的上下文无关文法，该文法可以按照下列规则构造:
* 对NFA的每个状态i，创建一个非终结符Ai
* 如果状态i遇见的输入符号a转换到状态j，则引入产生式Ai -> aAj
* 如果状态i遇见的输入符号e转换到状态j，则引入产生式Ai -> Aj
* 如果状态i是接受状态，则引入产生式Ai -> e
* 如果状态i是开始状态，则Ai是文法的开始符号

使用正则表达式而不用上下文无关文法定义语言的词法

* 语言的词法规则通常非常简单，不必用强大的文法来描述
* 对于记号，正则表达式比上下文无关文法提供了更简洁且易于理解的定义
* 从正则表达式可以自动地构造出有效的词法分析器，从任何文法都很难构造词法分析器
* 把语言的语法结构分成词法和非词法两部分为编译器前端的模块划分提供了方便的途径。

*注意：正则表达式对描述标识符、常数和关键字等词法结构时最常用。另一方面，文法在描述括号配对、begin-end配对、if-then-else对应等嵌套结构时最常用。正则表达式不能描述这些嵌套结构*

#### 验证文法所产生的语言

对“文法G产生语言L”的证明包括两个部分：必须证明由G产生的每个字符串都在L中，反之，L中的每个字符串都能由G产生。

如文法G`S->S(S)|e`能而且仅能产生所有配对的括号串，证明略.

#### 消除二义性

有些二义性文法可以通过改写来消除二义性。例子：消除“不匹配else”文法的二义性。

```
stmt -> if expr then stmt
    | if expr then stmt else stmt
    | other            
    (4-7)
```

这里，other代表任何其他语句。复合条件语句

```
if E1 then S1 else if E2 then S2 else S3
```

文法(4-7)具有二义性的，因为串`if E1 then if E2 then S1 else S2`有两棵分析树。而一般规则是，每个else和前面最近的没有配对的then配对，当然这条避免二义性的规则可以直接并入文法中。例如，可以把上述文法改写成下面的无二义性文法，其基本思想是：出现在then和else之间的语句必须是“配对”的，即它不能以一个未配对的then后面跟随任意的非else语句结束，于是else会被迫与这个未配对的then匹配。配对的语句是一个不包含不配对语句的if-then-else语句或者任何非条件语句。因此，按照上述思想改写后的文法如下：

```
stmt -> matched_stmt
    | unmatched_stmt
matched_stmt -> if expr then matched_stmt else matched_stmt
    | other
unmatched_stmt -> if expr then stmt 
    | if expr then matched_stmt else unmatched_stmt
```

#### 消除左递归

如果文法G具有一个非终结符A使得对某个字符串α存在推导`A +-> Aα`,则称G是左递归的。自顶向下语法分析法不能处理左递归文法，因此需要一种消除左递归的变换。

左递归产生式`A -> A α|β`可以由下面的非左递归产生式来代替:

```
A -> βA'    A' -> αA' | e
```

这种变换没有改变从A推导出的字符串集合。这条规则适用于很多文法。

例子：考虑下面的算术表达式文法
```
E -> E + T | T
T -> T * F | F
F -> (E) | id
```
消除E和T的直接左递归(形如`A -> Aα`的产生式)，可以得到
```
E -> TE'
E' -> +TE'| e
T -> FT'
T' -> *FT' | e
F -> (E) | id
```
无论有多少A产生式，都可以用下面的技术来消除直接左递归。首先，把A产生式放在一起：
```
A -> Aα1 | Aα2 | ... | Aαm | β1 | β2 | ... | βm 
```
其中，每个βi都不以A开头。然后用下面的产生式代替A产生式：
```
A  -> β1A' | β2A' | ... | βmA'
A' -> α1A' | α2A' | ... | αmA' | e 
```
变换后的非终结符A与变换前的非终结符A产生同样的字符串集合，但已经没有左递归了。这种方法可以从A产生式和A'产生式(假定αi都不等于e)消除直接左递归，但不能消除包括两步或多步推导的左递归。例如，考虑文法
```
S -> Aa | b
A -> Ac | Sd | e
```
非终结符S是左递归的，因为S -> Aa -> Sda,但不是直接左递归。

下面的算法4.1能够系统地消除文法中的左递归。该算法对于所有无循环推导(`A +-> A`的推导)和e产生式(形如`A -> e`的产生式)的文法都有效。循环推导和e产生式都可以系统地从文法中消除掉

**算法4.1** 消除左递归

```
输入：无循环推导和e产生式的文法G
输出：与G等价的无左递归文法
方法：对文法G应用如下算法。注意：得到的非左递归文法可能含有e产生式
1. 以某种顺序排列非终结符A1,A2,...,An
2. 
for i := 1 to n do begin
    for j := 1 to i - 1 do begin
        用产生式A -> δ1γ|δ2γ|...|δkγ代替每个形如A->Aiγ的产生式
        其中，Ai -> δ1|δ2|...|δk是所有的当前Aj的产生式
    end
    消除Ai产生式中的直接左递归
end
```

*注意：因为有e产生式，算法4.1不一定有效，但在这种情形天产生式A->e是无害的*

令非终结符的次序是S、A。在S产生式中没有直接左递归，对于i=1，什么也没做。i=2时，用S产生式替换A -> Sd中的S，得到下面的A产生式。
```
A -> Ac | Aad | bd | e
```
消除A产生式中的直接左递归，产生下面的文法
```
S  -> Aa | b
A  -> bdA' | A'
A' -> cA' | adA' | e
```

#### 提取左因子

提取左因子是一种对产生适合预测分析的文法非常有用的文法变换。提取左因子的基本思想是：当不清楚应该用两个选择中的哪一个来替换非终结符A时，可改写A产生式来推迟这种决定，制导看见足够多的输入能做出正确的选择为止

例如，有如下两个产生式：

```
stmt -> if expr then stmt else stmt
    | if expr then stmt
```

看到输入记号if时，不能立即立刻决定选择哪个产生式来扩展stmt。一般地，如果`A->αβ1|αβ2`是A的两个产生式，输入字符串从α导出的非空串开始，不知道是用`αβ1`来扩展A还是用`αβ2`。然而，可以通过先将A扩展到`αA'`来推迟这个决定。然后，扫描完由α导出的输入字符串后，再把`A'`扩展成`β1`或`β2`，亦即提取左因子。这样的变换以后，原来的产生式变为：
```
A -> αA'  A' -> β1 | β2
```

**算法4.2** 提取左因子
```
输入：文法G
输出：一个等价的提取了左因子的文法。
方法：对每个非终结符A，找出它的两个或者更多候选式的最长公共前缀α。如果α!=e,即有一个非平凡的公共前缀，则用下面的产生式代替所有A产生式A->αβ1|αβ2|...|αβn|γ,其中γ表示所有不以α开头的候选式:
A  -> αA' | γ
A' -> β1 | β2 | ... | βn
```

其中A'是一个新的非终结符。反复应用这种变换，直到任一非终结符都没有两个候选式具有公共前缀为止

#### 非上下文无关语言的结构

有些语言不能用任何文法产生。

例子：考虑抽象语言`L1 = {wcw|w属于(a|b)*}`。L1是所有由隔开的两个相同a、b串组成的字母串集合，例如`aabcaab`。这个语言是检查程序中标识符的声明应先于其应用的抽象，即wcw中的第一个w表示标识符w的声明，第二个w表示它的引用。可以证明该语言不是上下文无关语言。*因为它们要求标识符的声明先于引用，并且允许标识符任意长*

由于上述原因，描述Algol和Pascal语法的文法并不定义标识符中的字符，而只是用文法中id这样的记号代表所有的标识符。在这类语言的编译器中，语义分析阶段检查标识符的声明是否先于引用。

例子：语言`L2 = {a^nb^mc^nd^m | n >= 1 & m >= 1}`不是上下文无关语言。L2是由正则表达式`a*b*c*d*`所表示的语言的子集合，在它的每个句子中，a和c的个数相等，b和d的个数相等(a^n意味着a被写过n次)。它是“过程声明的形参个数和过程引用的实参个数和过程引用的实参个数应该一致”的抽象，a^n和b^m表示两个过程说明的形参表中分别有n和m个参数,c^n和d^m分别表示调用这两个过程的实参表

注意：过程定义和引用的语法并不涉及到参数的个数。例如，一个类似于Fortran语言的中的CALL语句的文法如下：
```
stmt -> call id (expr_list)
expr_list -> expr_list, expr
    | expr
```
其中带有expr的产生式。通常在语义分析阶段检查call中的实参个数是否正确。

例子：语言`L3 = {a^nb^nc^n | n >= 0}`是`L(a*b*c*)`子集合，每个串包括相等个数的a、b和c。L3不是上下文无关语言。下面是一个与L3相关的问题。设打字时用下划线标记的正文，排版输出时改用斜体。为了把在行式打印机的文本文件转换成适于在照相排版机上输出的文本，需要用斜体代替下划线。在打字机上打印一个用下划线标记的单词时，首先在键盘上敲打一串与这个单词对应的字母键，然后敲打相等数量的退格键，最后敲打相等数量的底线键。如用a表示任意的字母键，b表示退格键，c表示底线键，则L3可以表示所有用下划线标记的单词。但是，如果用`<`字母，退格，底线`>`三元组标识用下划线标记的单词，可以用正则表达式`(abc)*`表示用下划线标记的单词集合。

有些语言类似于L1,L2,L3,但却是上下文无关语言。例如，L1' = {wcw^R | w属于(a|b)*}是上下文无关语言，其中w^R表示w的逆序。
```
S -> aSa | bSb | c
```

### 自顶向下语法分析

无回溯自顶向下语法分析器也称为预测语法分析器。这种文法的预测语言分析器可以自动生成。关于预测语法分析器的讨论之外，只讨论非递归的预测语法分析器。

#### 递归下降语法分析器

自顶向下语法分析的目的是为了输入字符串寻找最左推导，从根节点(文法开始符号)开始，自上而下、从左到右地为输入串建立一棵分析树，并以预先确定的顺序创建分析树的节点。先前讨论了一种不需要回溯的特殊递归下降分析法，称为预测分析法。

考虑自顶向下分析的一般形式，称为**递归下降分析法**。它可能需要回溯，即需要重复地扫描输入。然而，需要回溯的语法分析器是不常见的，其原因是在分析程序设计语言的结构时很少需要回溯。即使在分析自然语言的情况下，回溯也不是非常有效的，并且列表的方法更可取。

下面是一个需要回溯的例子。当需要回溯时，建议使用一种记录输入轨迹的方法，考虑下述文法和输入字符串`w = cad`
```
S -> cAd
A -> ab | a
```
为了自顶向下地为w建立分析树，首先建立只具有标记为S的单个节点的树。输入指针指向w的第一个符号c。

最左边的叶子标记为c，匹配w的第一个符号。现在，将输入指针移到w的第二个符号a。考虑下一个标记为A的叶子。用A的第一个候选式扩展A，当已经匹配到了的哥输入符号a时，再将输入指针移到第三个输入符号d，把它和下一个标记为b的叶节点进行比较，因为b和d不匹配，报告失败，回到A，看是否还有别的候选式可试。

回到A时，必须将输入指针重置到第二个符号，即第一次进入A时的位置。这意味着A的程序必须将输入指针保存在一个局部变量中。现在尝试A的第二种候选式，得到图所示的分析树。叶子a匹配w的第二个符号，叶子d匹配w的第三个符号。因为已经产生了w的分析树，停止分析并宣告分析成功！

虽然递归下降语法分析器带有回溯能力，左递归文法也会使其进入无限循环，也就是说，当试图扩展A时，可能最终会发现：在不断试图扩展A，但输入指针并没有前移

#### 预测语法分析器

在许多情况下，通过仔细地编写文法，消除左递归，提取左因子，可以获得一个有效的文法，这个文法可以用不带回溯的递归下降语法分析器来分析。为了构造预测语法分析器，对给定的当前输入符号a和将要扩展的非终结符A，在A的所有可选产生式A -> α1 | α2 | ... | αn中，哪个候选式是唯一能推导出以a开头的串。预测语法分析器能够通过观察候选式所推导出的第一个符号，确定正确的候选式。这种方法可以检测出多数程序设计语言中具有不同关键字的控制流结构。
```
stmt -> if expr then stmt else stmt
    | while expr do stmt
    | begin stmt_list end
``` 
那么关键字if、while、begin告诉如果想找到一条语句哪个候选式是唯一可能成功的选择。

#### 预测分析器的状态转换图

对于词法分析器的设计者来说，状态转换图(transtion diagram)是非常有用的设计工具。也可以为预测语法分析器创建状态转换图。

词法分析器的状态转换图和预测语法分析器的状态转换图具有明显的区别。对于预测语法分析器，每个非终结符都对应一个状态转换图，边上的标记是记号和非终结符。记号(终结符)上的转换意味着如果该记号是下一个输入符号，就应进行该转换。非终结符A上的转换是对与A对应的过程的调用。

为了由文法构造预测语法分析器的状态转换图，首先需要消除文法中的左递归，然后提取左因子，并对每个非终结符A执行如下操作：
1. 创建一个开始状态和一个终态(返回状态)
2. 对每个产生式A->X1X2X...Xn,创建一条从开始状态到终止状态的路径，边上的标记分别为X1,X2,...,Xn

预测语法分析器以状态转换图为基础完成分析工作，其工作方式如下：开始，语法分析器进入状态图的开始状态，输入指针指向输入符号串的第一个符号。如果经过一些动作后，语法分析器进入状态s，且在状态图上从状态s到状态t的边上标记终结符a，而下一个输入符又正好是a，则语法分析器将输入指针向右移动一位指向下一个符号，语法分析器进入状态t。另一个方面，如果边上标记的是非终结符A，则语法分析器进入A的初始状态，但不移动输入指针。一旦语法分析器到达A的终止状态，则立刻进入状态t。事实上，语法分析器从状态s转移到状态t时，已经从输入符号串"读"了A。最后，如果从s到t有一条标记为e的边，那么语法分析器从状态s直接进入状态t而不移动输入指针。

基于状态转换图的预测分析程序试图进行终结符和输入的匹配，并且，当它经过标记为非终结符的边时，进行潜在的递归过程调用。一种非递归的实现方法是，当在状态s上有一个标记为非终结符的指向其他状态的转换时，则将状态s压入栈中，当到达该非终结符的终止状态时，将状态s弹出栈。下面将更详细地讨论状态转换图的实现。

如果给定的状态转换图是确定的，即一个状态对于一个输入仅有一个转换，则上述方法是有效的。如果出现二义性，就要消除，否则不能不够预测语法分析器。但是可以构造低估一下将语法分析器，用回溯的方法尝试所有可能的情况。

#### 非递归的预测分析

通过显式地维护一个状态栈，而不是通过隐式的递归调用，可以构造非递归的预测语法分析器。预测分析的关键问题就是确定用于扩展非终结符的产生式。

**非递归语法分析器**通过查分析表来选取产生式。表驱动的预测语法分析器有一个输入缓冲区、一个栈、一张分析表和一个输入流。输入缓冲区包含要分析的串，后面跟一个符号`$`,`$`是输入串的结束标记。栈用来存放文法符号序列。栈底符号是`$`。初始时，栈中含有文法符号序列及其下边的`$`。分析表是一个二维数组`M[A,a]`,A是非终结符，a是终结符或`$`

语法分析器由一个按如下方式工作的程序控制：程序根据栈顶当前的符号X和当前输入符号a决定语法分析器的动作：
* 如果`X = a = $`，则语法分析器宣告分析成功并停止
* 如果`X = a != $`，则语法分析器弹出栈顶符号X，并将输入指针移到下一个输入符号上。
* 如果X是非终结符,则程序访问分析表M的`M[X,a]`项。`M[X,a]`项是文法的一个X所产生或者出错信息。例如，如果`M[X,a] = {X -> UVW}`,则语法分析器用WVU(U在栈顶)代替栈顶符号X.

**算法4.3** 非递归的预测分析
```
输入：串w和文法G的分析表M
输出：如果w属于L(G),则输出w的最左推导，否则报告错误。
方法：开始时，语法分析器的格局是$在栈里(其中S是G的开始符号且在栈顶)，w$在输入缓冲区。下述程序是用预测分析表M分析输入串的程序

令ip指向w$的第一个符号；
repeat
    令X是栈顶符号，a是ip指向的符号；
    if X是终结符或者$ then
        if X = a then
            从栈中弹出X，ip指向下一个符号
        else 
            error()
    else
        if M[X,a] = X -> Y1Y2...Yk then begin
            总栈中弹出X;
            将Yk, Yk-1, ..., Y1 压入栈，Y1在栈顶
            输出产生式X -> Y1Y2...Yk
        end
        else 
            error()
until X = $  /* 栈空 */
```

#### FIRST和FOLLOW

构造文法G的分析表需要两个与G有关的函数FIRST和FOLLOW。可以用这两个函数来填写G的分析表的表项。由FOLLOW函数产生的记号集合还可用做紧急方式错误恢复期间的同步记号。

如果α是任意的文法符号串，则定义FIRST(α)是从α推导出的串的开始符号的终结符集合，即`FIRST(α) = {α | α *-> a..., a是终结符}`。如果`a *-> e`,则e也属于`FIRST(α)`

设A是一个非终结符，定义`FOLLOW(A)`是包含所有在句型中紧跟在A后面的终结符a的集合，即`FOLLOW(A) = {a | S *-> αAaβ, a是终结符}`。注意，在推导某一时刻，在A和a之间可能有符号，但如果是这样，它们将推导出e并消失。如果A是某个句型的最右符号，那么$属于FOLLOW(A)

为了计算文法符号X的FIRST(X),可以应用下列规则，直到没有终结符或e可加到某个FIRST集合为止：
* 如果X是终结符，则FIRST(X)是{X}
* 如果X->e是一个产生式，则将e加到FIRST(X)中
* 如果X是非终结符，且X->Y1Y2...Yk是一个产生式，则
1. FIRST(Yi)中的所有符号在FIRST(X)中
2. 若对于某个i，a属于FIRST(Yi)且e属于FIRST(Y1),...,FIRST(Yi-1),即`Y1...Yi-1 *-> e`,则将a加入FIRST(X)中。
3. 若对于所有的j=1,2,...,k,e在FIRST(Yj)中，则将e加到FIRST(X)中。

例如，FIRST(Y1)中的每个元素确实都存在FIRST(X)中，如果Y1不能导出e，则不再往FIRST(X)中增加新符号，如果`Y1*->e`,则将FIRST(Y2)加到FIRST(X)中，依次类推

```
FIRST(E) = FIRST(T) = FIRST(F) = {(, id}
FIRST(E) = {+, e}
FIRST(T) = {*, e}
FOLLOW(E) = FOLLOW(E') = {), $}
FOLLOW(T) = FOLLOW(T') = {+, ), $}
FOLLOW(F) = {+, *, ), $}
```

例如，根据计算FIRST的规则1，FIRST(id) = {id}且FIRST('(') = {(}。根据规则3与i=1,id和左括号被加入FIRST(F)中。再根据规则3与i = 1,产生式T->FT意味着id和左括号也在FIRST(T)中。另外，根据规则2，e属于FIRST(E')。

为计算FOLLOW集，根据计算FOLLOW的规则1将$放入FOLLOW(E)中。把规则2应用到产生式F->(E),右括号也在FOLLOW(E)。把规则3应用到产生式E->TE'意味着FIRST(E')中除e以外的所有字符都应该放入FOLLOW(T)。

#### 预测分析表的构造

**算法4.4** 构造预测分析表
```
输入：文法G
输出：分析表M
方法：
1. 对于文法中的每个产生式A->α，执行第2
2. 对FIRST(α)中每个终结符α，将A->α加入到M[A,a]中
3. 若e在FIRST(α)中，则对FOLLOW(A)的每个终结符b，将A->a加入到M[A,b]中，若e在FIRST(α)中，且$在FOLLOW(A)中，则将A->α加入到M[A,$]
4. 将M中每个没定义的表项均置为error
```

#### LL(1)文法

算法4.4应用于任何文法G可以产生分析表M。然而，对某些文法，M可能含有多重定义的表项。例如，若G是左递归的或二义性的，则M至少包含一个多重定义的表项。分析表项汇总没有多重定义表项的文法叫做LL(1)文法。LL(1)中的第一个L代表从左向右扫描输入，第二个L代表产生最左推导，1代表在决定语法分析器的每步动作时间向前扫描一个输入符。

可以证明：算法4.4可以为任何LL(1)文法G产生分析表。这个分析表能分析G的所有句子，而且只能分析G的句子

LL(1)文法有一些特殊的性质。它不是二义性的，也不含左递归。可以证明，G是LL(1)文法，而且仅当G的任何两个不容的产生式A->α|β满足下面的条件:
1. 不存在这样的终结符a，使得α和β导出的串都以a开始
2. α和β中至多有一个能导出空串
3. 如果`β * ->e`,那么α不能导出以FOLLOW(A)中的终结符开始的任何串。

消除分析表中含有的多重定义的方法：

## 第五章：语法制导翻译

## 第六章：类型检查

## 第七章：运行时环境

## 第八章：中间代码生成

## 第九章：代码生成

## 第十章：代码优化



