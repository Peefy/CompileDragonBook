
# 前言

**DSL 领域特定语言**

领域特定语言（英语：domain-specific language、DSL）指的是专注于某个应用程序领域的计算机语言。又译作领域专用语言。

在定义DSL是什么的问题上，Fowler 认为业界经常使用的一些特征，例如“关注于领域”、“有限的表现”和“语言本质”是非常模糊的。因此，唯一能够确定DSL边界的方法是考虑“一门语言的一种特定用法”和“该语言的设计者或使用者的意图”：
如果XSLT的设计者将其设计为XML的转换工具，那么认为XSLT是一个DSL。如果一个用户使用DSL的目的是该DSL所要达到的目的，那么它是一个DSL，但是如果有人以通用的方式来使用一个DSL，那么它（在这种用法下）就不再是一个DSL了

域特定语言（英语：domain-specific language、DSL）指的是专注于某个应用程序领域的计算机语言。又译作领域专用语言。不同于普通的跨领域通用计算机语言(GPL)，领域特定语言只用在某些特定的领域。 比如用来显示网页的HTML，以及Emacs所使用的Emac LISP语言。

DSL可以简化复杂的代码，促进与客户沟通的效率，提高工作效率，清除发展瓶颈。

**编译相关的程序**

* **解释程序 (interpreter)**-
* **汇编程序（assembler）**-
* **连接程序（linker）**-
* **装入程序（loader）**-
* **预处理器（preprocessor）**-
* **编辑器（editor）**-
* **调试程序（debugger）**-
* **描述器（profiler）**-
* **项目管理程序（project manager）**-

**编译相关的步骤**

* **扫描程序（scanner）**-
* **语法分析（parser）**-
* **语义分析（semantic analyzer）**-
* **优化程序（source code optimizer）**-
* **代码生成（code generator）**-
* **目标代码（target code optimizer）**-

**编译相关的记号**

* **记号（token）**-
* **语法树（syntax tree）**-
* **符号表（symbol table）**-
* **常数表（literal table）**-
* **中间代码（intermediate code）**-
* **临时文件（temporary file）**-

# 第一部分

## 第1章 入门例子

### 1.1 哥特式建筑安全系统

想要构建一套这样的安全系统，公司的人进入之后，设置某种无线网络，安装一些小的设备。如果发生某些有趣的事情，这些设备会发出一条四字符的消息。比如，打开抽屉，抽屉上的感应器就会发出一条消息：D2OP。还有一些小的控制设备，响应这样的四字符命令消息。比如，某个设备收到D1UL消息，就会打开一扇门。

假设有这样一系列系统，它们共享着大多数组件和行为，却彼此间差异巨大。在这个例子中，对所有的客户来说，控制器发送和接收消息的方式是相同的。但是产生的事件序列和发送的命令却不尽相同。

把控制器看做是**状态机(state machine)**，每个感应器都可以发送**事件(event)**，改变控制器的**状态(state)**。当控制器进入某种状态时，就会在网络上发出一条命令消息。

### 1.2 状态机模型

对于指定控制器如何运作而言，状态机是一个恰当的抽象，下一步就是确保这个抽象能够运用到软件自身。如果人们在考虑控制器行为时，也要考虑事件，状态和转换，那么，希望这些词汇也可以出现在软件代码里。从本质上说，这就是**领域驱动设计(Domain-Driven Design)**中的**DDD原则**。也就是说在领域人员和程序员之间构建的一种共享语言。

对于Java程序来说，自然的方式就是以状态机为Domain Model。通过接收事件消息和发送命令消息，控制器得以同设备通信。这些消息都是四字母编码，可以通过通信通道进行发送。在控制器代码里面，想用**符号名(symbolic name)**引用这些消息。创建了事件类和命令类，它们都有代码(code)和名字(name)。把它们放到单独的类里面(有一个超类)，因为在控制器的代码里，它们扮演者不同的角色。

```java
class AbstractEvent {
    private String name, code;
    public AbstractEvent(String name, String code) {
        this.name = name;
        this.code = code;
    } 
    public String getCode() {
        return code;
    }

    public String getName() {
        return name;
    }
}
public class Command extends AbstractEvent {}
public class Event extends AbstractEvent {}
```

状态类记录了它会发送的命令及其相应的转换

```java
class State {
    private String name;
    private List<Command> actions = new ArrayList<Command>();
    private Map<String, Transition> transitions = new HashMap<String, Transtion>();
}

class State {
    public void addTranstion(Event event, State targetState) {
        assert null != targetState;
        transtitions.put(event.getCode(), new Transition(this, event, targetState));
    }
}

class Transition {
    private final State source, target;
    private final Event trigger;

    public Transtion(State source, Event trigger, State target){
        this.source = source;
        this.target = target;
        this.trigger = trigger;
    }

    public State getSource() {
        return source;
    }

    public State getTarget() {
        return target;
    }

    public Event getTrigger() {
        return trigger;
    }

    public String getEventCode() {
        return trigger.getCode();
    }
}
```

状态机保存了其起始状态。

```java
class StateMachine...
    private State start;

    public StateMachine(State start) {
        this.start = start;
    }
```

这样，从这个状态可以到达状态机里的任何状态

```java
class StateMachine...
    public Collection<State> getStates() {
        List<State> result = new ArrayList<State>();
        collectState(result, start);
        return result;
    }

    private void collectStates(Collection<State> result, State s) {
        if (result.contains(s)) return;
        result.add(s);
        for (State next : s.getAllTargets())
            collectStates(result, next);
    }

class State...
    Collection<State> getAllTargets() {
        List<State> result = new ArrayList<State>();
        for (Transtion t : transitions.values())
            result.add(t.getTarget());
        return result;
    }
```

为了重置事件，在状态机上保存了一个列表。

```java
class StateMachine...
    private List<Event> resetEvents = new ArrayList<Event>();

    public void addResetEvents(Event... events) {
        for (Event e : events) 
            resetEvents.add(e);
    }
```

像这样用一个单独结构处理重置事并不是必需的。简单🉐地在状态机上声明一些额外的转换，也可以处理这种情况，如下所示：

```java
class StateMachine...
    private void addResetEvent_byAddingTransitions(Event e) {
        for (State s : getStates()) 
            if (!s.hasTransition(e.getCode(), s.addTransition(e,start)));
    }
```

倾向于在状态机上设置显式的重置事件，这样可以更好地表现意图。虽然这样做确实使状态机有点复杂，但它也更加清晰地表现出通用状态机该如何运作，要定义特定状态机也会更加清晰。

处理完结构，再来看看行为。事实证明，这真的相当简单。控制器有个handle方法，它以从设备接收到的事件代码为参数。

```java
class Controller...{
    private State currentState;
    private StateMachine machine;

    public CommandChannel getCommandChannel() {
        return commandsChannel;
    }

    private CommandChannel commandsChannel;

    public void handle(String eventCode) {
        if (currentState.hasTransition(eventCode))
            transitionTo(currentState.targetState(eventCode));
        else if (machine.isResetEvent(eventCode))
            transitionTo(machine.getStart());
        // ignore unknown events
    }

    private void trasitionTo(State target) {
        currentState = target;
        currentState.executeActions(commandsChannel);
    }
}
class State {
    public boolean hasTransition(String eventCode) {
        return transtions.containsKey(eventCode);
    }

    public State targetState(String eventCode) {
        return transtions.get(eventCode).getTarget();
    }

    public void executeActions(CommandChannel commandsChannel) {
        for (Command c : actions) commandChannel.send(c.getCode());
    }
}
class StateMachine... {
    public boolean isResetEvent(String eventCode) {
        return resetEventCode().contains(eventCode);
    }
}
```

对于未在状态上注册的事件，它会直接忽略。对于可识别的任何事件，它就会转换为目标状态，并执行这个目标状态上定义的命令。

### 1.3 控制器编写程序

除了构建状态机模型的代码，还需要其他代码。一般是按照如下划分：

* 程序库，框架或者组件的代码
* 配置代码，组件组装代码。

这种做法分开了公共代码和可变代码。用公共代码构建一套组件，然后根据不同的目的进行配置。如配置代码可以为XML，json，yaml等文件，但是代价是配置上的语法错误只能在运行时检测出来。

DSL只有同其他语言配合起来，才能完成整个工作，DSL的简单性意味着，它是容易编辑和处理的。本文DSL有两种，称为外部DSL和内部DSL。外部DSL是指，在主程序设计语言之外，用一种单独的语言表示领域专用语言。这种语言用的可能是定制语法，或者遵循另一种表现的语法，比如XML。内部DSL是指用通用语言的语法表示的DSL。

### 1.4 语言和语义模型

状态机与DSL的关系是至关重要的。在上面的例子中，DSL的角色就是组装状态机模型。

一个例子:

```dsl
events
  doorClosed D1CL
```

上述DSL会创建一个新的事件对象

```java
new Event("doorClosed", "D1CL")
```

并且把它保存在一边，这样，遇到`doorClosed => active`时，就可以将它包含在一个转换里(使用addTransition)。这个模型就是个引擎，提供了状态机的行为。事实上，可以说，这个设计的能力大多源自这样一个模型。DSL所做的一切就是提供一种更可读的方式来组装这个模型，这就是与开始的命令查询API不同的地方。

涉及到编程语言时，常常会提到**语法(syntax)**和**语义(semantics)**。语法描述程序的合法表达式，而在DSL中所能描述的一切都是由**文法(grammer)**决定的。程序的语义是指，它代表着什么。也就是说，它能做什么。

对于一个设计良好的DSL而言，语义模型至关重要。语义模型可以是对象模型，还可以是其他形式。即便它只是一个纯粹的数据结构，所有的行为都在单独的函数里，依然愿意称之为语义模型，因为在那些函数的上下文里，数据结构表现出了DSL脚本特定的含义。

DSL只是扮演着展示模型配置机制的角色。使用这种方式的益处大多源自模型，而非DSL。为客户配置新的状态很容易，这是模型的属性，而非DSL。控制器可以在运行时改变，无须编译，这是模型的属性，而非DSL。

DSL所带来的益处与状态机紧密相关，其所组成的某个特定模型就扮演了系统程序的角色。要改变状态机的行为，就需要修改模型中的对象及其相互关系。这种风格的模型通常称为“适应性模型”。这样得到的是一个模糊代码和数据之间差异的系统，只看代码，是无法理解状态机行为的，还必须了解对象实例的连接方式。当然，从某种程度上说，这总是对的，任何程序对不同的数据都会给出不同的结果，但在此有个极大的差异，因为状态对象的存在会在很大程度上改变系统的行为。

适应性模型非常强大，但是通常也很难用，因为人们看不到任何定义特定行为的代码。DSL是有价值的，它提供了一种显式的方式表现代码，这种形式让人们对状态机编程有了感觉。

### 1.5 使用代码生成

要处理DSL，组装“语义模型”，然后执行语义模型，提供希望从控制器得到的行为，在语言圈子里，这种方式称为**解释(interpretation)**。在解释文本时，会解析文本，然后程序立刻产生结果。

在语言领域里，与解释相对的是编译。在编译时，先解析程序文本，产生中间输出，然后单独处理输出，提供预期行为。在DSL的上下文里，编译方式通常指的是**代码生成(code generation)**

代码生成通常很笨拙，因为它常常需要进行额外的编译步骤。为了构建程序，首先需要编译状态框架和解析器，其次运行解析器，为控制器生成源代码，然后编译生成的代码。这样做，构建过程就变得复杂许多。然而，代码生成的一个优势在于，编写解析器和生成代码可以用不同的语言。在这个情况下，如果生成的代码用的是动态语言(如JS),第二哥编译步骤就可以省略。

### 1.6 使用语言工作台

语言工具台是一个环境，设计初衷就是帮助人们构建新的DSL，以及有效地运用这些DSL所需的高质量工具。甚至设计对图形语言的支持，但是还存在一些问题和发展前途。

### 1.7 可视化

语言工作台的一大优势在于它们给了DSL更为多样的表现形式，特别是图形化表示。然而，即使是文本化的DSL也可以有图形化的表示。

对于许多DSL来说，使用类似于Graphviz这样的工具非常有用，因为它给了另一种表现形式。类似于DSL本身，这种**可视化(visualization)**表现形式可以让人更好地理解模型。可视化不同于对应的源代码，其本身无法编辑。

## 第2章 使用DSL

### 2.1 定义DSL

领域特定语言：针对某一特定领域，具有受限表达性的一种计算机程序设计语言。这一定义包含4个关键元素：

* **计算机程序设计语言**-用DSL指挥计算机做一些事情。同大多数现代程序设计语言一样，其结构设计成便于人们理解的样子，但它应该还是可以由计算机执行的语言。
* **语言性**-DSL是一种程序设计语言，因此必须具备连贯的表达能力----不管是一个表达式还是多个表达式组合在一起
* **受限的表达性**-通用程序设计语言提供广泛的能力：支持各种数据，控制，以及抽象结构。这些能力很有用，但也会让语言难于学习和使用。DSL只支持特定领域所需要特性的最小集。使用DSL，无法构建一个完整的系统，相反，却可以解决系统某一方面的问题。
* **针对领域**-只有在一个明确的小领域下，这种能力有限的语言才会有用。这个领域才使得这种语言值得使用。

DSL主要分为三类：

* **外部DSL**-是一种“不同于应用系统主要使用语言”的语言。外部DSL通常采用自定义语法，不过选择其他语言的语法也很常见(XML就是一个常见的选择)。宿主应用的代码会采用文本解析技术对使用外部DSL编写的脚本进行解析。一些小语言的传统UNIX就符合这种风格。可能经常会遇到的外部DSL的例子包括：正则表达式、SQL、Awk，以及像Struts和Hibernate这样的系统所使用的XML配置文件。
* **内部DSL**-是一种通用语言的特定语法。用内部DSL写成的脚本是一段合法的程序，但是它具有特定的风格，而且只用到了语言的一部分特性，用于处理整个系统一个小方面的问题。用这种DSL写出的程序有一种自定义语言的风格，与其所使用的宿主语言有所区别。这方面最经典的例子是Lisp。Lisp程序员写程序就是创建和使用DSL。Ruby最著名的框架Rails，经常被认为是一套DSL。
* **语言工作台**-是一个专用的IDE，用于定义和构建DSL。具体来说，语言工作台不仅用来确定DSL的语言结构，而且是编写DSL脚本的编辑环境。最终的脚本将编辑环境和语言本身紧密结合在一起。

#### DSL的边界

DSL边界问题其实就是内部DSL与命令/查询式API之间的差异。从许多方面来说，内部DSl不过是一种特殊的API，核心差异在于语言性。

给具有命令/查询式API的类编写文档，一种常见的方式是列出其所拥有的所有方法，意味着每个方法自身都有独立含义，一组“词汇”，每一个都有自己的完备语义。而内部DSL的方法名只在一个更大表达式的上下文中才有明确的含义。

内部DSL给人的感觉是一个整句，而非一个无关命令的序列。这正是这种API称为连贯接口的基础。对内部DSL来说，受限表达式显然不是语言的一项核心属性，因为内部DSL植根于一个通用语言。在这种情况下，受限表达性表现在如何使用它。当构造DSL表达式时，会限制自己只使用通用语言的一部分特性，通常不会使用条件判断、循环结构和变量。

对外部DSL来说，其边界就是它与通用语言之间的边界。语言可以针对某领域，但仍然是通用语言。R语言就是一个很好的例子，它是一种用于统计的语言和平台，主要用于解决统计方面的问题，它也具备通用语言所有的表达性。因此，尽管它针对某一领域，但是依然不会称其为一种DSL。

一种更为明显的DSL是正则表达式。它所针对的领域(文本匹配)与其有限的特性紧密相关----那些特性刚刚好能做到易于匹配文本。DSL的一个普遍特征是，它们不是图灵完备的。一般来说，DSL不支持常见的命令式控制结构(条件和循环)，也不能定义变量和子例程。

#### 片段DSL和独立DSL

之前用的状态机的例子是一种独立的DSL。DSL出现的另外一种方式是**片段形式**。对于这种形式，DSL片段用于宿主语言的代码中。可以将其看作采用额外特性对宿主语言进行增强。

片段的一个典型例子是正则表达式，可以见到在一个程序中点缀着正则表达式片段，另外一个典型例子是SQL，在大型程序的上下文中，常常会用到SQL语句。

### 2.2 为何需要DSL

DSL是在特定条件下有专门用途的一种工具。DSL只是模型的一个薄壳，这个模型可能是程序库，也可能是框架。

#### 提高开发效率

DSL提供了一种手段，可以更加清晰地就系统某部分的意图进行沟通，DSL相比于采用命令-查询API，DSL形式更容易理解。DSL提供了一种“对阅读和操作抽象”更具表达性的形式，从而增强了这种抽象。DSL还可以帮助人们更好地学习使用API。

#### 与领域专家的沟通

让领域专家能够阅读懂代码，就可以直接指出问题所在，还可以同编写业务规则的程序员更好地交流，还可以编写一些草稿使程序员可以将其细化为适当的DSL规则。

#### 执行环境的改变

状态机可以在运行时解析，而非编译时。因此可以将代码运行于不同的环境，这类理由也是使用DSL一个常见的驱动力。对于XML配置文件而言，将逻辑从编译时移到运行时就是一个这样的理由。

用DSL常常可以弥补宿主语言的局限性，将事物以适宜的DSL形式表现出来，生成可用于实际执行环境的代码。模型的存在有助于这种迁移。

#### 其他计算模型

几乎所有主流的编程语言都采用命令式的计算模型。把非命令式方式称为声明式编程。之所以叫做声明式，是因为这个种风格让人定义做什么，而不是用一堆命令语句来描述怎么做。

### 2.3 DSL的问题

不使用DSL的唯一原因就是，使用DSL得不到任何好处，或者，至少是DSL的好处不足以抵消构建它的成本。

许多DSL的问题只是与某种特定DSL风格相关，要理解这些问题，需要深入理解这些DSL是如何实现的。

#### 语言噪音

虽然了解多种语言会让工作更加困难，但是DSL远比一门通用语言容易，因此，学习起来也要容易的多。

#### 构建成本

DSL的可维护性是一项重要的考量因素。DSL的成本大雨构建模型的成本。一个好的DSL可以封装一个糟糕的程序库，把它变得容易用。但是糟糕的DSL对于构建和维护而言，就是浪费资源，但这种说法对任何代码都适用。

#### 集中营语言

**集中营语言(ghetto language)**问题与语言噪音问题正好相反。一种DSL总是存在着无意中演化成一种通用语言的危险，有一种DSL，然后逐步为它添加新功能：今天添加条件表达式，明天又添加循环，最终图灵完备了。不是自己的业务，不要自己写，随着开源工具的崛起，基于已有开源工作量进行扩展，比从头打造更有意义。

#### “一叶障目”的抽象

任何DSL抽象总是伴随着风险，只知抽象，不知道具体实现。

### 2.4 广义的语言处理

也涉及语言处理技术，90%都是为了DSL，DSL中的语言处理技术也可以用在其他文字处理上。

### 2.5 DSL的生命周期

对于内部DSL，要符合宿主语言的语言；对外部DSL，语句要能够解析。其他DSL开始时比较非正式，然后再对照DSL进行修改，以得到一种合理的语法。对于每个例子，尝试用DSL的形式把它们写下来，随着处理到不同的情况，就要修改DSL，支持新的能力。最后，就会得到一套合理的用例，以及对这些用例的伪DSL描述。如果用的是语言工作台，就要在工作台之外完成这一阶段，用一个纯文本编辑器，或者一个普通的绘图软件，也可以是纸和笔。

一旦有了一套典型的伪DSL，就可以着手实现它了。这里的实现包括以宿主语言设计的状态机模型，模型的命令-查询API，DSL的具体语法以及DSL和命令-查询API之间的转换。

DSL分为测试驱动开发和基于模型发展两种方法。基于模型发展DSL发展DSL的方法有两种。对于“语言生长”的方式，要慢慢地在模型之上构建DSL，把模型几乎看作黑盒。首先看看目前所有的控制器，然后草拟出每个控制器的伪DSL。然后，一个场景一个场景地实现DSL，通常，不会对模型做任何深入的修改，尽管给模型添加一些方法能够更好的支持DSL。

### 2.6 设计优良的DSL从何而来

DSL的总体目标就是对读者要清晰，进行迭代设计，从目标受众那里获得反馈，准备多种方案，看看其他人的反应。DSL是一种程序设计语言，使用它应该像编程。

## 第3章 实现DSL

### 3.1 DSL处理之架构

DSL实现的大体架构：**DSL脚本 解析->语义模型 生成->目标代码**。所有重要的语义行为都可以在模型中铺货，而DSL的任务就是通过解析来填充模型。所以，语义模型在DSL中扮演着核心角色。

DSL语义模型通常是一个系统的Domain Model的子集，因为并不是Domain Model的所有部分都适合用DSL处理。语义模型完全就是一个普通的对象模型，可以像操作其他所有对象模型一样操作它。用状态模型的命令-查询API组装一个状态机，然后运行它，获取状态对象的行为。从某种意义上说，它与DSL是相互独立的，但是在现实中，它们又相互依赖。

分离语义模型和DSL有几个好处。首先，可以暂时不纠结于DSL的语法和解析器，而专注于当前领域的语义。如果用上DSL，就说明所表达的东西已经非常复杂，复杂到要拥有自己的模型来表示。可以直接创建语义模型中的对象，操作它们进行测试。比如，，可以创建一堆状态和迁移(transition)，测试事件(event)和命令(command)是否运行良好。

拥有一个独立的语义模型，模型和语言就可以独立演化。如果要改变模型，无须修改DSL就可以探索做法，模型能够工作后，给DSL添加必要的语言构造即可。同样，如果需要尝试不同的DSL语言，只要验证它们是否可以创建相同的模型对象即可。比较它们组装语义模型方式的不同，就可以知道两种语法之间的区别。

内部DSL和外部DSL的不同就在于解析这一步，既包括解析的目标，也包括解析的方式。两种风格的DSL都会产生同样的语义模型，没有理由不使用单独的语义模型。

当使用外部DSL时，DSL脚本，解析器和语义模型之间有条清晰的界限。DSL脚本由一种独立的语言编写，解析器读取这些脚本，然后组装语义模型。而使用内部DSL时，它们之间更容易混杂在一起。

代码生成是指生成单独编译和运行的代码，它是DSL中的一个可选项。使用语义模型生成代码的一个好处，它解耦了代码生成器和解析器。

### 3.2 解析器的工作方式

解析是一个很强的层级操作。当解析文本时，把数据块组织成一个树结构。考虑一个简单结构，状态机中的事件列表:

```dsl
events
  doorClosed D1CL
  drawOpened D2OP
end
```

这个复合结构是一个事件列表，包含一系列事件，每个事件都有名字和代码。对于真个列表，这里没有显式的标记，但是每一个事件本身仍然是一个层级：每个事件都有表示名字的符号和表示代码的字符串。

无论何时看到这样的脚本，都可以把它想象为一个层级，这样的层级称为语法树或解析树。任何脚本都可以转化为许多潜在的语法树----这取决于如何分解它。相当于单词，语法树是一种更高效的脚本表现形式，因为可以遍历语法树，使用各种不同的方式来对它进行操作。

可以把一个语法树翻译成语义模型。人们通常直接执行语法树，或者基于语法树生成代码。更有效的做法是，语法树可以直接当作语义模型来使用。

很多时候，语法树在调用栈中形成，在遍历的过程中得到处理。所以一般看不到整个树，而只能看到当前处理的分支。语法树的形成有赖于方法调用的实参和嵌套对象。使用外部DSL会产生一个更加显式的语法树。但即使是外部DSL，通常在处理过程中，也是在调用栈中不断形成和修剪着语法树。

### 3.3 文法，语法和语义

**文法**是一种规则，用以描述如何将文本流转化为语法树。文法由一系列**产生式规则**组成，每个产生规则都有一个名字(term)以及一个描述如何分解它的语句(statemant)。所以，一个加法语句可能就是:`addtionStatement:=number + number`。如果遇到语句`5+3`，解析器能够将其识别为加法语句。因为规则是相互引用的，所以也会有一条针对数字的规则，告诉如何识别合法数字。通过这些规则，可以得到一种语言的文法。

一种语言可以由多种不同的文法来定义，认识到这点很重要。世界上不存在某种语言的唯一文法。一种文法就定义了语言所生成的语法树的一种结构，对于一段特定的文本，可能会识别出许多不同的语法树结构。一种文法只定义一种形式的语法树：选择何种文法和语法树取决于很多因素，包括语言的文法特性以及处理语法树的方式等。

文法只定义一种语言的语法----它在语法树中如何表现。而这与语义无关。根据上下文不同，`5+3`可能等于`8`，也可能等于`53`，语法相同，但语义可能截然不同。语义的定义浓缩为如何根据语法树组装语义模型，以及如何处理语义模型。特别是，如果两个表达式产生相同结构的语义模型，即使语法不同，它们的语义其实也是相同的。

如果在使用外部DSL，用到了“语法制导翻译”，很可能会显式地使用文法来构建解析器。如果用的是内部DSL，可能没有显式的文法，但是从文法的角度思考DSL仍然是有用的，文法有助于在众多内部DSL模式中进行选择。

对于内部DSL，谈论文法显得有些奇怪，原因之一是，这里解析了两遍，所以包含了两种文法。第一种是宿主语言本身的解析，这显然要依赖于宿主语言的文法。这一遍解析创建宿主语言的执行指令。当宿主语言所构建的DSL执行时，语法树就会在调用栈中创建。只有在第二遍解析时，才会出现这个名义上的DSL语法。

### 3.4 解析中的数据

当解析器执行时，需要存储解析过程中的数据。这些数据可能是一个完整的语法树，但大多数情况下不是这样的。即使这种情况出现了，还是需要存储其他的一些数据，以便解析工作可以正常进行。

解析本质上是一种树遍历，当处理某一部分DSL脚本时，对于正在处理的语法树分支，可以得到其上下文的一些相关信息。然而，通常还会用到这个分支以外的信息。

命令定义在语言的某个地方，然后在其他地方引用。当命令在语句的行为中引用时，所在的语法树分支不同于命令定义的分支。如果语法树的表示只存在于调用栈中，那么到这里。命令定义就已经消失了。因此，要把命令对象保存下来以备后用。

为了做到这一点，需要使用**符号表**，它本质上是一个字典，其键是标识符`unlockDoor`，值是在解析中表示命令的对象。当处理文本`unlockDoor D1UL`时，创建一个对象持有数据，然后，把它存放在符号表里，键为`unlockDoor`。存放的对象可能是命令的语义对象，也可能针对局部语法树的中间对象。符号表对于交叉引用非常重要。如果在解析中创建一棵完整的语法树，理论上，可以省略符号表，但是它依赖是一个有用的结构。

### 3.5 宏

宏有两种风格，文本宏和语法宏。文本宏最容易理解，简单说就是文本替换。使用文本宏会带来便利，一个很好的例子就是在CSS文件中指定颜色。更复杂的宏例子是C的预处理器，比如，定义一个宏sqr(x)，它可以替换为`x*x`。

通过宏创建DSL有很多方式，可以使用宿主语言本身，也可以提供单独的一个文件，将其转换为宿主语言。语法宏也是通过替换实现的，但是它处理的是宿主语言中有效的元素，将一种表达式转换为另一种。

### 3.6 测试DSL

* 语义模型的测试
* 解析器的测试
* 脚本的测试

#### 语义模型的测试

```java
@Test
public void eventCausesTranstion() {
    State idle = new State("idle");
    StateMachine machine = new StateMachine(idle);
    Event cause = new Event("cause", "EV01");
    State target = new State("target");
    idle.addTransition(cause, target);
    Controller controller = new Controller(machine, new CommandChannel());
    controller.handle("EV01");
    assertEquals(target, controller.getCurrentState());
}
```

上面的代码演示了如何独立测试语义模型。然而，需要说明的是，这个例子的真是测试代码会更加复杂，也应该更好地分解。

有两种方法来分解这类代码。首先，创建一堆小的状态机，提供最小的测试夹具，以便测试语义模型的各种特性。比如，要测试“事件触发转换”(event triggers a transition)，只要创建一个简单状态机，它处于空闲态，并且可以转换(transition)为另外两个状态。

#### 解析器的测试

当使用语义模型时，解析器的工作就是组装语义模型。所以，解析器的工作就是组装语义模型。所以，解析器的测试就是，编写一小段DSL，确保它们生成结构正确的语义模型。

#### 无效输入的测试

刚才讨论的是正向测试，保证有效的DSL输入可以生成结构正确的“语义模型”。测试的另一种类型是负向测试，用于检测在无效输入的情况下会发生什么。无效输入的测试的基本想法，就是把各式各样的无效输入抛给解析器，经常会看到一些不起眼却很极端的错误。得到这样的结果可能已经足够了，除非要对错误诊断提供更多的支持。

#### 脚本的测试

语义模型和解析器的测试就是对普通对待进行单元测试。然而，DSL脚本也是代码，也应该考虑对它们进行测试。把测试看作double-check机制。当编写代码和测试时，其实是用两种非常不同的方式确定同一行为，一种用抽象的方式，另一种是用样例的方式。对任何有持久价值的东西，都应该进行双重确认。

脚本测试的细节很大程度上取决于要测试的东西。基本的方法是，提供一个测试环境，在其中创建文本夹具，运行DSL，比较结果。脚本测试也扮演着集成测试的角色，因为解析器或者语义模型的任何错误都会让它失败。

### 3.7 错误处理

解析器和生成输出是编写编译器中较为容易的部分，难点之一是给出更好的错误消息，DSL的注释支持。存在两个地方可以放置错误处理：模型或者解析器。对于语法错误，处理它最明显的地方就是解析器。

在处理语义错误时，要从解析器和模型中进行选择，两者都有其优点。如果要检查语义规则是否结构良好，模型是一个正确的地方。

* 把错误检测规则放在解析器中
* 把语义信息放入语义模型
* 使用语义模型检测错误

### 3.8 DSL迁移

DSL应该警惕的一个风险是“先编写，后使用”的想法。DSL的诸多属性同程序库完全一样，会不断发展变化并修改。

解决DSL修改问题的一种方式是，提供工具，自动把DSL从一个版本迁移到另一个版本。这些工具可以在升级时运行，也可以在尝试运行旧版脚本时自动运行。有两种方式实现迁移：

* 增量迁移的策略，这种方式本质上同人们处理数据库设计的演化所采用的想法是一致的。
* 基于模型的迁移，这种策略是可以与“语义模型”配合使用。语言就可以支持多个解析器，每个发布版对应一个解析器。每个解析器都会组装语义模型。当采用语义模型时，解析器的行为相当简单。*问题：很容易丢掉一些与语义无关但脚本编写者希望保留的东西：注释*

## 第4章 实现内部DSL

当使用内部DSL时，宿主语言很大程度上会造成限制，因为所用的任何表达式在宿主语言中都必须是合法的，内部DSL使用的很多思想都受限于语言特性。

**连贯接口**-用它描述接近语言风格的API，它是内部DSL的同义词。它揭示了API与DSL之间的核心区别----语言性。

### 4.1 连贯API与命令 - 查询API

连贯接口的核心模式是**方法级联**

```dsl
computer()
    .processor()
    .cores(2)
    .speed(2500)
    .i386()
.disk()
    .size(150)
.disk()
    .size(75)
    .speed(7200)
    .sata()
.end();
```

方法级联用了一连串的方法调用，每个调用都是在前一个的结果上继续调用，方法都是由一个叠一个的调用组成的。在常规的OO代码中，方法由点号隔开，还可以使用函数序列。

```dsl
computer();
    processor();
        cores(2);
        speed(2500);
        i386();
    disk();
        size(150);
    disk();
        size(75);
        speed(7200);
        sata();
```

只要以适当的方式对函数序列进行组织和代码布局，它读上去就可以像方法级联一样清晰明了。连贯性与所用的语法风格无关，而与方法本身的命名和分解方式相关。

连贯接口的本质是以不同的思路来思考如何使用组件，站在语言的角度，思考如何将“组装这些对象”的子句组装成句子。这种思想上的提升，正式内部DSL同调用API之间的核心差别。

命令-查询分离传递出一个信号：对象上的各种方法应该分为命令类方法与查询类方法。查询类方法有返回值，但不会改变系统的可观察状态。命令类方法可能会修改系统的可观察状态，但是不应该有返回值。这个原则非常重要，它可以帮助识别出查询类方法。由于查询类方法没有副作用，因此可以以任意顺序多次调用，而不改变调用结果。使用命令类方法，则要更谨慎一些，因为它们确实存在副作用。

在程序设计中，命令-查询分离是一条极具价值的原则。在内部DSL中使用方法级联，结果却常常破坏该原则----每个方法都要修改状态后返回一个对象，以继续链式操作。

命令-查询分离与连贯接口之间的另一重要区别是方法的命名。为命令-查询查询方法命名时，希望那些名字在独立的上下文中也有一定含义。对于连贯接口，方法命名则非常不同。因此往往会拥有一些方法，它们的名字在一个开放的上下文中并没有什么意义，但放在DSL句子的上下文中，读起来却很连贯。DSL中的方法命名，首先要考虑的是句子，元素的命名都应适应其上下文。DSL的命名都是基于脑海中特定DSL的上下文来编写的，而命令-查询的命名则是按照不需要上下文来撰写的。

### 4.2 解析层的需求

连贯接口与命令-查询接口的不同可能会产生复杂性。如果两种接口共存于一个类，则会让人产生迷惑。因此，建议构建一层“表达式生成器”，从而DSL中的语言处理元素与普通的命令-查询对象分隔开。表达式生成器对象的唯一任务就是，使用连贯接口构建普通对象的模型，从而将连贯的语句有效地翻译为一串命令-查询API调用。

使用表达式生成器的原因之一自然是两种接口的本质不同，但是更主要的原因是经典的“关注分离点”的观点。只要引入某种语言，即使是内部语言，也需要写出符合该语言的代码。这些代码往往需要保持对数据的跟踪，这些数据只有当处理该语言的时候才会有用。理解内部DSL的工作机制需要一定的时间，而一旦填充了底层模型，内部DSL如何工作就不再需要了。因此将语言处理的代码放在单独的层中是值得的，这个结构遵循DSL处理的一般过程。命令-查询接口对象的底层模型就是“语义模型”。表达式生成器就是解析器的一部分。

通常“解析器”用在解析文本的上下文中。在这种情况下，对文本的操作是由宿主语言解析器完成的。但是表达式生成器所做与解析器所谓的确有很多的共同之处。关键的差异在于，传统的解析器将标记流整理为语法树，而表达式生成器的输入则是函数调用流。同解析器的相同之处在于，将其理解为“将函数调用组织为解析树上节点”是有益的，使用了类似的解析数据结构，仍然会组装语义模型。

将语义模型同表达式生成器分离，带来的是使用语义模型一贯的优势。表达式生成器和语义模型可以独立测试，可以有多个解析器，既支持内部DSL，也支持外部DSL，或者用多个表达式生成器支持多种内部DSL。表达式生成器和语义模型也可以独立演化。如同其他软件一样，DSL很少一成不变。软件需要能够演进，能够在不改变DSL脚本的前提下，修改底层框架是很有用的，反之亦然。

有一种论调是反对使用表达式生成器的，但它只适用于语义模型自身使用了连贯接口的情形。在有些情况下，连贯接口是人们与模型交互的主要方式，这时模型类使用连贯接口是有意义饿的。然而，大多数情况下，倾向于模型累使用命令-查询接口。命令-查询接口在不同上下文中的使用方式更为灵活。连贯接口则往往需要存储临时的解析数据。

### 4.3 使用函数

命令-查询API往往表现为函数的形式，而通常，DSL结构也主要构建于函数基础之上。命令-查询API与DSL的主要区别在于函数组合的方式。既然存在组合函数的不同模式，选择哪种模式涉及不同的因素。第一个因素是函数作用域。如果用的是方法级联，DSL中的函数就是对象的方法，这些方法只能定义在链中的对象里，通常也就是“表达式生成器”里。如果在序列里使用裸函数，就要确保这些函数可以恰当地解决作用域问题。最显而易见的方式是使用全局函数，但是这么做会带来两个问题：让全局命名空间变得复杂，并为解析数据引入了全局变量。

全局的东西会让局部的修改变得困难，全局函数在程序的每个部分都可见，但理想情况下，函数应该只出现在DSL处理的部分。很多语言特性的存在都是为了消除对于全局化的需要。比如命名空间，只有导如一个特定的命名空间，其中的函数看起来才会像全局的一样。比如Java中的`static import`。

全局的解析数据是一个更严重的问题。无论以何种方式实现函数序列，都需要操作“语境变量”，以了解表达式解析进行到何种程度。

方法级联在很大程度上避免了全局性问题，虽然仍然需要从某种裸函数开始级联调用，不过，一旦开始，所有的解析数据都就可以保存在定义级联方法的表达式生成器对象里了。

在函数序列中使用“对象范围”，就可以避免上述全局情况。在大多数情形下，DSL脚本都放在表达式生成器的子类里面，这样，裸函数调用都是基于表达式生成器父类中的方法，从而解决了全局性的问题。DSL中的所有函数只定义在生成器类中，所以，都是局部化的。而且，因为它们都是实例方法，所以它们可以直接访问生成器实例的数据，保存解析数据。相对于将DSL脚本置于生成器子类所花的成本，这种做法有极具吸引力的优势，因此它是默认之选。

使用对象范围更进一步的好处是，对扩展性的支持。如果在DSL框架中很容易用范围类的子类，那么DSL用户就可以向DSL语言添加自己的方法。

函数序列与方法级联都需要使用语境变量跟踪解析状态。“嵌套函数”是第三种函数组合技术，使用它往往可以回避语境变量。如果使用嵌套函数，计算机配置的例子看上去应该是这样子的：

```dsl
computer(
    processor(
        cores(2),
        speed(2500),
        i386
    ),
    disk(
        size(150)
    ),
    disk(
        size(75),
        speed(7200),
        SATA
    )
);
```

嵌套函数组合函数的方式是，将函数调用作为更高层次函数调用的实参。结果就是函数调用嵌套起来。在解析技术中，层次结构随处可见，嵌套函数有着同任何类型的层次结构一样的强大优势。很直观的一点就是，在例子中，语言构造本身就反应出配置的层次结构----disk函数嵌套在computer函数里，这同框架对象最终嵌套得完全一致。因此，函数嵌套反映了DSL的逻辑语法树。使用函数序列与方法级联，只能以奇怪的缩进约定表现语法树，而嵌套函数则允许用语言反映语法树。

另一个结果是执行顺序的改变。使用嵌套函数，会在函数本身执行之前得到函数的实参。这样，即便没有语境变量，亦然可以构建框架对象。在computer函数执行之前，processor函数会先执行，返回一个完整的处理器(processor)对象。对后，根据完整的参数，computer函数就可以直接创建计算机(computer)对象。

在构建更高层次结构时，嵌套函数运作良好。然而，它也不尽完美。圆括号和逗号显得格外扎眼，同单纯的缩进约定相比，它们犹如噪音一般。因为嵌套函数同样要用裸函数，所以它与函数序列一样，也会存在全局性问题，而仍然可以通过对象范围加以完善。

如果只是将嵌套函数理解为一组命令，而非构建一个层次结构，其执行顺序会造成混淆。一个简单的嵌套函数序列最终的执行顺序与其编写顺序是相反的。

嵌套函数还客服了“函数实数参数由位置而非名字决定”的问题。考虑一个指定磁盘大小与转速的例子。如果所需全部内容只是两个整数，那么真正需要的就是`disk(75,7200)`。为了解决这个问题，可以使用嵌套函数，其仅仅返回整数值，这样写:`disk(size(75), speed(7200))`.这样的代码更为可读，却无法阻止写出这样的代码：`disk(speed(7200),size(75))`。

大多数程序员都会将大量使用嵌套函数看作一种与众不同，但只是反映了在日常(非DSL)编程中如何运用函数组合模式而已。

还可以进行模式混合，例子的各个部分分别展现出各个模式的长处。当定义列表中的元素时，函数序列运作良好。它很好地将每台计算机(computer)的定义划分到不同的语句里。实现起来也很容易，因为每条语句只是向结果列表中添加了一个配置完整的计算机对象。

对于每台计算机而言，嵌套函数消除了当前计算机对于语境变量的需求，因为所有的实参在computer函数调用之前就得到了。假设一台计算机由一个处理器以及数量可变的磁盘组成，那么该函数的实参列表就应该用其类型更好地反映这一点。一般来说，嵌套函数会让全局函数的使用更为安全，因为这么做会更容易将全局函数组织为“只返回对象而不改变解析状态”。

如果每个处理器和磁盘都有多个可选参数，那么方法级联会很适合。可以设置任意想要的值，以构建出所需元素。

然而，混合使用也会带来问题，特别是标点符号困惑：有些元素以逗号分隔，有些是点，有些则是分号，作为程序员，即使能够将它们分清楚，也很难记得住。对于一个非程序员而言，即使只是读这些表达式，他们都很可能会觉得困惑。标点符号差异是实现的产物，并不是DSL本身所需。

### 4.4 字面量集合

程序编写，无论以通用语言还是DSL，都事关将元素组合在一起。通常程序的组合方式是，将语句组合为序列，还有使用函数。组织元素还有另外一种方式，就是使用“列表的字面构造”和"Literal Map".

列表的字面构造包括一组元素，这些元素可以是相同类型，也可以是不同类型，而且数目不限。

类C风格的语言也有字面量数组的语法，比如`{1,2,3}`,它们可以当作更灵活的列表的字面构造来用，但是，就其使用场景以所能接受的元素而言，确实相当受限。也可以使用哈希或者字典表示脚本语言的字面量集合。

**符号(symbol数据类型)**-这种类型在大括号风格的语言中并不存在。符号数据类型主要用于在映射表中查找，尤其是在“符号表”中。符号都是不可变的，所以出于性能考虑，在实现上，相同符号值表示相同的对象。符号的字面形式不支持空格，它们也不支持大部分的字符串操作，因为其角色是符号查找，而非持有文本。

### 4.5 基于文法选择内部元素

内部DSL的元素有很多种不同的选择。选择的技巧之一是，考虑DSL的逻辑文法。当使用“语法指导翻译”时，创建的文法规则对于思考内部DSL也大有帮助。确定种类的表达式，加上其“BNF”规则，往往对应确定种类的内部DSL结构。

对于必选元素的子句`(parent ::= first second)`,嵌套函数是很好的选择。嵌套函数的实参可以直接匹配规则中的元素。如果是强类型语言，那么基于**类型感知(type aware)**的自动补全可以为每个参数提示正确的选项。

如果用嵌套函数处理可选元素列表`(parent ::= first maybeSecond ? maybeThird?)`,那就要困难的多，因为很可能最终得到的是，各种组合可能性的爆炸。在这种情况下，方法级联通常更适合，因为方法调用只要指明要用的元素即可。方法级联的棘手部分是，需要做一些额外的工作，确保规则中的每一项都只出现一次。

结构|BNF|考虑
-|-|-
必选列表|`parent::=first second third`|嵌套函数
可选列表|`parent::=first maebeSecond?maybeThird?`|方法级联
同构集合|`parent::=child*`|列表的字面构造、函数序列
异构集合|`parent::=(this|that|theOther)*`|方法级联
set|`n/a`|Literal Map

对于由多个相同类型的子元素组成的子句`(parent::=child*)`,采用列表的字面构造会比较合适。如果这个表达式定义的语句在语言的最顶层，那这就是会考虑函数序列的少量地方之一。

若是多个不同类型的子元素`(parent::=(this|that|theOther)*)`,会回到方法级联上，方法名很好地提示了所处理的元素。

子元素集合(set)往往不能与BNF很好地契合，有多个子元素，但每个子元素都最多只出现一次。也将其看作一个比选元素列表，其中的子元素可以按任意顺序排列。Literal Map在逻辑上很符合，但常常会遇到的问题是，必须使用正确的键(key)进行沟通，否则则不行。

对于‘最少一次’格式`(parent::=child+)`的文法规则来说，它并不能很好地与内部DSL契合。最好的方式是，使用一般的多元素格式，在解析过程中，检查至少有一个子元素。

### 4.6 闭包

**闭包(closure)**是程序涉及语言的一种能力，它们有很多的名字(**lambda**, **block**, **匿名函数**等)。闭包的作用是可以把某些内里联代码打包成一个对象，到处传递，在适当的时候执行。

对于内部DSL而言，会把闭包用作DSL脚本里的“嵌套闭包”。嵌套闭包有三个特点，使其很容易用于DSL：内联嵌套，延迟执行以及受限作用域的变量。

“嵌套函数”最好的特性之一是允许以一种对于宿主语言有意义的方式保留DSL的层次特征，而不像在“函数序列”和“方法级联”里，不得不以缩进表示层次关系。嵌套闭包同样具有这样的特点。

可以将任意的内联代码进行嵌套----这也是术语内联嵌套的由来。关于在函数实参里可以放什么，大多数语言都有一些限制，这也限制了在嵌套函数里编写的内容。但是，嵌套闭包可以突破这些界限。通过这个方式，可以嵌套非常复杂的结构，诸如，将函数序列嵌入嵌套闭包里，这在嵌套函数之中是不可能的。还有一个优势，在很多语言里面，从语法上说，嵌套闭包比嵌套函数更容易嵌入多条语句。

延迟执行可能是嵌套闭包带来的最重要的能力。使用嵌套函数，函数实参会在函数本身调用之前执行。使用嵌套闭包，则可以完全控制闭包执行的时机。可以改变执行的顺序，或者根本不执行某些闭包，或将所有的闭包存储起来以备后用。语义模型要完全控制程序执行的方式。这种做法尤为方便，这种模型称为“适应性模型”。DSL会包括一段宿主语言代码，这些代码会放入语义模型。这样，DSL与宿主语言代码就可以天衣无缝地融合了。

最后一个特点是，嵌套闭包允许引入作用域仅限于闭包内部的变量。通过使用作用域受限的变量，查看方法到底在操作那些数据就更容易了。

一个例子:

```ruby
#ruby
    ComputerBuilder.build do |c|
        c.processor do |p|
            p.cores 2
            p.i386
            p.speed 2.2
        end
        c.disk do |d|
            d.size 150
        end
        c.disk do |d|
            d.size 75
            d.speed 7200
            d.sata
        end
    end
```

对processor和disk的调用都包括一些代码，就是几条Ruby语句。这段代码还演示了作用域受限变量的用法，包括computer, processor, disks。这些变量虽然增加了一些噪音，但是也更容易看清楚，哪些对象在何处使用。从这段代码还可以看出，全局函数或者“对象范围”也不再是必需的了，比如，speed函数是定义在作用域受限变量上的“表达式生成器”

另一个例子：要到一组**验证(validate)**规则。通常，在面向对象的环境中，需要考虑对象是否合法，并且在某处有一些代码检查合法性。如果验证是上下文相关的，可能会更加复杂，比如为了做某事而验证对象。如果可以查看某人的数据，对于某人是否符合某项保险政策，一项政策的校验规则可能与另一项是不同的。在DSL里指定规则可能会这么做：

```cs
class ExampleValidation : ValidationEngineBuilder {
    protected override void build() {
        Validate("Annual Incomde is present")
            .With(p => p.AnnualIncome != null);
        Validate("positive Annual Income")
            .With(p => p.AnnualIncome > 0);
    }
}
```

函数调用`With`的内容是一个闭包，这个闭包以一个“人”为实参，并包含一些任意的C#代码。这些代码存储在语义模型上，当模型运行时再执行。
嵌套闭包是一项非常有用的DSL模式，即使对于支持闭包的语言，其闭包的语法也往往比较别扭。

### 4.7 解析树操作

解析树操作的基本思想是，当遇到一个使用宿主编程语言的表达式时，并不执行它，获取其结果，而是将其解析数看作数据。比如`aPerson.Age > 18`表达式的解析树如下：

```json
{
    "node" : "BinaryExpr",
    "childs" : [
        {
            "node" : "MemberExpr",
            "childs" : [
                {
                    "node" : "Member",
                    "value" : "Age"
                },
                {
                    "node" : "op",
                    "value" : "."
                },
                {
                    "node" : "Expr",
                    "value" : "aPerson"
                }
            ]
        },
        {
            "node" : "op",
            "value" : ">"
        },
        {
            "node" : "ConstantExpr",
            "value" : "18"
        }
    ]
}
```

解析树操作的强大之处在于，除了存储闭包本身外，还可以用于宿主语言编写表达式，然后可以把这些表达式转换为不同的表达式，以组装“语义模型”。

### 4.8 标注

Java的**标注annotation**和C#的**特性attribute**等。

标注允许程序员向程序构造(如类和方法)里面附加元数据。这些标注可以在编译期或者运行期进行读取。

```java
class PatientVisit {
    @ValidRange(lower = 1, upper = 1000, units = Units.LB)
    private Quantity weight;
    @ValidRange(lower = 1, upper = 120, units = Units.IN)
    private Quantity height;    
}
```

另一种显而易见的替代方案是，将范围检查代码放到字段的setter里面。不过采用标注会有诸多优势。字段边界读起来更清晰，范围检查也更容易，或者当给属性赋值时，或者稍后的对象校验阶段，这种方式指定的校验规则可以读到，并由GUI组件进行配置。

**标注可以看作一种扩展语言的方式，有了它语言就可以支持新的关键字(keyword功能)**。的确，即便是一些既有关键字，如果用标注实现，也可能会做的更好。比如，从一个新的角度来看，访问修饰符----private，public等以这种方式实现就会更好。

标注同宿主语言的绑定非常之紧密，所以它们很适合片段DSL，而非独立DSL。它们尤其擅长提供非常同一的思路来给宿主语言添加领域专用的增强特性。

### 4.9 为字面量提供扩展

为字面量提供扩展的危险之一是它在全局上增加了方法，但这些方法应该只用在DSL的受限上下文中。为字面量提供扩展虽然不是需要频繁使用的技巧，但用到的时候却非常方便----它非常适合针对特定领域定制语言的场合。

### 4.10 消除语法噪音

内部DSL的关键在于它们只是基于宿主语言的表达式，其编写格式使之读起来如同语言一样。这种做法的影响之一是，它们与宿主语言的语法结构交织在一起。从某些方面这样很好，因为其提供的语法是很多程序员都熟悉的，但有些人会觉得某些语法令人恼火。

消除这些语法负担的方式之一是，以尽可能接近宿主语言的语法编写DSL代码，但也不一定要完全一致，然后用简单的文本替换，将其转换为宿主语言。比如将`3 % if value at least $30000`转换为`percent(3).when.minimum(30000)`。

另一种方法是使用语法着色。大多数文本编辑器都提供了可定制的文本着色方案。

### 4.11 动态接收

动态语言的特点之一是，它们在运行时处理方法**调用(invoation)**。所以，如果写下`aPerson.name`，而person对象又没有定义name函数时，代码将会顺利通过编译，只在运行时抛出错误。

这些语言所采用的非统寻常的机制是这样的，将这个预期之外的调用路由到一个特殊方法进行处理。这个特殊方法的默认行为是抛出一个错误，但是，程序员可以重写该方法，进行其他处理，这种重写为“动态接收”，因为接收到的消息是否合法，是动态判断的。动态接收可能会带来一些有用的编程术语，尤其是使用代理时。有了代理，可以将对象包起来，无须准确知道哪个方法得到调用，就可以利用这些方法调用做一些事情。

在DSL中，动态接收的常见做法是，将信息从方法实参转移到方法名称上。动态接收的关键在于给了一个选择，将信息从参数转移到方法名上面，在某些情形下，这会让表达式更易于阅读和理解。

### 4.12 提供类型检查

静态类型的理由是，现代IDE通常提供了一些针对静态类型的优秀支持。然而，DSL中的大多数类似符号却没有得到这样的支持，因为需要将它们表示为字符串或者符号数据类型，并将其保存在自己的符号表。

## 第5章 实现外部DSL

虽然单靠内部DSL已经足以定义出连贯的语言，但最终还是会受限于宿主语言的语法结构。外部DSL则提供了更大的语法自由度----可以使用自己喜欢的语法。

相比于内部DSL，实现外部DSL的不同之处就在于解析过程，需要解析纯文本输入，这些输入不受任何现有语言的约束。创造DSL所需的背景知识要少于开发通用语言。

### 5.1 语法分析策略

当解析外部DSL时，要将一串文本分解成某种结构，通过这种结构来理解文本的含义。这个“结构化”的过程称为**语法分析(syntactic analysis)**。

一个简单的方法是分隔符指导翻译，受限找出能把输入分解成语句的分隔符（通常是换行符），根据这些分隔符把输入拆分成语句，然后逐个语句进行处理，找出其中的含义。通常，每行文本都包含一些明显的标识。

分隔符指导翻译很容易使用，涉及的工具也是大多数程序员都熟悉的字符串操作和正则表达式。其局限性在于，它不适用于处理层次结构的输入上下文。

更合适的办法是“语法指导翻译”。首先为输入语言定义一个形式化的文法，一般使用生成式表达。绝大多数文法都是以某种形式的**BNF**编写的，其中每行代表一条规则：首先是规则的名称，然后是满足该规则的合法元素。文法对于语法指导翻译特别有用，因为根据文法就可以机械地生成解析器。由语法指导翻译生成的解析器非常适合于处理这样的层次结构。

三种将BNF转换成某种解析算法的方式：

* **递归下降语法解析器**-是经典的转换方法。递归下降算法是一种易于处理理解的解析算法：用函数内部的控制流来展现文法规则。每条文法规则会转换成解析器中的一个函数，每个BNF运算符到控制流的转换过程都有清晰的模式可循。
* **解析器组合子**-将每条规则转换成一个对象，再把对象组合成一个与文法对应的结构。仍然需要递归下降语法解析器的元素，但这些元素会包装成组合子对象，只要将它们组合起来就可以了。
* **解析器生成器**-可以把BNF当作DSL来操作：用这种DSL来编写文法，解析器生成器负责生成解析器。

解析器生成器是最精密的途径：以BNF作为DSL，会让语言更容易理解和维护，因为其语法已经清晰地定义出来，并且能够自动地绑到解析器上。不过这些工具的缺点是需要花时间学习。

ANTLR解析器生成器是一个成熟的，广泛适用的开源工具，它是一个强大的递归下降语法解析器。

### 5.2 输出生成策略

当想要解析某些输入时，必须知道：要使用解析的结果干什么----输出应该是什么样子的？大部分时候，解析过程的输出应该是一个“语义模型”，随后就可以直接解释它或者将其用作代码生成的输入。

* **嵌入式语法翻译**-一个步骤，直接把方法调用放入解析器，从而在解析过程中生成语义模型
* **树的构建**-两个步骤，首先解析输入文本，构造出一棵包含文本结构的语法树，同时用符号表处理语法树各个部分之间的交叉引用；然后执行第二阶段，遍历语法树，生成语义模型。
* **内嵌解释器**-在解析过程中执行解释，并直接输出最终结果。内嵌解释器的一个经典例子就是计算器：它接受算术表达式作为输入，将计算的结果作为输出。也就是说，内嵌解释器并不生成语义模型。

使用树的构建有一个很大的好处：它把整个解析任务分解成两个更简单的任务。当识别输入文本时，只需要关注如何构建语法树----实际上，很多解析器生成器提供了用于树构建的DSL。可以让这部分工作变得更加简单。遍历语法树组装语义模型则是一个常规的编程练习，随时检查整棵树来判断应该做什么。比如XML代码，嵌入式语言翻译类似于SAX，而树的构建则类似于DOM。

即使不生成语义模型，也可以使用嵌入式语法翻译和树的构建----其实在使用代码生成时，这种情况相当常见，大部分解析器生成器的例子都会这样做。

### 5.3 解析中的概念

“语法指导翻译”通常分为两个阶段：**词法分析**(扫描或标记/词素解释)和**语法分析**。词法分析阶段将输入文本转化为一串**标记(token)**，这是一种数据类型，包含两个主要属性：类型和内容。语法分析器随后会根据文法规则把这一串标记组织成一棵语法树。

一般的词法分析会将空白符去掉，解析器根本不会看见它们，当然有时空白字符会用作语法的一部分，例如用换行符作为语句分隔符，或者像Python那样用缩进来标识语法结构。

通常某种结构的文法不只一种，多种文法能够识别同一语言的情况很常见。又很多原因得到不同的文法：不同的**解析器生成器**使用不同的文法，这些文法的语法和语义都不同。即便对于同一个解析器生成器，当采用不同的方式构建文法规则时，也会得到不同的文法。和其他任何代码一样，也要重构文法，使其更容易理解。最终的产出代码也会影响构建文法的方式。

#### 正则文法、上下文无关文法、上下文相关文法

所有正则文法都是上下文无关的，所有上下文无关文法都是上下文相关的。正则文法很重要，因为可以用一个有限状态机来处理，因为正则表达式就是有限状态机，所以正则语言可以用正则表达式来解析。

就计算机语言而论，正则文法有一个大问题：其无法处理嵌套元素。正则语言可以解析`1+2*3+4`这样的表达式，但不能解析`1+(2*(3+4))`。正则文法“不能计数”----对解析器而言，不能用有限状态机解析带有嵌套块的语言。

要处理起嵌套块，就得向上走一步：上下文无关文法。因为一个上下文无关的文法却会给文法添加层级上下文，使其能够“计数”。上下文无关文法可以用**下推机(push-down machine)**----带有栈的有限状态机来实现。大部分语言额解析器都使用上下文无关文法，大部分“解析器生成器”也使用它。“递归下降语法解析器”和“解析器组合子”都会生成下推机。于是，大部分现代编程语言都是用上下文无关文法来解析的。

但是上下文无关文法并不能处理想要的所有语法规则。一个常见异常情况是这样一条规则：变量务必先声明再使用。问题在于，当使用变量时，变量声明常出现在当前所在程序分支所在层次结构之外。尽管上下文无关文法可以保存层次结构上下文，但也没有足够的上下文来处理这种情况----因此还需要**符号表**。

**解析式表达文法(Parsing Expression Grammer, PEG)**-使用一种新的文法格式，可以处理大部分上下文无关的情景和一些上下文相关的情景。PEG解释器不倾向于使用单独的词法分析，并且大部分情况下，PEG似乎比上下文无关文法更好用。

#### 自顶向下解析和自底向上解析

编写解析器的办法有很多种，所以出现了“解析器生成器”。其中最大的一个区别是：解析器是自顶向下的还是自底向上的。

自顶向下解析器首先处理文法中最高级别的规则，根据它确定如何尝试以及匹配，自底向上正好相反。自顶向下解析器也称为LL解析器，自底向上解析器称为LR解析器。自底向上解析有时还称为“移进-规约解析”，因为移进-规约方法是最常见的自底向上解析实现方式。

自底向上解析器比自顶向下解析器要难以编写和理解。Yacc系列可能是最有名的解析器生成器系列，它就是一个自底向上(LALR)解析器。

递归下降算法是一个自顶向下的解析算法，自然“递归下降语法解析器”也是一个自顶向下的解析器，解析器组合子也是。ANTLR解析器生成器也是基于递归下降算法的。

自顶向下解析器的缺点是，无法处理**左递归(left recursion)**。下列规则：

```bnf
expr : expr '+' expr
```

类似这样的规则会导致解析器在尝试匹配`expr`时陷入无穷递归。通过提取左因子就可以消除左递归，做法比较简单，但最终得到的文法就会比较难懂。

### 5.4 混入另一种语言

面对一种外部DSL，一个最大的风险是：它可能在不经意间演变成了一种通用语言。即便没有那么极端，一种DSL也很容易变得过于复杂，尤其是在其中考虑很多特殊情况时，这些情况很少出现，但往往需要特别处理。

使用外加代码的一个问题是：需要不同的方式对外加代码进行标记划分，因此需要某种“可变分词方式”。最简单的可变分词方式方法是，用某种清晰的分隔符将嵌入代码引用起来，使其能够识别为单个标记从而以单一字符串的形式经过解析。

可变分词方式不仅可以处理外加代码。在不同的解析上下文中，也许希望把语言的关键字解释为一个名称的一个部分，可以用圆括号来完成这个技巧，但可变分词方式的其他实现方式引入的语法噪音更少。

### 5.5 XML DSL

很多常见的XML配置文件实际上就是DSL。当然并非所有的配置文件都是DSL。“属性列表”和DSL是不同的。属性列表只是一份简单的“键-值对”列表，可能再加上分类。属性列表没有多少语法结构----完全不具备DSL那些神奇的语言性。另一方面，很多配置文件确实具有像DSL一样的语言性。如果是用XML来实现，就把它们看作外部DSL。XML不是编程语言：它是一种没有语义的语法结构。因此，需要首先把XML代码解读成标记，然后再处理，而不能直接解释、执行它。DOM处理本质上就是“树的构建”，SAX则是“嵌入式语法翻译”。XML就是DSL的承载语法，跟内部DSL的宿主语言提供的承载语法是一样的。

以XML作为承载语法，它引入了太多的语法噪音----太多的尖括号，引号和斜线，每个嵌套元素都必须有开始标签和结束标签。结果有太多的字符是在为语法结构----而非真正的内容----服务，代码变得难以理解----而“容易理解”正是DSL的全部意义所在。

自定义的外部DSL也带来了一个烦恼：它们处理引用，字符转义之类的事情的方式总是难以统一。

除了生成树或者事件的解析器之外，还有一些XML绑定接口，可以很轻松地将XML数据翻译成对象和字段。如果使用解析器生成器，就可以在文法中定义XML结构所能提供的很多检查功能。但很少有工具能使用文法输入。

JSON和YAML相比于XML语法噪音小的多，但是这些语言很大程度上是针对结构化数据的，因此缺乏真正连贯的语言所需的灵活性。DSL与数据序列化不同，连贯性对于DSL的易读性至关重要，而数据序列化格式为了它自己的主要用途做了太多的妥协。

## 第6章 内部DSL vs 外部DSL

### 6.1 学习曲线

内部DSL的学习成本更低，它们看起来只是一些更加好用时髦的API，并且是建立在一种熟悉的语言之上。而学习外部DSL，则需要学习解析器，文法和“解析器”生成器等。

### 6.2 创建成本

构建DSL的成本重要的是区分模型构建的成本和基于模型构建DSL层的成本。在许多情况下，模型与DSL是相关联的，但模型有其自身的考量。

就内部DSL而言，于模型之上构建一层“表达式生成器”就需要额外的付出。在外部DSL中，相应的成本在于解析器的创建，一旦掌握了“语法指导翻译”，编写文法和翻译代码实际上是相当快的。开发解析器的成本同构建表达式生成器层是相似的。

### 6.3 程序员的熟悉度

外部DSL其实相当简单，如果能够遵循常用编程语言的语法规范，那么会让它的接受读更高。

有时，会用到一些更复杂的技术，比如“类符号表”，它需要工具的支持，但采用这种方式，可以继续享受IDE的优势。然而，使用外部DSL，除了最基本的文本编辑功能外，可能什么都没有。支持语法高亮的功能并不困难，大多数编辑器都配置了这样的功能，但是像类型感知的自动补全这类功能就有些困难。

### 6.4 与领域专家沟通

内部DSL通常会和宿主语言的语法绑定在一起，导致其在表达自由度上有限受限，并且会有一些语法噪音。但领域专家不一样，表达受限的程度以及语法噪音同语言相关，有些语言会比其他语言更加适合作为DSL。就算最好的内部DSL，也无法提供和外部DSL一样的语法灵活度。

### 6.5 与宿主语言混合

内部DSL本质上只是一些连贯方法的使用约定，DSL与宿主语言之间边界很模糊，存在利弊，取决于如何使用。

好处在于，当内部DSL缺乏某种构造时，可以很方便地使用宿主语言。这样一来，如果要在DSL中使用算数表达式，无须在DSL里面为此创建专门的构造，使用宿主语言的特性即可。如果要在DSL基础上构建抽象，直接使用宿主语言的抽象功能就好了。

外部DSL无法和宿主语言混合使用，但可以把宿主语言作为“外加代码”嵌入DSL脚本。同样，DSL也可以作为字符串嵌入通用语言，就像嵌入正则表达式和SQL一样。

### 6.6 强边界

宿主语言代码和DSL代码进行混合并不总是带来好处，只有当DSL的用户非常熟悉宿主语言时，这才行的通。DSL的好处就是其能力范围是有限的。这种限制使其易于理解，屏蔽bug。如果DSL有很强的边界，就会限制要测试的东西。DSL中的定价规则不会给集成服务器发送任意的消息，也无法改变订单处理流程。

### 6.7 运行时配置

XML DSL之所以流行，是因为改变代码执行上下文的时间从编译时到运行时。外部DSL可以帮助做到不重新编译就可改变系统行为，在运行时解析，翻译成“语义模型”，然后执行模型。

一种方式是将解释型语言和编译型语言结合使用，然后，用解释型语言编写内部DSL。

### 6.8 趋于平庸

Ant是一种描述Java构建的语言：它是一种使用XML语法的外部结构。相比于扩展一门语言，可以引入另一种语言处理特殊以及复杂的情况。可以在基础的DSL之上再设计另一种语言，其输出就是基础的DSL。这种技术非常有用，有了它，就能用那种缺乏抽象构建能力的语言构建抽象。

### 6.9 组合多种DSL

DSL应该是小巧的，能力受限的。所以，要完成实际工作，就要将DSL同一种或多种通用语言集成起来。也可以将多种DSL组合起来。

对于内部DSL而言，组合DSL就像通宿主语言混合一样容易。还可以用宿主语言的抽象特性帮助完成组合的工作。对于外部DSL来说，这种组合要困难一些。用“语法指导翻译”进行组合，要为不同的语言编写独立的文法，还要能把这些文法组合在一起。大多数“解析器生成器”都不具备这样的能力，这也是只关注通用语言的另一个后果。

### 6.10 总结

无论是内部DSL还是外部DSL，其各有利弊，同时在两个方向进行尝试，所需的投入并不如想象的高。如果使用“语义模型”，在其上构建多种DSL并不困难，无论是内部还是外部。

## 第7章 其他计算模型概述

主流的编程语言大都遵循命令式计算模型。命令式模型把整个计算过程定义为一系列的步骤，如果条件成立再做其他的事情。条件和循环会改变步骤的执行顺序，多个步骤可以组合成为函数。面向对象语言提供了数据与操作之间的绑定，以及多态----但基础仍然是命令式模型。

命令式的展现方式有一个潜在的严重缺陷，它会丢掉一些有用的机会。决策表就有这样一个好处，可以检查它，确保没有遗漏或者重复某些排列项。使用命令式代码还有一种实现方式，创建决策表抽象，然后根据这里的特定情况进行配置。

### 7.1 几种计算模型

#### 7.1.1 决策表

决策表是一种很简单的计算模型，也很适合DSL表达。由于决策表就是一张表格，因此也很适合在电子表格中编辑。

#### 7.1.2 产生式规则系统

**产生式规则系统**是一种对逻辑进行建模的常用概念：它将逻辑分解成多条规则，每条规则由条件和由此引发的行为两部分组成。如果是采用命令式代码，每条规则都可以用类似于if-then语句的风格表述:

```dsl
if
    passenger.frequentFlier
then
    passenger.priorityHandling = true;
if
    mileage > 25000
then
    passenger.frequentFilter = true;
```

有了产生式规则系统，就可以用“条件+行为”的形式定义规则，至于规则的执行和规则之间的关联则交给背后的系统。

这种性质(触发某些规则会改变另一些规则是否被触发)称为**级联(chaining)**，这是产生式规则系统的一个重要性质。有了级联，就可以单独编写规则，无须考虑在更大范围内造成的影响，让系统自己找到结果。

产生式规则系统依赖大量隐式的逻辑，经常会做出意想不到的事情。对于其他计算模型而言，隐式行为造成的问题相当常见。当实现其他计算模型时，有必要加入某种跟踪机制，以便看出模型执行过程中到底发生了什么。对于产生式规则系统而言，就意味着需要记录触发了哪些规则，必要时可以很容易提供这些记录。

级联无疑是产生式规则系统的重要组成部分，但它并非不可或缺。不支持级联的产生式规则系统有时也很有用，例如，一个很好的例子是一组校验规则。当校验时，通常只提供一组校验条件，其中校验未通过的行为就是“报错”。尽管不需要级联，不过把整个校验行为看做一组彼此独立的规则仍然有有助于理清思路。

当使用产生式规则系统时，每次只关注一条规则的行为；而使用决策表时，则要同时关注整张表。这种视角的变化使这两个模型成为不同的思维工具。

#### 7.1.3 状态机

状态机把对象的行为划分成一组状态，用事件触发行为，根据对象所处的状态，事件会使对象从当前状态转换到另一个状态。

状态机的核心元素包括状态、事件和转换，但在这个基本结构之上还有很多变化。特别是，状态机初始化的行为有着诸多变化。状态机很常用，因为很多系统都可以看做“以变动的状态响应各种事件”。

#### 7.1.4 依赖网络

如果有一系列耗费大量计算资源并且彼此依赖的任务需要管理，依赖网络就是很好的选择。

#### 7.1.5 选择模型

所有的模型选择最终都归结于一种感觉：这种计算模型是否符合思考这个问题的方式。而判断“是否符合”的最好办法就是“试一下”：先在纸上尝试用简单的文字和图表来描述行为；如果某个模型似乎能通过这个简单的纸上测试，那就值得把它构建出来。

## 第8章 代码生成

通常来说，直接执行语义模型是最容易做的事，然而还有很多情况，无法这样做。比如，DSL的逻辑只能在有很大差异的环境中执行，在那种环境里，语义模型或解析器都极难构建，甚至无法构建。通过代码生成，几乎可以在任何环境下运行DSL指定的行为。

使用代码生成，要考虑两种不同的环境：DSL处理器和目标环境。DSL处理器都是解析器、语义模型和代码生成器之所在，应该是便于开发的。目标环境则是为生成代码及其周边准备的。使用代码生成的意义在于，将目标环境通DSL处理器分离开来，因为在目标环境下，可能无法构建DSL处理器。

### 8.1 选择生成什么

可用的代码生成风格有两种：“基于模型的代码生成”和“无视模型的代码生成”。二者的差别在于，在目标环境里，“语义模型”是否显式地表现出来。实现状态机有两种经典方案，分别是嵌套条件和状态表。看一个非常简单的状态模型。

这里有两个条件测试，一个嵌套在另一个里面。外部条件查看状态机的当前状态，内部条件根据接收到的事件进行切换。这就是无视模型的代码生成，因为状态机的逻辑嵌套在语言的控制流中----语义模型没有显式地表现出来。

如果用基于模型的代码生成，就要在生成代码中表现出语义模型。这个模型不必与DSL处理器使用的完全吻合，但它会表现出某种形式的数据。

通过将语义模型表现在生成代码中，通用框架代码和专用配置代码分离开来，这通开篇中谈及的划分是一样的。基于模型的代码生成保留了通用/专用的区分，而无视模型的代码生成规则把语义模型放入控制流中，将二者混在一起。

如果采用基于模型的代码生成，唯一要生成的就是专用的配置代码。完全可以在目标环境中构建出基本的状态机，在那里进行测试。而采用无视模型的代码生成，就不得不生成更多的代码。固然可以将一些代码提取出来放到程序库函数里面，省去生成的过程，但大多数关键行为依然要生成。

采用基于模型的代码生成会容易许多，生成的代码也会很简单。虽然依然要构建通用的部分，但是，鉴于这个部分可以独立于代码生成系统运行和测试，实现起来通常容易。因此，尽可能采用基于模型的代码生成。

### 8.2 如何生成

有两种文本输出的风格可以遵循

* 基于转换器的代码生成
* 模版化的生成器

采用基于转换器的代码生成的话，要编写代码，读取“语义模型”，生成目标源码的语句。如果用的是模版化的生成器，会写出一个示例的输出文件。输出文件会有特定状态机专有的一些东西，这样就可以调用语义模型生成相应的代码。

模版化的生成器是由输出的结构驱动的，而基于转换器的代码则是由输入、输出或者二者共同驱动的。两种代码生成方式用起来都不错，要在二者中选择，最好每个都试一下，选择最适合自己的那个。模版化的生成器适用于输出里有大量静态代码，只有少量静态部分呢的情况----而且，可以查看模版文件，了解生成代码会是什么样子。如果用到**无视模型的代码生成**，很可能采用模版化的生成器。否则更倾向于基于转换器的代码生成。

### 8.3 混合生成代码和手写代码

有时，在目标环境下执行的所有代码都可以生成，但更常见的情况是，需要混合生成代码和手写代码。有一些需要遵循的通用规则：

* 不要修改生成代码
* 将生成代码和手写代码严格分开

根据DSL生成代码，其重点在于DSL应该成为行为的权威来源。将文件清楚地分为“全生成”或是“全手写”。生成代码是不会提交到源码库里面的，因为这些代码都是可以在构建过程中重新生成的。

在一个过程式系统中，代码是以函数的方式组织在文件里面的，因此做到这点很容易。而面向对象则不然，类混合了数据和行为，分开二者要相对复杂一些。处理这种情况最简单的方法是，把这个类分成多个文件。根据需要，分成生成代码和手写代码。

这个问题有一个好的解决方案，就是**代沟**，用继承分离生成代码和手写代码。按照其基本形式，生成一个超类，然后手写一个子类，在子类里增强或者重写生成的行为。这样就用文件生成代码和手写代码分开了，在一个类里结合了两种风格，具有极大的灵活性。

### 8.4 生成可读的代码

可以让生成代码如手写代码那样好----拥有清晰的变量名，良好的结构，以及遵循大多数的良好习惯。

### 8.5 解析之前的代码生成

在某些情况下，DSL脚本要集成一些外部信息。确保DSL脚本里用的符号与企业数据库中的一致。可以用**代码生成**生成脚本编写所需的信息。这样，在组装**语义模型**时，就可以利用这些信息进行检查，有时，这些信息在源码中也很有用，对于代码导航以及静态类型尤其如此。

## 第9章 语言工作台

**语言工作台**是这样一种工具，可以帮助打造DSL，并为这种DSL提供现代IDE风格的工具支持。其基本想法就是，这类工具不仅要提供一个创建DSL的IDE，还要为编辑这些DSL构建新的IDE。

### 9.1 语言工作台之要素

各种语言工作台都可以从以下三个方面定义DSL环境：

* **语义模型**模式一般用模型定义出语义模型的数据结构以及静态语意
* DSL编辑环境为人们编写DSL脚本定义丰富的编辑体验，可能是直接编辑源码，也可能是惊醒投射编辑。
* 语义模型行为定义出构建好语义模型后，DSL脚本能够做些什么，通常采用的技术是代码生成。

语言工作台以语义模型为系统核心，提供工具辅助模型定义。语言工作台并不使用程序设计语言定义语义模型，而采用一种特殊的元模型建模结构，这种结构要用到运行时工具处理模型。正是利用了元模型建模结构，语言工作台才能够提供更高级的工具支持。

这样一来，模式和行为得以分离。语义模型模式本质上是一种数据模型，没有任何行为。语义模型行为来自数据结构之外，大部分源自代码生成。有些工具提供语义模型，就可以根据此构造解释器，不过代码生成依旧是运行语义模型最常用的方式。

语言工作台最有趣也是最重要的一个特征是它们的编辑环境。这也是语言工作台给软件开发带来的最重要的改变，为组装和操作语义模型提供了广泛的工具支持。

### 9.2 模式定义语言和元模型

语言工作台所用的模型文本和语义模型有着显著的差异。语言工作台提供了一个环境，用于定义模型的模式，也就是数据结构，通常会用到一种专用的DSL----模式定义语言。至于行为语义，则是要单独定义的，一般用代码生成来做。

**元模型**只是另一种语义模型，容易定义一个DSL组装这个模型，就像为基本模型所做的一样----这样的DSL，称为模式定义语言。模式定义语言其实仅仅是某种形式的数据模型，能够定义实体及相互关系而已。

当手动构建DSL时，创建元模型的意义不大。在大多数情况下，使用熟悉的宿主语言的结构定义能力是最好的选择。因为所用的是熟悉的语言构造，所以用起来会比较容易。

元模型也只是一种模型而已。同其他的模型一样，它也要有自己的模式定义其结构。用语言工作台自身的建模工具处理模式定义系统自身，而创建模型的工具就是编写DSL脚本的工具。

这种方式称为**自举工作台**，许多语言工作台采用的都是这种方式。通常来说，自举工作台更值得信赖，既然这个建模工具都能定义自己，对工作而言足够。

模式定义语言和文法的差别：文法定义某种（文本）语言的具体语法，而模式定义语言定义语义模型模式的结构。所以，文法包含需要用于描述输入语言的东西，而模式定义语言则独立于任何“用于组装语义模型”的DSL。文法还隐含解析树的结构，以及树的构建规则，可以定义语法树的结构。

当定义模式时，要考虑的数据结构：类和字段。模式定义大部分考虑的是，用于存储语义模型元素的逻辑数据结构。还有一个要素需要考虑：模式的结构性约束。这些约束用于定义什么是最有效的语义模型，其等价于契约式设计中的**不变式(invariant)**。

结构性约束通常指的是不是那些由数据结构带来的约束----可以保存数据，但也不管用。数据结构可能会有些附加的约束。约束的复杂度是任意的，甚至会牵扯到多个字段和对象。

模式定义语言都有一些表现结构性约束的方式，也许简单到仅仅允许设定属性的取值范围，也许复杂到用一种通用语言表现任何约束。结构性约束往往存在一个限制，它无法改变语义模型，只能查询。按照这种方式，这些约束就是一个没有级联的“产生式规则系统”

### 9.3 源码编辑和投射编辑

基于源码的编辑系统用一种可编辑的表现形式定义程序，通过工具将其带入运行时系统，然而，这种表现形式与工具无关。在实际中，这种表现形式是基于文本的，这意味着，程序可以由任何文本编辑工具读取和编辑。这个文本就是程序的源码，将它交给编辑器或者解释器，就可以转为可执行的格式，但是对于程序员来说，源码才是编辑和保存的主要表现形式。

采用投射编辑系统，程序的核心表现形式则是一种与所用工具相关的格式。这个格式就是工具使用的“语义模型”的一种持久化表现形式。当编辑程序时，要先启动工具的编辑环境，然后，工作将语义模型投射为一个可编辑的形式。

相比于基于文本的方式，投射编辑带来的好处是可以通过不同的表现形式进行编辑。状态机最好用图形化的方式展现，采用投射编辑器，状态机就可以将状态机渲染成一张图，直接以图的方式编辑。而采用源码，只能编辑文本。

这样的投射可以使得更好地控制编辑体验，输入正确信息，避免犯错。调用一个对象的方法，文本投射只显示这个类合法的方法，也只能输入有效的方法名。编辑器与程序之间就有了一个更紧密的反馈，编辑器也可以给予程序员更多的帮助。

还可以使用多个投射，可以同时作为主要投射的备选方案。可以根据喜好选择最适合于查看信息的投射方式。比如一个类的超类可以显示为表格的一个字段，在编辑环境的另一个面板中，则显示为类层次结构中的节点。编辑其中的任何一个都会更新核心模型，随即也会更新所有的投射。

这些表现形式不过是底层模型的投射而已，所以，鼓励对模型进行语义转换。如果重命名方法，最好体现在模型上，而非其文本表现形式上。从语义层面上看，许多变化都可以看做是对语义模型的操作，而非文本操作。这一点对于安全和有效的重构格外有帮助。

源文件还有一些实用上的优势，在某些场景下通过投射和截屏来解释则要麻烦得多。使用一些文本处理工具，某些转换可以很好地自动化，如果投射系统不支持所需的转换，这一点就显得特别有用。投射系统只接收有效输入，这一点固然很好，但有时当思考解决方案时，可能要键入一些无法立即起作用的东西作为临时

源码扮演两种角色：编辑形式和存储形式。编译器会将这种表现形式转换为可执行的形式。可以在机器上运行的形式。对于解释器语言来说，源码也就是可执行形式。

在某个时刻，比如编译期间，会生成某种抽象的表现形式，这纯粹是一种面向计算机的构造，只是为了使程序处理起来更加容易。现代IDE也会生成一种抽象的表现形式来辅助编辑。也许会有多种抽象的表现形式：IDE用于编辑的表现形式可能不同于编译器所用的语法树。现代编译器也会为不同的目的创建多种抽象表现形式，比如，为了某些目的的创建的是语法树，而为其他目的创建的是调用图。

使用投射性编辑，表现形式可以有不同的安排。核心表现形式是工具所用的**语义模型**。这种表现形式可以投射为多种编辑形式。模型通过一个单独的存储表现形式进行保存。存储表现形式也许在某个层面上是可读的，比如，以XML进行序列化。

### 9.4 说明性编程

投射编辑最引人入胜的一个发展就是，它堆成为说明性编程的支持。在常规程序设计中，最关注的是程序，是对增养的东西应该工作的一般性描述。说它是一般性，因为它只是一段文本，描述一般性的情况，对于不同的输入产生不同的结果。

相比于在解释器里运行代码片段的能力，说明性编程是一个更宽泛的概念。解释代码片段可以探索执行过程，但它并不会把示例置于重要的位置。说明性编程技术将说明推到了编辑体验的前台，程序则退居幕后，只在探讨说明的某个部分时，才会出现。

### 9.5 工具之旅

* **Intenional Workbench**
* **Meta-Programming System(MPS)**
* **Xtext**
* **SQL Server Modeling**

### 9.6 语言工作台和CASE工具

**CASE(Computer-Aided Software Engineering)**计算机辅助软件工程鞠躬可以使用各种图形符号表现软件设计，然后生成软件。特征：以模型为核心，使用元模型定义，图形投射编辑。

语言工作台和CASE工具的差异：CASE工具无法定义自己的语言。

# 第二部分

## 第10章 各种DSL

### 10.1 Graphviz

Graphviz可以生成一个图表，使用DOT语言编写，图表中有`节点`和`弧线`。节点用node关键字声明，但不一定要声明出来。弧用`->`操作符声明。在方括号里列出的是，节点和弧的属性。

### 10.2 JMock

JMock是Mock Object的一个Java程序库。其作者曾经写过多个mock对象程序库，关于如何用内部DSL定义mock上的预期。

Mock对象是用来做测试的。测试从声明预期开始，预期就是测试过程中会调用的对象方法。然后，把mock对象插入要测试的实际对象里，与之交互。随后，mock对象会汇报它是否接收到了正确的方法调用。

JMock使用了渐进式接口。采用这种方式，with只能出现在method之后，这样的，IDE的自动补全就可以帮助按照正确的方式写出预期。JMock采用**表达式生成器**处理DSL调用，并将其翻译称mock和预期的**语义模型**

### 10.3 CSS

CSS在声明式计算模型方面是一个好例子，这种计算模型不同于命令式模型。只要声明HTML元素的匹配规则即可。
 
SASS是另一种类似于CSS的DSL，生成CSS作为输出。SASS提供了数学运算和变量。在CSS块结构上加入语法上的换行和缩进。在一种DSL之上构建另外一种DSL，提供底层DSL缺失的抽象。上层的DSL应该类似于底层的DSL，上层DSL的用户也都能够理解底层的DSL。

### 10.4 HQL

Hibernate是一个广泛应用的对象-关系映射系统，可以将Java类映射到关系数据库的表上。HQL(Hibernate查询语言)提供了这样一种能力，在Java类上以类似于SQL的方式编写查询语句，映射到真实数据库的SQL查询上。

```hql
select person from Person person, Calendar calendar
where calander.holidays['national day'] = person.birthday
    and person.nationality.calendar = calendar
```

HQL处理的本质是，将HQL查询翻译成SQL查询：

* 用**语法指导翻译**和**树的构建**将HQL输入文本转换为HQL的抽象语法树
* 把HQL的AST转换为SQL的AST
* 代码生成器根据SQL的AST生成SQL

所有这些情况都用到了ANTLR。除了可以用标记流作为ANTLR语法分析器的输入，还可以用AST作为ANTLR的输入。ANTLR的树构建语法HQL和SQL的AST时都有用到。

这个转换的路径`输入文本-输入AST->输出AST->输出文本->输出文本`，对于源码到源码转换很常用。

### 10.5 XAML

XAML是C# WPF等UI布局的一种DSL，XAML就是XML文件，用来布局对象结构：使用WPF，可以布局屏幕。

```xaml
<?xml version="1.0" encoding="UTF-8"?>
<ContentView xmlns="http://xamarin.com/schemas/2014/forms"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml" 
    xmlns:binders="clr-namespace:DuGu.XFLib.Binders"
    xmlns:duguctrls="clr-namespace:DuGu.XFLib.Controls"
    xmlns:carView="clr-namespace:CarouselView.FormsPlugin.Abstractions;assembly=CarouselView.FormsPlugin.Abstractions"
    xmlns:ffimg="clr-namespace:FFImageLoading.Forms;assembly=FFImageLoading.Forms"
    xmlns:fftrans="clr-namespace:FFImageLoading.Transformations;assembly=FFImageLoading.Transformations"
    x:Class="QZhiHuFind.Views.DailyView"
    BackgroundColor="#E2DFED">
    <ContentView.Resources>
        <ResourceDictionary>
            <Style TargetType="ffimg:CachedImage">
                <Setter Property="DownsampleToViewSize" Value="true"/>
                <Setter Property="CacheDuration" Value="7" />
                <Setter Property="DownsampleUseDipUnits" Value="true" />
                <Setter Property="ErrorPlaceholder" Value="ic_placeholder.jpg" />
                <Setter Property="LoadingPlaceholder" Value="ic_placeholder.jpg" />
            </Style>
        </ResourceDictionary>
    </ContentView.Resources>
	<ListView
        x:Name="ItemsListView"
        binders:ListViewBinder.ItemTappedCommand="{Binding ItemSelectedCommand}"
        binders:ListViewBinder.LoadMoreCmd="{Binding LoadMoreCommand}"
        BackgroundColor="#E2DFED"
        CachingStrategy="RecycleElement"
        HasUnevenRows="True"
        IsPullToRefreshEnabled="True"
        IsRefreshing="{Binding IsBusy, Mode=TwoWay}"
        ItemsSource="{Binding Items}"
        RefreshCommand="{Binding RefreshCommand}"
        SeparatorVisibility="None"
        VerticalOptions="FillAndExpand">
        <ListView.Header>
...
...
```

在屏幕布局方面，这种做法HTML非常类似。

从逻辑上说，XAML文档定义了一个C#类，这里确实会用到代码生成。生成的代码是**部分类(C#语言特性)**。

### 10.6 FIT

FIT是测试框架，其目标是，以领域专家可以理解的方式，描述测试场景。随后的许多工具扩展了这个基本的想法，尤其是Fitnesse。

如果把FIT当作一种DSL，它的很多方面都很有趣：FIT的核心是提供一种记法，让非程序员也能够很容易地用表格形式指定示例值。所以，FIT程序就是一堆表格，典型的做法是嵌套在HTML页面里。表格之间可以放置其他HTML元素，这些元素都会当做注释。这样，领域专家就可以用平实的叙述方式描述他们想要的东西，表格就提供了可处理的部分。

FIT表格可以采用不同的形式，其本质就是一种简单的命令式语言。它简单到没有条件，没有循环，只有一堆动词。

每个表格同一个夹具相关联，将动词翻译成系统行为。check这个动词比较特殊，只是用来执行比较的。当运行表格时，会产生一个HTML输出，同输入页面完全一样，只会根据比较匹配与否，将check行标上颜色，或绿或红。

<!-- DSL看到了第148页-->

### 10.7 Make

## 第11章 语义模型

### 11.1 工作模型

### 11.2 使用场景

### 11.3 入门例子（Java）

## 第12章 符号表

### 12.1 工作原理

### 12.2 使用场景

### 12.3 参考文献

### 12.4 以外部DSL实现的依赖网络（Java和ANTLR）

### 12.5 在一个内部DSL中使用符号键（Ruby）

### 12.6 用枚举作为静态类型符号（Java）

## 第13章 语境变量

### 13.1 工作原理

### 13.2 使用场景

### 13.3 读取INI文件（C#）

## 第14章 构造器生成器

### 14.1 工作原理

### 14.2 使用场景

### 14.3 构建简单的航班信息(C#)

## 第15章 宏

### 15.1 工作原理

### 文本宏

### 语法宏

### 15.2 使用场景

## 第16章 通知

### 16.1 工作原理

### 16.2 使用场景

### 16.3 一个非常简单的通知（C#）

### 16.4 解析中的通知（Java）

## 第17章 分隔符指导翻译

### 17.1 工作原理

### 17.2 使用场景
 
### 17.3 常客记分（C#）

### 17.4 

# 第三部分

## 第18章 语法指导翻译

### 18.1 工作原理

#### 词法分析器

#### 语法分析器

#### 产生输出

#### 语义预测

### 18.2 使用场景

## 第19章 BNF

### 19.1 工作原理

### 19.2 使用场景

## 第20章 基于正则表达式表的词法分析器

### 20.1 工作原理

### 20.2 使用场景

## 第21章 递归下降法语法解析器

### 21.1 工作原理

### 21.2 使用场景

### 21.3 递归下降

## 第22章 解析器组合子

### 22.1 工作原理

### 22.2 使用场景

## 第23章 解析器生成器

### 23.1 工作原理

### 23.2 使用场景

### 23.3 Hello World（Java和ANTLR）

#### 编写基本的文法

#### 构建语法分析器

#### 为文法添加代码动作

#### 使用代沟

## 第24章 树的构建

### 24.1 工作原理

### 24.2 使用场景

### 24.3 使用ANTLR的树构建语法（Java和ANTLR）

#### 标记解释

#### 解析

#### 组装语义模型

### 24.4 使用代码动作进行树的构建

## 第25章 嵌入式语法翻译

### 25.1 工作原理

### 25.2 使用场景

## 第26章 内嵌解释器

### 26.1 工作原理

### 26.2 使用场景

### 26.3 计算器

## 第27章 外加代码

### 27.1 工作原理

### 27.2 使用场景

### 27.3 嵌入动态代码

#### 语义模型

#### 语法分析器

## 第28章 可变分词方式

### 28.1 工作原理

#### 字符引用

#### 词法状态

#### 修改标记类型

#### 忽略标记类型

### 28.2 使用场景

## 第29章 嵌套的运算符表达式

### 29.1 工作原理

#### 使用自底向上的语法分析器

#### 自顶向下的语法分析器

### 29.2 使用场景

## 第30章 以换行符作为分隔符

### 30.1 工作原理

### 30.2 使用场景

## 第31章 外部DSL

### 31.1 语法缩进

### 31.2 模块化文法

# 第四部分

## 第32章 表达式生成器

### 32.1 工作原理

### 32.2 使用场景

### 32.3 具有和没有生成器的连贯日历

### 32.4 对于日历使用多个生成器

## 第33章 函数序列

### 33.1 工作序列

### 33.2 使用场景

### 33.3 简单的计算机配置

## 第34章 嵌套函数

### 34.1 工作原理

### 34.2 使用场景

### 34.3 简单计算机配置范例

### 34.4 用标记处理多个不同的参数

### 34.5 针对IDE支持使用子类型标记

### 34.6 使用对象初始化器

### 34.7 周期性事件

## 第35章 方法级联

### 35.1 工作原理

#### 生成器还是值

#### 收尾问题

#### 分层结构

#### 渐进式接口

### 35.2 使用场景

### 35.3 简单的计算机配置范例

### 35.4 带有属性的方法级联

### 35.5 渐进式接口

## 第36章 对象范围

### 36.1 工作原理

### 36.2 使用场景

### 36.3 安全代码

#### 语义模型

#### DSL

### 36.4 使用实例求值

### 36.5 使用实例初始化器

## 第37章 闭包

### 37.1 工作原理

### 37.2 使用场景

## 第38章 嵌套闭包

### 38.1 工作原理

### 38.2 使用场景

### 38.3 用嵌套闭包来包装函数序列

### 38.4 简单的C#示例

### 38.5 使用方法级联

### 38.6 带显式闭包参数的函数序列

### 38.7 采用实例级求值

## 第39章 列表的字面构造

### 39.1 工作原理

### 39.2 使用场景

## 第40章 Literal Map

### 40.1 工作原理

### 40.2 使用场景

### 40.3 使用List和Map表达式计算机的配置信息

### 40.4 演化为Greenspun式

## 第41章 动态接收

### 41.1 工作原理

### 41.2 使用场景

### 41.3 积分-使用方法名解析

#### 模型

#### 生成器

### 41.4 积分-使用方法级联

#### 模型

#### 生成器

## 第42章 标注

### 42.1 工作原理

#### 定义标注

#### 处理标注

### 42.2 使用场景

### 42.3 用于运行时处理的特定语法

### 42.4 使用类方法

### 42.5 动态代码生成

## 第43章 解析树操作

### 43.1 工作原理

### 43.2 使用场景

### 43.3 由C#条件生成IMAP查询

#### 语义模型

#### 以C#构建

#### 退后一步

## 第44章 类符号表

### 44.1 工作原理

### 44.2 使用场景

### 44.3 在静态类型中实现类符号表

## 第45章 本文润色

### 45.1 工作原理

### 45.2 使用场景

### 45.3 使用润色的折扣规则

## 第46章 为字面量提供扩展

### 46.1 工作原理

### 46.2 使用场景

### 46.3 食谱配料

# 第五部分 其他计算模型

## 第47章 适应性模型

### 47.1 工作原理

#### 在适应性模型中使用命令式代码

#### 工具

### 使用场景

## 第48章 决策表

### 48.1 工作原理

### 48.2 使用场景

### 48.3 为一个订单计算费用

#### 模型

#### 解析器

## 第49章 依赖网络

### 49.1 工作原理

### 49.2 使用场景

### 49.3 分析饮料

## 第50章 产生式规则系统

### 50.1 工作原理

#### 链式操作

#### 矛盾推导

#### 规则结构里的模式

### 50.2 使用场景

### 50.3 俱乐部会员校验

#### 模型

#### 解析器

#### 演进DSL

### 50.4 适任资格的规则：扩展俱乐部成员

#### 模型

#### 解析器

## 第51章 状态机

### 51.1 工作原理

### 51.2 使用场景

### 51.3 安全面板控制器

## 第52章 基于转换器的代码生成

### 52.1 工作原理

### 52.2 使用场景

### 52.3 安全面板控制器

## 第53章 模版化的生成器

### 53.1 工作原理

### 53.2 使用场景

### 53.3 生成带有嵌套条件的安全控制面板状态机

## 第54章 嵌入助手

### 54.1 工作原理

### 54.2 使用场景

### 54.3 安全控制面板的状态

### 54.4 助手类应该生成HTML吗

## 第55章 基于模型的代码生成

### 55.1 工作原理

### 55.2 使用场景

### 55.3 安全控制面板的状态机

### 55.4 动态载入状态机

## 第56章 无视类型的代码生成

### 56.1 工作原理

### 56.2 使用场景

### 56.3 使用嵌套条件的安全面板状态机

## 第57章 代沟

### 57.1 工作原理

### 57.2 使用场景

### 57.3 根据数据结构生成类
