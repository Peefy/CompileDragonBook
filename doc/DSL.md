
# 前言

**DSL 领域特定语言**

领域特定语言（英语：domain-specific language、DSL）指的是专注于某个应用程序领域的计算机语言。又译作领域专用语言。

在定义DSL是什么的问题上，Fowler 认为业界经常使用的一些特征，例如“关注于领域”、“有限的表现”和“语言本质”是非常模糊的。因此，唯一能够确定DSL边界的方法是考虑“一门语言的一种特定用法”和“该语言的设计者或使用者的意图”：
如果XSLT的设计者将其设计为XML的转换工具，那么认为XSLT是一个DSL。如果一个用户使用DSL的目的是该DSL所要达到的目的，那么它是一个DSL，但是如果有人以通用的方式来使用一个DSL，那么它（在这种用法下）就不再是一个DSL了

域特定语言（英语：domain-specific language、DSL）指的是专注于某个应用程序领域的计算机语言。又译作领域专用语言。不同于普通的跨领域通用计算机语言(GPL)，领域特定语言只用在某些特定的领域。 比如用来显示网页的HTML，以及Emacs所使用的Emac LISP语言。

DSL可以简化复杂的代码，促进与客户沟通的效率，提高工作效率，清除发展瓶颈。

**编译相关的程序**

* **解释程序 (interpreter)**-
* **汇编程序（assembler）**-
* **连接程序（linker）**-
* **装入程序（loader）**-
* **预处理器（preprocessor）**-
* **编辑器（editor）**-
* **调试程序（debugger）**-
* **描述器（profiler）**-
* **项目管理程序（project manager）**-

**编译相关的步骤**

* **扫描程序（scanner）**-
* **语法分析（parser）**-
* **语义分析（semantic analyzer）**-
* **优化程序（source code optimizer）**-
* **代码生成（code generator）**-
* **目标代码（target code optimizer）**-

**编译相关的记号**

* **记号（token）**-
* **语法树（syntax tree）**-
* **符号表（symbol table）**-
* **常数表（literal table）**-
* **中间代码（intermediate code）**-
* **临时文件（temporary file）**-

# 第一部分

## 第1章 入门例子

### 1.1 哥特式建筑安全系统

想要构建一套这样的安全系统，公司的人进入之后，设置某种无线网络，安装一些小的设备。如果发生某些有趣的事情，这些设备会发出一条四字符的消息。比如，打开抽屉，抽屉上的感应器就会发出一条消息：D2OP。还有一些小的控制设备，响应这样的四字符命令消息。比如，某个设备收到D1UL消息，就会打开一扇门。

假设有这样一系列系统，它们共享着大多数组件和行为，却彼此间差异巨大。在这个例子中，对所有的客户来说，控制器发送和接收消息的方式是相同的。但是产生的事件序列和发送的命令却不尽相同。

把控制器看做是**状态机(state machine)**，每个感应器都可以发送**事件(event)**，改变控制器的**状态(state)**。当控制器进入某种状态时，就会在网络上发出一条命令消息。

### 1.2 状态机模型

对于指定控制器如何运作而言，状态机是一个恰当的抽象，下一步就是确保这个抽象能够运用到软件自身。如果人们在考虑控制器行为时，也要考虑事件，状态和转换，那么，希望这些词汇也可以出现在软件代码里。从本质上说，这就是**领域驱动设计(Domain-Driven Design)**中的**DDD原则**。也就是说在领域人员和程序员之间构建的一种共享语言。

对于Java程序来说，自然的方式就是以状态机为Domain Model。通过接收事件消息和发送命令消息，控制器得以同设备通信。这些消息都是四字母编码，可以通过通信通道进行发送。在控制器代码里面，想用**符号名(symbolic name)**引用这些消息。创建了事件类和命令类，它们都有代码(code)和名字(name)。把它们放到单独的类里面(有一个超类)，因为在控制器的代码里，它们扮演者不同的角色。

```java
class AbstractEvent {
    private String name, code;
    public AbstractEvent(String name, String code) {
        this.name = name;
        this.code = code;
    } 
    public String getCode() {
        return code;
    }

    public String getName() {
        return name;
    }
}
public class Command extends AbstractEvent {}
public class Event extends AbstractEvent {}
```

状态类记录了它会发送的命令及其相应的转换

```java
class State {
    private String name;
    private List<Command> actions = new ArrayList<Command>();
    private Map<String, Transition> transitions = new HashMap<String, Transtion>();
}

class State {
    public void addTranstion(Event event, State targetState) {
        assert null != targetState;
        transtitions.put(event.getCode(), new Transition(this, event, targetState));
    }
}

class Transition {
    private final State source, target;
    private final Event trigger;

    public Transtion(State source, Event trigger, State target){
        this.source = source;
        this.target = target;
        this.trigger = trigger;
    }

    public State getSource() {
        return source;
    }

    public State getTarget() {
        return target;
    }

    public Event getTrigger() {
        return trigger;
    }

    public String getEventCode() {
        return trigger.getCode();
    }
}
```

状态机保存了其起始状态。

```java
class StateMachine...
    private State start;

    public StateMachine(State start) {
        this.start = start;
    }
```

这样，从这个状态可以到达状态机里的任何状态

```java
class StateMachine...
    public Collection<State> getStates() {
        List<State> result = new ArrayList<State>();
        collectState(result, start);
        return result;
    }

    private void collectStates(Collection<State> result, State s) {
        if (result.contains(s)) return;
        result.add(s);
        for (State next : s.getAllTargets())
            collectStates(result, next);
    }

class State...
    Collection<State> getAllTargets() {
        List<State> result = new ArrayList<State>();
        for (Transtion t : transitions.values())
            result.add(t.getTarget());
        return result;
    }
```

为了重置事件，在状态机上保存了一个列表。

```java
class StateMachine...
    private List<Event> resetEvents = new ArrayList<Event>();

    public void addResetEvents(Event... events) {
        for (Event e : events) 
            resetEvents.add(e);
    }
```

像这样用一个单独结构处理重置事并不是必需的。简单🉐地在状态机上声明一些额外的转换，也可以处理这种情况，如下所示：

```java
class StateMachine...
    private void addResetEvent_byAddingTransitions(Event e) {
        for (State s : getStates()) 
            if (!s.hasTransition(e.getCode(), s.addTransition(e,start)));
    }
```

倾向于在状态机上设置显式的重置事件，这样可以更好地表现意图。虽然这样做确实使状态机有点复杂，但它也更加清晰地表现出通用状态机该如何运作，要定义特定状态机也会更加清晰。

处理完结构，再来看看行为。事实证明，这真的相当简单。控制器有个handle方法，它以从设备接收到的事件代码为参数。

```java
class Controller...{
    private State currentState;
    private StateMachine machine;

    public CommandChannel getCommandChannel() {
        return commandsChannel;
    }

    private CommandChannel commandsChannel;

    public void handle(String eventCode) {
        if (currentState.hasTransition(eventCode))
            transitionTo(currentState.targetState(eventCode));
        else if (machine.isResetEvent(eventCode))
            transitionTo(machine.getStart());
        // ignore unknown events
    }

    private void trasitionTo(State target) {
        currentState = target;
        currentState.executeActions(commandsChannel);
    }
}
class State {
    public boolean hasTransition(String eventCode) {
        return transtions.containsKey(eventCode);
    }

    public State targetState(String eventCode) {
        return transtions.get(eventCode).getTarget();
    }

    public void executeActions(CommandChannel commandsChannel) {
        for (Command c : actions) commandChannel.send(c.getCode());
    }
}
class StateMachine... {
    public boolean isResetEvent(String eventCode) {
        return resetEventCode().contains(eventCode);
    }
}
```

对于未在状态上注册的事件，它会直接忽略。对于可识别的任何事件，它就会转换为目标状态，并执行这个目标状态上定义的命令。

### 1.3 控制器编写程序

除了构建状态机模型的代码，还需要其他代码。一般是按照如下划分：

* 程序库，框架或者组件的代码
* 配置代码，组件组装代码。

这种做法分开了公共代码和可变代码。用公共代码构建一套组件，然后根据不同的目的进行配置。如配置代码可以为XML，json，yaml等文件，但是代价是配置上的语法错误只能在运行时检测出来。

DSL只有同其他语言配合起来，才能完成整个工作，DSL的简单性意味着，它是容易编辑和处理的。本文DSL有两种，称为外部DSL和内部DSL。外部DSL是指，在主程序设计语言之外，用一种单独的语言表示领域专用语言。这种语言用的可能是定制语法，或者遵循另一种表现的语法，比如XML。内部DSL是指用通用语言的语法表示的DSL。

### 1.4 语言和语义模型

状态机与DSL的关系是至关重要的。在上面的例子中，DSL的角色就是组装状态机模型。

一个例子:

```dsl
events
  doorClosed D1CL
```

上述DSL会创建一个新的事件对象

```java
new Event("doorClosed", "D1CL")
```

并且把它保存在一边，这样，遇到`doorClosed => active`时，就可以将它包含在一个转换里(使用addTransition)。这个模型就是个引擎，提供了状态机的行为。事实上，可以说，这个设计的能力大多源自这样一个模型。DSL所做的一切就是提供一种更可读的方式来组装这个模型，这就是与开始的命令查询API不同的地方。

涉及到编程语言时，常常会提到**语法(syntax)**和**语义(semantics)**。语法描述程序的合法表达式，而在DSL中所能描述的一切都是由**文法(grammer)**决定的。程序的语义是指，它代表着什么。也就是说，它能做什么。

对于一个设计良好的DSL而言，语义模型至关重要。语义模型可以是对象模型，还可以是其他形式。即便它只是一个纯粹的数据结构，所有的行为都在单独的函数里，依然愿意称之为语义模型，因为在那些函数的上下文里，数据结构表现出了DSL脚本特定的含义。

DSL只是扮演着展示模型配置机制的角色。使用这种方式的益处大多源自模型，而非DSL。为客户配置新的状态很容易，这是模型的属性，而非DSL。控制器可以在运行时改变，无须编译，这是模型的属性，而非DSL。

DSL所带来的益处与状态机紧密相关，其所组成的某个特定模型就扮演了系统程序的角色。要改变状态机的行为，就需要修改模型中的对象及其相互关系。这种风格的模型通常称为“适应性模型”。这样得到的是一个模糊代码和数据之间差异的系统，只看代码，是无法理解状态机行为的，还必须了解对象实例的连接方式。当然，从某种程度上说，这总是对的，任何程序对不同的数据都会给出不同的结果，但在此有个极大的差异，因为状态对象的存在会在很大程度上改变系统的行为。

适应性模型非常强大，但是通常也很难用，因为人们看不到任何定义特定行为的代码。DSL是有价值的，它提供了一种显式的方式表现代码，这种形式让人们对状态机编程有了感觉。

### 1.5 使用代码生成

要处理DSL，组装“语义模型”，然后执行语义模型，提供希望从控制器得到的行为，在语言圈子里，这种方式称为**解释(interpretation)**。在解释文本时，会解析文本，然后程序立刻产生结果。

在语言领域里，与解释相对的是编译。在编译时，先解析程序文本，产生中间输出，然后单独处理输出，提供预期行为。在DSL的上下文里，编译方式通常指的是**代码生成(code generation)**

代码生成通常很笨拙，因为它常常需要进行额外的编译步骤。为了构建程序，首先需要编译状态框架和解析器，其次运行解析器，为控制器生成源代码，然后编译生成的代码。这样做，构建过程就变得复杂许多。然而，代码生成的一个优势在于，编写解析器和生成代码可以用不同的语言。在这个情况下，如果生成的代码用的是动态语言(如JS),第二哥编译步骤就可以省略。

### 1.6 使用语言工作台

语言工具台是一个环境，设计初衷就是帮助人们构建新的DSL，以及有效地运用这些DSL所需的高质量工具。甚至设计对图形语言的支持，但是还存在一些问题和发展前途。

### 1.7 可视化

语言工作台的一大优势在于它们给了DSL更为多样的表现形式，特别是图形化表示。然而，即使是文本化的DSL也可以有图形化的表示。

对于许多DSL来说，使用类似于Graphviz这样的工具非常有用，因为它给了另一种表现形式。类似于DSL本身，这种**可视化(visualization)**表现形式可以让人更好地理解模型。可视化不同于对应的源代码，其本身无法编辑。

## 第2章 使用DSL

### 2.1 定义DSL

领域特定语言：针对某一特定领域，具有受限表达性的一种计算机程序设计语言。这一定义包含4个关键元素：

* **计算机程序设计语言**-用DSL指挥计算机做一些事情。同大多数现代程序设计语言一样，其结构设计成便于人们理解的样子，但它应该还是可以由计算机执行的语言。
* **语言性**-DSL是一种程序设计语言，因此必须具备连贯的表达能力----不管是一个表达式还是多个表达式组合在一起
* **受限的表达性**-通用程序设计语言提供广泛的能力：支持各种数据，控制，以及抽象结构。这些能力很有用，但也会让语言难于学习和使用。DSL只支持特定领域所需要特性的最小集。使用DSL，无法构建一个完整的系统，相反，却可以解决系统某一方面的问题。
* **针对领域**-只有在一个明确的小领域下，这种能力有限的语言才会有用。这个领域才使得这种语言值得使用。

DSL主要分为三类：

* **外部DSL**-是一种“不同于应用系统主要使用语言”的语言。外部DSL通常采用自定义语法，不过选择其他语言的语法也很常见(XML就是一个常见的选择)。宿主应用的代码会采用文本解析技术对使用外部DSL编写的脚本进行解析。一些小语言的传统UNIX就符合这种风格。可能经常会遇到的外部DSL的例子包括：正则表达式、SQL、Awk，以及像Struts和Hibernate这样的系统所使用的XML配置文件。
* **内部DSL**-是一种通用语言的特定语法。用内部DSL写成的脚本是一段合法的程序，但是它具有特定的风格，而且只用到了语言的一部分特性，用于处理整个系统一个小方面的问题。用这种DSL写出的程序有一种自定义语言的风格，与其所使用的宿主语言有所区别。这方面最经典的例子是Lisp。Lisp程序员写程序就是创建和使用DSL。Ruby最著名的框架Rails，经常被认为是一套DSL。
* **语言工作台**-是一个专用的IDE，用于定义和构建DSL。具体来说，语言工作台不仅用来确定DSL的语言结构，而且是编写DSL脚本的编辑环境。最终的脚本将编辑环境和语言本身紧密结合在一起。

#### DSL的边界

DSL边界问题其实就是内部DSL与命令/查询式API之间的差异。从许多方面来说，内部DSl不过是一种特殊的API，核心差异在于语言性。

给具有命令/查询式API的类编写文档，一种常见的方式是列出其所拥有的所有方法，意味着每个方法自身都有独立含义，一组“词汇”，每一个都有自己的完备语义。而内部DSL的方法名只在一个更大表达式的上下文中才有明确的含义。

内部DSL给人的感觉是一个整句，而非一个无关命令的序列。这正是这种API称为连贯接口的基础。对内部DSL来说，受限表达式显然不是语言的一项核心属性，因为内部DSL植根于一个通用语言。在这种情况下，受限表达性表现在如何使用它。当构造DSL表达式时，会限制自己只使用通用语言的一部分特性，通常不会使用条件判断、循环结构和变量。

对外部DSL来说，其边界就是它与通用语言之间的边界。语言可以针对某领域，但仍然是通用语言。R语言就是一个很好的例子，它是一种用于统计的语言和平台，主要用于解决统计方面的问题，它也具备通用语言所有的表达性。因此，尽管它针对某一领域，但是依然不会称其为一种DSL。

一种更为明显的DSL是正则表达式。它所针对的领域(文本匹配)与其有限的特性紧密相关----那些特性刚刚好能做到易于匹配文本。DSL的一个普遍特征是，它们不是图灵完备的。一般来说，DSL不支持常见的命令式控制结构(条件和循环)，也不能定义变量和子例程。

#### 片段DSL和独立DSL

之前用的状态机的例子是一种独立的DSL。DSL出现的另外一种方式是**片段形式**。对于这种形式，DSL片段用于宿主语言的代码中。可以将其看作采用额外特性对宿主语言进行增强。

片段的一个典型例子是正则表达式，可以见到在一个程序中点缀着正则表达式片段，另外一个典型例子是SQL，在大型程序的上下文中，常常会用到SQL语句。

### 2.2 为何需要DSL

DSL是在特定条件下有专门用途的一种工具。DSL只是模型的一个薄壳，这个模型可能是程序库，也可能是框架。

#### 提高开发效率

DSL提供了一种手段，可以更加清晰地就系统某部分的意图进行沟通，DSL相比于采用命令-查询API，DSL形式更容易理解。DSL提供了一种“对阅读和操作抽象”更具表达性的形式，从而增强了这种抽象。DSL还可以帮助人们更好地学习使用API。

#### 与领域专家的沟通

让领域专家能够阅读懂代码，就可以直接指出问题所在，还可以同编写业务规则的程序员更好地交流，还可以编写一些草稿使程序员可以将其细化为适当的DSL规则。

#### 执行环境的改变

状态机可以在运行时解析，而非编译时。因此可以将代码运行于不同的环境，这类理由也是使用DSL一个常见的驱动力。对于XML配置文件而言，将逻辑从编译时移到运行时就是一个这样的理由。

用DSL常常可以弥补宿主语言的局限性，将事物以适宜的DSL形式表现出来，生成可用于实际执行环境的代码。模型的存在有助于这种迁移。

#### 其他计算模型

几乎所有主流的编程语言都采用命令式的计算模型。把非命令式方式称为声明式编程。之所以叫做声明式，是因为这个种风格让人定义做什么，而不是用一堆命令语句来描述怎么做。

### 2.3 DSL的问题

不使用DSL的唯一原因就是，使用DSL得不到任何好处，或者，至少是DSL的好处不足以抵消构建它的成本。

许多DSL的问题只是与某种特定DSL风格相关，要理解这些问题，需要深入理解这些DSL是如何实现的。

#### 语言噪音

虽然了解多种语言会让工作更加困难，但是DSL远比一门通用语言容易，因此，学习起来也要容易的多。

#### 构建成本

DSL的可维护性是一项重要的考量因素。DSL的成本大雨构建模型的成本。一个好的DSL可以封装一个糟糕的程序库，把它变得容易用。但是糟糕的DSL对于构建和维护而言，就是浪费资源，但这种说法对任何代码都适用。

#### 集中营语言

**集中营语言(ghetto language)**问题与语言噪音问题正好相反。一种DSL总是存在着无意中演化成一种通用语言的危险，有一种DSL，然后逐步为它添加新功能：今天添加条件表达式，明天又添加循环，最终图灵完备了。不是自己的业务，不要自己写，随着开源工具的崛起，基于已有开源工作量进行扩展，比从头打造更有意义。

#### “一叶障目”的抽象

任何DSL抽象总是伴随着风险，只知抽象，不知道具体实现。

### 2.4 广义的语言处理

也涉及语言处理技术，90%都是为了DSL，DSL中的语言处理技术也可以用在其他文字处理上。

### 2.5 DSL的生命周期

对于内部DSL，要符合宿主语言的语言；对外部DSL，语句要能够解析。其他DSL开始时比较非正式，然后再对照DSL进行修改，以得到一种合理的语法。对于每个例子，尝试用DSL的形式把它们写下来，随着处理到不同的情况，就要修改DSL，支持新的能力。最后，就会得到一套合理的用例，以及对这些用例的伪DSL描述。如果用的是语言工作台，就要在工作台之外完成这一阶段，用一个纯文本编辑器，或者一个普通的绘图软件，也可以是纸和笔。

一旦有了一套典型的伪DSL，就可以着手实现它了。这里的实现包括以宿主语言设计的状态机模型，模型的命令-查询API，DSL的具体语法以及DSL和命令-查询API之间的转换。

DSL分为测试驱动开发和基于模型发展两种方法。基于模型发展DSL发展DSL的方法有两种。对于“语言生长”的方式，要慢慢地在模型之上构建DSL，把模型几乎看作黑盒。首先看看目前所有的控制器，然后草拟出每个控制器的伪DSL。然后，一个场景一个场景地实现DSL，通常，不会对模型做任何深入的修改，尽管给模型添加一些方法能够更好的支持DSL。

### 2.6 设计优良的DSL从何而来

DSL的总体目标就是对读者要清晰，进行迭代设计，从目标受众那里获得反馈，准备多种方案，看看其他人的反应。DSL是一种程序设计语言，使用它应该像编程。

## 第3章 实现DSL

### 3.1 DSL处理之架构

DSL实现的大体架构：**DSL脚本 解析->语义模型 生成->目标代码**。所有重要的语义行为都可以在模型中铺货，而DSL的任务就是通过解析来填充模型。所以，语义模型在DSL中扮演着核心角色。

DSL语义模型通常是一个系统的Domain Model的子集，因为并不是Domain Model的所有部分都适合用DSL处理。语义模型完全就是一个普通的对象模型，可以像操作其他所有对象模型一样操作它。用状态模型的命令-查询API组装一个状态机，然后运行它，获取状态对象的行为。从某种意义上说，它与DSL是相互独立的，但是在现实中，它们又相互依赖。

分离语义模型和DSL有几个好处。首先，可以暂时不纠结于DSL的语法和解析器，而专注于当前领域的语义。如果用上DSL，就说明所表达的东西已经非常复杂，复杂到要拥有自己的模型来表示。可以直接创建语义模型中的对象，操作它们进行测试。比如，，可以创建一堆状态和迁移(transition)，测试事件(event)和命令(command)是否运行良好。

拥有一个独立的语义模型，模型和语言就可以独立演化。如果要改变模型，无须修改DSL就可以探索做法，模型能够工作后，给DSL添加必要的语言构造即可。同样，如果需要尝试不同的DSL语言，只要验证它们是否可以创建相同的模型对象即可。比较它们组装语义模型方式的不同，就可以知道两种语法之间的区别。

内部DSL和外部DSL的不同就在于解析这一步，既包括解析的目标，也包括解析的方式。两种风格的DSL都会产生同样的语义模型，没有理由不使用单独的语义模型。

当使用外部DSL时，DSL脚本，解析器和语义模型之间有条清晰的界限。DSL脚本由一种独立的语言编写，解析器读取这些脚本，然后组装语义模型。而使用内部DSL时，它们之间更容易混杂在一起。

代码生成是指生成单独编译和运行的代码，它是DSL中的一个可选项。使用语义模型生成代码的一个好处，它解耦了代码生成器和解析器。

### 3.2 解析器的工作方式

解析是一个很强的层级操作。当解析文本时，把数据块组织成一个树结构。考虑一个简单结构，状态机中的事件列表:

```dsl
events
  doorClosed D1CL
  drawOpened D2OP
end
```

这个复合结构是一个事件列表，包含一系列事件，每个事件都有名字和代码。对于真个列表，这里没有显式的标记，但是每一个事件本身仍然是一个层级：每个事件都有表示名字的符号和表示代码的字符串。

无论何时看到这样的脚本，都可以把它想象为一个层级，这样的层级称为语法树或解析树。任何脚本都可以转化为许多潜在的语法树----这取决于如何分解它。相当于单词，语法树是一种更高效的脚本表现形式，因为可以遍历语法树，使用各种不同的方式来对它进行操作。

可以把一个语法树翻译成语义模型。人们通常直接执行语法树，或者基于语法树生成代码。更有效的做法是，语法树可以直接当作语义模型来使用。

很多时候，语法树在调用栈中形成，在遍历的过程中得到处理。所以一般看不到整个树，而只能看到当前处理的分支。语法树的形成有赖于方法调用的实参和嵌套对象。使用外部DSL会产生一个更加显式的语法树。但即使是外部DSL，通常在处理过程中，也是在调用栈中不断形成和修剪着语法树。

### 3.3 文法，语法和语义

**文法**是一种规则，用以描述如何将文本流转化为语法树。文法由一系列**产生式规则**组成，每个产生规则都有一个名字(term)以及一个描述如何分解它的语句(statemant)。所以，一个加法语句可能就是:`addtionStatement:=number + number`。如果遇到语句`5+3`，解析器能够将其识别为加法语句。因为规则是相互引用的，所以也会有一条针对数字的规则，告诉如何识别合法数字。通过这些规则，可以得到一种语言的文法。

一种语言可以由多种不同的文法来定义，认识到这点很重要。世界上不存在某种语言的唯一文法。一种文法就定义了语言所生成的语法树的一种结构，对于一段特定的文本，可能会识别出许多不同的语法树结构。一种文法只定义一种形式的语法树：选择何种文法和语法树取决于很多因素，包括语言的文法特性以及处理语法树的方式等。

文法只定义一种语言的语法----它在语法树中如何表现。而这与语义无关。根据上下文不同，`5+3`可能等于`8`，也可能等于`53`，语法相同，但语义可能截然不同。语义的定义浓缩为如何根据语法树组装语义模型，以及如何处理语义模型。特别是，如果两个表达式产生相同结构的语义模型，即使语法不同，它们的语义其实也是相同的。

如果在使用外部DSL，用到了“语法制导翻译”，很可能会显式地使用文法来构建解析器。如果用的是内部DSL，可能没有显式的文法，但是从文法的角度思考DSL仍然是有用的，文法有助于在众多内部DSL模式中进行选择。

对于内部DSL，谈论文法显得有些奇怪，原因之一是，这里解析了两遍，所以包含了两种文法。第一种是宿主语言本身的解析，这显然要依赖于宿主语言的文法。这一遍解析创建宿主语言的执行指令。当宿主语言所构建的DSL执行时，语法树就会在调用栈中创建。只有在第二遍解析时，才会出现这个名义上的DSL语法。

### 3.4 解析中的数据

当解析器执行时，需要存储解析过程中的数据。这些数据可能是一个完整的语法树，但大多数情况下不是这样的。即使这种情况出现了，还是需要存储其他的一些数据，以便解析工作可以正常进行。

解析本质上是一种树遍历，当处理某一部分DSL脚本时，对于正在处理的语法树分支，可以得到其上下文的一些相关信息。然而，通常还会用到这个分支以外的信息。

命令定义在语言的某个地方，然后在其他地方引用。当命令在语句的行为中引用时，所在的语法树分支不同于命令定义的分支。如果语法树的表示只存在于调用栈中，那么到这里。命令定义就已经消失了。因此，要把命令对象保存下来以备后用。

为了做到这一点，需要使用**符号表**，它本质上是一个字典，其键是标识符`unlockDoor`，值是在解析中表示命令的对象。当处理文本`unlockDoor D1UL`时，创建一个对象持有数据，然后，把它存放在符号表里，键为`unlockDoor`。存放的对象可能是命令的语义对象，也可能针对局部语法树的中间对象。符号表对于交叉引用非常重要。如果在解析中创建一棵完整的语法树，理论上，可以省略符号表，但是它依赖是一个有用的结构。

### 3.5 宏

宏有两种风格，文本宏和语法宏。文本宏最容易理解，简单说就是文本替换。使用文本宏会带来便利，一个很好的例子就是在CSS文件中指定颜色。更复杂的宏例子是C的预处理器，比如，定义一个宏sqr(x)，它可以替换为`x*x`。

通过宏创建DSL有很多方式，可以使用宿主语言本身，也可以提供单独的一个文件，将其转换为宿主语言。语法宏也是通过替换实现的，但是它处理的是宿主语言中有效的元素，将一种表达式转换为另一种。

### 3.6 测试DSL

* 语义模型的测试
* 解析器的测试
* 脚本的测试

#### 语义模型的测试

```java
@Test
public void eventCausesTranstion() {
    State idle = new State("idle");
    StateMachine machine = new StateMachine(idle);
    Event cause = new Event("cause", "EV01");
    State target = new State("target");
    idle.addTransition(cause, target);
    Controller controller = new Controller(machine, new CommandChannel());
    controller.handle("EV01");
    assertEquals(target, controller.getCurrentState());
}
```

上面的代码演示了如何独立测试语义模型。然而，需要说明的是，这个例子的真是测试代码会更加复杂，也应该更好地分解。

有两种方法来分解这类代码。首先，创建一堆小的状态机，提供最小的测试夹具，以便测试语义模型的各种特性。比如，要测试“事件触发转换”(event triggers a transition)，只要创建一个简单状态机，它处于空闲态，并且可以转换(transition)为另外两个状态。

#### 解析器的测试

当使用语义模型时，解析器的工作就是组装语义模型。所以，解析器的工作就是组装语义模型。所以，解析器的测试就是，编写一小段DSL，确保它们生成结构正确的语义模型。

#### 无效输入的测试

刚才讨论的是正向测试，保证有效的DSL输入可以生成结构正确的“语义模型”。测试的另一种类型是负向测试，用于检测在无效输入的情况下会发生什么。无效输入的测试的基本想法，就是把各式各样的无效输入抛给解析器，经常会看到一些不起眼却很极端的错误。得到这样的结果可能已经足够了，除非要对错误诊断提供更多的支持。

#### 脚本的测试

语义模型和解析器的测试就是对普通对待进行单元测试。然而，DSL脚本也是代码，也应该考虑对它们进行测试。把测试看作double-check机制。当编写代码和测试时，其实是用两种非常不同的方式确定同一行为，一种用抽象的方式，另一种是用样例的方式。对任何有持久价值的东西，都应该进行双重确认。

脚本测试的细节很大程度上取决于要测试的东西。基本的方法是，提供一个测试环境，在其中创建文本夹具，运行DSL，比较结果。脚本测试也扮演着集成测试的角色，因为解析器或者语义模型的任何错误都会让它失败。

### 3.7 错误处理

解析器和生成输出是编写编译器中较为容易的部分，难点之一是给出更好的错误消息，DSL的注释支持。存在两个地方可以放置错误处理：模型或者解析器。对于语法错误，处理它最明显的地方就是解析器。

在处理语义错误时，要从解析器和模型中进行选择，两者都有其优点。如果要检查语义规则是否结构良好，模型是一个正确的地方。

* 把错误检测规则放在解析器中
* 把语义信息放入语义模型
* 使用语义模型检测错误

### 3.8 DSL迁移

DSL应该警惕的一个风险是“先编写，后使用”的想法。DSL的诸多属性同程序库完全一样，会不断发展变化并修改。

解决DSL修改问题的一种方式是，提供工具，自动把DSL从一个版本迁移到另一个版本。这些工具可以在升级时运行，也可以在尝试运行旧版脚本时自动运行。有两种方式实现迁移：

* 增量迁移的策略，这种方式本质上同人们处理数据库设计的演化所采用的想法是一致的。
* 基于模型的迁移，这种策略是可以与“语义模型”配合使用。语言就可以支持多个解析器，每个发布版对应一个解析器。每个解析器都会组装语义模型。当采用语义模型时，解析器的行为相当简单。*问题：很容易丢掉一些与语义无关但脚本编写者希望保留的东西：注释*

## 第4章 实现内部DSL

当使用内部DSL时，宿主语言很大程度上会造成限制，因为所用的任何表达式在宿主语言中都必须是合法的，内部DSL使用的很多思想都受限于语言特性。

**连贯接口**-用它描述接近语言风格的API，它是内部DSL的同义词。它揭示了API与DSL之间的核心区别----语言性。

### 4.1 连贯API与命令 - 查询API

连贯接口的核心模式是**方法级联**

```dsl
computer()
    .processor()
    .cores(2)
    .speed(2500)
    .i386()
.disk()
    .size(150)
.disk()
    .size(75)
    .speed(7200)
    .sata()
.end();
```

方法级联用了一连串的方法调用，每个调用都是在前一个的结果上继续调用，方法都是由一个叠一个的调用组成的。在常规的OO代码中，方法由点号隔开，还可以使用函数序列。

```dsl
computer();
    processor();
        cores(2);
        speed(2500);
        i386();
    disk();
        size(150);
    disk();
        size(75);
        speed(7200);
        sata();
```

只要以适当的方式对函数序列进行组织和代码布局，它读上去就可以像方法级联一样清晰明了。连贯性与所用的语法风格无关，而与方法本身的命名和分解方式相关。

连贯接口的本质是以不同的思路来思考如何使用组件，站在语言的角度，思考如何将“组装这些对象”的子句组装成句子。这种思想上的提升，正式内部DSL同调用API之间的核心差别。

命令-查询分离传递出一个信号：对象上的各种方法应该分为命令类方法与查询类方法。查询类方法有返回值，但不会改变系统的可观察状态。命令类方法可能会修改系统的可观察状态，但是不应该有返回值。这个原则非常重要，它可以帮助识别出查询类方法。由于查询类方法没有副作用，因此可以以任意顺序多次调用，而不改变调用结果。使用命令类方法，则要更谨慎一些，因为它们确实存在副作用。

在程序设计中，命令-查询分离是一条极具价值的原则。在内部DSL中使用方法级联，结果却常常破坏该原则----每个方法都要修改状态后返回一个对象，以继续链式操作。

命令-查询分离与连贯接口之间的另一重要区别是方法的命名。为命令-查询查询方法命名时，希望那些名字在独立的上下文中也有一定含义。对于连贯接口，方法命名则非常不同。因此往往会拥有一些方法，它们的名字在一个开放的上下文中并没有什么意义，但放在DSL句子的上下文中，读起来却很连贯。DSL中的方法命名，首先要考虑的是句子，元素的命名都应适应其上下文。DSL的命名都是基于脑海中特定DSL的上下文来编写的，而命令-查询的命名则是按照不需要上下文来撰写的。

### 4.2 解析层的需求

连贯接口与命令-查询接口的不同可能会产生复杂性。如果两种接口共存于一个类，则会让人产生迷惑。因此，建议构建一层“表达式生成器”，从而DSL中的语言处理元素与普通的命令-查询对象分隔开。表达式生成器对象的唯一任务就是，使用连贯接口构建普通对象的模型，从而将连贯的语句有效地翻译为一串命令-查询API调用。

使用表达式生成器的原因之一自然是两种接口的本质不同，但是更主要的原因是经典的“关注分离点”的观点。只要引入某种语言，即使是内部语言，也需要写出符合该语言的代码。这些代码往往需要保持对数据的跟踪，这些数据只有当处理该语言的时候才会有用。理解内部DSL的工作机制需要一定的时间，而一旦填充了底层模型，内部DSL如何工作就不再需要了。因此将语言处理的代码放在单独的层中是值得的，这个结构遵循DSL处理的一般过程。命令-查询接口对象的底层模型就是“语义模型”。表达式生成器就是解析器的一部分。

通常“解析器”用在解析文本的上下文中。在这种情况下，对文本的操作是由宿主语言解析器完成的。但是表达式生成器所做与解析器所谓的确有很多的共同之处。关键的差异在于，传统的解析器将标记流整理为语法树，而表达式生成器的输入则是函数调用流。同解析器的相同之处在于，将其理解为“将函数调用组织为解析树上节点”是有益的，使用了类似的解析数据结构，仍然会组装语义模型。

将语义模型同表达式生成器分离，带来的是使用语义模型一贯的优势。表达式生成器和语义模型可以独立测试，可以有多个解析器，既支持内部DSL，也支持外部DSL，或者用多个表达式生成器支持多种内部DSL。表达式生成器和语义模型也可以独立演化。如同其他软件一样，DSL很少一成不变。软件需要能够演进，能够在不改变DSL脚本的前提下，修改底层框架是很有用的，反之亦然。

有一种论调是反对使用表达式生成器的，但它只适用于语义模型自身使用了连贯接口的情形。在有些情况下，连贯接口是人们与模型交互的主要方式，这时模型类使用连贯接口是有意义饿的。然而，大多数情况下，倾向于模型累使用命令-查询接口。命令-查询接口在不同上下文中的使用方式更为灵活。连贯接口则往往需要存储临时的解析数据。

### 4.3 使用函数

命令-查询API往往表现为函数的形式，而通常，DSL结构也主要构建于函数基础之上。命令-查询API与DSL的主要区别在于函数组合的方式。既然存在组合函数的不同模式，选择哪种模式涉及不同的因素。第一个因素是函数作用域。如果用的是方法级联，DSL中的函数就是对象的方法，这些方法只能定义在链中的对象里，通常也就是“表达式生成器”里。如果在序列里使用裸函数，就要确保这些函数可以恰当地解决作用域问题。最显而易见的方式是使用全局函数，但是这么做会带来两个问题：让全局命名空间变得复杂，并为解析数据引入了全局变量。

全局的东西会让局部的修改变得困难，全局函数在程序的每个部分都可见，但理想情况下，函数应该只出现在DSL处理的部分。很多语言特性的存在都是为了消除对于全局化的需要。比如命名空间，只有导如一个特定的命名空间，其中的函数看起来才会像全局的一样。比如Java中的`static import`。

全局的解析数据是一个更严重的问题。无论以何种方式实现函数序列，都需要操作“语境变量”，以了解表达式解析进行到何种程度。

方法级联在很大程度上避免了全局性问题，虽然仍然需要从某种裸函数开始级联调用，不过，一旦开始，所有的解析数据都就可以保存在定义级联方法的表达式生成器对象里了。

在函数序列中使用“对象范围”，就可以避免上述全局情况。在大多数情形下，DSL脚本都放在表达式生成器的子类里面，这样，裸函数调用都是基于表达式生成器父类中的方法，从而解决了全局性的问题。DSL中的所有函数只定义在生成器类中，所以，都是局部化的。而且，因为它们都是实例方法，所以它们可以直接访问生成器实例的数据，保存解析数据。相对于将DSL脚本置于生成器子类所花的成本，这种做法有极具吸引力的优势，因此它是默认之选。

使用对象范围更进一步的好处是，对扩展性的支持。如果在DSL框架中很容易用范围类的子类，那么DSL用户就可以向DSL语言添加自己的方法。

函数序列与方法级联都需要使用语境变量跟踪解析状态。“嵌套函数”是第三种函数组合技术，使用它往往可以回避语境变量。如果使用嵌套函数，计算机配置的例子看上去应该是这样子的：

```dsl
computer(
    processor(
        cores(2),
        speed(2500),
        i386
    ),
    disk(
        size(150)
    ),
    disk(
        size(75),
        speed(7200),
        SATA
    )
);
```

嵌套函数组合函数的方式是，将函数调用作为更高层次函数调用的实参。结果就是函数调用嵌套起来。在解析技术中，层次结构随处可见，嵌套函数有着同任何类型的层次结构一样的强大优势。很直观的一点就是，在例子中，语言构造本身就反应出配置的层次结构----disk函数嵌套在computer函数里，这同框架对象最终嵌套得完全一致。因此，函数嵌套反映了DSL的逻辑语法树。使用函数序列与方法级联，只能以奇怪的缩进约定表现语法树，而嵌套函数则允许用语言反映语法树。

另一个结果是执行顺序的改变。使用嵌套函数，会在函数本身执行之前得到函数的实参。这样，即便没有语境变量，亦然可以构建框架对象。在computer函数执行之前，processor函数会先执行，返回一个完整的处理器(processor)对象。对后，根据完整的参数，computer函数就可以直接创建计算机(computer)对象。

在构建更高层次结构时，嵌套函数运作良好。然而，它也不尽完美。圆括号和逗号显得格外扎眼，同单纯的缩进约定相比，它们犹如噪音一般。因为嵌套函数同样要用裸函数，所以它与函数序列一样，也会存在全局性问题，而仍然可以通过对象范围加以完善。

如果只是将嵌套函数理解为一组命令，而非构建一个层次结构，其执行顺序会造成混淆。一个简单的嵌套函数序列最终的执行顺序与其编写顺序是相反的。

嵌套函数还客服了“函数实数参数由位置而非名字决定”的问题。考虑一个指定磁盘大小与转速的例子。如果所需全部内容只是两个整数，那么真正需要的就是`disk(75,7200)`。为了解决这个问题，可以使用嵌套函数，其仅仅返回整数值，这样写:`disk(size(75), speed(7200))`.这样的代码更为可读，却无法阻止写出这样的代码：`disk(speed(7200),size(75))`。

大多数程序员都会将大量使用嵌套函数看作一种与众不同，但只是反映了在日常(非DSL)编程中如何运用函数组合模式而已。

还可以进行模式混合，例子的各个部分分别展现出各个模式的长处。当定义列表中的元素时，函数序列运作良好。它很好地将每台计算机(computer)的定义划分到不同的语句里。实现起来也很容易，因为每条语句只是向结果列表中添加了一个配置完整的计算机对象。

对于每台计算机而言，嵌套函数消除了当前计算机对于语境变量的需求，因为所有的实参在computer函数调用之前就得到了。假设一台计算机由一个处理器以及数量可变的磁盘组成，那么该函数的实参列表就应该用其类型更好地反映这一点。一般来说，嵌套函数会让全局函数的使用更为安全，因为这么做会更容易将全局函数组织为“只返回对象而不改变解析状态”。

如果每个处理器和磁盘都有多个可选参数，那么方法级联会很适合。可以设置任意想要的值，以构建出所需元素。

然而，混合使用也会带来问题，特别是标点符号困惑：有些元素以逗号分隔，有些是点，有些则是分号，作为程序员，即使能够将它们分清楚，也很难记得住。对于一个非程序员而言，即使只是读这些表达式，他们都很可能会觉得困惑。标点符号差异是实现的产物，并不是DSL本身所需。

### 4.4 字面量集合

程序编写，无论以通用语言还是DSL，都事关将元素组合在一起。通常程序的组合方式是，将语句组合为序列，还有使用函数。组织元素还有另外一种方式，就是使用“列表的字面构造”和"Literal Map".

列表的字面构造包括一组元素，这些元素可以是相同类型，也可以是不同类型，而且数目不限。

类C风格的语言也有字面量数组的语法，比如`{1,2,3}`,它们可以当作更灵活的列表的字面构造来用，但是，就其使用场景以所能接受的元素而言，确实相当受限。也可以使用哈希或者字典表示脚本语言的字面量集合。

**符号(symbol数据类型)**-这种类型在大括号风格的语言中并不存在。符号数据类型主要用于在映射表中查找，尤其是在“符号表”中。符号都是不可变的，所以出于性能考虑，在实现上，相同符号值表示相同的对象。符号的字面形式不支持空格，它们也不支持大部分的字符串操作，因为其角色是符号查找，而非持有文本。

### 4.5 基于文法选择内部元素

内部DSL的元素有很多种不同的选择。选择的技巧之一是，考虑DSL的逻辑文法。当使用“语法指导翻译”时，创建的文法规则对于思考内部DSL也大有帮助。确定种类的表达式，加上其“BNF”规则，往往对应确定种类的内部DSL结构。

对于必选元素的子句`(parent ::= first second)`,嵌套函数是很好的选择。嵌套函数的实参可以直接匹配规则中的元素。如果是强类型语言，那么基于**类型感知(type aware)**的自动补全可以为每个参数提示正确的选项。

如果用嵌套函数处理可选元素列表`(parent ::= first maybeSecond ? maybeThird?)`,那就要困难的多，因为很可能最终得到的是，各种组合可能性的爆炸。在这种情况下，方法级联通常更适合，因为方法调用只要指明要用的元素即可。方法级联的棘手部分是，需要做一些额外的工作，确保规则中的每一项都只出现一次。

结构|BNF|考虑
-|-|-
必选列表|`parent::=first second third`|嵌套函数
可选列表|`parent::=first maebeSecond?maybeThird?`|方法级联
同构集合|`parent::=child*`|列表的字面构造、函数序列
异构集合|`parent::=(this|that|theOther)*`|方法级联
set|`n/a`|Literal Map

对于由多个相同类型的子元素组成的子句`(parent::=child*)`,采用列表的字面构造会比较合适。如果这个表达式定义的语句在语言的最顶层，那这就是会考虑函数序列的少量地方之一。

若是多个不同类型的子元素`(parent::=(this|that|theOther)*)`,会回到方法级联上，方法名很好地提示了所处理的元素。

子元素集合(set)往往不能与BNF很好地契合，有多个子元素，但每个子元素都最多只出现一次。也将其看作一个比选元素列表，其中的子元素可以按任意顺序排列。Literal Map在逻辑上很符合，但常常会遇到的问题是，必须使用正确的键(key)进行沟通，否则则不行。

对于‘最少一次’格式`(parent::=child+)`的文法规则来说，它并不能很好地与内部DSL契合。最好的方式是，使用一般的多元素格式，在解析过程中，检查至少有一个子元素。

### 4.6 闭包

**闭包(closure)**是程序涉及语言的一种能力，它们有很多的名字(**lambda**, **block**, **匿名函数**等)。闭包的作用是可以把某些内里联代码打包成一个对象，到处传递，在适当的时候执行。

对于内部DSL而言，会把闭包用作DSL脚本里的“嵌套闭包”。嵌套闭包有三个特点，使其很容易用于DSL：内联嵌套，延迟执行以及受限作用域的变量。

“嵌套函数”最好的特性之一是允许以一种对于宿主语言有意义的方式保留DSL的层次特征，而不像在“函数序列”和“方法级联”里，不得不以缩进表示层次关系。嵌套闭包同样具有这样的特点。

可以将任意的内联代码进行嵌套----这也是术语内联嵌套的由来。关于在函数实参里可以放什么，大多数语言都有一些限制，这也限制了在嵌套函数里编写的内容。但是，嵌套闭包可以突破这些界限。通过这个方式，可以嵌套非常复杂的结构，诸如，将函数序列嵌入嵌套闭包里，这在嵌套函数之中是不可能的。还有一个优势，在很多语言里面，从语法上说，嵌套闭包比嵌套函数更容易嵌入多条语句。

延迟执行可能是嵌套闭包带来的最重要的能力。使用嵌套函数，函数实参会在函数本身调用之前执行。使用嵌套闭包，则可以完全控制闭包执行的时机。可以改变执行的顺序，或者根本不执行某些闭包，或将所有的闭包存储起来以备后用。语义模型要完全控制程序执行的方式。这种做法尤为方便，这种模型称为“适应性模型”。DSL会包括一段宿主语言代码，这些代码会放入语义模型。这样，DSL与宿主语言代码就可以天衣无缝地融合了。

最后一个特点是，嵌套闭包允许引入作用域仅限于闭包内部的变量。通过使用作用域受限的变量，查看方法到底在操作那些数据就更容易了。

一个例子:

```ruby
#ruby
    ComputerBuilder.build do |c|
        c.processor do |p|
            p.cores 2
            p.i386
            p.speed 2.2
        end
        c.disk do |d|
            d.size 150
        end
        c.disk do |d|
            d.size 75
            d.speed 7200
            d.sata
        end
    end
```

对processor和disk的调用都包括一些代码，就是几条Ruby语句。这段代码还演示了作用域受限变量的用法，包括computer, processor, disks。这些变量虽然增加了一些噪音，但是也更容易看清楚，哪些对象在何处使用。从这段代码还可以看出，全局函数或者“对象范围”也不再是必需的了，比如，speed函数是定义在作用域受限变量上的“表达式生成器”

另一个例子：要到一组**验证(validate)**规则。通常，在面向对象的环境中，需要考虑对象是否合法，并且在某处有一些代码检查合法性。如果验证是上下文相关的，可能会更加复杂，比如为了做某事而验证对象。如果可以查看某人的数据，对于某人是否符合某项保险政策，一项政策的校验规则可能与另一项是不同的。在DSL里指定规则可能会这么做：

```cs
class ExampleValidation : ValidationEngineBuilder {
    protected override void build() {
        Validate("Annual Incomde is present")
            .With(p => p.AnnualIncome != null);
        Validate("positive Annual Income")
            .With(p => p.AnnualIncome > 0);
    }
}
```

函数调用`With`的内容是一个闭包，这个闭包以一个“人”为实参，并包含一些任意的C#代码。这些代码存储在语义模型上，当模型运行时再执行。
嵌套闭包是一项非常有用的DSL模式，即使对于支持闭包的语言，其闭包的语法也往往比较别扭。

### 4.7 解析树操作

解析树操作的基本思想是，当遇到一个使用宿主编程语言的表达式时，并不执行它，获取其结果，而是将其解析数看作数据。比如`aPerson.Age > 18`表达式的解析树如下：

```json
{
    "node" : "BinaryExpr",
    "childs" : [
        {
            "node" : "MemberExpr",
            "childs" : [
                {
                    "node" : "Member",
                    "value" : "Age"
                },
                {
                    "node" : "op",
                    "value" : "."
                },
                {
                    "node" : "Expr",
                    "value" : "aPerson"
                }
            ]
        },
        {
            "node" : "op",
            "value" : ">"
        },
        {
            "node" : "ConstantExpr",
            "value" : "18"
        }
    ]
}
```

解析树操作的强大之处在于，除了存储闭包本身外，还可以用于宿主语言编写表达式，然后可以把这些表达式转换为不同的表达式，以组装“语义模型”。

### 4.8 标注

Java的**标注annotation**和C#的**特性attribute**等。

标注允许程序员向程序构造(如类和方法)里面附加元数据。这些标注可以在编译期或者运行期进行读取。

```java
class PatientVisit {
    @ValidRange(lower = 1, upper = 1000, units = Units.LB)
    private Quantity weight;
    @ValidRange(lower = 1, upper = 120, units = Units.IN)
    private Quantity height;    
}
```

另一种显而易见的替代方案是，将范围检查代码放到字段的setter里面。不过采用标注会有诸多优势。字段边界读起来更清晰，范围检查也更容易，或者当给属性赋值时，或者稍后的对象校验阶段，这种方式指定的校验规则可以读到，并由GUI组件进行配置。

**标注可以看作一种扩展语言的方式，有了它语言就可以支持新的关键字(keyword功能)**。的确，即便是一些既有关键字，如果用标注实现，也可能会做的更好。比如，从一个新的角度来看，访问修饰符----private，public等以这种方式实现就会更好。

标注同宿主语言的绑定非常之紧密，所以它们很适合片段DSL，而非独立DSL。它们尤其擅长提供非常同一的思路来给宿主语言添加领域专用的增强特性。

### 4.9 为字面量提供扩展

为字面量提供扩展的危险之一是它在全局上增加了方法，但这些方法应该只用在DSL的受限上下文中。为字面量提供扩展虽然不是需要频繁使用的技巧，但用到的时候却非常方便----它非常适合针对特定领域定制语言的场合。

### 4.10 消除语法噪音

内部DSL的关键在于它们只是基于宿主语言的表达式，其编写格式使之读起来如同语言一样。这种做法的影响之一是，它们与宿主语言的语法结构交织在一起。从某些方面这样很好，因为其提供的语法是很多程序员都熟悉的，但有些人会觉得某些语法令人恼火。

消除这些语法负担的方式之一是，以尽可能接近宿主语言的语法编写DSL代码，但也不一定要完全一致，然后用简单的文本替换，将其转换为宿主语言。比如将`3 % if value at least $30000`转换为`percent(3).when.minimum(30000)`。

另一种方法是使用语法着色。大多数文本编辑器都提供了可定制的文本着色方案。

### 4.11 动态接收

动态语言的特点之一是，它们在运行时处理方法**调用(invoation)**。所以，如果写下`aPerson.name`，而person对象又没有定义name函数时，代码将会顺利通过编译，只在运行时抛出错误。

这些语言所采用的非统寻常的机制是这样的，将这个预期之外的调用路由到一个特殊方法进行处理。这个特殊方法的默认行为是抛出一个错误，但是，程序员可以重写该方法，进行其他处理，这种重写为“动态接收”，因为接收到的消息是否合法，是动态判断的。动态接收可能会带来一些有用的编程术语，尤其是使用代理时。有了代理，可以将对象包起来，无须准确知道哪个方法得到调用，就可以利用这些方法调用做一些事情。

在DSL中，动态接收的常见做法是，将信息从方法实参转移到方法名称上。动态接收的关键在于给了一个选择，将信息从参数转移到方法名上面，在某些情形下，这会让表达式更易于阅读和理解。

### 4.12 提供类型检查

静态类型的理由是，现代IDE通常提供了一些针对静态类型的优秀支持。然而，DSL中的大多数类似符号却没有得到这样的支持，因为需要将它们表示为字符串或者符号数据类型，并将其保存在自己的符号表。

## 第5章 实现外部DSL

虽然单靠内部DSL已经足以定义出连贯的语言，但最终还是会受限于宿主语言的语法结构。外部DSL则提供了更大的语法自由度----可以使用自己喜欢的语法。

相比于内部DSL，实现外部DSL的不同之处就在于解析过程，需要解析纯文本输入，这些输入不受任何现有语言的约束。创造DSL所需的背景知识要少于开发通用语言。

### 5.1 语法分析策略

当解析外部DSL时，要将一串文本分解成某种结构，通过这种结构来理解文本的含义。这个“结构化”的过程称为**语法分析(syntactic analysis)**。

一个简单的方法是分隔符指导翻译，受限找出能把输入分解成语句的分隔符（通常是换行符），根据这些分隔符把输入拆分成语句，然后逐个语句进行处理，找出其中的含义。通常，每行文本都包含一些明显的标识。

分隔符指导翻译很容易使用，涉及的工具也是大多数程序员都熟悉的字符串操作和正则表达式。其局限性在于，它不适用于处理层次结构的输入上下文。

更合适的办法是“语法指导翻译”。首先为输入语言定义一个形式化的文法，一般使用生成式表达。绝大多数文法都是以某种形式的**BNF**编写的，其中每行代表一条规则：首先是规则的名称，然后是满足该规则的合法元素。文法对于语法指导翻译特别有用，因为根据文法就可以机械地生成解析器。由语法指导翻译生成的解析器非常适合于处理这样的层次结构。

三种将BNF转换成某种解析算法的方式：

* **递归下降语法解析器**-是经典的转换方法。递归下降算法是一种易于处理理解的解析算法：用函数内部的控制流来展现文法规则。每条文法规则会转换成解析器中的一个函数，每个BNF运算符到控制流的转换过程都有清晰的模式可循。
* **解析器组合子**-将每条规则转换成一个对象，再把对象组合成一个与文法对应的结构。仍然需要递归下降语法解析器的元素，但这些元素会包装成组合子对象，只要将它们组合起来就可以了。
* **解析器生成器**-可以把BNF当作DSL来操作：用这种DSL来编写文法，解析器生成器负责生成解析器。

解析器生成器是最精密的途径：以BNF作为DSL，会让语言更容易理解和维护，因为其语法已经清晰地定义出来，并且能够自动地绑到解析器上。不过这些工具的缺点是需要花时间学习。

ANTLR解析器生成器是一个成熟的，广泛适用的开源工具，它是一个强大的递归下降语法解析器。

### 5.2 输出生成策略

当想要解析某些输入时，必须知道：要使用解析的结果干什么----输出应该是什么样子的？大部分时候，解析过程的输出应该是一个“语义模型”，随后就可以直接解释它或者将其用作代码生成的输入。

* **嵌入式语法翻译**-一个步骤，直接把方法调用放入解析器，从而在解析过程中生成语义模型
* **树的构建**-两个步骤，首先解析输入文本，构造出一棵包含文本结构的语法树，同时用符号表处理语法树各个部分之间的交叉引用；然后执行第二阶段，遍历语法树，生成语义模型。
* **内嵌解释器**-在解析过程中执行解释，并直接输出最终结果。内嵌解释器的一个经典例子就是计算器：它接受算术表达式作为输入，将计算的结果作为输出。也就是说，内嵌解释器并不生成语义模型。

使用树的构建有一个很大的好处：它把整个解析任务分解成两个更简单的任务。当识别输入文本时，只需要关注如何构建语法树----实际上，很多解析器生成器提供了用于树构建的DSL。可以让这部分工作变得更加简单。遍历语法树组装语义模型则是一个常规的编程练习，随时检查整棵树来判断应该做什么。比如XML代码，嵌入式语言翻译类似于SAX，而树的构建则类似于DOM。

即使不生成语义模型，也可以使用嵌入式语法翻译和树的构建----其实在使用代码生成时，这种情况相当常见，大部分解析器生成器的例子都会这样做。

### 5.3 解析中的概念

“语法指导翻译”通常分为两个阶段：**词法分析**(扫描或标记/词素解释)和**语法分析**。词法分析阶段将输入文本转化为一串**标记(token)**，这是一种数据类型，包含两个主要属性：类型和内容。语法分析器随后会根据文法规则把这一串标记组织成一棵语法树。

一般的词法分析会将空白符去掉，解析器根本不会看见它们，当然有时空白字符会用作语法的一部分，例如用换行符作为语句分隔符，或者像Python那样用缩进来标识语法结构。

通常某种结构的文法不只一种，多种文法能够识别同一语言的情况很常见。又很多原因得到不同的文法：不同的**解析器生成器**使用不同的文法，这些文法的语法和语义都不同。即便对于同一个解析器生成器，当采用不同的方式构建文法规则时，也会得到不同的文法。和其他任何代码一样，也要重构文法，使其更容易理解。最终的产出代码也会影响构建文法的方式。

#### 正则文法、上下文无关文法、上下文相关文法

所有正则文法都是上下文无关的，所有上下文无关文法都是上下文相关的。正则文法很重要，因为可以用一个有限状态机来处理，因为正则表达式就是有限状态机，所以正则语言可以用正则表达式来解析。

就计算机语言而论，正则文法有一个大问题：其无法处理嵌套元素。正则语言可以解析`1+2*3+4`这样的表达式，但不能解析`1+(2*(3+4))`。正则文法“不能计数”----对解析器而言，不能用有限状态机解析带有嵌套块的语言。

要处理起嵌套块，就得向上走一步：上下文无关文法。因为一个上下文无关的文法却会给文法添加层级上下文，使其能够“计数”。上下文无关文法可以用**下推机(push-down machine)**----带有栈的有限状态机来实现。大部分语言额解析器都使用上下文无关文法，大部分“解析器生成器”也使用它。“递归下降语法解析器”和“解析器组合子”都会生成下推机。于是，大部分现代编程语言都是用上下文无关文法来解析的。

但是上下文无关文法并不能处理想要的所有语法规则。一个常见异常情况是这样一条规则：变量务必先声明再使用。问题在于，当使用变量时，变量声明常出现在当前所在程序分支所在层次结构之外。尽管上下文无关文法可以保存层次结构上下文，但也没有足够的上下文来处理这种情况----因此还需要**符号表**。

**解析式表达文法(Parsing Expression Grammer, PEG)**-使用一种新的文法格式，可以处理大部分上下文无关的情景和一些上下文相关的情景。PEG解释器不倾向于使用单独的词法分析，并且大部分情况下，PEG似乎比上下文无关文法更好用。

#### 自顶向下解析和自底向上解析

编写解析器的办法有很多种，所以出现了“解析器生成器”。其中最大的一个区别是：解析器是自顶向下的还是自底向上的。

自顶向下解析器首先处理文法中最高级别的规则，根据它确定如何尝试以及匹配，自底向上正好相反。自顶向下解析器也称为LL解析器，自底向上解析器称为LR解析器。自底向上解析有时还称为“移进-规约解析”，因为移进-规约方法是最常见的自底向上解析实现方式。

自底向上解析器比自顶向下解析器要难以编写和理解。Yacc系列可能是最有名的解析器生成器系列，它就是一个自底向上(LALR)解析器。

递归下降算法是一个自顶向下的解析算法，自然“递归下降语法解析器”也是一个自顶向下的解析器，解析器组合子也是。ANTLR解析器生成器也是基于递归下降算法的。

自顶向下解析器的缺点是，无法处理**左递归(left recursion)**。下列规则：

```bnf
expr : expr '+' expr
```

类似这样的规则会导致解析器在尝试匹配`expr`时陷入无穷递归。通过提取左因子就可以消除左递归，做法比较简单，但最终得到的文法就会比较难懂。

### 5.4 混入另一种语言

面对一种外部DSL，一个最大的风险是：它可能在不经意间演变成了一种通用语言。即便没有那么极端，一种DSL也很容易变得过于复杂，尤其是在其中考虑很多特殊情况时，这些情况很少出现，但往往需要特别处理。

使用外加代码的一个问题是：需要不同的方式对外加代码进行标记划分，因此需要某种“可变分词方式”。最简单的可变分词方式方法是，用某种清晰的分隔符将嵌入代码引用起来，使其能够识别为单个标记从而以单一字符串的形式经过解析。

可变分词方式不仅可以处理外加代码。在不同的解析上下文中，也许希望把语言的关键字解释为一个名称的一个部分，可以用圆括号来完成这个技巧，但可变分词方式的其他实现方式引入的语法噪音更少。

### 5.5 XML DSL

很多常见的XML配置文件实际上就是DSL。当然并非所有的配置文件都是DSL。“属性列表”和DSL是不同的。属性列表只是一份简单的“键-值对”列表，可能再加上分类。属性列表没有多少语法结构----完全不具备DSL那些神奇的语言性。另一方面，很多配置文件确实具有像DSL一样的语言性。如果是用XML来实现，就把它们看作外部DSL。XML不是编程语言：它是一种没有语义的语法结构。因此，需要首先把XML代码解读成标记，然后再处理，而不能直接解释、执行它。DOM处理本质上就是“树的构建”，SAX则是“嵌入式语法翻译”。XML就是DSL的承载语法，跟内部DSL的宿主语言提供的承载语法是一样的。

以XML作为承载语法，它引入了太多的语法噪音----太多的尖括号，引号和斜线，每个嵌套元素都必须有开始标签和结束标签。结果有太多的字符是在为语法结构----而非真正的内容----服务，代码变得难以理解----而“容易理解”正是DSL的全部意义所在。

自定义的外部DSL也带来了一个烦恼：它们处理引用，字符转义之类的事情的方式总是难以统一。

除了生成树或者事件的解析器之外，还有一些XML绑定接口，可以很轻松地将XML数据翻译成对象和字段。如果使用解析器生成器，就可以在文法中定义XML结构所能提供的很多检查功能。但很少有工具能使用文法输入。

JSON和YAML相比于XML语法噪音小的多，但是这些语言很大程度上是针对结构化数据的，因此缺乏真正连贯的语言所需的灵活性。DSL与数据序列化不同，连贯性对于DSL的易读性至关重要，而数据序列化格式为了它自己的主要用途做了太多的妥协。

## 第6章 内部DSL vs 外部DSL

### 6.1 学习曲线

内部DSL的学习成本更低，它们看起来只是一些更加好用时髦的API，并且是建立在一种熟悉的语言之上。而学习外部DSL，则需要学习解析器，文法和“解析器”生成器等。

### 6.2 创建成本

构建DSL的成本重要的是区分模型构建的成本和基于模型构建DSL层的成本。在许多情况下，模型与DSL是相关联的，但模型有其自身的考量。

就内部DSL而言，于模型之上构建一层“表达式生成器”就需要额外的付出。在外部DSL中，相应的成本在于解析器的创建，一旦掌握了“语法指导翻译”，编写文法和翻译代码实际上是相当快的。开发解析器的成本同构建表达式生成器层是相似的。

### 6.3 程序员的熟悉度

外部DSL其实相当简单，如果能够遵循常用编程语言的语法规范，那么会让它的接受读更高。

有时，会用到一些更复杂的技术，比如“类符号表”，它需要工具的支持，但采用这种方式，可以继续享受IDE的优势。然而，使用外部DSL，除了最基本的文本编辑功能外，可能什么都没有。支持语法高亮的功能并不困难，大多数编辑器都配置了这样的功能，但是像类型感知的自动补全这类功能就有些困难。

### 6.4 与领域专家沟通

内部DSL通常会和宿主语言的语法绑定在一起，导致其在表达自由度上有限受限，并且会有一些语法噪音。但领域专家不一样，表达受限的程度以及语法噪音同语言相关，有些语言会比其他语言更加适合作为DSL。就算最好的内部DSL，也无法提供和外部DSL一样的语法灵活度。

### 6.5 与宿主语言混合

内部DSL本质上只是一些连贯方法的使用约定，DSL与宿主语言之间边界很模糊，存在利弊，取决于如何使用。

好处在于，当内部DSL缺乏某种构造时，可以很方便地使用宿主语言。这样一来，如果要在DSL中使用算数表达式，无须在DSL里面为此创建专门的构造，使用宿主语言的特性即可。如果要在DSL基础上构建抽象，直接使用宿主语言的抽象功能就好了。

外部DSL无法和宿主语言混合使用，但可以把宿主语言作为“外加代码”嵌入DSL脚本。同样，DSL也可以作为字符串嵌入通用语言，就像嵌入正则表达式和SQL一样。

### 6.6 强边界

宿主语言代码和DSL代码进行混合并不总是带来好处，只有当DSL的用户非常熟悉宿主语言时，这才行的通。DSL的好处就是其能力范围是有限的。这种限制使其易于理解，屏蔽bug。如果DSL有很强的边界，就会限制要测试的东西。DSL中的定价规则不会给集成服务器发送任意的消息，也无法改变订单处理流程。

### 6.7 运行时配置

XML DSL之所以流行，是因为改变代码执行上下文的时间从编译时到运行时。外部DSL可以帮助做到不重新编译就可改变系统行为，在运行时解析，翻译成“语义模型”，然后执行模型。

一种方式是将解释型语言和编译型语言结合使用，然后，用解释型语言编写内部DSL。

### 6.8 趋于平庸

Ant是一种描述Java构建的语言：它是一种使用XML语法的外部结构。相比于扩展一门语言，可以引入另一种语言处理特殊以及复杂的情况。可以在基础的DSL之上再设计另一种语言，其输出就是基础的DSL。这种技术非常有用，有了它，就能用那种缺乏抽象构建能力的语言构建抽象。

### 6.9 组合多种DSL

DSL应该是小巧的，能力受限的。所以，要完成实际工作，就要将DSL同一种或多种通用语言集成起来。也可以将多种DSL组合起来。

对于内部DSL而言，组合DSL就像通宿主语言混合一样容易。还可以用宿主语言的抽象特性帮助完成组合的工作。对于外部DSL来说，这种组合要困难一些。用“语法指导翻译”进行组合，要为不同的语言编写独立的文法，还要能把这些文法组合在一起。大多数“解析器生成器”都不具备这样的能力，这也是只关注通用语言的另一个后果。

### 6.10 总结

无论是内部DSL还是外部DSL，其各有利弊，同时在两个方向进行尝试，所需的投入并不如想象的高。如果使用“语义模型”，在其上构建多种DSL并不困难，无论是内部还是外部。

## 第7章 其他计算模型概述

主流的编程语言大都遵循命令式计算模型。命令式模型把整个计算过程定义为一系列的步骤，如果条件成立再做其他的事情。条件和循环会改变步骤的执行顺序，多个步骤可以组合成为函数。面向对象语言提供了数据与操作之间的绑定，以及多态----但基础仍然是命令式模型。

命令式的展现方式有一个潜在的严重缺陷，它会丢掉一些有用的机会。决策表就有这样一个好处，可以检查它，确保没有遗漏或者重复某些排列项。使用命令式代码还有一种实现方式，创建决策表抽象，然后根据这里的特定情况进行配置。

### 7.1 几种计算模型

#### 7.1.1 决策表

决策表是一种很简单的计算模型，也很适合DSL表达。由于决策表就是一张表格，因此也很适合在电子表格中编辑。

#### 7.1.2 产生式规则系统

**产生式规则系统**是一种对逻辑进行建模的常用概念：它将逻辑分解成多条规则，每条规则由条件和由此引发的行为两部分组成。如果是采用命令式代码，每条规则都可以用类似于if-then语句的风格表述:

```dsl
if
    passenger.frequentFlier
then
    passenger.priorityHandling = true;
if
    mileage > 25000
then
    passenger.frequentFilter = true;
```

有了产生式规则系统，就可以用“条件+行为”的形式定义规则，至于规则的执行和规则之间的关联则交给背后的系统。

这种性质(触发某些规则会改变另一些规则是否被触发)称为**级联(chaining)**，这是产生式规则系统的一个重要性质。有了级联，就可以单独编写规则，无须考虑在更大范围内造成的影响，让系统自己找到结果。

产生式规则系统依赖大量隐式的逻辑，经常会做出意想不到的事情。对于其他计算模型而言，隐式行为造成的问题相当常见。当实现其他计算模型时，有必要加入某种跟踪机制，以便看出模型执行过程中到底发生了什么。对于产生式规则系统而言，就意味着需要记录触发了哪些规则，必要时可以很容易提供这些记录。

级联无疑是产生式规则系统的重要组成部分，但它并非不可或缺。不支持级联的产生式规则系统有时也很有用，例如，一个很好的例子是一组校验规则。当校验时，通常只提供一组校验条件，其中校验未通过的行为就是“报错”。尽管不需要级联，不过把整个校验行为看做一组彼此独立的规则仍然有有助于理清思路。

当使用产生式规则系统时，每次只关注一条规则的行为；而使用决策表时，则要同时关注整张表。这种视角的变化使这两个模型成为不同的思维工具。

#### 7.1.3 状态机

状态机把对象的行为划分成一组状态，用事件触发行为，根据对象所处的状态，事件会使对象从当前状态转换到另一个状态。

状态机的核心元素包括状态、事件和转换，但在这个基本结构之上还有很多变化。特别是，状态机初始化的行为有着诸多变化。状态机很常用，因为很多系统都可以看做“以变动的状态响应各种事件”。

#### 7.1.4 依赖网络

如果有一系列耗费大量计算资源并且彼此依赖的任务需要管理，依赖网络就是很好的选择。

#### 7.1.5 选择模型

所有的模型选择最终都归结于一种感觉：这种计算模型是否符合思考这个问题的方式。而判断“是否符合”的最好办法就是“试一下”：先在纸上尝试用简单的文字和图表来描述行为；如果某个模型似乎能通过这个简单的纸上测试，那就值得把它构建出来。

## 第8章 代码生成

通常来说，直接执行语义模型是最容易做的事，然而还有很多情况，无法这样做。比如，DSL的逻辑只能在有很大差异的环境中执行，在那种环境里，语义模型或解析器都极难构建，甚至无法构建。通过代码生成，几乎可以在任何环境下运行DSL指定的行为。

使用代码生成，要考虑两种不同的环境：DSL处理器和目标环境。DSL处理器都是解析器、语义模型和代码生成器之所在，应该是便于开发的。目标环境则是为生成代码及其周边准备的。使用代码生成的意义在于，将目标环境通DSL处理器分离开来，因为在目标环境下，可能无法构建DSL处理器。

### 8.1 选择生成什么

可用的代码生成风格有两种：“基于模型的代码生成”和“无视模型的代码生成”。二者的差别在于，在目标环境里，“语义模型”是否显式地表现出来。实现状态机有两种经典方案，分别是嵌套条件和状态表。看一个非常简单的状态模型。

这里有两个条件测试，一个嵌套在另一个里面。外部条件查看状态机的当前状态，内部条件根据接收到的事件进行切换。这就是无视模型的代码生成，因为状态机的逻辑嵌套在语言的控制流中----语义模型没有显式地表现出来。

如果用基于模型的代码生成，就要在生成代码中表现出语义模型。这个模型不必与DSL处理器使用的完全吻合，但它会表现出某种形式的数据。

通过将语义模型表现在生成代码中，通用框架代码和专用配置代码分离开来，这通开篇中谈及的划分是一样的。基于模型的代码生成保留了通用/专用的区分，而无视模型的代码生成规则把语义模型放入控制流中，将二者混在一起。

如果采用基于模型的代码生成，唯一要生成的就是专用的配置代码。完全可以在目标环境中构建出基本的状态机，在那里进行测试。而采用无视模型的代码生成，就不得不生成更多的代码。固然可以将一些代码提取出来放到程序库函数里面，省去生成的过程，但大多数关键行为依然要生成。

采用基于模型的代码生成会容易许多，生成的代码也会很简单。虽然依然要构建通用的部分，但是，鉴于这个部分可以独立于代码生成系统运行和测试，实现起来通常容易。因此，尽可能采用基于模型的代码生成。

### 8.2 如何生成

有两种文本输出的风格可以遵循

* 基于转换器的代码生成
* 模版化的生成器

采用基于转换器的代码生成的话，要编写代码，读取“语义模型”，生成目标源码的语句。如果用的是模版化的生成器，会写出一个示例的输出文件。输出文件会有特定状态机专有的一些东西，这样就可以调用语义模型生成相应的代码。

模版化的生成器是由输出的结构驱动的，而基于转换器的代码则是由输入、输出或者二者共同驱动的。两种代码生成方式用起来都不错，要在二者中选择，最好每个都试一下，选择最适合自己的那个。模版化的生成器适用于输出里有大量静态代码，只有少量静态部分呢的情况----而且，可以查看模版文件，了解生成代码会是什么样子。如果用到**无视模型的代码生成**，很可能采用模版化的生成器。否则更倾向于基于转换器的代码生成。

### 8.3 混合生成代码和手写代码

有时，在目标环境下执行的所有代码都可以生成，但更常见的情况是，需要混合生成代码和手写代码。有一些需要遵循的通用规则：

* 不要修改生成代码
* 将生成代码和手写代码严格分开

根据DSL生成代码，其重点在于DSL应该成为行为的权威来源。将文件清楚地分为“全生成”或是“全手写”。生成代码是不会提交到源码库里面的，因为这些代码都是可以在构建过程中重新生成的。

在一个过程式系统中，代码是以函数的方式组织在文件里面的，因此做到这点很容易。而面向对象则不然，类混合了数据和行为，分开二者要相对复杂一些。处理这种情况最简单的方法是，把这个类分成多个文件。根据需要，分成生成代码和手写代码。

这个问题有一个好的解决方案，就是**代沟**，用继承分离生成代码和手写代码。按照其基本形式，生成一个超类，然后手写一个子类，在子类里增强或者重写生成的行为。这样就用文件生成代码和手写代码分开了，在一个类里结合了两种风格，具有极大的灵活性。

### 8.4 生成可读的代码

可以让生成代码如手写代码那样好----拥有清晰的变量名，良好的结构，以及遵循大多数的良好习惯。

### 8.5 解析之前的代码生成

在某些情况下，DSL脚本要集成一些外部信息。确保DSL脚本里用的符号与企业数据库中的一致。可以用**代码生成**生成脚本编写所需的信息。这样，在组装**语义模型**时，就可以利用这些信息进行检查，有时，这些信息在源码中也很有用，对于代码导航以及静态类型尤其如此。

## 第9章 语言工作台

**语言工作台**是这样一种工具，可以帮助打造DSL，并为这种DSL提供现代IDE风格的工具支持。其基本想法就是，这类工具不仅要提供一个创建DSL的IDE，还要为编辑这些DSL构建新的IDE。

### 9.1 语言工作台之要素

各种语言工作台都可以从以下三个方面定义DSL环境：

* **语义模型**模式一般用模型定义出语义模型的数据结构以及静态语意
* DSL编辑环境为人们编写DSL脚本定义丰富的编辑体验，可能是直接编辑源码，也可能是惊醒投射编辑。
* 语义模型行为定义出构建好语义模型后，DSL脚本能够做些什么，通常采用的技术是代码生成。

语言工作台以语义模型为系统核心，提供工具辅助模型定义。语言工作台并不使用程序设计语言定义语义模型，而采用一种特殊的元模型建模结构，这种结构要用到运行时工具处理模型。正是利用了元模型建模结构，语言工作台才能够提供更高级的工具支持。

这样一来，模式和行为得以分离。语义模型模式本质上是一种数据模型，没有任何行为。语义模型行为来自数据结构之外，大部分源自代码生成。有些工具提供语义模型，就可以根据此构造解释器，不过代码生成依旧是运行语义模型最常用的方式。

语言工作台最有趣也是最重要的一个特征是它们的编辑环境。这也是语言工作台给软件开发带来的最重要的改变，为组装和操作语义模型提供了广泛的工具支持。

### 9.2 模式定义语言和元模型

语言工作台所用的模型文本和语义模型有着显著的差异。语言工作台提供了一个环境，用于定义模型的模式，也就是数据结构，通常会用到一种专用的DSL----模式定义语言。至于行为语义，则是要单独定义的，一般用代码生成来做。

**元模型**只是另一种语义模型，容易定义一个DSL组装这个模型，就像为基本模型所做的一样----这样的DSL，称为模式定义语言。模式定义语言其实仅仅是某种形式的数据模型，能够定义实体及相互关系而已。

当手动构建DSL时，创建元模型的意义不大。在大多数情况下，使用熟悉的宿主语言的结构定义能力是最好的选择。因为所用的是熟悉的语言构造，所以用起来会比较容易。

元模型也只是一种模型而已。同其他的模型一样，它也要有自己的模式定义其结构。用语言工作台自身的建模工具处理模式定义系统自身，而创建模型的工具就是编写DSL脚本的工具。

这种方式称为**自举工作台**，许多语言工作台采用的都是这种方式。通常来说，自举工作台更值得信赖，既然这个建模工具都能定义自己，对工作而言足够。

模式定义语言和文法的差别：文法定义某种（文本）语言的具体语法，而模式定义语言定义语义模型模式的结构。所以，文法包含需要用于描述输入语言的东西，而模式定义语言则独立于任何“用于组装语义模型”的DSL。文法还隐含解析树的结构，以及树的构建规则，可以定义语法树的结构。

当定义模式时，要考虑的数据结构：类和字段。模式定义大部分考虑的是，用于存储语义模型元素的逻辑数据结构。还有一个要素需要考虑：模式的结构性约束。这些约束用于定义什么是最有效的语义模型，其等价于契约式设计中的**不变式(invariant)**。

结构性约束通常指的是不是那些由数据结构带来的约束----可以保存数据，但也不管用。数据结构可能会有些附加的约束。约束的复杂度是任意的，甚至会牵扯到多个字段和对象。

模式定义语言都有一些表现结构性约束的方式，也许简单到仅仅允许设定属性的取值范围，也许复杂到用一种通用语言表现任何约束。结构性约束往往存在一个限制，它无法改变语义模型，只能查询。按照这种方式，这些约束就是一个没有级联的“产生式规则系统”

### 9.3 源码编辑和投射编辑

基于源码的编辑系统用一种可编辑的表现形式定义程序，通过工具将其带入运行时系统，然而，这种表现形式与工具无关。在实际中，这种表现形式是基于文本的，这意味着，程序可以由任何文本编辑工具读取和编辑。这个文本就是程序的源码，将它交给编辑器或者解释器，就可以转为可执行的格式，但是对于程序员来说，源码才是编辑和保存的主要表现形式。

采用投射编辑系统，程序的核心表现形式则是一种与所用工具相关的格式。这个格式就是工具使用的“语义模型”的一种持久化表现形式。当编辑程序时，要先启动工具的编辑环境，然后，工作将语义模型投射为一个可编辑的形式。

相比于基于文本的方式，投射编辑带来的好处是可以通过不同的表现形式进行编辑。状态机最好用图形化的方式展现，采用投射编辑器，状态机就可以将状态机渲染成一张图，直接以图的方式编辑。而采用源码，只能编辑文本。

这样的投射可以使得更好地控制编辑体验，输入正确信息，避免犯错。调用一个对象的方法，文本投射只显示这个类合法的方法，也只能输入有效的方法名。编辑器与程序之间就有了一个更紧密的反馈，编辑器也可以给予程序员更多的帮助。

还可以使用多个投射，可以同时作为主要投射的备选方案。可以根据喜好选择最适合于查看信息的投射方式。比如一个类的超类可以显示为表格的一个字段，在编辑环境的另一个面板中，则显示为类层次结构中的节点。编辑其中的任何一个都会更新核心模型，随即也会更新所有的投射。

这些表现形式不过是底层模型的投射而已，所以，鼓励对模型进行语义转换。如果重命名方法，最好体现在模型上，而非其文本表现形式上。从语义层面上看，许多变化都可以看做是对语义模型的操作，而非文本操作。这一点对于安全和有效的重构格外有帮助。

源文件还有一些实用上的优势，在某些场景下通过投射和截屏来解释则要麻烦得多。使用一些文本处理工具，某些转换可以很好地自动化，如果投射系统不支持所需的转换，这一点就显得特别有用。投射系统只接收有效输入，这一点固然很好，但有时当思考解决方案时，可能要键入一些无法立即起作用的东西作为临时

源码扮演两种角色：编辑形式和存储形式。编译器会将这种表现形式转换为可执行的形式。可以在机器上运行的形式。对于解释器语言来说，源码也就是可执行形式。

在某个时刻，比如编译期间，会生成某种抽象的表现形式，这纯粹是一种面向计算机的构造，只是为了使程序处理起来更加容易。现代IDE也会生成一种抽象的表现形式来辅助编辑。也许会有多种抽象的表现形式：IDE用于编辑的表现形式可能不同于编译器所用的语法树。现代编译器也会为不同的目的创建多种抽象表现形式，比如，为了某些目的的创建的是语法树，而为其他目的创建的是调用图。

使用投射性编辑，表现形式可以有不同的安排。核心表现形式是工具所用的**语义模型**。这种表现形式可以投射为多种编辑形式。模型通过一个单独的存储表现形式进行保存。存储表现形式也许在某个层面上是可读的，比如，以XML进行序列化。

### 9.4 说明性编程

投射编辑最引人入胜的一个发展就是，它堆成为说明性编程的支持。在常规程序设计中，最关注的是程序，是对增养的东西应该工作的一般性描述。说它是一般性，因为它只是一段文本，描述一般性的情况，对于不同的输入产生不同的结果。

相比于在解释器里运行代码片段的能力，说明性编程是一个更宽泛的概念。解释代码片段可以探索执行过程，但它并不会把示例置于重要的位置。说明性编程技术将说明推到了编辑体验的前台，程序则退居幕后，只在探讨说明的某个部分时，才会出现。

### 9.5 工具之旅

* **Intenional Workbench**
* **Meta-Programming System(MPS)**
* **Xtext**
* **SQL Server Modeling**

### 9.6 语言工作台和CASE工具

**CASE(Computer-Aided Software Engineering)**计算机辅助软件工程鞠躬可以使用各种图形符号表现软件设计，然后生成软件。特征：以模型为核心，使用元模型定义，图形投射编辑。

语言工作台和CASE工具的差异：CASE工具无法定义自己的语言。

# 第二部分

## 第10章 各种DSL

### 10.1 Graphviz

Graphviz可以生成一个图表，使用DOT语言编写，图表中有`节点`和`弧线`。节点用node关键字声明，但不一定要声明出来。弧用`->`操作符声明。在方括号里列出的是，节点和弧的属性。

### 10.2 JMock

JMock是Mock Object的一个Java程序库。其作者曾经写过多个mock对象程序库，关于如何用内部DSL定义mock上的预期。

Mock对象是用来做测试的。测试从声明预期开始，预期就是测试过程中会调用的对象方法。然后，把mock对象插入要测试的实际对象里，与之交互。随后，mock对象会汇报它是否接收到了正确的方法调用。

JMock使用了渐进式接口。采用这种方式，with只能出现在method之后，这样的，IDE的自动补全就可以帮助按照正确的方式写出预期。JMock采用**表达式生成器**处理DSL调用，并将其翻译称mock和预期的**语义模型**

### 10.3 CSS

CSS在声明式计算模型方面是一个好例子，这种计算模型不同于命令式模型。只要声明HTML元素的匹配规则即可。
 
SASS是另一种类似于CSS的DSL，生成CSS作为输出。SASS提供了数学运算和变量。在CSS块结构上加入语法上的换行和缩进。在一种DSL之上构建另外一种DSL，提供底层DSL缺失的抽象。上层的DSL应该类似于底层的DSL，上层DSL的用户也都能够理解底层的DSL。

### 10.4 HQL

Hibernate是一个广泛应用的对象-关系映射系统，可以将Java类映射到关系数据库的表上。HQL(Hibernate查询语言)提供了这样一种能力，在Java类上以类似于SQL的方式编写查询语句，映射到真实数据库的SQL查询上。

```hql
select person from Person person, Calendar calendar
where calander.holidays['national day'] = person.birthday
    and person.nationality.calendar = calendar
```

HQL处理的本质是，将HQL查询翻译成SQL查询：

* 用**语法指导翻译**和**树的构建**将HQL输入文本转换为HQL的抽象语法树
* 把HQL的AST转换为SQL的AST
* 代码生成器根据SQL的AST生成SQL

所有这些情况都用到了ANTLR。除了可以用标记流作为ANTLR语法分析器的输入，还可以用AST作为ANTLR的输入。ANTLR的树构建语法HQL和SQL的AST时都有用到。

这个转换的路径`输入文本-输入AST->输出AST->输出文本->输出文本`，对于源码到源码转换很常用。

### 10.5 XAML

XAML是C# WPF等UI布局的一种DSL，XAML就是XML文件，用来布局对象结构：使用WPF，可以布局屏幕。

```xaml
<?xml version="1.0" encoding="UTF-8"?>
<ContentView xmlns="http://xamarin.com/schemas/2014/forms"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml" 
    xmlns:binders="clr-namespace:DuGu.XFLib.Binders"
    xmlns:duguctrls="clr-namespace:DuGu.XFLib.Controls"
    xmlns:carView="clr-namespace:CarouselView.FormsPlugin.Abstractions;assembly=CarouselView.FormsPlugin.Abstractions"
    xmlns:ffimg="clr-namespace:FFImageLoading.Forms;assembly=FFImageLoading.Forms"
    xmlns:fftrans="clr-namespace:FFImageLoading.Transformations;assembly=FFImageLoading.Transformations"
    x:Class="QZhiHuFind.Views.DailyView"
    BackgroundColor="#E2DFED">
    <ContentView.Resources>
        <ResourceDictionary>
            <Style TargetType="ffimg:CachedImage">
                <Setter Property="DownsampleToViewSize" Value="true"/>
                <Setter Property="CacheDuration" Value="7" />
                <Setter Property="DownsampleUseDipUnits" Value="true" />
                <Setter Property="ErrorPlaceholder" Value="ic_placeholder.jpg" />
                <Setter Property="LoadingPlaceholder" Value="ic_placeholder.jpg" />
            </Style>
        </ResourceDictionary>
    </ContentView.Resources>
	<ListView
        x:Name="ItemsListView"
        binders:ListViewBinder.ItemTappedCommand="{Binding ItemSelectedCommand}"
        binders:ListViewBinder.LoadMoreCmd="{Binding LoadMoreCommand}"
        BackgroundColor="#E2DFED"
        CachingStrategy="RecycleElement"
        HasUnevenRows="True"
        IsPullToRefreshEnabled="True"
        IsRefreshing="{Binding IsBusy, Mode=TwoWay}"
        ItemsSource="{Binding Items}"
        RefreshCommand="{Binding RefreshCommand}"
        SeparatorVisibility="None"
        VerticalOptions="FillAndExpand">
        <ListView.Header>
...
...
```

在屏幕布局方面，这种做法HTML非常类似。

从逻辑上说，XAML文档定义了一个C#类，这里确实会用到代码生成。生成的代码是**部分类(C#语言特性)**。

### 10.6 FIT

FIT是测试框架，其目标是，以领域专家可以理解的方式，描述测试场景。随后的许多工具扩展了这个基本的想法，尤其是Fitnesse。

如果把FIT当作一种DSL，它的很多方面都很有趣：FIT的核心是提供一种记法，让非程序员也能够很容易地用表格形式指定示例值。所以，FIT程序就是一堆表格，典型的做法是嵌套在HTML页面里。表格之间可以放置其他HTML元素，这些元素都会当做注释。这样，领域专家就可以用平实的叙述方式描述他们想要的东西，表格就提供了可处理的部分。

FIT表格可以采用不同的形式，其本质就是一种简单的命令式语言。它简单到没有条件，没有循环，只有一堆动词。

每个表格同一个夹具相关联，将动词翻译成系统行为。check这个动词比较特殊，只是用来执行比较的。当运行表格时，会产生一个HTML输出，同输入页面完全一样，只会根据比较匹配与否，将check行标上颜色，或绿或红。

### 10.7 Make等

构建软件是需要若干步的。所以，在UNIX早期，Make工具提供了一个组织构建的平台。Make程序由若干目标组成，这些目标通过依赖联系在一起。

Make这样的构建语言不在于其计算模型，因为它们需要将DSL同常规的程序设计语言混合在一起。除了指定目标及其依赖关系外，还需要关心每个目标如何构建----这通常会采用命令式的方式。使用Make，这就意味着要用到shell脚本命令。

而标准的Java构建语言是Ant，它也是一种外部DSL，使用XML作为承载语法。能够避免Make由制表符和空格在语法缩进带来的大麻烦。由通用脚本或其他系统(Maven)生成Ant脚本。

## 第11章 语义模型

### 11.1 工作原理

在DSL的上下文中，语义模型是指一种表现形式，比如，内存对象模型，以表示DSL所描述的对象。如果DSL描述的是状态机，那么语义模型可能就是由状态、事件等类组成的对象模型。定义了特定状态和事件的DSL脚本，对应组装了一个模型，这个模型是一个符合其模式的特定实例，其事件就是DSL脚本里声明的事件。所以，语义模型就是由DSL组装的程序库或框架。

**之前提到的语义模型都是内存中的对象模型**，但并不是它们的唯一表现形式。可以用数据结构，用函数操作数据，表现一些状态机的行为。模型也不必存在于内存中：DSL也可以组装保存在关系数据库中的模型。

语义模型应该根据DSL的意图设计。对状态机而言，使用“状态机”模型就是要控制系统的行为。事实上，语义模型应该能够脱离DSL单独使用，应该能够通过命令-查询接口构建出来，这就可以保证语义模型完整地描述了主题领域的所有语义，可以独立地测试它和解析器。

语义模型同语法树有所不同，因为它们的目的不同。语法树对应DSL脚本的结构。虽然抽象语法树可能经过简化，或者重新组织输入数据，但是，其基本上遵循相同的形式。语义模型则更多的是用DSL脚本信息能够做些什么，因此会采用不同的结构，一般不是树结构。在某些场合下，对于DSL来说，AST也是一种有效的语义模型，但是只是特例，而非通则。

DSL和通用语言的一个差别：通用语言一般不涉及语义模型，语法树就够了，可以根据它进行代码生成，所以，再有个不同的语义模型也没什么必要。有时也会用到语义模型；比如，如果要做优化，调用图的表现形式很有用。这样的模型称为中间形式----代码生成之前的中间步骤。

语义模型经常先于DSL产生。另一种情况是DSL和语义模型要一起构建。语义模型可以包含执行自身的代码（解释风格），也可以作为代码生成的基础（编译风格）。即便用的是代码生成，提供解释方式也有助于DSL的测试和调试。

将验证逻辑放入语义模型中是最合适的，因为它包含验证所需的所有信息和结构。在解释执行或代码生成前，执行验证尤其有帮助。

组合型DSL以文本形式描述某种组合结构，一个例子是用XAML描述UI布局----语义模型的主要形式是各种元素如何组合在一起。状态机的例子更多的是一个计算型DSL，其产生的语义模型更像代码，而不是数据。

计算型DSL的语义模型用于驱动计算，通常用的是其他计算模型----而不是常见的命令式模型。这样的语义模型通常都是“适应性模型”。采用计算型DSL可以做很多事情，但是用起来没那么容易。

可以将语义模型想象称具有两组不同接口：**操作接口(operational intreface)**----客户端操作时使用组装好的模型所用的接口：**组装接口(population interface)**----DSL用来创建模型中类实例的接口。

* 操作接口应该假设语义模型已经创建好，系统的其他部分都可以很好地利用它了。
* 组装接口只用于创建模型实例，可能只是由解析器使用，虽然尽可能将语义模型通解析器解耦，但为了组装语义模型，解析器显然会依赖它。尽管如此，通过构建清晰的接口，降低因修改语义模型的实现而修改解析器的几率。

### 11.2 使用场景

语义模型的优点：

* DSL的语义和解析可以分开测试
* 测试语义：可以直接组装语义模型，基于模型执行测试；
* 测试解析器：可以看其组装的语义模型是否正确。如果有多个解析器，比较组装出的语义模型，就可以知道产生的输出在语义上是否相等。
* 语义模型同时提高了解析和执行的灵活性。可以直接执行语义模型，也可以进行代码生成。
* 分离了对语义和解析的关注

对于算术表达式而言，即便是不立即解析，其生成的抽象语法树AST同语义模型的内容几乎一致。那么如果模型不比AST更丰富，就不值得创建单独的语义模型。

当执行代码生成时，一般不需要语义模型。解析器生成AST，代码生成使用AST。

在函数式编程中，语义模型并不属于DSL文化的一部分。

### 11.3 入门例子（Java）

大多数情况下，并不需要为同一个语义模型提供多个DSL，但是这却是这个例子的一个需求，语义模型让这个需求变得相对简单。

语义模型让这个需求变得相对简单。用到多个解析器，既有内部DSL的，也有外部DSL的。一种测试的方式是，确保它们组装出等价的语义模型。无须复制其他解析器的代码，也无须修改语义模型，可以很容易添加新的DSL和解析器。

除了用做执行和输出的基础外，语义模型还是做校验的好地方。比如，检查是否有状态是不可达的，或者无法推出的。再比如，状态和转换定义中的所有事件和命令都用到了。

## 第12章 符号表

很多语言都需要在代码的不同地方引用对象。如果有一种语言，可以定义任务的配置及其依赖关系，就需要一种方式，在一个任务定义中，引用其依赖的任务。

为了达到这个目的，要对每个任务都定义某种形式的符号；当处理DSL脚本时，这些符号都放到符号表中，通过这张表，可以由符号关联到持有完整信息的底层对象。

### 12.1 工作原理

符号表的根本目的，建立DSL脚本中表示对象的符号与符号所🈯指对象之间的映射关系。这样的映射关系非常适合用map这种数据结构表示，因此用map实现符号表是最常见的做法，符号作为键，“语义模型”对象作为值。

需要考虑的问题是，在符号表里，用做键的对象应该是何种类型。对于很多语言来说，字符串是最显而易见的选择，因为DSL文本就是字符串。

有些语言不实用字符串，因为它们支持“符号”(symbol)数据类型，从结构上说，符号和字符串很像----基本上看，符号就是字符序列----但通常来说，二者在行为有所不同。符号主要用来查找，符号类型一般就是这样设计的。所以，两个字符串“foo”和“foo”可能不是同一个对象，需要比较其内容才能断定其相等性。

性能是一个好的理由，让符号数据类型优于字符串。但对于小型DSL而言，差别就没多大了，首选符号数据类型还有个更大的理由，使用它能够更好地表达意图。通过将某些东西声明为符号，可以清晰地表示出用它做什么，这会让代码就更容易理解。

支持符号的语言都会为符号准备一种特殊的字面量语法。Ruby用`:aSymbol`，而Lisp把所有的纯标识符看做符号。这样做的话，符号会从内部DSL中凸显出来----这也是使用符号的又一重要理由。

符号表中的值可以是最终的模型对象，也可以是处于中间状态的**生成器(builder)**，使用模型对象，符号表就可以作为结果数据，在简单情况下，这种做法很好；而把生成器对象当做值放进去，则可以提供更大的灵活性，代价是要多做一些工作。

有些语言要引入不同类型的对象。在开篇的状态模型里，要识别状态、命令和事件。有多种对象要引用，意味着需要在一个map、多个map以及特殊类等方法之间进行抉择。

在符号表中采用一个map，意味着所有的查找都要在同一个map上完成。这么做的直接后果是，对于不同类型的对象，不能用相同的符号名，也就是说，事件不能与状态同名。也许，这个约束是有用的，可以降低DSL中的混淆。

使用一个map，每一类对象都有一个单独的map。比如，状态模型有三个表，分别对应事件、命令和状态。可以将其看作一张逻辑符号表，或者三张符号表。

使用特殊类，意味着用一个对象表示符号表，以不同的方法引用存储其中的不同类型的对象。有时，这种方式很有用，任何特定的符号处理行为都有一个合适的地方。

在某些情况下，对象在定义好之前就引用了----这称为前向引用。DSL并不会严格使用限制标识符之前一定要声明它，所以，前向引用是有意义的。要支持前向引用的话，当引用一个符号时，如果符号表里面没有对应的项。要这么做的话，除非模型对象异常灵活，否则，应该用生成器作为符号表中的值。

如果符号无须显式声明，需要非常小心拼写错误的符号，这是诸多令人泄气的错误之根源。有一些地方可以检测到拼错的符号，加入这种检查可以减少麻烦。正是由于这种问题的存在，因此最好所有的符号都以某种方式声明出来。

一些复杂的语言还支持嵌套作用域，符号可以只定义在整个程序的某个子集里。在通用语言里，这种做法很普遍，但在简单的DSL里却很少见。

**静态类型符号**-如果用C#或Java这样的静态类型语言实现内部DSL，可以用**哈希表(hashmap)**作为符号表，以字符串为键。这种DSL的语句可能是这样的：

```dsl
task("drinkCoffee").dependsOn("make_coffee", "wash");
```

这样使用字符串肯定能起作用，但是还有以下一些问题：

* 字符串引入了语法噪音，因为它们要加引号
* 编译器不能做类型检查。如果拼错任务名，只有到运行时才能发现。此外，如果要识别不同类型的对象，编译器无法分辨是否引用了错误的类型----只有到运行时才能发现。
* 即便用的是现代IDE，也无法给字符串提供自动补全。
* 自动重构无法很好地支持字符串。

### 12.2 使用场景

对于任何的语言处理而言，符号表都是通用的，预期是尽可能能用它。也有时候不见得要用。当使用**树的构建**时，从语法树上找到所需的东西。有时，搜索构建出的**语义模型**也可以达成一点。但是要用一些中间存储，就算并不真的需要。

### 12.3 以外部DSL实现的依赖网络（Java和ANTLR）

```
go_to_work -> drink_coffee dress
drink_coffee -> make_coffee wash
dress -> wash
```

`->`左边的任务依赖于右边的任务。“->”左边的任务依赖于右边的任务，用“嵌入式语法翻译”解析这段脚本。希望这些依赖可以按任意顺序编写，返回一个头列表，就是不为其他任务所依赖的任务。这是一个很好的例子，可以说明用符号表跟踪任务是值得的。

例子：一个loader类封装ANTLR解析器：它会从reader中获取输入：

```java
class TaskLoader...
    private Reader input;
    public TaskLoader(Reader input) {
        this.input = input;
    }
    public void run() {
        try {
            TaskersLexer lexer = new TaskLexer(new ANTLRReaderStream(input));
            TasksParser parser = new TasksParser(new CommonTokenStream(lexer));
            parser.helper = this;
            parser.network();
        }
        catch (IOException e) {
            throw new RuntimeException(e);
        }
        catch (RecognitionException e) {
            throw new RuntimeException(e);
        }
    }
```

loader类把自己作为“嵌入助手”插入生成的解析器中。其所做的一件事就是提供符号表，也就是一个任务名和任务的简单map：

```java
class TaskLoader {
    private Map<String, Task> tasks = new HashMap<>();
} 
```

这个DSL的文法极其简单，如下所示：

```dsl
grammer file...
    network : SEP ? dependency (SEP dependency) * SEP ?;
    dependenfy
        : lhs = ID '->' rhs += ID+
          {helper.recognizedDependenc($lhs, $rhs);}
        ;
```

这个助手还有一段处理可识别依赖关系的代码。为了将任务连接在一起，它会组装和使用符号表：

```java
class TaskLoader {
    public void recognizedDependency(Token consequent, List dependencies) {
        registerTask(consequent.getText());
        Task consequentTask = tasks.get(consequent.getText());
        for (Object o : dependencies) {
            String taskName = ((Token)o).getText();
            registerTask(taskName);
            consequentTask.addPrerequisite(tasks.get(taskName));
        }
    }

    private void registerTask(String name) {
        if (!tasks.containsKey(name)) {
            tasks.put(name, new Task(name));
        }
    }
}
```

一旦运行完loader，就可以通过它通过得到图的所有头。

```java
class TaskLoader {
    public List<Task> getResult() {
        for (Task t : tasks.values())
            if (!taskUsedAsPrerequisites().contains(t))
                result.add(t);
        return result;
    }

    public Set<Task> tasksUsedAsPrerequisites() {
        Set<Task> result = new HashSet<Task>();
        for (Task t : tasks.values())
            for (Task preReq : t.getPrerequisites())
                result.add(preReg);
        return result;
    }
}
```

### 12.4 在一个内部DSL中使用符号键（Ruby）

符号表来自解析领域，但对内部DSL同样有用。下面是一个简单的DSL脚本，描述了早餐任务及其前置条件：

```dsl
task :go_to_work => [:drink_coffee, :dress]
task :drink_coffee => [:make_coffee, :wash]
task :dress => [:wash]
```

在DSL中，每个任务都可以通过Ruby的符号数据类型引用。任务列表用“函数序列”声明，每个任务的细节用**Literal Map**来展示。

**语义模型**描述起来很简单，就是一个任务类。

```ruby
class Task
    attr_reader : name
    attr_accessor : prerequisites

    def initialize name, *prereqs
        @name = name
        @prerequisites = prereqs
    end

    def to_s    
        name
    end
end
```

DSL脚本由**表达式生成器**负责读取，用到了**对象范围**和instance_eval

```ruby
class TaskBuilder
    def load aStream
        instance_eval aStream
        return self
    end
```

符号表就是个简单的字典

```ruby
class TaskBuilder
    def initialize
        @task = {}
    end
```

任务子句以一个哈希表作为实参，用于组装任务信息。

```ruby
class TaskBuilder...
    def task argMap
        raise "syntax error" if argMap.keys.size != 1
        key = argMap.keys[0]
        newTask = obtain_task(key)
        prereqs = argMap[key].map{|s| obtain_task(s)}
        newTask.prerequistes = prereqs
    end
    def obtain_task aSymbol
        @task[aSymbol] = Task.new(aSymbol.to_s) unless @task[aSymbol]
        return @task[aSymbol]
    end
end
```

用符号实现的符号表和使用字符串作为标志符是一样的。然而，如果支持的话，请使用符号。

### 12.5 用枚举作为静态类型符号（Java）

```java
public enum TaskName {
    wash, dress, make_coffee, drink_coffee, go_to_work
}
```

任务依赖可以这样定义：

```dsl
builder = new TaskBuilder() {{
    task(wash);
    task(dress).needs(wash);
    task(make_coffee);
    task(drink_coffee).needs(make_coffee, wash);
    task(go_to_work).needs(drink_coffee, dress);
}};
```

借助枚举的方式很简单，而且不会强迫使用继承，或者在编写DSL脚本代码时有所限制，并且时优于“类符号表”的地方。

使用这种方法，如果这些符号对应于一些外部数据源，那么应该有一个步骤，读取外部数据源，用代码生成枚举声明，这样没所有一切就可以保持同步。

这样实现的后果时，所有的符号都在一个命名空间。对于多个脚本需要共享同一套符号的情况，这没什么问题，但有时候，希望不同的脚本可以使用不同的符号。

假设有两套任务，一套用于早晨的任务，另一套用于铲雪。当完成早晨的任务时，希望IDE只把它们提供给我；对于铲雪任务，也是一样的道理。实现的方法是：根据接口来定义任务生成器，然后，让枚举实现这个接口。

```java
public interface TaskName {}

class TaskBuilder {
    PrerequisiteClause task(TaskName name) {
        registerTask(name);
        return new PrerequisiteClause(this, tasks.get(name));
    }
    private void registerTask(TaskName name) {
        if (!task.containsKey(name)) {
            tasks.put(name, new Task(name.toString()));
        }
    }
    private Map<TaskName, Task> tasks = new HashMap<TaskName, Task>();
}
```

然后，定义一些枚举，根据特定的任务使用特定的枚举，选择性地导入所需的枚举即可。

```java
import static path.io.ShovelTasks.*;

enum ShoveTasks implements TaskName {
    shobel_path, shobel_drive, shovel_sidewalk, make_out_chocolate
}

builder = new TaskBuilder() {{
    task(shovel_path);
    task(shovel_drive).needs(shovel_path);
    task(shovel_sidewalk);
    task(make_hot_chocolate).needs(shovel_drive, shovel_sidewalk);
}}
```

如果要进行更多的静态类型控制，可以创建一个通用版本的任务生成器，检查其是否使用了正确的TaskName子类型。但是，如果主要感兴趣的是良好的IDE可用性，那么选择导入恰当的枚举，这就够了。

## 第13章 语境变量

### 13.1 工作原理

在解析过程中，如果使用一个命名类似于currentItem的变量，在处理输入脚本时，随着从一个对象移到下一个对象，就要定期更新这个变量，那就是在使用语境变量。

**语境变量**可能是一个**语义模型**，也可能是一个生成器对象。语义模型是一个非常直白的选择，但是有这个前提，所有的属性都要是可变的，这样在需要的时候，解析器才能修改。如果不是这样，通常来说，最好使用某种形式的生成器，用来搜集信息，当完成时创建语义模型，比如“构造器生成器”(第14章)。

### 13.2 使用场景

在解析过程中，有很多地方要保存语境，这时候语境变量就是一个显而易见的选择了，易于创建也易于使用。

然而，如果需要很多语境变量，那也是有问题的。因为从其本性来说，它们是可变状态的，而这些状态是必须跟踪的。

## 第14章 构造器生成器

### 14.1 工作原理

构造型生成器的基本做法很简单。假设要逐步创建一个不可变对象，称为产品。找出产品构造函数的实参，为每一个实参创建一个字段。对于要搜集产品的其他属性，也添加一些字段。最后，添加一个创建方法，返回一个由构造型生成器中所有数据组成的产品对象。

或许，还要在构造型生成器中添加一些生命周期控制，这种控制可能检查是否信息已足够创建产品。可能要设置一个标记，保证已返回的产品不会再返回，或者把已创建的产品放到一个字段里。可能是在创建了产品后，如果尝试给构造型生成器添加属性，就抛出异常。

多个构造型生成器可以深度组合在一起。可以产生一组相关联的对象，而不只是一个对象。

### 14.2 使用场景

有时，要创建一个对象，其中有多个不变字段，而且这些字段的值只能逐渐搜集，这时，构造型生成器就大显身手了。在实际创建这个产品之前，构造型生成器提供了一个存放所有数据的地方。

构造型生成器最简单的一个做法，把信息存放在局部变量，或者没有什么目的的字段中。如果只有一两个产品，这种做法还能运转良好，但如果要一次创建一堆对象，就像解析这种情况，那很快就会带来困惑。

还有一种做法，创建一个实际的模型对象，但是在搜集一项不可变属性的数据之后，就创建模型对象的一个副本，其中的属性已经更改了，替换掉了旧值。这样，避免了编写构造型生成器，但是，通常来说，这并不是很好的做法。尤其是，如果有多个对象引用，这种做法就不起作用了，或者，至少在必须替换每个引用时，这种做法就很麻烦。

要处理此类问题，最佳方式当属构造型生成器，但请记住，只有在处理不可变字段时才会用到它。如果不是这样，那就直接创建产品对象。

## 第15章 宏

### 15.1 工作原理

在程序设计语言构建抽象方面，宏是最古老的技术之一。宏主要分为文本宏和语法宏。文本宏就是把文本当做文本。语法宏理解宿主语言和语法结构，这样，保证其操作的文本单元在语法上是正确的，产生的结果也是语法有效的，就会容易一些。文本宏处理器可以操作任何语言，只要是文本形式的。语法宏处理器只是为一种语言设计的，通常，它就是为这种语言打造的工具，甚至本省就在语言规范中。

#### 文本宏

多数现代语言不支持文本宏，宏处理最简单的形式是，用一个字符串替换另外一个。宏和函数调用的区别是，宏是在预编译期执行的，可以省去函数调用的开销。

#### 语法宏

在C++中语法宏就是模版。对于C++来说，比较复杂，不鼓励内部DSL的使用。语法宏确实有一些强大的能力，在Lisp中，多数甚至绝大多数宏，都是在处理“闭包”时打磨语法的。

### 15.2 使用场景

文本宏的问题很多，错误展开，变量捕获，多次执行诡异bug等，并且难以跟踪和调试。除了非常简单的场景，不推荐使用文本宏。而是否使用语法宏，主要取决于语言环境。

## 第16章 通知

通知是收集错误信息的对象。当校验失败时，会添加一条错误信息到通知中：当校验完成后，返回通知。通过通知，可以知道是否一切正常，如果有错误，还可以深入到错误中。

### 16.1 工作原理

通知的基本形式是一个由错误组成的集合。当执行具体任务时，要能够把错误信息加入通知中。简单的形式是一个错误消息的字符串；复杂的形式是一个错误对象。当任务完成时，返回给调用者。调用者通过简单的布尔查询了解是否一切正常。如果有错误，查询通知获取进一步的信息。

虽然通知的主要目的是收集错误信息，但它也可以用来捕捉警告和其他信息。错误表示执行的命令中有错误，警告则表示，虽未失败，但调用者仍可能会担心的问题。在很多方面，通知和日志文件的行为非常相似，所以日志系统中许多常见的特性在这里一样有用。

### 16.2 使用场景

有时候，复杂的操作可能会触发多个错误，而不希望程序在第一个错误发生时就失败，通知就是一种很管用的做法。一个通知可以保存多个异常，给调用者以更加完整的错误反馈。

通知在一种情况下特别有用，就是UI触发某个底层操作的时候。因为底层最好不要直接与UI交互，所以，通知变成了UI和底层之前的信使。

### 16.3 一个非常简单的通知（C#）

```cs
class Notification {
    List<string> errors = new List<string>();
    public void AddError(string s, params object[] args) {
        errors.Add(string.Format(s, args));
    }

    public bool IsOK {
        get {
            return 0 == errors.Count;
        }
    }

    public bool HasErrors {
        get {
            return IsOK;
        }
    }

    public void AssertOK() {
        if (HasErrors) 
            throw new ValidationException(this);
    }
}
```

# 第三部分

## 第17章 分隔符指导翻译

### 17.1 工作原理

分隔符指导翻译的工作原理是在获取输入后，基于分隔符将其分解成小块。可以使用任何字符作为分隔字符，但是最常用的分隔符是行尾符。

把脚本分解成行通常相当简单，因为多数编程环境都有程序类库，一次一行地读取输入流。还可以使用续行符，表示不同行之间是同一行。

```
score 300 for 3 nights at Bree
score 200 for 2 nights at Dol
score 150 for 2 nights at Orthanc
```

每一行都是称作是自洽的，因为任何一行都不会影响其他行。可以重新排列甚至删除任何行而不会影响解释其他行。它们形式相同,因为每一行编码同种类的消息。所以处理起来相当简单，对每一行执行相同的行处理函数，函数会找到需要的信息，并转换为需要的表达方式。如果使用**嵌入式语法翻译**，意味着把它放入**语义模型**。如果使用**树的构建**，意味着创建一个抽象的语法树。很少见到在分隔符指导翻译时使用树的构建。

如何找出需要的信息依赖于语言中字符串处理的能力，以及需要处理的行的复杂度。在可能的情况下，最简单的方式是使用字符串分隔函数。大多数字符串类库都有这样的函数，可以通过分隔字符把字符串分隔成多个元素。

有时字符串的分解方式不会很清晰，最好的方式是使用**正则表达式**，可以在正则表达式中使用分组来提取需要的字符。正则表达式比分隔符字符串强大的多，

使用分隔符指导翻译处理飞自洽的语句会更加复杂，因为必须保留解析的一些状态信息。一个例子就是状态机，解决这个问题的好办法是，对解析的每种状态有一组不同的解析器。于是状态机解析器有一个顶层的行解析器，并对命令块，事件块，重置事件块和状态块有进一步的行解析器。

### 17.2 使用场景
 
分隔符指导翻译的最大优点是非常简单易用。它的主要替代方案，“语法指导翻译”，需要客服一定的学习曲线才能理解如何使用语法。

这种方法的缺点是难以处理更复杂的语言。因此，只有当面对简单的自洽语句，或者只有一个嵌套上下文时，建议选择分隔符指导翻译。

### 17.3 常客记分（C#）

#### 语义模型

DSL如下：

```dsl
300 for stay 3 nights at Bree
150 per day for stay 2 nights at Bree
50 for spa treatment at Dol Amroth
60 for stay 1 night at Otthanc or Helm's Deep or Dunharrow
1 per dollar for dinner at Bree
```

脚本的每一行代表一行奖励。奖励的主要职责是记录常客活动的基本。活动用来简单地描述数据：

```cs
class Activity {
    public string Type {get;set;}
    public int Amount {get;set;}
    public int Revenue {get;set;}
    public string Location {get;set;}
}
```

奖励包括三个组件，`LocationSpecification`查看活动发生的地方是否合适；活动规范查看活动是否值得奖励；如果这两个规范都满足，Reward对象计算分数。

这三个组件中最简单的是位置规范。只需要检查酒店的名称是否包含在已有的酒店列表中：

```cs
class LocationSpecification {
    private readonly IList<Hotel> hotels = new List<Hotel>();

    public LocationSpecification(params String[] names) {
        foreach (string n in names) {
            hotels.Add(Repository.HotelNamed(n));
        }
    }

    public bool IsSatisfiedBy(Activity a) {
        Hotel hotel = Repository.HotelNamed(a.Location);
        return hotels.Contains(hotel);
    }
}
```

这里需要两种类型的活动规范。一个活动规范肩擦好保持的事件不能少于规定的时间。

```cs
abstract class ActivitySpecification {
    public abstract bool isStatisfiedBy(Activity a);
}

class MinimumNightStayActivitySpec : ActivitySpecification {
    private readonly int minimumNumberOfNights;

    public MinimumNightStayActivitySpec(int numberOfNights) {
        this.minimumNumberOfNights = numberOfNights;
    }
    
    public override bool isStatisfiedBy(Activity a) {
        return a.Type == "stay" 
            ? a.Amount >= minimumNumberOfNights
            : false;
    } 
}
```

第二个活动规范检查活动的类型必须正确

```cs
class TypeActivitySpec : ActivitySpecification {
    private readonly string type;

    public TypeActivitySpec(string type) {
        type = type;
    }

    public override bool isStatisfiedBy(Activity a) {
        return a.Type == type;
    } 
}
```

Reward类根据不同的基准保存积分

```cs
class Reward {
    protected int points;
    public Reward(int points) {
        this.points = points
    }
    virtual public int Score (Activity activity) {
        return points;
    }
}

class RewardPerDay : Reward {
    public RewardPerDay(int points) : base(points) {}

    public override int Score (Activity activity) {
        if (activity.TYpe != "stay")
            throw new ArgumentException("can only use per day scores on stays");
        return activity.Amount * points;
    }
}

class RewardPerDollar : Reward {
    public RewardPerDollar(int points) : base(points) {}

    public override int Score (Activity activity) {
        return activity.Revenue * points;
    }
}
```

#### 解析器

解析器的基本结构是读取每一行输入并处理。这个例子，支持使用`&`作为续航符。一个简单的递归函数就可以工作。当解析行时，首先去除注释，忽略空行。完成以后，开始正确解析，把解析工作委托给一个新的对象：

```cs
class OffsetScriptParser {
    readonly TextReader input;
    readonly List<Offer> result = new List<Offer>();
    public OffsetScriptParser(TextReader input) {
        this.input = input;
    }
    public List<Offer> Run() {
        string line;
        while ((line = input.ReadLine()) != null) {
            line = appendCoutinuingLine(line);
            parseLine(line);
        }
        return result;
    }
    string appendCoutinuingLine(string line) {
        if (IsContinueLine(line)) {
            var first = Regex.Replace(line, @"&\s*$", "");
            var next = input.ReadLine();
            if (null == next) 
                throw;
            return first.Trim() + " " + appendCoutinuingLine(next);
        }
        return line.Trim();
    }
    bool IsContinueLine(string line) {
        return Regex.IsMatch(line, @"&\s*$");
    }
    void ParseLine(string line) {
        line = removeComment(line);
        if (IsEmpty(line))
            return;
        result.Add(new OffsetLineParser().Parse(line.Trim()))
    }
    bool IsEmpty(string line) {
        return Regex.IsMatch(line, @"^\s*$");
    }
    string removeComment(string line) {
        return Regex.IsMatch(line, @"#.*", "");
    }
}
```

基本的解析方法把行分解成子句，并对每个子句调用不同的解析函数。这个方法的核心行为是把正则表达式分解成组，然后分组解析后映射到结果中。在组的定义和使用上有很强的语义关联。

```cs
class OffsetLineParser {
    public Offer Parse(string line) {
        var result = new Offer();

        const string rewardRegexp = @"?<reward>.*";
        const string activityRegexp = @"?<activity>.*";
        const string locationRegexp = @"?<location>.*";

        var source = rewardRegexp + keywordToken("for") + 
            activityRegexp + keywordToken("at") + locationRegexp;

        var m = new Regex(source).Match(line);

        result.Reward = parseReward(m.Groups["reward"].Value);
        result.Location = parseLocation(m.Groups["location"].Value);
        result.Activity = parseActivity(m.Groups["activity"].Value);
    }
    string keywordToken(string keyword) {
        return @"\s+" + keyword + @"\s+";
    }
    LocationSpecification parseLocation(string input) {
        if (Regex.IsMatch(input, @"\bor\b"))
            return parseMultipleHotels(input);
        return new LocationSpecification(input);
    }
    ActivitySpecification parseActivity(string input) {
        if (input.StartWith("stay"))
            return parseStayActivity(input);
        return new TypeActivitySpec(input);
    }
    LocationSpecification parseMultipleHotels(string input) {
        string[] hotelNames = Regex.Split(input, @"\s+or+\s+");
        return new LocationSpecification(hotelNames);
    }
    ActivitySpecification parseStayActivity(input) {
        const string stayKeyword = @"^stay\s+";
        const string nightsKeyword = @"\s+nights?$";
        const string amount = @"(?<amount>\d+)";
        const string source = stayKeyword + amount + nightsKeyword;

        var m = Regex.Match(input, source);
        if (!m.Success) 
            throw;
        return new MinimumNightStayActivitySpec(Int32.Parse(m.Groups["amount"].Value));
    }
    Reward parseReward(string input) {
        if (Regex.IsMatch(input, @"^\d+$"))
            return new Reward(int.Parse(input));
        else if (Regex.IsMatch(input, @"^\d+ per day$"))
            return new RewardPerDay(int.Parse(extractDigits(input)));
        else if (Regex.IsMatch(input, @"^\d+ per dollar$"))
            return new RewardPerDollar(int.Parse(extractDigits(input)));
        throw;
    }
    string extractDigits(string input) {
        return Regex.Match(input, @"^\d+").Value;
    }
}
```

## 第18章 语法指导翻译

计算机语言天生倾向于遵循一种层次化的结构，具有多层的上下文，编写一种文法，描述如何将语言的元素分解为子元素，就可以为这种语言定义合法的语法。

语法指导翻译使用这个文法定义如何创建解析器，解析器可以将输入文本转换成**语法分析树(parse tree)**，语法分析树具有类似于文法规则的结构。

### 18.1 工作原理

文法通常都是以BNF编写的。有了文法，可以更容易理解语言的合法语法是什么样的。使用语法指导翻译，可以让文法更进一步，以此为基础，设计处理这门语言的程序。

几种根据文法进行处理的方式：一种方式是把语言当做规范和实现指南，手写解析器。常见的做法有**递归下降语法解析器**和**解析器组合子**两种。还有一种方式是把语法当做DSL，然后用**解析器生成器**根据文法文件自动构建解析器。对于这个情况，自己无须编写任何解析器的核心代码，所有的代码都是根据文法生成的。

语法固然有用，但是只处理了一部分问题：如何将输入文本转换为语法分析树这个数据结构。但是，几乎总是需要对输入做更多的处理。因此解析器生成器也提供了一些方式，以便在解析器里嵌入进一步的行为，完成诸如组装**语义模型**之类的工作。所以，虽然解析器生成器已经做了很多的事情，但依然可以写一些程序，去做一些很有用的东西。从各个角度来看，解析器生成器都是一个非常精彩的DSL实践的例子。

#### 词法分析器

**词法分析器(lexer)**也叫做**标记解释器(tokenizer)**或**扫描器(scanner)**，它是处理输入文本的第一阶段。词法分析器将输入字符分解成**标记(token)**,标记对输入进行了一个合理的划分。

标记的定义通常采用正则表达式：

```
event-keyword: 'events';
command-keyword: 'commands';
end-keyword: 'end';
identifier: [a-z A-Z 0-9]*
```

比如下面的DSL：

```dsl
events
    dorrClosed D1CL
    drawOpened D2OP
end
```

词法规则将输入转换成一系列标记。

```
[Event-keyword: "events"]
[Identifier: "doorClosed"]
[Identifier: "D1CL"]
[Identifier: "drawOpened"]
[Identifier: "D2OP"]
[End-keyword: "end"]
```

每个标记都是一个有两个根本属性的对象：类型和承载内容(payload)。类型是标记的种类。承载内容是词法分析器匹配出的文本。对于关键字而言，承载内容无所谓，重要的是类型。对于标识符而言，承载内容就很重要了，因为它是数据，在后续的解析中很重要。将词法分析分离出来是有原因的。首先，这会让解析器更简单，因为这样一来，解析器就可以按照标记来编写，而非原始字符。其次，在于效率：将字符归为标记，这种实现不同于直接在解析器中使用字符。

在自动机理论中，词法分析器通常是一个状态机，而解析器是一个下推栈机。因此，这种划分算是一种传统的方式。对词法规则的检查是按顺序进行的，先匹配先算。所以，不能用字符串events做标识符。因为词法分析器会把它识别为关键字。
有些情况下，可以用“可变分词方式”绕过这种做法。

词法分析时，会遇到空白，空格，制表符和换行符。在很多语言里，词法分析器会去掉空白，解析器也就不必处理了，这是同**分隔符指导翻译**的一个巨大差别，而后者把空白是构成结构的关键角色。

如果空白在语义上有作用----比如，换行符表示语句分隔符，或者缩进表示块结构----词法分析器就不能简单地忽略了。相反，必须生成某种标记，表示发生的事情，比如，用换行符表示“以换行作为分隔符”。然而，有些语言采用语法指导翻译进行处理，却故意尝试忽略空白。确实，DSL可以采用任何形式的分隔符，例如状态机就在词法分析器中丢弃所有空白。

词法分析器也常常丢掉注释。即便对于最小的DSL而言，注释也总是有用的，词法分析器可以轻松地去掉这些注释。

标记有`类型`和`承载内容`两个属性。在实践中，会有更多的信息，比如行号、字符位置等。当确定标记时，有时会有一种微调匹配过程的诱惑。比如当上述例子中的事件代码必须是4个字符的序列时，包括大写字母和数字。可以考虑一个特定的标记类型:

```
code: [A-Z 0-9]{4}
```

这个问题在于，会把以4个字母或数字组成的关键字也识别为标识符。

词法分析器处理的三种标记:

* **标点符号**-关键字、运算符或者其他用做组织的构造(括号，语句分隔符;等)。对于标点符号来说，类型是重要的，内容不重要，比如运算符。
* **领域文本**-事物的名字，字面值。比如“数字”或“标识符”或“字符串”
* **可忽略的标记**-空白，换行，注释等。

词法分析器的生成器一般用正则表达式，手写词法分析器会有更大的灵活性，解析器和词法分析器之间的交互也可以更复杂。

有一种特别的“解析器-词法分析器”交互方式可能很有用，就是对词法分析器多模式的支持，允许解析器在模式之间显式切换。通过这种做法，解析器可以在语言某个特定的点上改变标记解释的方式。对于可变分词方式来说很有用。

#### 语法分析器

一旦有了标记流，语法指导翻译的下一部分就是解析器本身了。解析器的行为可以分为两个主要的部分，称为语法分析和动作。语法分析接受标记流，把它们组织成语法分析树。这个工作可以完全来自文法本身，如果用了**解析器生成器**，代码可以由工具生成。动作部分接受语法树，进行更多的处理----比如组装**语义模型**。

动作部分无法由文法生成，它通常是在解析树构建过程中执行的。在解析器生成器的文法文件里，文法定义和指定动作的额外代码常常结合在一起的。通常，会用通用程序设计语言编写这些动作，当然，也可以有一些动作可以由某种DSL来写。

只做语法分析，分析的结果就是成功运行或者失败，表示输入是否匹配语法。为了形成解析树，语法分析会引入了额外的节点，这些节点都是由文法定义的。

使用语法指导翻译，文法定义了如何将输入文本转换成解析树，可以选择不同的文法，这依赖于想如何控制解析。

在大多数情况下，并不会直接访问解析树。在解析的过程中，解析器会一点一点构建解析树，并在解析过程中执行一些动作。一旦完成了一部分解析树，就会丢弃那部分。当然也可以生成完整语法树，只不过是**抽象语法树(AST)**。

语法分析树是一颗树，它会按照文法精确地解析出解析的内容，带有所有出现的标记----基本上就是一棵原始树。AST指的是一棵简化过的树，丢弃了不必要的标记，重新组织过，容易后续处理。语法树是AST和语法分析树的超类型，当需要一个术语属于表示一棵树可能是二者之一时，使用语法树。

#### 产生输出

对于描述语法分析而言，文法足够了，但是，这仅仅够解析器识别某些输入。通常来说，不会止步于识别：想产生一些输出。产生输出的方式，分成三类：“嵌入式语法翻译”，“树的构建”和“内嵌解释器”。所有这些方式，除了文法之外，都还需要一些其他的内容，以指定它们的工作方式，所以，通常需要额外编写一些代码来产生输出。

如果把代码放入解析器，取决于如何编写解析器。使用“递归下降语法解析器”，要在手写代码总添加行为。使用“解析器组合子”，要采用语言的机制把动作对象传给组合子：使用“解析器生成器”，则要用“外加代码”把代码动作添加到文法文件的文本里。

#### 语义预测

语法分析器，无论是手写还是生成，都遵循一个核心算法，可以基于文法识别输入。然而，在某些情况下，识别规则无法完全以文法表达。

为了处理这一点，一些解析器生成器支持语义预测。**语义预测**是一块通用代码，它会提供一个布尔值，表示文法生成是否接受，即文法是否有效重写了规则表达的内容。这样一来，解析器就可以做一些超越文法表述内容的事情。

一个需要语义预测的经典例子是，当解析C++时，遇到T(6)。根据上下文，这可能是一个函数调用，也可能是一个构造函数风格的类型转换。为了分辨这两者，需要知道T是如何定义的。在一个上下文无关的文法里，做不到这一点，因此，就需要语义预测解决这种二义性。

对DSL而言，不应该遇到语义预测，因为应该在定义语言时避免这种需求。

### 18.2 使用场景

语法指导翻译主要的劣势在于需要通过文法驱动解析，而通过分隔符进行分隔是一种更常见的方式。

尤其是，文法文件本身就是一个DSL，为其处理的DSL提供了一个清晰的语法结构文档。随着时间推移，它会让DSL的语言演进更容易。

## 第19章 BNF

形式化地定义编程语言地语法：

```bnf
grammerDef : rule+
rule       : id ':' altList ';';
altList    : element+ ( '|' element+ )*;
element    : id ebnfSuffix?
           | '('  altList ')'
           ;
ebnfSuffix : '?' | '*' | '+' ;
id         : 'a'..'z' ('a'..'z'|'A'..'Z'|'_'|'0'..'9')* ;       
```

### 19.1 工作原理

BNF以及EBNF是编写文法来定义语言语法地一种方式。BNF(全称是“Backus-Naur”范式)发明于19世纪60年代。此后，BNF文法广泛用于解释和驱动“语法指导翻译”。

作为一种用来定义语法地语言，BNF本身却没有一个标准语法。各种BNF都用一系列的**产生规则**来描述一种语言。

#### 多重性符号(Kleene运算符)

类似于正则表达式模式匹配符号`+`,`*`,`|`等，分组结构经常与多重性符号同时出现，这样就可以把几个元素组合起来，然后对整个分组使用多重性规则。所以就可以把子规则内联，从而得到下列文法：

```bnf
contact : 'contact' Idenfifier '{'
    QuotedString?
    {'email:' emailAddress}+
    {'tel:' TelephoneNumber}*
    '}'
    ;
```

不建议这样做，因为子规则的存在能表达文法的意图，从而使整个文法更可读。但是有些时候，过多的子规则会使文法变得混乱。适当的分组有助于改善这一情况。

大部分BNF忽视换行符，所以把规则中的每个逻辑片段单列一行有助于阅读者理解复杂的规则。在这种时候，通常会把分号也单列一行，以便阅读者清晰地看到“整个规则的结束”。这是最常见的一种格式化风格，如果一条规则复杂到一行里面放不下，建议采用。

除了上述形式的多重性符号时，还有采用方括号来作为多重性符号的形式，但是大部分解析器生成器还是倾向于使用正则表达式风格。

#### 其他一些有用的运算符

* `~`直到运算符，会匹配所有字符，直到跟在`~`之后的那个元素为止。所以，如果想要匹配直到（但不包括）右大括号为止的所有字符，就可以使用`~'}'`模式。如果没有这个运算符，等价的正则的表达式是`[^}]*`
* `..`范围运算符，比如`'a'..'z'`表示从`a`到`z`之间的共26个小写字母。

词法分析也可以用于产生规则的风格来定义，词法分析规则大致更接近正则表达式，因为正则表达式背后的有穷状态机确实更适合用于词法分析----而解析器的背后则是一个下推机。

```bnf
Identifier:
    ('a'..'z' | 'A'..'Z')
    ('a'..'z' | 'A'..'Z' | '0'..'9' | '_')*
```

这个规则规定，标识符必须以小写或者大写字母开头，随后的字符可以是字母，数字或下划线。范围只在词法分析规则中有意义，在语法规则中则没用。另外，范围运算符传统上是以ASCII为中心的，因此支持非英语的标识符会有困难。

#### 解析表达式文法

大部分BNF文法都是**上下文无关文法(Context-Free Grammer,CFG)**。要有一种叫做**解析表达式文法(Parsing Expression Grammer,PEG)**的文法风格出现。PEG和CFG之间最大的区别在于：前者支持有序的选择。在CFG中，如果这样写：

```
contact : email | tel;
```

就表示“每个联系人有一个Email地址或一个电话号码”。这两个选择的顺序对解释毫无影响。有时候，无序的选择会造成歧义。

符号|含义|例子
-|-|-
`|`|选择|`email | tel`
`*`|0个或多个|`tel*`
`+`|1个或多个|`email+`
`?`|可选|`fullname?`
`~`|直到|`~'}'`
`..`|范围|`'0'..'9'`
`/`|有序选择|`us_tel / raw_tel`

#### 将EBNF转换为基础BNF

多重性符号大大提高了BNF的可读性，但并没有增加BNF的表达能力。使用多重性符号的EBNF文法完全可以替换为等价的基础BNF文法。由于一些**解析器生成器**使用基础BNF来描述文法，因此这种转换经常是非常重要的。

转换的关键在于使用选择，先从可选元素开始，所有`foo?`都可以替换为`foo|`。重复元素的转换同样依靠选择来实现，一般采用递归处理的方法，但是自顶向下的解析器根本不能实现左递归：Yacc两种都可以做，但还是首选右递归。多重标记`+`与`*`相似，但结束状态是一个元素，但不是空。因此可以把`x:y+`替换为`x:y|x y`或者`x:y|y x`,以避免左递归。

#### 行为代码

BNF提供了一种为语言定义语法结构的方式，**解析器生成器**通常也使用BNF来驱动解析器的运作。然而，只有BNF还不够：它能提供生成解析树所需的信息，但还不足以得到更有用的AST，也不足以完成**嵌入式语法翻译**或者**内嵌解释器**之类的任务。因此，一种做法是在BNF中嵌入**行为代码(code action)**,通过这些代码进行交互。

并非所有的解析器生成器都使用行为代码。另一种做法是提供一个单独的DSL来完成树的构建等。行为代码背后的想法是：是文法中插入外加代码片段。当解析器识别到这部分文法时，代码片段就会执行。行为代码可以做任何事，因此也可以往数据结构中添加信息。

行为代码经常需要引用解析过程中识别到的元素：不同的解析器生成器对此有不同的处理方式。经典的Yacc采用特殊的变量来引用这些标记，这些变量可以索引元素的位置。文法中的位置可能经常变化。因此现代的解析器生成器更多采用“给元素打标签”的方式。

为了解析这些引用，解析器生成器会借助一个模版系统来执行行为代码，这个模版系统会把`$e`这样的表达式替换成对应的值。但ANTLR其实更进一步：text这样的属性并非直接引用字段或方法，ANTLR做了更多的替换以便保存正确的信息。

任何东西都可以从规则中返回并在父规则中引用。与行为代码一样，这种能力也非常重要。很多时候，能最好地提供某个值的规则并不是最适合处理这些数据的。通过将数据传递到上一级规则栈，就可以在低层的解析中捕捉信息，然后在高层中对其进行处理。如果没有这种能力，就需要大量的“语境变量”，这会让文法很快变得混乱。

在内嵌解析器、嵌入式语法翻译和树的构建中都可以使用行为代码。但对于树的构建来说，其特有的代码风格使得它必须使用另一种DSL来描述如何构造最终的语法树。行为代码在文法中的位置将决定其执行的时机。

大部分情况下，把行为代码放在规则的最后是最简单的做法，但有时需要把它们放在规则中间。行为代码的执行顺序可能很难理解，因为它依赖于解析器的算法。递归下降解析器通常比较容易理解，而自底向上解析器则经常令人迷惑。

行为代码可能带来的一个危险是：可能一不小心在文法中放了太多代码，使文法变得难以阅读，就丧失了行为代码文档化的好处。

### 19.2 使用场景

只要用到**解析器生成器**，就会需要BNF，因为这些工具都借助BNF文法来定义解析规则。BNF也是一种很有用的非形式化四维工具，可以用于描述DSL的结构，或者与别人讨论一种语言的语法规则。

## 第20章 基于正则表达式表的词法分析器

通过一组正则表达式来实现词法分析器

模式|标记类型
-|-
`^events`|`K_EVENT`
`^end`|`K_END`
`^(\\w)+`|`IDENTIFIER`
`^(\\s)+`|`WHITESPACE`

语法分析器主要用来处理语言的结构，特点是提供各种不同的语言特性组合。虽然它能很轻松地识别基本语法元素----比如，关键字、数字和各种命名，但通常会将这些东西交给单独的词法分析器来处理。通过使用独立的词法分析器识别这些终结符，可以简化语法分析器的构造。

词法分析器的实现相对比较简单，因为它只能解析正则文法，可以通过标准的正则表达式API来实现它们。对于基于正则表达式的词法分析器，将每个语法符号表达为一个正则表达式，每个正则比奥大使与特定的终结符关联。然后扫描输入数据，把输入的每部分匹配的正确的正则表达式，根据匹配结果生成具有每个终结符的**标记流(token stream)**。这个标记流就是语法分析器的输入。

### 20.1 工作原理

当采用**语法指导翻译**时，通常都会将词法分析作为一个独立的阶段。如果需要了解词法分析的基本概念以及为什么需要使用它。

词法分析的基本算法很简单，它从头开始扫描输入字符串，随着扫描进行匹配相应的标记。正则表达式的检查是有顺序的，因此可以正确利用这个特性来处理关键字。比如，在状态机文法的例子里，关键字可以匹配标识符的规则。将关键字规则放在标识符规则之前，这样标记就能被识别为关键字而不是标识符。词法分析器的一个设计要点就是选择恰当的标记，如果它没有位于合法代码的位置。通常，词法的标记集合包括关键字，命名，数值和操作符一类的东西。

使用一系列识别器来实例化词法分析器，并通过列表或者表格维持它们的顺序。每个识别器包含标识类型，正则表达式和一个布尔值----用以指定是否需要将识别出的标记输出。标记类型用以通知语法分析器标记的类型。布尔值用来处理在语义上无意义的空格和注释。这些字符串存在输入流中，也会被词法分析器处理，但是不会将对应标记传给语法分析器。对于表重复的线性扫描保证了匹配的顺序，而表识别器让添加新的标记类型变得更容易。

当布尔型输出标记为真时，词法分析器将根据识别器表逐一匹配标记，并将匹配的字符从输入字符串中获得结果放入输出流。将所有结果都一一保存在tokenValued字段中，虽然通常而言，仅仅对于标识符、数字和操作符都需要用到它，但这么设计可以省掉另外一个布尔标记，同时也简化了代码。主扫描器将持续调用match，以保证有相应的标识识别出来。当输入字符串匹配完成后，所有识别出来的标记将被传递给文法分析器处理。

为了简化错误排查，可以在标记中添加关于标记在字符串流中的原始位置信息，比如行号和列的位置。

### 20.2 使用场景

有很多词法分析生成器，比如Lex，但因为绝大多数语言都支持正则表达式API，所以不太需要使用它们。不过当使用ANTLR作为“解析器生成器”时，可能是个例外。因为它的词法和语法分析结合得非常紧密。

这里的描述的是词法分析器最直接的一种实现方法，它的性能取决于所使用的正则表达式API的特定方面。因此，仅有一种情况不推荐使用基于正则表达式表的词法分析器，那就是没有找到合适的正则表达式API的特定方面可供使用的时候。

考虑到DSL的语法都很简单，这个方法也可以用于处理整个DSL。

### 词法分析器的一个例子（Java）

状态机文法的词法分析器是个很典型的例子。所需的标记包括关键字、标点符号、标识符的标记类型、空格和注释。使用`java.util.regex`来指定模式并自动完成匹配。词法分析器的输入是DSL脚本，输出则是标记缓冲区----它们将成为语法分析器的输入。

它的实现分为两个部分：指定需要识别的标记和词法分析算法本身。这样做可以简化向词法分析器添加新标记类型的动作。使用枚举类型来表示标记的类型，它包含相应的正则表达式和布尔值----控制标记的输出。

```java
class ScannerPatterns {
    public enum TokenTypes {
        TT_EVENT("^events", true),
        TT_RESET("^resetEvents", true),
        TT_COMMANDs("^commands", true),
        TT_END("^end", true),
        TT_STATE("^state", true),
        TT_ACTIONS("^actions", true),
        TT_LEFT("^\\{", true),
        TT_RIGHT("^\\", true),
        TT_TRANSITION("^=>", true),
        TT_IDENTIFIER("^(\\w)+", true),
        TT_WHITESPACE("^(\\s)+", true),
        TT_COMMENT("^\\\\(.)*$", false),
        TT_EOF("^EOF", false);

        private final String regExPattern;
        private final Boolean outputToken;

        TokenTypes(String regexPattern, Boolean output) {
            this.regExPattern = regexPattern;
            this.outputToken = output;
        }
    }
}
```

在这个词法分析器中，实例化识别对象表。这通过编译的识别器及其标记类型和布尔值完成。

```java
class ScannerPatterns {
    public static ArrayList<ScanRecognizer> LoadPatterns() {
        Pattern pattern;
        for (TokenTypes t : TokenTypes.values()) {
            pattern = Pattern.compile(t.regExPattern);
            patternMatchers.add(new ScanRecognizer(t, pattern, t.outputToken));
        }
        return patternMatchers;
    }
}
```

为了词法分析器定了一个类，它的实例变量包含识别器、输入字符串和输出标记列表。

```java
class StateMachineTokenizer {
    private String scannerBuffer;
    private ArrayList<Token> tokenList;
    private ArrayList<ScanRecognizer> recognizerPatterns;
}
```

词法分析器的主处理循环是个`do-while`循环

```java
class StateMachineTokenizer {
    while (parseInProgress) {
        Iterator<ScanRecognizer> patternIterator = recognizerPatterns.iterator();
        parseInProgress = matchToken(patternIterator);
    }
}
```

这个循环持续地调用标记匹配方法，直到所有缓冲区都耗尽或者无法在剩余缓冲区中匹配到相应的标记时结束。

`matchToken`方法一次遍历各个识别器并尝试匹配单个标记。

```java
private boolean matchToken(Iterator<ScanRecognizer> patternIterator) {
    boolean tokenMatch;
    ScanRecognizier recognizer;
    Pattern pattern;
    Matcher matcher;
    boolean result;
    tokenMatch = false;
    result = true;

    do {
        recognizer = patternIterator.next();
        pattern = recognizer.tokenPattern;
        matcher = pattern.matcher(scannerBuffer);
        if (matcher.find()) {
            if (recognizer.outputToken) {
                tokenList.add(new Token(recognizer.token, matcher.group()));
            }
            tokenMatch = true;
            scannerBuffer = scannerBuffer.substring(matcher.end());
        }
        while (patternIterator.hasNext() && (!tokenMatch));
        if ((!tokenMatch) || matcher.end() == scannerBuffer.length() ) {
            result = false;
        }
        return result;
    }
}
```

如果匹配成功，将输入缓冲区指向匹配结果结束的位置，在这段代码里，是通过调用`matcher.end()`来获取这个位置的。检查匹配的识别器的布尔标记以决定是否为匹配结果产生标记。如果没有匹配成功就会产生错误：`regex API`提供的`find`将会扫描到字符结束，如果无法找到匹配结果，整个词法分析就会失败。

如果内层循环能够匹配标记，那么外层循环就会持续进行到字符串结束。为了保证所有的标记模式都能够进行匹配，迭代器在内层循环结束的时候会重置。词法分析的结果是标记缓冲区，其中每个标记又会具有相应的标记类型和词法分析器中匹配的实际字符串值。

## 第21章 递归下降法

使用递归函数来处理非终止识别器，把文法运算符转化为控制流，从而实现自顶向下的语法解析器。

```java
boolean eventBlock() {
    boolean parseSuccess = false;
    Token t = tokenBuffer.nextToken();
    if (t.isTokenType(ScannerPatterns.TokenTypes.TT_EVENT)) {
        tokenBuffer.popToken();
        parseSuccess = eventDecList();
    }
    if (parseSuccess) {
        t = tokenBuffer.nextToken();
        if (t.isTokenType(ScannerPatterns.TokenTypes.TT_END)) {
            tokenBuffer.popToken();
        }
        else {
            parseSuccess = false;
        }
        return parseSuccess;
    }
}
```

从语言的角度上来说，很多DSL都是非常简单的。虽然外部DSL的灵活性看起来非常有吸引力，但是使用**解析器生成器**来构造语法解析器会在项目中引入新的工具和语言，这会使构建的过程变得复杂。

递归下降语法解析器可以达到外部DSL的灵活性而不会引入解析器生成器。它可由任意的通用语言实现。文法运算符由控制流运算符实现，而文法中非终止符的解析则由不同的方法或函数实现。

### 21.1 工作原理

和其他语法解析器一样，将分离词法分析和语法解析。递归下降语法解析器将从词法分析器----比如**基于正则表达式表的词法分析器**中接收标记流。

递归下降语法解析器的基本结构很简单，文法中每个非终止符都由一个方法来处理。该方法实现与非终止关联的不同产生规则。方法本身返回一个布尔值来表示匹配的结果。如果匹配失败，那么错误将会沿调用栈向上传递。每个方法都在标识缓冲区内进行操作，随着句子的识别，在缓冲区内标识出已识别的部分。

由于文法运算符只有有限的几种(顺序，选择和重复)，它们的实现可以归结为几种模式。首先从选择的处理开始，它可以通过条件语句来实现。对于如下文法片段：

```
grammer file...
    C : A | B
```

对应的解析函数为:

```
boolean C ()
    if (A())
        then true
    else if (B())
        then true
    else flase
```

这种实现方法先判断其中一种选择，然后再判断其他的选择。这种行为更像BNF中的有序选择。如果确实需要无序选择带来的二义性，那么很可能需要使用**解析器生成器**。

如果调用`A()`成功，那么标识缓冲区中的指针将会跃过A匹配的前几个标记。而如果匹配失败，那么标记缓冲区不会发生任何变化。

文法的顺序操作符由嵌套的if语句实现，任何部分匹配失败整个匹配过程就会停止。因此，对于如下文法片段：

```
grammer file
    C : A B
```

实现方式为:

```
boolean C () 
    if (A())
        then if (B())
            then true
        else false
    else false
```

文法的可选运算符稍有不同:

```
grammer file...
    C : A?
```

必须尝试匹配非终止符A，但是这个匹配永远不会失败。如果A匹配成功，就返回true。如果匹配失败，仍然返回true，因为A是可选匹配。实现方法如下:

```
boolean C ()
    A()
    true
```

如果A匹配失败，那么标识缓冲区没有任何变化。如果A匹配成功，那么缓冲区将会跃进。无论那种情况，对于C的调用都会成功。

文法的重复操作符有两种形式：零或多次("*")和一或多次("+")。如下文法所示表示一或多次：

```
grammer file...
    C: A+
```

可以使用如下方法实现：

```
boolean C ()
    if (A())
        then while (A())
            {}
            true
        else
            false
```

这段代码首先检查是否至少可以匹配一次A。如果是，则尝试寻找尽可能多的A，无论结果如何都会返回true，因为它已经至少匹配了一次A。对于零次的情况只需移除掉最外层的if语句，然后把返回值永远置为true即可。

文法规则|实现方法
-|-
`A|B`|`if (A()) then true else if (B()) then true else false`
`A B`|`if (A()) then if (B()) then true else false else false`
`A?`|`A(); true`
`A*`|`while(A()); true`
`A+`|`if (A()) then while (A()); else false`

“树的构建”和"嵌入式语法翻译"在敌对递归下降法中也可以使用。为了使得这种办法尽可能地清晰，实现产生式规则匹配的方法必须在行为上保持一致。其中最重要的就是对于输入标识缓冲区的管理。如果当前方法正确地匹配内容，那么缓冲区的位置指针应该指向匹配内容的下一个标识。

例如，对于event关键字，这个指针应该仅仅移动一个位置。如果匹配失败，那么缓冲区中的位置指针应该和函数调用前的位置一致。这对于文法的顺序操作符尤其重要。在顺序匹配的情况下，需要在函数执行开始的地方保存缓冲区的位置指针，这样如果B匹配失败，仍然可以保持缓冲区中的位置不变。通过管理缓冲区，可以正确地处理文法的分支。

另外一种重要的规则与语义模型或语法树的生成相关。每个方法应该尽可能地处理它所对应的模型或语法树上的元素。所有后续行为都只应该在全部匹配完成后再执行。对于使用缓冲区管理的文法顺序操作符，后续行为的执行应该延期到整个序列完成之后。

对于使用解析器生成器常有一种抱怨，说它要求开发人员熟悉语言文法。虽然在递归下降法中文法操作符并没有出现，但是文法却明显存在于函数之中。修改这些函数实际上就是修改文法。因此，差别并不在于是否使用文法，而是文法以何种形式表达。

### 21.2 使用场景

递归下降法语法解析器最大的优势就是它很简单。一旦理解了基本算法和如何处理各种文法运算符，编写一个递归下降语法解析器仅仅是个简单的编程任务。然后就得到了一个文法分析器，仅仅是系统中普通的类，可以按照常规的方式来测试它。而且当被测试的单元是方法时，做单元测试也变得更有意义。此外，由于语法分析器本身是一段程序，因此它的行为更易推断，也更便于调试解析器。递归下降法语法解析器本身是语法分析算法的直接实现，它的执行过程也更容易追踪和理解。

递归下降语法解析器最大的不足是对于文法结构没有直观的表现形式。递归下降法语法解析器通过递归下降算法把文法实现到函数中，因此就无法清晰地看出文法的结构，从而只能依赖于文档或者注释才能理解文法的内容。而解析器组合子和解析器生成器对文法结构都有直观的表述，使得文法更容易理解和演进。

因为递归下降法语法分析器采用自顶向下算法，后者无法处理左递归，这使得嵌套的运算符表达式变得难以处理。同时，它的性能比起解析器生成器生成的语法分析器也要低一些。

当文法足够简单时，递归下降法语法解析器是最直接的实现方式。此外还需要考虑超前分析的量级。所谓超前分析是指语法分析器需要提前知道多少个标识解析器才能决定当前标识是否匹配。通常，对于需要多个符号超前分析的文法，不会使用递归下降法语法解析器，这类文法更适合使用解析器生成器处理。

### 21.3 递归下降（Java）

从创建一个文法分析器的类开始，这个类分别表示几个实例变量，分别表示输入缓冲区，作为输出结果的状态机和一些分析数据。当前的实现使用**基于正则表达式表的词法分析器**从输入字符串中创建输入标识缓冲区

```java
class StateMachineParser {
    TokenBuffer tokenBuffer;
    StateMachine machineResult;
    ArrayList<Event> machineEvents;
    ArrayList<Command> machineCommands;
    ArrayList<Event> resetEvents;
    Map<String, State> machineStates;
    State partialState;
}
```

`StateMachine`类的构造函数接收输入缓冲区并配置相应的数据结构。启动文法分析器很简单，仅仅需要调用代表整个状态机的函数就可以了

```java
class StateMachineParser {
    public StateMachine startParser() {
        if (stateMachine()) {
            loadResetEvents();
        }
        return machineResult;
    }
}
```

当语法解析成功时，startParser方法还会负责创建状态机对象。其余方法唯一剩下的操作是为状态机设置重置事件。

这个状态机的文法规则是由不同块组成的一个简单序列。

```
grammer file
    stateMachine: eventBlock optionalResetBlock optionalCommandBlock stateList
```

最上层的函数是状态机中不同组件构成的一个序列。

```java
class StateMachineParser {
    private boolean stateMachine() {
        boolean parseSuccess = false;
        if (eventBlock()) {
            if (optionalResetBlock()) {
                if (optionalCommandBlock()) {
                    if (stateList()) {
                        parseSuccess = true;
                    }
                }
            }
        }
        return parseSuccess;
    }
}
```

将使用事件的声明来说明这些函数是如何在一起工作的。第一个产生的是表明事件定义块的结构，主要由一个序列组成。

```
grammer file
    eventBlock: eventKeyword eventDecList endKeyword
```

下面的代码按照前面所介绍的模式来实现，注意其中是如何保存缓冲区中的初始位置信息的，当匹配失败时会还原它。

```java
class StateMachineParser {
    private boolean eventBlock() {
        Token t;
        boolean parseSuccess = false;
        int save = tokenBuffer.getCurrentPositions();
        t = tokenBuffer.nextToken();
        if (t.isTokenType(ScannerPatterns.TokenTypes.TT_EVENT)) {
            tokenBuffer.popToken();
            parseSuccess = eventDecList();
        }
        if (parseSuccess) {
            t = tokenBuffer.nextToken();
            if (t.isTokenType(ScannerPatterns.TokenTypes.TT_END)) {
                tokenBuffer.popToken();
            }
            else {
                parseSuccess = false;
            }
        }
        if (!parseSuccess) {
            tokenBuffer.resetCurrentPosition(save);
        }
        return parseSuccess;
    }
}
```

事件列表的语法规则定义非常直观：

```
grammer file...
    eventDecList: eventDec+
```

eventDecList函数严格按照前面介绍的模式来实现，具体的匹配操作在eventDec函数中执行。

```java
class StateMachineParser {
    int save = tokenBuffer.getCurrentPosition();
    boolean parseSuccess = false;

    if (eventDec()) {
        parseSuccess = true;
        while (parseSuccess) {
            parseSuccess = eventDec();
        }
        parseSuccess = true;
    }
    else {
        tokenBuffer.resetCurrentPosition(save);
    }
    return parseSuccess;
}
```

事件定义的匹配是重点，它的文法定义很直观:

```
grammer file...
    eventDec: identifier identifier
```

这段代码也保存了缓冲区中的初始标识位置信息，当匹配成功后，还会创建状态机模型。

```java
class StateMachineParser {
    private boolean eventDoc() {
        Token t;
        boolean parseSuccess = false;
        int save = tokenBuffer.getCurrentPosition();
        t = tokenBuffer.nextToken();
        String elementLeft = "";
        String elementRight = "";

        if (t.isTokenType(ScannerPatterns.TokenTypes.TT_IDENTIFIER)) {
            elementLeft = consumeIdentifier(t);
            t = tokenBuffer.nextToken();
            if (t.isTokenType(ScannerPatterns.TokenTypes.TT_IDENTIFIER)) {
                elementRight = consumeIdentifier(t);
                parseSuccess = true;
            }
        }

        if (parseSuccess) {
            makeEventDec(elementLeft, elementRight);
        } else {
            tokenBuffer.resetCurrentPosition(save);
        }
        return parseSuccess;
    }
}
```

这里需要对两个助手函数进行进一步的解释。第一个是consumeIdentifier，它将缓冲区位置前进一位，并从缓冲区中获取下一个标识符的标记值。因此它可以用来填充事件声明。

```java
class StateMachineParser {
    private String consumeIdentifier(Token t) {
        String identName = t.tokenValue;
        tokenBuffer.popToken();
        return identName;
    }
}
```

另一个助手函数是`makeEventDec`,它通过事件的名称和代码来填充事件声明。

```java
class StateMachineParser {
    private void makeEventDec(String left, String right) {
        machineEvents.add(new Event(left, right));
    }
}
```

从功能来说，最大的难点是对于状态的处理。标识状态迁移的对象可能会引用尚不存在的状态，因此助手函数必须允许对于未定义状态的引用。对于所有不使用**树的构建**的实现来说，都需要面对这个问题。

最后再来看看`optionalResetBlock`函数是如何实现文法规则的。

```
grammer file
    optionalResetBlock: (resetBlock)?
    resetBlock: resetKeyword (resetEvent)* endKeyword
    resetEvent: identifier
```

因为这个文法规则太简单了，所以就不严格按照前面解释的模式来实现它，而是把`resetBlock`和`optionalResetBlock`合并在一起实现。

```java
class StateMachineParser {
    boolean optionalResetBlock() {
    int save = tokenBuffer.getCurrentPosition();
    boolean parseSuccess = true;
    Token t = tokenBuffer.nextToken();

    if (t.isTokenType(ScannerPatterns.TokenTypes.TT_RESET)) {
        tokenBuffer.popToken();
        t = tokenBuffer.nextToken();
        parseSuccess = true;
        while (!(t.isTokenType(ScannerPatterns.TokenTypes.TT_END)) & (parseSuccess) ) {
            parseSuccess = resetEvent();
            t = tokenBuffer.nextToken();
        }
        if (parseSuccess) {
            tokenBuffer.popToken();
        } else {
            tokenBuffer.resetCurrentPosition(save);
        }
    }
    return parseSuccess;
    }
    boolean resetEvent() {
        Token t;
        boolean parseSuccess = false;
        t = tokenBuffer.nextToken();

        if (t.isTokenType(ScannerPatterns.TokenTypes.TT_IDENTIFIER)) {
            resetEvents = true;
            tokenBuffer.popToken();
        }
        return parseSuccess;
    }
}
```

如果reset关键字不存在，这个方法仍然会返回true，因为整个块是可选的。如果reset关键字存在，那么它必须有零或多个事件声明，这组声明之后要跟随end关键字。如果不是这样，该块的匹配就会失败，函数会返回false。

## 第22章 解析器组合子

通过组合解析器对象，创建一个自顶向下的解析器

### 22.1 工作原理

使用**递归下降法语法解析器**，会用到词法分析器，比如**基于正则表达式表的词法分析器**，执行对于输入字符串的词法分析。而解析器组合子则是对解析出来的标记字符串进行操作。

组合子这一术语源自函数式语言。组合子的设计旨在组合，对其输入，创建同样类型的却更为复杂的操作。这样，解析器组合子就可以组成更为复杂的解析器组合子。在函数式语言中，这些组合子都是第一类的函数，在面向对象的环境里，可以用对象做同样的事。从基本的情况触发，在文法中，就是终结符的识别器。可以用组合子实现各种文法运算符(序列和列表等)，以实现语法中的产生规则。一种有效的做法是，对文法中的每个非终结符，都有一个对应的组合子，就像递归下降法语法解析器，对每个终结符都有一个递归函数。

每个组合子负责识别语言的某个部分，确定匹配的话，则使用匹配输入缓冲区中的相关标记，执行必要的动作。这些操作等同于递归下降语法解析器里递归函数所需的操作。

单个解析器组合子接受的输入包括匹配状态，当前的标记缓冲区，一组累积的动作结果。解析器组合子返回匹配状态，可能已经修改过的标记缓冲区和一套动作的结果。为了让描述更清晰，假设此刻标记缓冲区和匹配结果集作为状态保存在背后的某个地方。

**终结符识别器**-终结符的识别很容易：只要简单地把输入标记缓冲区当前位置上的标记同任意终结符比较即可，这个终结符就是识别器寻找的标记。如果标记匹配，就在向前移动标记缓冲区的当前位置。

```
grammer file
    C : A | B
```

C的选择组合子先尝试一个组合子，比如，B；如果组合子的匹配状态是true，则C的返回值就等同于B的返回值。遍历选项，逐一尝试。如果所有选项都失败了，返回值是失败的匹配状态，输入标记缓冲区未改变。用伪代码实现，组合子看上去就是这样：

```
CombinatorResult C ()
    if (A())
        then return true
    else
        if (B())
            then true
        else return false
```

这个逻辑就像一个递归下降算法。

顺序运算符有点复杂

```
grammer file 
    C : A B
```

为了实现这个运算符，需要逐步遍历序列里的组件。如果任何一个匹配失败，则需要重置标记缓冲区为其输入状态，对于上面的文法规则，其组合子看上去如下:

```
CombinatorResult C ()
    saveTokenBuffer
    if (A())
        then 
        if (B())
            then true
        else 
            restoreTokenBuffer
            return false
    else return false
```

这一实现以及随后的其他实现都依赖于组合子的典型行为。如果匹配成功，利用标记缓冲区中匹配相关的标记。如果匹配失败，组合子则返回未修改的标记缓冲区。

可选运算符非常直白

```
grammer file
    C : A?
```

这个运算符会根据对A的匹配结果返回原有的标记或者修改它们。对于上面的文法规则，其组合子看上去如下:

```
CombinatorResult C ()
    A()
    return true
```

对一个或多个列表进行操作的列表(list)运算符是接下来要考虑的运算符


```
grammer file
    C: A+
```

这个组合子先检查，确保至少有一个A。得到确认则循环，直至匹配失败，返回新的标记缓冲区。如果初始匹配失败，则返回false，以及输入的标记。

```
CombinatorResult C ()
    if (A())
        then 
        while (A())
            then true
        else 
            return false
```

对于可选列表而言，则总是返回true，根据匹配结果，相应地对标记缓冲区进行处理。代码大致如下：

```
CombinatorResult C ()
    while (A())
        then true
```

这里展示的组合子的实现是特定规则的直接实现。组合子解析器的强大之处在于可以用组件组合子构建出组合的组合子。因此，指定下面序列运算的代码如下：

```
grammer file
    C : A B
```

非常像这个声明：

```
C = new SequeceCombinator (A, B)
```

其中序列的逻辑实现可以被所有这样的规则所共享。

#### 处理动作

既然了解了识别是如何运作的，下面就看动作。此刻，再次假设得到了动作要操作的状态。动作有许多形式。对于“树的构建”，动作是在解析时构建抽象语法树。对于“嵌入式语法翻译”，动作则是组成语义模型。匹配值的类型取决于动作。

再以终结符组合子这个基本情况为例。如果匹配成功，就根据匹配结果组成匹配值，然后用这个匹配值调用动作。一旦识别了序列的全部组件，就需要根据来自各个组件的匹配值列表调用动作。按照这种方式，修改识别器，调用动作。

```
CombinatorResult C ()
    saveTokenBuffer()
    saveActions()
    if (A())
        then
        if (B())
            then
            executeActions (aResult, bResult)
            return true
        else
            restoreTokenBuffer()
            restoreActions()
            return false
    else return false
```

`executeActions`方法中隐藏了很多东西。A和B匹配的匹配值需要保存，以便在动作中使用。

在其他运算符加入动作是类似的。选择运算符在对选中的选项执行动作。类似于序列运算符，列表运算符必须对所有的匹配值执行。显然，可选运算符只在匹配时执行动作。

动作的调用相对直白。其挑战在于如何获得与组合子关联的合适的动作方法。在有闭包或是有其他方式将函数作为参数进行传递的语言中，只要把动作方法的细节当做函数传给构造函数即可。在没有闭包的语言中，比如Java，就需要用特定于某个产生规则的类扩展运算符类，重写动作方法，引入特定行为。

动作可以用于构建抽象语法树。在这种情况下，传给动作函数的匹配值就是不同组件构建出的树，正如讨论中的文法规则所隐含的那样，动作就会把这些解析树组合起来。比如，对于列表运算符，语法树中通常会有某个节点类型表示列表。列表运算符的动作就是以列表节点为根，创建一棵子树，从组件匹配出的子树就会成为这个根的子节点。

#### 函数风格的组合子   

如果以函数式风格进行思考，组合子其实就是一个函数，它把输入组合子结果值映射到输出组合子的结果值上。组合子结果值的组件包括标记缓冲区的当前状态、匹配的当前状态，以及到目前为止已执行的累积动作的当前状态。遵循这种风格，序列运算符带有动作的实现如下：

```
CombinatorResult C (in)
    aResult = A (in)
    if (aResult.matchSuccess)
        then
        bResult = B(aResult)
        if (bResult.matchSuccess)
            then
            cResult.value = executeActions (aResult.value, bResult.value)
            return (true, bResult.tokens, cResult.value)
        else
            return (false, in.tokens, in.value)
    else return (false, in.tokens, in.value)
```

在这个版本里，因为输入参数的值总是有效的，所以并不需要进行保存。这个版本也让标记缓冲区的处理以及动作值的来源更为透明。

### 22.2 使用场景

在各种语言中都有程序库来实现不同的文法运算符。函数式语言是实现解析器组合子的一个显而易见的选择，因为它支持函数作为第一类对象，允许动作函数作为参数传递给组合子构造函数。然而，用其他语言实现也是可能的。

与递归下降语法解析器一样，解析器组合子也会产生一个自顶向下的解析器，因此它也会面对递归下降法语法解析器中同样的限制。但是，它也同时拥有递归下降语法解析器的许多优势，特别是，推理动作何时执行会很容易。即便解析器组合子是一个非常不同的解析器实现，也可以使用调试其他程序的同样工具来对解析控制算法进行跟踪。确实，解析器组合子方式同运算符程序库或者被测运算符实现之间产生了耦合，这么做会让语言实现者更多地关注动作而非解析。

解析器组合子最大的不足之处在于，仍然需要自行构建。另外，也无法获得成熟的解析器生成器给予精细解析以及错误处理特性。

### 解析器组合子例子（Java）

<!-- TODO：待补充-->

## 第23章 解析器生成器

文法文件是一种“描述DSL语法结构”的自然方式。有了文法，把它转成手写的解析器却是一件乏味的工作，乏味的工作应该交由计算机完成。

解析器生成器可以根据文法文件生成解析器。更新文法之后，只要重新生成，解析器也就更新了。既然解析器是生成的，它就可以使用一些难于手工构建和维护的高效技术。

### 23.1 工作原理

解析器生成器不是一件容易的事情，但是大多数编程语言平台都有对应的工具，并且通常开源。使用解析器生成器最为常见的方式是，编写文法文件。这个文件会用到解析器生成器特定的**BNF**。不要在这里期待任何的标准。如果更换解析器生成器，编写全新的文法是必然的。如果要产生输出，解析器生成器允许使用**外加代码**嵌入代码动作(code action)。

大多数解析器生成器都会用到代码生成，为不同的宿主语言生成解析器。并不会阻止解析器生成器在运行时读取文法文件，进行解析，也许还会构建出**解析器组合子**。解析器生成器采用代码生成，是综合传统和性能两方面考量的原因，特别是因为其主要目标是通用语言。

ANTLR解析器生成器说明了许多模式，并且是一个容易获得、成熟的工具，具有良好的文档支持，还有一个IDE风格的工具（ANTLRWorks），为开发文法提供了编辑易用的UI。

#### 嵌入动作

语法分析会产生语法分析树，如果要使用这棵树，就要嵌入进一步的代码。用**外加代码**把代码放到文法中。在文法中放置的位置就是执行代码的时机。嵌入代码放在**规则表达式(rule expression)**里，只要识别了这条规则，代码就会执行。

一个例子，只要见到事件声明，就会注册事件。

```
eventBlock  : Event-keyword eventDec* End-keyword;
eventDec    : Identifier Identifier {registerEvent($1, $2);}
```

这段代码说明：在`eventDec`这条规则里，解析器识别第二个标识符后会调用registerEvent方法。为了将语法分析树的数据传给registerEvent，需要以某种方式在规则中引用这些标记。`$1`和`$2`分别表示对应位置的标识符----这是Yacc解析器生成器的风格。

当生成器解析器时，动作就会生成到代码里。所以，嵌入的代码与生成器的解析器通常都会使用同一种语言。

对于在规则中嵌入代码以及把动作同规则联系起来，不同的解析器生成器工具有不同的处理方式。既然解析器的属性是创建语法分析树，在这棵树上来回移动数据就很有用。

动作定义了如何处理DSL，因此，编写方式取决于DSL整体的解析方式：**树的构建**、**内嵌解释器**和**嵌入式语法翻译**。

语义预测类似于动作，它是个外加代码块，但是它会返回一个布尔值，表示规则解析成功与否。动作不会影响到解析，但是语义动作会。如果文法语言无法描述所处理的文法，就使用语义预测。语义预测通常会用一些比较复杂的语言中。

### 23.2 使用场景

使用解析器生成器最大的优势在于，它提供了一个显式的文法，定义所处理语言的语法结构，解析器生成器还会提供良好的错误处理机制和诊断机制。

解析器生成器倾向于使用代码生成，这会让构建过程更复杂，这可能会是个大麻烦。

### 23.3 Hello World（Java和ANTLR）

<!-- TODO：待补充-->

#### 编写基本的文法

#### 构建语法分析器

#### 为文法添加代码动作

#### 使用代沟

## 第24章 树的构建

解析器会创建并返回源代码的语法树表示形式，用于在后续的树遍历代码中进行操作。

### 24.1 工作原理

使用**语法指导翻译**的解析器都会在解析的同时创建出一棵语法树。它会基于栈进行构建，在处理时修剪分支。使用树的构建，会创建解析器动作，在解析时在内存构建语法树。解析完毕，就得到这个DSL脚本的语法树。基于这个语法树，可以执行进一步的操作。如果使用的是**语义模型**，就运行代码遍历语法树，组装语义模型。

内存中创建的语法树并不直接对应于解析器在解析过程中实际创建的解析树。相反，构建的是抽象语法树。抽象语法树是解析树的一种简化，其为输入语言提供了一种更好的树表示形式。

通过解析输入来形成语法树，并以此来描述一种分层的数据结构。在下面的情形下，会使用语法树作为通用术语：解析树和AST是特殊类型的语法树。解析器是语法树，其直接对应于输入文本，而AST针对用途对输入做了一些简化。

要构建语法树，可以在BNF中使用代码动作。尤其是，代码动作返回节点值的能力对于这种方式是非常方便的----每个代码动作都会组成其在结果语法树上的节点表示形式。

一些解析器生成器还可以提供DSL以指定语法树。比如，在ANTLR中，可以使用下面的规则创建以上AST.

```
eventDec : name=ID code=ID -> ^(EVENT_DEC $name $code);
```

`->`运算符引入构建树的规则。规则体是一个列表，第一个元素是节点类型`(EVENT_DEC)`,后面跟着子节点，在这个例子中，就是名字和代码的标记。

使用DSL来构建树，可以极大地简化AST的构建。通常，支持这种做法的解析器生成器会在不提供任何树的构建规则的情况下，给出一棵解析树，不过，这棵解析树几乎用不到。通常，会使用这些规则把它简化成一棵AST。

以此方式构建出的AST，会由一组持有树上数据的通用对象组成。在上述例子中，eventDec是一个通用的树节点，具有作为其子节点的名字和代码。名字和代码都是通用的标记。如果采用动作节点自行构建树，这里就可以创建真正的对象----拨入，真正的事件对象，以名字和代码作为其字段。

### 24.2 使用场景

树的构建和嵌入式语法翻译都是解析时组成语义模型有用的方式、嵌入式语法翻译用一步完成转换，而树的构建用了两步，采用AST作为中间模型。采用树的构建的理由是，其将单个转换分解为两个更简单的转换。

树的构建可能要比其他做法消耗更多的内存，因为它要存储AST。然而，大多数情况下， 这不会有什么显著差别。

对于同样的AST，如果需要的话，可以有几种不同的处理方式，组成不同的语义模型，以重用解析器。

### 24.3 使用ANTLR的树构建语法（Java和ANTLR）

<!-- TODO：待补充-->

#### 标记解释

#### 解析

#### 组装语义模型

### 24.4 使用代码动作进行树的构建（Java和ANTLR）

## 第25章 嵌入式语法翻译

当使用语法指导翻译时，语法分析器只产生内部语法分析树，因而需要多一些努力才能生成语义模型。通过将代码嵌入语法分析器中，语法分析器在分析过程中的适合时刻组装语义模型，嵌入式语法翻译可以用于生成语义模型。

### 25.1 工作原理

语法分析主要关乎语法结构的识别。当使用嵌入式语法翻译时，将生成**语义模型**的代码放置在语法分析器中，随着语法分析的进行，可以逐渐产生语义模型。绝大多数情况下，需要在输入语言的子句被识别出来的地方放入模型填充代码，不过当实际情况需要时，也可以在其他地方放置它们。

当结合解析器生成器使用嵌入式语法翻译时，通常会发现生成代码会以**外加代码**的形式出现。大部分解析器生成器都支持外加代码的使用。

带有副作用的代码会给嵌入式语法翻译的使用带来问题，经常会在非预期的情况下执行，而具体的执行行为则取决于语法分析算法如何识别语法规则，由于副作用的存在，这可能会搞乱环境中的其他变量的值。而使用树的构建则不会有这个问题，因为它只会产生某个子树的值。

### 25.2 使用场景

嵌入式语法翻译最有吸引力的地方在于，提供一种简单的方式，可以在一遍处理中同时处理语法分析和模型的生成。而使用树的构建则需要提供生成抽象语法树的代码，以及根据AST生成模型的代码。

嵌入式语法翻译最大的问题在于，它会使文法文件变得很复杂，尤其是外加代码没有很好地使用的时候。

嵌入式语法翻译很好地符合了单遍语法分析的要求，所有工作都可以在语法分析阶段完成。但这意味这某些工作在嵌入式语法翻译中会变得很困难。

### 25.3 示例（Java和ANTLR）

<!-- TODO：待补充-->

## 第26章 内嵌解释器

内嵌解释器在文法分析的过程中解析DSL脚本，因而使得文法解析的结果就是脚本的执行结果。

### 26.1 工作原理

内嵌解释器通过尽可能早地计算DSL表达式，收集结果并将这些最终结果返回。内嵌解释器不实用语义模型，而是直接在DSL的输入上完成解释过程。随着语法分析器解析出DSL脚本的每个片段，解释器就会对这些片段进行解释。

### 26.2 使用场景

当需要计算的表达式很简单的时候，可能会非常有用。即使是一个很小的DSL，通过创建语义模型并解释它，也会比直接在语法分析器里做所有事情容易的多。

### 26.3 计算器（Java和ANTLR）

计算器可能是用于阐明内嵌解释器的最好例子，它的每一个表达式都很简单，可以很容易地解释，结果也很容易组合在一起。此外，数学表达式的语法树本身就是一个很好的语义模型，不必为它再单独创建一个语义模型。

从最顶层的语法规则开始，因为算术表达式是递归的，所以ANTLR需要一个顶层语法规则作为文法分析的起始点。

```
grammer "Arith.g" ......
    prog returns [double result] : e=expression {$result = $e.result;};
```

为了ANTLR文法文件创造一个简单的Java包装类，并从这个类中调用刚才定义的顶层语法规则:

```java
class Calculator {
    public static double evaluate(String expression) {
        try {
            Lexer lexer = new ArithLexer(new ANTLRReaderStream(new StringReader(expression)));
            ArithParser parser = new ArithPaser(new CommandTokenStream(lexer));
            return paeser.prog();
        }
        catch (IOException e) {
            throw new RuntimeException(e);
        }
        catch (RecognitionException e) {
            throw new RuntimeException(e);
        }
    }
}
```

由于嵌套的运算符表达式特性，需要从优先级最低的运算符开始，在这个例子里是加法和减法。

```antlr
grammer "Arith.g"
    expression returns [double result]
      : a=multi_exp {$result = $a.result;}
        ( '+' b=mult_exp {$result += $b.result;}
        | '-' b=mult_exp {$result -= $b.result;}
        )
    ;
```

这段代码展示了计算器的一般模式，每一条语法规则识别一个运算符，然后执行一段内嵌的Java代码来完成计算。其余部分和这个模式类似。

```antlr
grammer "Arith.g"
    power_exp returns [double result]
      : a=unary_exp {$result = $a.result;}
        ( '**' b=mult_exp {$result = Math.pow($result, $b.result);}
        | '//' b=mult_exp {$result = Math.pow($result, 1.0 / $b.result);}
        )
    ;

    unary_exp returns [double result]
      : '-' a=unary_exp {$result = -$a.result;}
      | a=factor_exp {$result = $a.result;}
      ;    

    factor_exp returns [double result]
      : n=NUMBER {$result = Double.parseDouble($n.text);}
      | a=par_exp {$result = $a.result;}
      ;     

    par_exp returns [double result]
      : '(' a=expression ')' {$result = $a.result;}
      ;
```

这个计算器非常简单，它的结构和语法树非常一致，因此甚至不需要使用嵌入助手。

## 第27章 外加代码

DSL从定义上讲是仅能完成一些功能且语法结构有限的语言。但是需要在DSL中描述超过其表达能力的东西。一个选择是扩展DSL脚本使其具有处理这些复杂度的能力，但是这么做可能会让DSL变得非常复杂。外加代码则是另一个选择，它讲不同的语言----通常是通用语言----嵌入DSL中。

### 27.1 工作原理

外加代码仅在DSL脚本的特点位置出现，因此DSL的文法需要定义它们可以在哪里出现。通常结合**可变分词方式**使用外加代码，将它作为一个长字符串读入解析器。然后，可以选择是把它直接保存在语义模型中，还是通过独立的语法解析器分析它的内容，再把相应的结果放置在语义模型中。第二种方式更加费时费力，如果外加代码是另一种DSL的话，倒不失为一种选择。而如果使用通用语言，那么作为字符保存就够了。

一旦外加代码保存到语义模型中，必须抉择如何处理它。最大的问题就是它是否可以解释，还是必须要经过编译

如果宿主语言通常有方法可以与解释器交互操作，那么解释执行的外加代码通常是最简单的，如果使用的宿主语言本来就是可以解释的，那么可以把它作为DSL的外加代码。如果宿主语言是可以编译的，那么需要使用一种可以解释的语言，它可以从宿主语言中调用，这样可以从DSL向外加代码传入数据。

另一种做法是把宿主语言直接嵌入DSL中，这种做法会在构建过程中引入额外的编译步骤，其情形和使用代码生成类似。

当使用通用语言作为外加代码时，应该考虑使用嵌入助手。这样可以简化DSL脚本中的外加代码，对于所有处理，仅需调用对应的嵌入助手。外加代码存在的一个问题是，太多的外加代码可能会淹没DSL脚本，这将丧失DSL在可读性上的优势。嵌入助手是一种简单的技术。

有时候外加代码需要引入DSL脚本中定义的符号，这仅仅发生在DSL脚本中存在变量或其他间接构造的情况下。

### 27.2 使用场景

当考虑使用外加代码时，通常还可以选择扩展DSL来实现外加代码的功能。引入外加代码有明显的不足之处，它将会破坏DSL提供的抽象能力，阅读DSL的人需要同时理解外加代码和DSL本身。而且使用外加代码将会让构建过程变得复杂，通常也会让语义模型变得复杂。

这些额外的复杂度需要根据为了支持这些特性而在DSL中引入的复杂度进行权衡。通常而言，DSL功能越强，它就越难理解和使用。

使用外加代码的场景：需要使用通用语言，但是不希望把DSL变成通用语言。

### 27.3 嵌入动态代码（ANTLR，Java和JavaScript）

<!-- TODO：待补充-->

#### 语义模型

#### 语法分析器

## 第28章 可变分词方式
 
### 28.1 工作原理

词法分析器向语法分析器提供标记流，然后语法分析器把标记流组装成语法分析树，有些时候词法分析器需要根据当前在语法树中所处的位置改变行为，这就意味着语法分析器需要改变词法分析器分词的方式。

在item关键字之后识别任意多个词的最简单文法如下所示：

```
catalog : item*;
item    : 'item' ID* ';';
```

这样的文法无法处理其名称含有“item”的条目名称，比如`item small white item;`。词法分析器将`item`识别为关键字而不是词，希望实现的是将关键字`item`和分号之间的所有东西都识别为ID。实际上就是在文法分析器中修改分词规则。

对于这种情况，另外一个常见的例子是**外加代码**，它可能会在DSL脚本中包含任意种类的有意义标记，但是希望忽略所有这些，仅仅把它们当做一个字符串，嵌入**语义模型**中。

#### 字符引用

处理这个问题最简单的方式是把文本括起来，这样词法分析器就可以把它们当做特殊的情况来处理。对于上述的例子而言，可以通过某种引用符号把文字括起来，比如，下面这个例子:

```
item camera
item small power plant;
item "small white item";
```

对应的文法为：

```
catalog  :  item*;
item     :  'item' item_name ';'
item_name : (ID | QUOTED_STRING)*;
QUOTED_STRING : '"' (options{greedy = false;} : .)* '"'
```

字符引用将会把分隔符之间的所有文本去掉，因此它不会被其他词法规干扰。可以从中取出引用的文本任意进行处理。字符引用不会用到任何分析器，因此某个引用形式必须出现在整个语言中。不能指定特殊规则，仅仅去引用特定的语言元素。对于很多情况而言，这已经足够好了。

字符引用有个比较尴尬的地方，就是引用字符串中出现分隔符，比如，Active “Marauders” Map。对于这个例子，需要处理引用字符串中的引号。

第一种方式是提供转义机制，比如反斜线和双写分隔符号；第二种方式是选择不常见并且不容易出现在引用的文本中的符号组合来作为分隔符号；第三种方式是使用多种分隔符，因此当需要嵌入某个分隔字符时，可以切换到另一种引用方式。很多脚本语言都允许使用单引号或双引号来引用字符串，不同的分隔符也会使用不同的转义机制。

#### 词法状态

根据词法分析器的状态进行切换，当发现关键字item时，将通常的词法分析器换成另外一个，直到后一个词法分析器看到分号为止，再把词法分析器换回之前使用的哪个。

使用词法状态时，如果使用通用的边界标记，可以避免由于只有一个预判标记带来的问题。否则，就需要小心处理语法分析器的预判标记和词法状态间的交互。因此组合使用语法分析预判标记和词法状态很容易变得非常混乱。

#### 修改标记类型

语法分析器根据标记的类型而不是内容采取对应的行为。如果可以在标记到达语法分析器之前修改它的类型，就能将关键字`item`变成文本词`item`。

这个做法和词法分析器状态正好相反，对于词法分析状态而言，需要让词法分析器向语法分析器提供标记，每次一个。而使用这种方法，需要在标记流中提前寻找。这种方法更适合ANTLR而不是Yacc。

比如Hibernate解析HQL的方式，HSQL必须处理作为关键字的“order”(order by)以及作为列名或表名的`order`。词法分析器默认将`order`作为关键字，但是语法分析器将检查其后是否是`by`,如果不是就将它的类型变成标识符。

#### 忽略标记类型

如果标记类型不重要而希望获得全部文本内容，那么可以忽略所有的标记类型，然后直接抓取所有内容，直到发现卫兵(ssentinel)标记为止(这里是分隔符)。

```
catalog : item*;
item : 'item' item_name SEP;
item_name : -SEP*;
SEP : ';'
```

基本的做法就是编写条目名称规则，可以接受除分隔符外的所有标记。通过取反运算符在ANTLR中这可以很容易实现，但是其他**解析器生成器**可能不具有这种能力。如果不幸如此，那么可能需要这样做：

```
item  :  (ID | 'item')* SEP;
```

需要在这条规则中列出所有关键字，比起只使用一个取反运算符，这更尴尬。标记仍然会携带正确的类型信息，但是在这个语境中并不需要使用它。

### 28.2 使用场景

如果使用语法指导翻译并且分离词法和语法分析时----通常而言是这样的----可变分词方式会是一种有意义的技术。当有一段特殊文本不应该使用常规方案分词的时候，可能会需要使用它。

可变分词方式的常用场景包括：在特定语境下不应该当做关键字的关键字，任意形式的文本(通常对于散文描述)以及**外加代码**。

## 第29章 嵌套的运算符表达式

嵌套的运算符表达式是语法分析中一个常见的问题，尤其是在自底向上的分析器中需要消除左递归的时候。

### 29.1 工作原理

嵌套的运算符表达式有两个方面让它变得比较难处理：其递归本性以及运算符优先级。虽然具体如何来处理这些问题部分呢取决于所使用的**解析器生成器**，但是仍然有些有用的通用原则可以采用。这里最大的差异是自底向上和自顶向下的语法分析器如何处理它们。

一个常用的例子是计算器，它可以处理四种常见的算术运算`(+,-,*,/)`、圆括号表达式求值、`幂(**)`以及`开方(//)`。它还支持一元运算符----负号。

选择这些运算符，意味着需要不同的运算符优先级。负号的优先级最高，其次是幂和开方，然后是乘除操作，最后是加减。这里引入了幂和开方，它们是右结合运算符，而其他二元运算符都是左结合的。

#### 使用自底向上的语法分析器

将从自底向上的语法分析器开始，因为它们是最容易描述的。用于处理四则运算表达式的基本文法式这样的：

```bnf
expr ::= 
    NUMBER:n {: RESULT = new Double(n); :}
  | expr:a PLUS expr:b   {: RESULT = a + b :}
  | expr:a MINUS expr:b  {: RESULT = a - b :}
  | expr:a TIMES expr:b  {: RESULT = a * b :}
  | expr:a DIVIDE expr:b {: RESULT = a / b :}
  | expr:a POWER expr:b  {: RESULT = Math.pow(a, b); :}
  | expr:a ROOT expr:b   {: RESULT = Math.pow(a, (1.0/b)); :}
  | UMINUS expr:e         {: RESULT = - e; :}
  | LPAREN expr:e RPAREN {: RESULT = e; :}
```

这个文法使用Java CUP----经典的Yacc系统的Java版----作为解析器生成器。在这个文法里，表达式语法的结构通过一条产生式规则来表示，这个产生式规则来表示，这个产生式规则的每个分支都表达一种运算符，然后基本情况是只会有数字出现。

与这里使用了**内嵌解释器**来完成计算，可以在每个分支定义后面看到计算结果的代码（代码通过`{:`和`:}`分隔，用于区分代码中的花括号）。特殊变量RESULT用来表示返回值：规则中的元素通过末尾的`:label`标识出来。

这个基本文法可以直接处理递归结构，但是不能处理运算符优先级：希望`1+2*3`解释成`1+(2*3)`。为此需要声明运算符的优先级。

```
precedence left PLUS, MINUS
precedence left TIMES, DIVIDE
precedence right POWER, ROOT
precedence left UNIMUS
```

每条优先级语句列出相同优先级的运算符，然后声明它们是如何与操作数结合的（左或者右）。优先级从低到高声明。

优先级也可以在文法规则中声明，比如，负号就是通过`%prec UNMINUS`来声明的。`UMINUS`是标记引用并不是真的标记，是为了调整优先级而引入的。通过使用这个与语境相关的优先级，可以告知解析器生成器，这条规则不使用`-`运算符的默认优先级，而是使用为`UMINUS`运算符声明的优先级。

在编程语言中，运算符优先级解决了表达式二义性。如果不使用优先级规则，语法分析器可以将`1+2*3`分析成`(1+2)*3`或`1+(2*3)`，这就带来了二义性。

通过结合递归文法规则和优先级声明，在自底向上的语法分析器中，可以较容易地处理嵌套表达式。

#### 自顶向下的语法分析器

当处理嵌套的运算符表达式时，自顶向下的语法分析器的情况比较复杂。不能使用递归文法，因为这将引入左递归。必须使用一组文法规则，通过它们同时处理左递归和优先级的问题。

通过ANTLR来定义计算器的语法规则：

```
expression : multi_exp ( ('+' | '-') multi_exp )*;
multi_exp : power_exp ( ('*' | '/') power_exp )*;
```

这里将会看到左结合运算符的模式，它的定义开始于下一优先级的规则定义，然后是由运算符和右侧元素组成的可重复组。在整个定义中，只引用了下一优先级的规则，而不会使用自身的定义规则。

幂和开方运算符则给出了右结合运算符的模式。

```
power_exp : unary_exp ( ('**' | '//') power_exp )?;
```

可以看出右结合和上面模式的差别。首先，右侧规则是对自身规则的递归引用，而不是对于下一优先级规则的引用。其次，它是个可选组而不是重复组。递归定义可以让多个幂表达式组合在一起，这样的右递归本身是右递归的。

一元表达式的负号是可选的。

```
unary_exp
    : '-' unary_exp
    | factor_exp
    ;
```

*注意：当负号存在（允许在同一表达式里存在多个负号）但在下一优先级表达式中不存在负号（避免左递归）的时候，是如何使用递归的*

语言中的原子元素和圆括号

```
factor_exp : NUMBER | par_exp;
par_exp : '(' expression ')';
```

圆括号表达式引入了深层递归，因为前者再次引用了最高层的表达式。

这个文法比其自底向上的例子要复杂的多，花费了很多时间来处理解析器生成器的问题，而不是表达意图。最终产生的语法很扭曲。由扭曲的文法带来的另一个问题是最终的语法分析树也会变得很复杂，比如希望的语法树如下：

```
+
    1
    2
```

但其实结果是:

```
+
    multi_exp
        power_exp
            unary_exp
                factor_exp
                    1
    multi_exp
        power_exp
            unary_exp
                factor_exp
                    2           
```

优先级的文法规则向语法分析树中添加大量凌乱的节点。

### 29.2 使用场景

嵌套的运算符表达式并不符合通常所描述的模式，如果是个更好的作者，就不需要写这样一章，而是可能会找到更何时的东西来写。

## 第30章 以换行符作为分隔符

### 30.1 工作原理

使用换行符标记语句的结束是编程语言的共有特性。这也很适合**分隔符指导翻译**，因为换行符主要用来分隔输入。但是在使用**语法指导翻译**时，换行符作为分隔符会引入一些陷阱。

换行符分隔符和语法指导翻译结合得不那么顺畅的原因是因为换行符分隔符通常扮演两个角色。除了语法角色外，它还为文件排版提供垂直方向上的空行。于是，它们会出现在不希望冒出语句分隔符的位置。

下面是一个使用行结束符作为分隔符的文法：

```
catalog  :  statement*;
statement : 'item' ID EOL

EOL :  '\r'? '\n';
ID  :  ('a'..'z' | 'A'..'Z' | '0'..'9' | '_' )+;
WS  :  (' ' | '\t')+ {$channel = HIDDEN;};
```

这个文法描述了物品列表，其中每行是一个物品，由关键字item开始，之后则是这个物品的标识符。这是个非常简单的语法，使用它作为语法分析的“Hello World”示例。虽然这个文法非常简单明了。但是仍然有一些常见的陷阱：

* 语句间的空行
* 第一条语句前的空行
* 最后一条语句后的空行
* 最后一条语句没有行结束符

前三条都是由空行引起的，但是在文法中它们可能需要不同的处理方式，也需要有针对性的测试。

处理空行有一个有效的办法，就是使用“语句结束规则”来匹配多个空行。可以将这个规则放在词法解析器里，因为它是一条正则规则（可以被正则表达式匹配）。而最后一种情况----最后一条语句缺少行结束符----则更复杂。为了解决这个问题，需要在词法解析器里匹配文件结束符（EOF）。然而，对于一些**解析器生成器**，这是办不到的。因此在ANTLR中，需要在文法中引入一条**语句结束(end-of-statement)**规则。

```
catalog  :  verticalSpace statement*;
statement : 'item' ID eos;
verticalSpace : EOL*;
eos:  EOL+ | EOF;
```

最后一条语句缺少结束符的办法----可以避免最后一条语句缺少结束符的问题----是将结束符当做分隔符而不是结束符。那么文法将变成这样：

```
catalog  :  verticalSpace statement (separator statement)* verticalSpace;
statement  :  'item' ID;
separator  :  EOL+;
verticalSpace  :  EOL*;  
```

第三种方案是将语句体作为目录每一行的可选项:

```
catalog  :  line*;
line  :  EOL | statement EOF | statement EOL;
statement : 'item' ID;
```

这条规通过显式地匹配文件结束符来避免最后一条语句缺少结束符的情况。如果无法匹配文件结束符，那么需要这样的规则：

```
catalog  :  line*  statement?;
line  :  statement? EOL;
statement : 'item' ID;
```

另外一种可能会给换行符分隔符带来麻烦的元素是注释。如果忽略所有的换行符，那么匹配到行尾的注释是个好办法，因为它可以轻易地将多余的换行符清除掉。而如果换行符是分隔符的话，清除换行符就是一个大问题了，因为通常注释都是写在语句后面的：

```
item laser # explain something
```

如果匹配的注释清除换行符，那么也将失去语句终止符。这类问题通常可以通过这样的表达式得到避免：

```
COMMENT : '#' - '\n'* {skip();};
```

对应的正则表达式如下：

```
Comment = #[^\n]*
```

另外一个需要考虑的问题是，在行过长的时候应该提供“行继续符”。这可以通过这样的词法分析器规则来完成：

```
CONTINUATION : '&' WS* EOL {skip();};
```

### 30.2 使用场景

当决定使用换行符作为分隔符，其实决定了两件事：语句具有分隔符且这个分隔符是换行符。由于DSL通常结构都比较简单，纵使不使用语句分隔符，语法解析器通常也可以根据指定的关键字分析出语境信息。

语句分隔符使得定位和发现错误变得容易起来。语法解析器通常需要一些检查点标记来定位错误，如果没有检查点，语法解析器就无法及时发现脚本中某一行的错误，从而使得错误消息混乱而不易理解。语句分隔符可以很好地扮演路标这个角色。

如果决定使用语句分隔符，那么可以选择使用可见的字符。使用换行符的好处是：绝大多数情况下，每行只有一条语句，因此换行符不会给DSL带来太多语法噪音----尤其是对于非程序员而言。使用换行符作为分隔符不好的地方是，当使用语法指导翻译时，会变得更加困难，必须使用之前讨论过的那些技术来解决这个问题，还需要用测试来覆盖那些常见的问题。

## 第31章 外部DSL补充

### 31.1 语法缩进

很多语言里面的元素都存在很强的层级结构。这个结构通常编码为某种嵌套的块。所以也许可以用下面的语法来描述欧洲的结构

```
Europe {
    Denmark
    France
    Great Britain {
        England
        Scotland
        #...
    }
    #...
}
```

这个例子展示了各类程序员演示其程序层次结构的通用方法。关于结构的语法信息包含在分隔符之间。然而，当读这个结构的时候，会在格式上面花费额外的时间。读到的主要结构形式是缩进，而不是大括号。再比如下面的格式化代码：

```
Europe
    Denmark
    France
    Great Britain
        England
        Scotland
```

在这种方式下，缩进就像它展示的格式一样定义结构。这种方式在Python里面常用，它也被YAML使用----一种描述数据结构的语言。

从实用性角度出发，语法缩进的最大优势在于其定义与所视总是保持一致的----不会因为修改了格式但却没有修改真正的结构而让自己迷惑不解。

如果使用语法缩进，要小心制表符与空格之间的相互影响。因为制表符宽度因为本文编辑器的设置不同而不同。所以在一个文件里面混合使用制表符与空格可能会导致迷惑。一个解决方案是杜绝使用制表符，但是makefile中使用制表符。

语法缩进用起来非常方便，但是却给解析器带来了一些困难，比如Python与YAML的解析器实现就非常复杂。

解析器是在词法分析器里面处理语法缩进，因为词法分析器是处理字符的语法指导翻译系统的一部分。分隔符指导翻译可能不是一个处理语法缩进的好模式，因为语法缩进都是关于统计块结构的，而分隔符指导翻译在这方面有问题。

一个通用而且认为有效的策略是使用词法分析器在检测到缩进的变化时，输出特殊的**缩进**和**顶前(dedent)**标记给解析器。使用这些虚构的标记可以使用处理块的普通技巧来编写解析器----而不是使用`{`和`}`。

另一种方式是在词法分析器之前预处理输入文本。这个预处理只关注于识别 缩进的修改，当找到的时候就往文本里面插入特殊的文本标记。这些文本标记接下来可以被词法分析器用普通的方法识别处理。需要选择不会与语言的其他东西相冲突的标记。也必须考虑这会如何影响诊断器告诉行号和列号。但是这种方式会极大地简化语法缩进的词法分析。

### 31.2 模块化文法

对DSL的约束越多，它们就会越好。有限的表达性使他们易于理解，使用和处理。DSL最大的危险之一是增加过多的表达性----导致语言掉入陷阱，一不留神就变成了通用语言。

为了避免这个问题，能够将独立的DSL结合在一起是非常有用的。要做到这些，需要对不同的部分独立的解析，不同的DSL使用单独的文法，但又能将这些文法编织入单个整体解析器。希望能够从文法里面引用不同的文法，因此如果被引用的文法修改了，不需要修改自己的文法。模块化文法让现在使用可重用库的相同方法使用可重用的文法。

模块化文法，虽然对于DSL很有用，但在语言领域并不是一个很好理解的领域。一些人正在深入研讨这个主题。

大多数解析器生成器使用了单独的词法分析器，进一步让模块化文法的使用变得复杂，因为不同的文法通常需要与父级文法不同的词法分析器。可以通过使用可变分词方式绕过这个问题，但那给子级文法如何适配父级文法增加了约束。

# 第四部分

## 第32章 表达式生成器

设计API的目的是让对象提供一套自立的方法。理解情况下，这些方法都可以单独理解。称这种风格的API为命令-查询API。而DSL需要另外一种API，称为连贯接口，其设计原则是追求整个表达式的可读性。连贯接口使得每个方法不再具有独立的含义，这违反了命令-查询API设计的原则。

表达式生成器作为一个独立的层次，在常规API之上提供连贯接口。。采用这种做法，就拥有了两种风格的接口，连贯接口被清晰地隔离开来。

### 32.1 工作原理

表达式生成器对象提供一组连贯接口，之后将连贯接口调用转换为对低层命令-查询API的调用。可以把它想象为翻译层----从连贯接口到命令-查询API。表达式生成器通常使用组合模式，通过一组子表达式生成器在整个子句中构建子表达式。

如何组织表达式生成器取决于需要处理的子句是什么样子的。通过**方法级联**来调用一系列方法，每一个方法都返回表达式生成器：**嵌套函数**可以使用表达式生成器作为父类或一组全局函数。因此无法在这里给出表达式生成器的通则。可以参考其他内部DSL模式例子中不同种类的表达式生成器。

一个值得注意的问题是：是应该为整个DSL提供一个表达式生成器对象，还是为DSL的不同部分提供多个表达式生成器。多个表达式生成器通常遵循树型结构，后者通常是DSL的语法树。DSL越复杂，表达式生成器树越重要。

另一个建议是，为了确保有结构良好的**语义模型**，更清晰地隔离表达式生成器。语义模型上应该定义有命令-查询接口，可以不借助任何连贯接口进行访问----要验证这件事，可以尝试在使用任何DSL的情况下，对语义模型进行测试。内部DSL的目的就是为了简化对这些对象的访问。通常在测试中使用DSL比使用命令-查询接口容易的多。

然后可以在这些模型之上使用表达式生成器，并且可以通过对表达式生成器操纵的语义模型，直接调用语义模型命令-查询API，来对表达式生成器进行测试。

### 32.2 使用场景

如果不使用表达式生成器，那么可以把连贯方法放置在**语义模型**上。但是一个问题是这将使构造语义模型和执行模型的方法混在一起----而通常它们并不应该有什么关联。语义模型的执行逻辑通常并不容易理解，尤其如果它表达式另一个计算模型。而连贯接口则有它自己的逻辑来保持连贯性。

另外一个原因是连贯接口并不常见。将连贯接口和命令-查询方法放在同一个类上，同一个API就出现了两种表达方式。事实是连贯API比较罕见，而开发人员并不太熟悉连贯接口的方式，这使得整个情况都变得更糟糕。

对于不使用表达式生成器的一个论点是：如果语义模型的执行逻辑足够简单，那么把构建逻辑放在模型中并不会增加任何复杂度。

### 32.3 具有和没有生成器的连贯日历（Java）

<!-- TODO：待补充-->

### 32.4 对于日历使用多个生成器（Java）

<!-- TODO：待补充-->

## 第33章 函数序列

将函数调用组合成语句序列：

```
computer();
    processor();
        cores(2);
        speed(2500);
        i386();
    disk();
        size(150);
    disk();
        size(75);
        speed(7200);
        sata();
```

### 33.1 工作原理

函数序列将产生一系列函数调用，而这次调用除了时序上的关系外，没有任何----特别是数据上的一一关联。正因为这样，函数调用之间的任何关系需要通过数据解析来实现，因此，当使用函数序列时，通常意味着还会使用**语境变量**。

为了使得函数序列更容易阅读，通常使用最简单函数调用----一个做法是使用语言中提供的全局函数。但是会带来两个问题：静态的分析数据以及这些函数必须是全局的事实。

全局函数的问题在于它们是全局可见的。如果所使用的语言提供了命名空间支持，那么可以使用它，将这些函数的作用域降低到仅对于**表达式生成器**。Java中的静态导入就是这样一种特殊机制，如果语言不支持全局函数机制，那么就必须使用隐式类方法类处理这些调用。这将会给DSL带来一些噪音。

虽然全局函数最明显的问题是全局可见性，但是讨厌的问题却是会强迫使用静态数据。通常而言静态数据是个棘手的问题，无法确认到底有哪部分使用了它----特别是在多线程的环境中。这个问题对于函数序列更是有害，为了使它正常工作，会用到很多的语境变量对象。

解决全局作用域和静态数据的方案是使用**对象范围**，他可以将所有函数以面向对象的方式放置在类中，然后可以将解析的数据放置到某个对象里。

### 33.2 使用场景

函数序列的用处是最少的，组合DSL函数调用的方式。使用**语境变量**跟踪分析进度始终很不方便，导致代码难以理解且容易出错。

通常，DSL需要在最外层调用一些语句，而仅仅需要单个结果列表和一个语境变量来对数据进行跟踪，将这些语句组合称函数序列就是一个可行的方案。在语言的最外层或者**嵌套闭包**的最顶层中使用函数序列是个合理的选择。当然如果不是在这些地方，那么为了构成表达式，可能需要**嵌套函数**和**方法级联**。

使用函数序列最主要的原因是，DSL总可以从函数序列开始----哪怕只有一个调用。这是因为其他所有的DSL技术都需要一个语境，而函数序列则不用。

函数序列可以是由不同元素组成的列表，因此也可以使用**列表的字面构造**作为它的一个替代品。

### 33.3 简单的计算机配置（Java）

<!-- TODO：待补充-->

## 第34章 嵌套函数

通过将函数调用嵌套变为其他调用的参数列表来创建函数：

```
computer(
    processor(
        cores(2),
        speed(2500),
        i386
    ),
    disk(
        size(150)
    ),
    disk(
        size(75),
        speed(7200),
        SATA
    )
)
```

### 34.1 工作原理

通过把DSL语句表示成嵌套函数，可以在某种程度上反映出对应于宿主语言的层次结构本质，而不仅仅是一种格式化约定。

嵌套函数的一个显著特征是，它会影响它的参数的计算顺序。**函数序列**和**方法级联**都是以从左到右的顺序计算函数。而嵌套函数会在封闭函数之前，计算此函数的参数。

随后计算封闭函数会很方便，因为它提供了一个使用参数的内置上下文。假设定一个计算机处理器配置：

```
processor(cores(2), speed(2500), i386())
```

这样processor函数就可以把参数函数返回的完整的值组装到它的返回值里。因为processor函数是最后才计算的，所以不需要担心方法级联的停止问题，也不需要函数序列所必需的**语境变量**。

通过语法中的强制性元素，以及`parent::=first second`这样的代码，嵌套函数工作得尤其的好。父函数可以精确定义子函数所需的函数，而且通过静态类型语言，还可以定义返回类型，这样可以让IDE支持自动补全功能。

函数参数存在的问题之一是如何标识它们以具备可读性。可选参数也可能产生问题。如果基础语言支持函数的默认参数，可以将其用在可选的情况下。如果没有这样的支持，方法之一就是为可选参数的每个组合定义不同的函数。如果需要处理几种情况。随着可选参数的数目增加，处理的情况更加复杂。这种问题的一种解决方法是，再次使用中间数据----标记是个特别有效的选择。

对于同一调用中的多个参数的情况，如果宿主语言能支持，可变参数是最好的选择。也可以把它看嵌套的“列表的字面构造”。不同种类的多个参数最后就像是具有相同复杂度的可选参数。

最糟糕的情况是像`parent::=(this|that)*`这样的语法。问题在于：除非有关键字参数，否则唯一识别参数的办法就是通过它们的位置和类型。如果this和that有相同的类型，就会让挑出哪个参数是混乱的，哪个参数是直白的变得没那么容易。一旦这种情况发生，就不得不要么返回中间结果，要么使用语境变量。

为了让DSL具备一定的可读性，通常会希望嵌套函数是裸函数调用。要么需要把它们变成全局函数，要么使用**对象范围**。因为全局函数是有问题的，所以如果可以，通常会尝试使用**对象范围**。然而，全局函数一般在嵌套函数中问题要少得多，因为全局函数的最大问题往往发生在当具有全局解析状态时。如果一个全局函数只返回一个值。

### 34.2 使用场景

嵌套函数最大的优点也是缺点之一是计算顺序。通过嵌套函数，参数会在父函数之前进行计算，除非对参数使用**闭包**。这对于增强值的层次很有帮助，因为可以从参数创建由父函数装配的完整模型对象。这样可以避免在使用**函数序列**和**方法级联**时涉及替换和中间数据的很多工作。

嵌套函数中的可选参数和多个可变参数通常很棘手。嵌套函数非常期望明确说出你想要的，以及期望的精确顺序，因此如果需要更大的灵活性，需要尝试方法级联或者**Literal MAp**。Literal Map通常是个不错的选择，因为允许在调用父函数之前对参数排序，同时提供参数的排序和选择上的灵活性，尤其在涉及哈希参数的时候。

**嵌套函数**的另一个缺点是它的标点符号，通常依赖于匹配方括号和在正确位置标注逗号。最糟糕的情况下，可以把它看做变形的Lisp，带着所有的圆括号和附加的瑕疵。

命名冲突相比较函数序列而言也不是个大麻烦，因为父函数提供了上下文来解释嵌套的函数调用。

### 34.3 简单计算机配置范例（Java）

<!-- TODO：待补充-->

### 34.4 用标记处理多个不同的参数（C#）

<!-- TODO：待补充-->

### 34.5 针对IDE支持使用子类型标记（Java）

<!-- TODO：待补充-->

### 34.6 使用对象初始化器（C#）

<!-- TODO：待补充-->

### 34.7 周期性事件（C#）

<!-- TODO：待补充-->

#### 语义模型

#### DSL

## 第35章 方法级联

让修饰符方法返回宿主对象，这样就可以在一个表达式中调用多个修饰符

```
computer()
    .processor()
        .cores(2)
        .speed(2500)
        .i386()
    .disk()
        .size(150)
    .disk()
        .size(75)
        .speed(7200)
        .sata()
    .end()
```

### 35.1 工作原理

方法级联因为看起来很像内部DSL，所以前者很快流行起来。它的通常形式是**表达式生成器**。例子：硬盘驱动器，可以使用普通的命令-查询API创建它，下面这样：

```java
HardDrive hd = new HardDrive();
hd.setCapacity(150);
hd.setExternal(true);
hd.setSpeed(7200);
```

创建了一个对象，把它放到变量里，然后使用一些`setter`来操作它的属性。对于三个这样的属性，一般更喜欢使用构造函数，但假设会有很多这样的属性。DSL通常是关于构建对象的配置，如果在构造方法中做这件事可读性不好，因为构造函数要求传入的参数位置正确。

使用方法级联，会写出如下形式：

```java
new HardDrive().capacity(150).external().speed(7200);
```

Java中的实现方法返回对象自身：

```java
private HardDrive speed(int arg) {
    speed = arg;
    return this;
}
```

修改方法有返回值违反了命令-查询分离的原则。而连贯接口是需要违反这个原则的一个例外。

像这样使用方法级联还有第二个后果----方法的命名。在很多命令规范里面，像`sata()`这样的方法看起来更像是查询，而不是修改器。这样的命名很有问题，因为会让本期望是命令-查询API的人感觉非常困惑。结合这两者，方法级联违反了很多通用命令-查询API设计的普通规则。

方法级联不仅改变了API设计的规则，它还隐含着对格式规范的改变。通常，会试图把多个方法的调用放在同一行，但这样的话常常的方法级联看起来不美观，因此可以把每个调用放在单独的行上，格式化方法级联：

```java
new HardDrive()
    .capacity(150)
    .external()
    .speed(7200);
```

#### 生成器还是值

在表达式生成器之外使用方法级联可能也是有用的，比如在`42.grams.flour`中，在这种情况下，通过一个Value Object序列来构建表达式。grams方法（使用**为字面量提供扩展**定义在整数上），并返回一个拥有flour方法的数量对象，flour方法返回某种成分。并不仅仅是单个表达式生成器，有一个规则对象序列。通常，如果你看到这样的对象，它们就是Value Object。

在表达式中的每一步，都看到一次变化成新的类型，可以称作**类型变形(type transmogrification)**。当然也可以使用表达式生成器，来明确地分离命令-查询风格和连贯API的风格。

#### 收尾问题

收尾问题是方法级联的常见问题。问题归结为于方法级联缺少明确的终点。假设有一个关于预约生成器，其表达式像下面这样：

```cs
var dentist = new AppointmentBuilder()
    .From(1300)
    .To(1400)
    .For("dentist");
var dinner = new AppointmentBuilder()
    .From(1900)
    .To(2100)
    .For("dinner")
    .At("Turners");
```

希望返回值是一个Appointment对象，因为这会是最自然的用法。然而，继续进行方法级联的需求意味着每个方法必须返回一个`AppointmentBuilder`。在方法级联中没有能告诉什么时候结束，所以不得不在最后使用某种标记方法。

```cs
Appointment dentist = new AppointmentBuilder()
    .From(1300)
    .To(1400)
    .For("dentist")
    .End();
```

#### 分层结构

与收尾问题密切相连的，是方法级联无法自然地适应分层结构的问题。分层结构在主流语言中很常见，这也是考虑分层结构时语法树很有价值的原因。

一个是使用**语境变量**，比如`currentDisk`。每当看到disk方法，就可以更新语境变量。可以维护一个磁盘列表。然后每次更新列表中的最后一个磁盘。

通常，一个有用的方法是针对磁盘提供一个新的子生成器。单独的生成器可以在那些需要提供磁盘信息或者收尾方法的地方提供有限的可用方法。

#### 渐进式接口

基本的方法级联方法一个有价值的变种是，使用多个接口来驱动固定顺序的方法级联调用。例子：考虑如何构建Email消息。希望程序员首先指定目的地址、抄送人、主题，然后是正文。可以通过提供一个**表达式生成器**的接口序列来实现。第一个接口只有`to`方法。`to`方法返回一个接口，此接口只具有接下来合法的方法：`to`、`cc`和`subject`。`cc`方法返回一个只带有cc和subject的接口。`subject`方法返回一个只带有`body`方法的接口。

这可以在具备IDE支持的静态类型语言中工作得很好。IDE的自动补全功能会只提示方法级联中对于当前点有效的方法，从而可以逐步通过DSL的每个子句。

这种控制在哪些上下文中哪些方法是有效的能力，跟使用子生成器的方法中获得的能力类似。实际上，可以使用子生成器来实现跟渐进式接口一样的事情，但如果没有其他理由来创建子生成器的话，渐进式接口会更容易。

渐进式接口也可以用来在方法级联中实施必需的元素：在这里可以定义一个只接受单个强制元素的接口。

### 35.2 使用场景

方法级联可以为内部DSL添加极好的可读性，因此，它在一些人心目中已经成为内部DSL的同义词。然而，当方法级联和其他函数组合联合使用时前者是最好的。

方法级联在使用语言中的可选子句时工作得最好。方法级联很容易让DSL的脚本编写者挑选出特定情况下需要的子句。很难在语言中指定某些子句是必须存在的。使用渐进式接口可以给子句排序，但最后子句总是会省略掉。**嵌套函数**是对于强制性子句更好的选择。

收尾问题一次又一次地冒出来。虽然有一些权宜之计，但如果遇到它，最好使用嵌套函数或者嵌套闭包。这两个替代方案也是在遇到**语境变量**的困境时更好的选择。

### 35.3 简单的计算机配置范例（Java）

<!-- TODO：待补充-->

### 35.4 带有属性的方法级联（C#）

<!-- TODO：待补充-->

### 35.5 渐进式接口（C#）

<!-- TODO：待补充-->

## 第36章 对象范围

**嵌套函数**以及**函数序列**也许可以提供一种优雅的DSL语法，但是按照其基本形式来说，它们附带有极其严重的成本问题：全局函数以及全局状态。

通过把所有裸调用都解析为某个对象，对象范围可以缓解这些问题，可以避免全局函数对于全局命名空间带来的影响，同时也可以让在宿主对象中保存任意解析数据。最常见的实现方式是，在某个定义方法的生成器的子类中编写DSL脚本，这使得解析数据可以在对象中保存。

### 36.1 工作原理

面向对象技术有很多好处，比如每个对象为函数和数据提供了一个包含的作用域。而继承可以让分离作用域的使用和定义。DSL可以利用这些特性，在基类中定义函数，在子类中使用这些函数编写DSL程序。在基类还可以定义字段，用于保存需要解析的数据。

对于**表达式生成器**而言使用基类是个很好的选择。DSL的使用者可以在这个表达式生成器的子类中编写程序。使用继承可以让DSL的使用者在子类中添加他们所需的函数，还可以根据需要重写基类中定义的函数。

虽然继承是最常用的方式，但是有些语言还是提供了不同的做法。比如Ruby的实例判断，这个功能可以在某个对象的作用域内接受并执行任意代码。这样DSL编写者无须声明对于基类的引用，基类定义DSL语言，就可以编写DSL文本了。

### 36.2 使用场景

由于对象范围解决了**嵌套函数**和**函数序列**中存在的全局函数问题，因此这个方法总是值得考虑的。使用对象范围可以使得DSL脚本中所有裸函数调用都变成某个对象上的实例方法调用，这不仅避免了对于全局命名空间的干扰，还能使在**表达式生成器**对象上保存相关数据。

更常见的问题是，对象范围会限制DSL脚本放置的位置。对于继承的情况，必须将DSL脚本放置在表达式生成器子类的一个方法中。对于自成体系的DSL脚本，这不是什么问题。他们通常都有独立的问题，并且和其他代码有较好的隔离。唯一的问题是，在语法上有些噪音。也就是必须配置继承关系，但是这并不是什么突出的问题。真正的问题在于片段化的DSL，对于这种情况，通过继承来强制对象范围非常别扭，甚至是无法实现的。

对象范围是过分依赖全局函数的解药，但是必须记住，全局函数最大的问题来自于修改全局数据。而在一个常见的情况下，使用全局函数并不存在这个问题，那就是全局函数仅仅创建并返回新的对象，比如`Date.today()`。静态方法----实际上是全局函数的一种----可以有效地返回普通对象或者表达式生成器。如果可以把全局函数都像这样组织起来，那么对于对象范围的需求也就没有那么强烈了。

如果DSL框架允许DSL的用户为**对象范围**添加子类的话，DSL就会更具扩展性。用户定义的子类可以为DSL添加新方法。如果某些方法只在某个脚本里使用，那么用户可以在这个脚本的子类中直接定义这些方法。

### 36.3 安全代码（C#）

<!-- TODO：待补充-->

#### 语义模型

#### DSL

### 36.4 使用实例求值（Ruby）

<!-- TODO：待补充-->

### 36.5 使用实例初始化器（Java）

<!-- TODO：待补充-->

## 第37章 闭包

可由对象（或第一类数据结构）表示的代码块，通过引用词法作用域内的变量，可与流程代码无缝地结合在一起。

```cs
var threshold = ComputeThreshold();
var heavyTravellers = employeeList.FindAll(e => e.MilesOfCommute > threshold);
```

已知的闭包结构有：lambda表达式、代码块或者匿名函数。

假设希望可以通过不同的方法筛选对象，如果为每个筛选方法都提供独立的实现的话，那么可能会有很多重复的代码。

通过使用闭包，可以将筛选器的设置处理流程作为独立因子提取出来，并针对每个筛选条件传递任何代码块。

### 37.1 工作原理

尽管闭包作为一种语言特性已经存在很久了，但直到最近它才被很多软件开发人员所关注。闭包是可以当做对象的代码块。本质上，闭包是一种更优雅的方案，可以很容易地创建一个代码段，然后把它作为对象传递，不同的语言中对闭包的定义有所不同，比如C+和Python中使用lambda表达式，C#中使用lambda表达式和匿名函数，Lua中就使用闭包作为命名。

### 37.2 使用场景

对于消除重复以及支持自定义控制结构而言，闭包是非常有用的工具。闭包在DSL中扮演有用的角色。最明显的就是，它是**嵌套闭包**的核心元素。它也可以简化**适应性模型**的实现。

## 第38章 嵌套闭包

### 38.1 工作原理

嵌套闭包的基本思想与嵌套函数类似，只是函数调用的子表达式处于一个闭包中。

```ruby
processor(
    cores 2,
    i386
)
```

用嵌套闭包

```ruby
processor do
    cores 2
    i386
end
```

把子元素放在嵌套闭包中给实现上带来了一个直接的影响----必须加入对闭包求值的代码。通过嵌套函数，不需要这些工作，因为语言本身会在调用processor函数前先自动对cores和i386函数求值。而当参数用闭包传递时，processor函数先调用，闭包只有先显式编写了代码时才会求值。通常在processor函数在对闭包进行求值前后，有时也会做些其他任务，比如设置一些**语境变量**

在上面的例子中，闭包的内容是一个**函数序列**。函数序列的一个问题是多个函数调用之间通过隐藏的语境变量来通信。而在嵌套闭包中仍然需要这么做。不过，可以在processor函数判断闭包前先创建语境变量，然后在调用之后销毁。这样可以极大地降低语变量散落各处的问题。

另一种方式是使用**方法级联**。而且，这里有一项额外的好处：父函数可以设置调用链的开头，然后以参数形式传给闭包。

```ruby
processor do |p|
    p.cores(2).i386
end
```

通常，也可以传入一个语境变量作为参数。

```ruby
processor do |p|
    p.cores 2
    p.i386
end
```

这个例子里，使用了函数序列，但是其中的语境变量显式存在。这通常很容易理解，也不会添加多少混乱。

嵌套闭包中的裸函数会在定义它们的上下文中求值，所以，通常也应该采用**对象范围**。显式传递语境变量或者使用方法级联的做法可以避免同样的情况，以及把生成器代码组织到不同的生成器中。

有些语言允许操纵执行闭包的上下文，这样就可以使用裸函数，同时保留多个生成器。

### 38.2 使用场景

嵌套闭包是一种很有用的技术，因为它既有**嵌套函数**带来的清晰的层次化结构，又能任意控制是否对参数进行求值。这种能力带来了极大的灵活性，能帮你消除嵌套函数的许多局限性。

嵌套闭包最大局限性在于宿主语言对闭包的支持。许多语言根本就不提供闭包，还有很多虽然提供语言，但并不对DSL友好，比如，要求使用拗口的关键词。

通常可以把嵌套闭包看做对嵌套函数，**函数序列**以及**方法级联**的增强。有了对函数求值的隐式控制能力，这些技术各自有用了新的优势。但归根结底，不外乎可以在闭包调用前后做些特别的预置和清理工作。对函数序列额来说，这意味着能提前准备**语境变量**；而对方法级联来说，则可以在调用闭包前设置调用链的开头。

### 38.3 用嵌套闭包来包装函数序列（Ruby）

<!-- TODO：待补充-->

### 38.4 简单的C#示例（C#）

<!-- TODO：待补充-->

### 38.5 使用方法级联（Ruby）

<!-- TODO：待补充-->

### 38.6 带显式闭包参数的函数序列（Ruby）

<!-- TODO：待补充-->

### 38.7 采用实例级求值（Ruby）

<!-- TODO：待补充-->

## 第39章 列表的字面构造

通过列表的字面构造表示语言表达式

```
martin.follows("WardCunningham", "bigballofmud", "KentBeck", "neal4d");
```

### 39.1 工作原理

列表的字面构造是构造列表数据结构饿的编程语言特性。许多语言为列表的字面构造提供了直接的语法支持。其中最明显的就是Lisp的：Ruby也有类似的`[first,second,third]`----虽然不如Lisp的优雅。列表的字面构造通常都允许列表嵌套：事实上，整个Lisp程序都可以看做一个嵌套列表。

列表的字面构造经常用于表达函数调用。父函数从列表中提取一些元素，然后按照函数定义处理它们。

基于C语言的主流语言并不支持嵌套列表语法。通常有数组的字面构造`{1,2,3}`,但是通常仅仅允许其中的常量或字面量，而不像允许任意符号或表达式的通用语法。

有一个办法可以绕过这个限制，就是用变参函数，比如`companions(jo, saraJane,leela)`。在强类型语言中，变参调用的所有元素类型都必须是同样的类型。

### 39.2 使用场景

通过使用某些逻辑文法比如`(parent::=child*)`，列表的字面构造可以作为其他元素的一部分使用----通常是作为函数调用。通常列表中的元素也是函数调用本身，所以可以通过列表的字面构造来实现**嵌套函数**。

即便所使用的语言支持列表的字面构造，在函数调用中，最好仍然使用变参函数而不是列表。也就是，倾向于使用`conpanions(jo, saraJane, leela)`而不是`companions([jo, saraJane, leela])`

通过模仿Lisp，可以仅仅使用列表的字面构造来构造任何DSL。在其他非Lisp语言中，如果语言本身为提供了语法支持，可以让列表和其他形式的表达式有效地结合起来的话，那么这种做法就是非常有用的。

## 第40章 Literal Map

### 40.1 工作原理

Literal Map存在于很多语言中，是一种构造Map数据结构的语言结构（这种数据结构也叫做字典、散列表、散列或者关联数组）。它通常在函数调用中使用，函数接收Map并处理它。

在动态类型语言中，使用**Literal Map**面临的最大问题是无法保证键名的合法性。于是，不得不处理那些陌生的键，此外也无法告知DSL脚本编写者那些键是正确的。在静态类型语言中，可以通过定义特定类型的枚举为键来避免这个问题。

在动态类型语言中，Literal Map的键值通常是符号数据类型（或者字符串）。符号是最自然的选择，很多语言为了使符号键更容易使用，提供了简化的语法。比如Ruby，可以使用`{cores:2}`代替`{:cores>=2}`。

如将变参函数调用表示为**列表的字面构造**一样，使用Literal Map表示具有关键字参数的函数调用。其实关键字参数更好，允许定义哪些是合法的关键字/关键字参数是比Literal Map更少见的语法特性。

如果所使用的语言的只为Literal List提供语法支持，而不支持Literal Map，可以使用Literal List来表示Map。

### 40.2 使用场景

如果需要一个列表，其中的每个元素最多出现一次，Literal Map就是个非常不错的选择。虽然无法有效地验证键很令人恼火，但是总体而言，对于这种情况，该语法通常是最佳选择。但有一点需要讲清楚，所有元素最多只能出现一次，只有这样，Map数据结构才是处理调用函数最佳选择。

如果所使用的语言不支持Literal Map，可以使用**列表的字面构造**，**嵌套函数**或**方法级联**。

### 40.3 使用List和Map表达式计算机的配置信息（Ruby）

<!-- TODO：待补充-->

### 40.4 演化为Greenspun式（Ruby）

<!-- TODO：待补充-->

## 第41章 动态接收

任何对象定义的方法都是有限的。对象的调用方可能会尝试调用一个没有在接收方定义的方法。静态类型语言会在编译时发现这个问题，报告编译错误。于是便知道运行时不会再出这种问题。动态语言可以在运行时调用一个不存在的方法，这往往会抛出运行时错误。

动态接收允许改变这种行为，也就是说，可以换种响应未知消息的方式。

### 41.1 工作原理

许多动态语言对待未知方法调用的方式都是调用一个位于对象层次结构顶端的专用错误处理方法。这个方法没有标准名称，可以在自己的类里面重写这个方法，改变处理未知方法的方式。在做这件事情的时候，就从根本上动态改变了接收方法调用的规则。

在日常编程中动态接收是很有用的。支持动态委派给另一个对象就是个很好的例子。在原始的消息接受方定义想处理的方法，然后用动态接收把未知的消息全都发送给委派对象。动态接收在DSL上的用途也很多。常见的一个用法是把方法参数变成方法名。

### 41.2 使用场景

通过动态接收把参数放到方法名中还是挺有吸引力的。首先，它模仿的就是正常定义方法时要做的事情，但是减少了工作量。

其次，替换参数为方法名有助于保持标点符号的一致性。

把数据放入方法名会带来一些一个问题，编程语言对于程序文本所使用的编码方式跟字符串数据常常不一样：很多语言只支持ASCII编码，于是碰到非ASCII的人名就无法工作了。同样，方法名所遵守的语法规则也可能会把有效的人名排除在外。

只有在用动态接收构建通用结构，不处理任何特殊场景的时候，动态接收才会发挥应有的作用。换句话说，如果可以清晰地把动态方法转换成用于其他目的的方法，动态接收才值得一用。条件判断是很好的例子，因为它一般都会调用领域模型对象的属性。

动态接收存在很多问题，也有不少限制。最大的问题是完全没法在静态语言中使用它。但即便是在动态语言中，也要小心谨慎一些。一旦重写了处理未知方法调用的处理程序，犯任何的错误都有可能让陷入调试地狱。

动态接收不适用于复杂的条件判断表达式，并不意味着连简单的情况都不能用。

### 41.3 积分-使用方法名解析（Ruby）

<!-- TODO：待补充-->

#### 模型

#### 生成器

### 41.4 积分-使用方法级联（Ruby）

<!-- TODO：待补充-->

#### 模型

#### 生成器

## 第42章 标注

跟程序元素----如类、方法等相关的数据，可以在编译或者执行时进行处理。

```java
@ValidRange(lower = 1, upper = 1000, units = Units.LB)
private Quantity weight;
@ValidRange(lower = 1, upper = 120, units = Units.IN)
private Quantity height;
```

标注是描述程序元素的一段信息。可以获取这段信息并在运行时处理，如果环境支持的话，也可以在编译时处理。注解通过这种方式提供了扩展编程语言的机制。比如Java中的注解Annotation或者C#中的特性Attribute。

### 42.1 工作原理

使用标注要考虑两点：定义它们与处理它们。虽然二者所以来的技术都会因为语言的不同而有很大差异，但定义和处理之间是没有多少依赖关系的，比如同一种技术可以用来处理以不同方式定义的标注。

为了和DSL通用模型保持一致，下面的定义语法表现的是标注如何作为内部DSL工作。在每个例子中，它们都通过把数据附加到程序的运行时模型，创建**语义模型**，这个运行时模型是语言本身内置的。后面的处理步骤也都对应于语义模型的运行；跟任何DSL一样，都可以包括模型执行和代码生成。

#### 定义标注

比如Java中和C#中的Test标注分别为:

```java
@test public void softwareAlwaysWorks()
```

```cs
[test] public void SoftwareAlwaysWorks()
```

它们都允许在标注里面放参数，所以还可以这样做

```java
class PatientVisit {
    @ValidRange(lower = 1, upper = 1000, units = Units.LB)
    private Quantity weight;
    @ValidRange(lower = 1, upper = 120, units = Units.IN)
    private Quantity height;
}
```

使用专门设计的语言来定义标注是最显而易见的事情，也往往是最容易的。但还有其他的选择。

指定标注有一些很自然的方式，其中一种是使用类方法。加入要添加一个标注，用来指定字段的有效区间。在Ruby里面，这样描述：

```ruby
valid_range :height, 1..120
valid_range :weight, 1..1000
```

为了让这段代码可以执行，要定义一个类方法，名字叫`valid_range`。这个方法接受两个参数，一个是字段名，一个是字段的取值范围。这个方法可以对数据进行任何处理。它可以把裸数据放到一个结构中，跟内置的语法一样：或者直接创建validator对象并进行保存。

使用这种类方法就跟用专门设计的语言一样简单。最大的问题就是当调用类方法的时候需要标注的程序元素名称。这可能会让程序显得有些冗余，但却让程序员可以分开标注和标注的声明。

使用这种类方法要注意一些问题。这些要保存下来的标注需要执行。存储标注数据最简单的方式是使用类变量，但有很多语言会在类和子类之间共享类变量。

对于面向对象的语言标注的用法显而易见，不过对于任何一门语言，只要它可以方便地表述语言元素，就可以达到同样的效果。可以定义个Lisp结构体，其中将数据标注到对应的函数名上。可以将这个结构体存储在任何地方，留待后续处理。

在静态类型语言中，还有一个常用的技术是标记型接口。它的意思是定义一个无任何方法的接口，然后实现这个接口。接口实际上就给实现类打了标签，可以对此进行后续处理。但是这个技术只能用来类上，不能用于方法和字段。

命名惯例也是标注的一种简单形式。很多xUnit实现都是这样做的----依照惯例，测试方法在方法名前加上test。它可以用于简单的标注，但很难支持多重标注，也几乎不可能传入参数了。

在上面的例子中，标注会由内置的语言构造进行处理，生成语义模型。除了一般的内部DSL约束以外----DSL的语法受到宿主语言的限制，这里对标注还有另外一个约束。当使用标注的时候，语义模型只能是基于程序本身的基本表示方式的。面向对象程序的基本表示方式都是类、字段、方法。标注的语义模型是对这种结构的一种装饰----基本无法构造一个彻底独立并与该结构分离的语义模型。

#### 处理标注

标注是在源码中定义的，但可以在随后的阶段中进行处理----通常是在编译的时候，或者程序加载的时候，或者常规的运行时操作中。

在常规操作中处理标注可能是最常见的做法了。其中包括用标注来控制对象的某些行为，例如，执行xUnit风格测试框架中的测试方法。这种框架都允许把测试定义成测试类中的方法，但并非所有的方法都是测试方法，所以就使用标注来识别哪些才是真正的测试。测试运行程序会找到这些测试并执行。

数据库映射也可以以类似的方式工作。数据库映射程序会询问属性，找出字段和持久化存储结构之间的对应关系。然后它便用这些信息来建立数据映射。

这种处理方式可以在运行时和程序加载时共同完成。像上面的例子提到的校验标注，其中一部分是在程序启动时处理的，这个时候程序会创建validator随想，并把它们附加在类上。然后这些validator又会在程序执行的时候用于校验。

这些标注的运行时使用对应于DSL模型执行的通用方式。当然，跟任何DSL一样，代码生成也有不同方式。在动态语言中，代码生成可以在运行时完成----一般是在程序加载的时候，可以生成新类，或者往已有类中添加方法。

编译型语言在运行时生成代码就要复杂多了。虽然也可以在运行时进行编译，动态链接模块，但配置工作相当棘手。如果语言的编译器提供了钩子，那么也可以用来处理标注----Java正是这样做的。

当然，代码可以在编译前生成。对校验的例子而言，可以在宿主类里生成一个新方法，或者把校验作为一个单独的对象。这段代码会跟程序一起编译。但这种把编写的代码和生成的代码混在一起的做法存在使用隐患。

操作字节码是编译型程序的另一条出路。在这种方法中，可以让编译器先编译程序，编译过后再操作字节码，加上生成的步骤。

对标注的处理可以在多处进行，处理的定义也会有所不同。如果构建一个Web应用，需要定义字段的检测规则，会希望在多处进行校验。用JavaScript在浏览器端校验的响应速度最快。因此，在服务端也需要校验，用了标注之后，可以在服务端创建运行时检查，同时生成JS代码在客户端校验，省去冗余的嗲吗。这些检查都完全源于一个标注。

### 42.2 使用场景

标注的核心特性是允许把定义和处理分离。校验就是一个很好的示例。如果要约束字段的取值范围，最明显的做法是在setting方法里面写一段处理代码。但这个方式就把定义约束和约束的实施时机混在了一起----这里的实施时机是在修改字段取值的时候强制校验。

在其他时间点检查约束条件的例子也有很多，比如，只在用户提交表单的时候做校验，填写的时候不管。为了支持这种行为，可能要在对象上增加一个完整的校验方法，但还是把约束条件的定义和检查放到了一起。

把它们分开以后，就可以在不同的时间点检查约束条件，甚至还可以在不同的时间点只应用某一部分约束。让约束的定义独立出来以后，代码的可读性也增强了。程序员可以只关心约束的定义本身，不用被检查机制干扰视线。

标注的强项在需要分离定义和处理过程的地方才显现出来。如果希望在定义不变的情况下修改处理方式，或者让定义更容易理解，就可以采用标注。

标注带来的负面作用是定义和处理过程不在一起了。如果既需要理解定义，又要理解处理过程，就必须到两个地方去查找。而且处理逻辑也没什么特别之处，这就更加让人难以理解。

**结论：标注的定义应当是声明式的，不应该让任何逻辑流参与进来，而且它也不该和处理逻辑的运行时机及附加到相同或不同程序元素的标注的处理顺序有关系。**

### 42.3 用于运行时处理的特定语法（Java）

<!-- TODO：待补充-->

### 42.4 使用类方法（Ruby）

<!-- TODO：待补充-->

### 42.5 动态代码生成（Ruby）

<!-- TODO：待补充-->

## 第43章 解析树操作

在编写闭包代码时，代码会在未来某个时间执行。解析树操作不仅能够执行代码，还可以检查、修改其解析树。

### 43.1 工作原理

为了使用解析树操作，需要一个可以接受代码片段，并将其转成可以操作的解析树的编程环境。这个编程语言特性相对较稀少----一方面是很少有语言支持；另一方面是即使语言支持，它也会很少使用。

虽然解析树操作允许以宿主语言编写表达式，但表达式的编写并不是任意的。对表达式的处理一般都会存在一些约束。在这些情形下，当拿到所不能处理的表达式时，及早报错非常重要。通常，在遍历解析树时，知道树上的节点与你的期望将一致。使用解析树操作，解析树可以包括宿主语言之中任何合法的构建块，所以在遍历的时候必须自己做一些检查。

通常不会需要或者想要遍历整棵表达式树。大多数的情形是遍历树的某些部分，只留下重要的子树以便判断。这样不需要构建完整的解析器，而仅仅解析组件**语义模型**所需的那一部分，并在不需要进一步遍历的时候就立即判断那些子树。

### 43.2 使用场景

解析树操作允许在宿主编程语言中表示逻辑，然后以相较而言更加灵活的方式操作表达式。有了这些，在DSL中使用解析树操作的驱动性因素是希望在表达式中使用宿主语言本身更多的特性，而不是一般内部DSL构建块的混杂形式。

能够利用宿主语言并不是使用解析树操作的全部原因。毕竟，内部DSL的优势之一是可以尽可能地将完整的宿主语言与DSL构建块混在一起。关键区别在于通常只能操作宿主语言的可执行结果----无法深入到宿主语言的表达式，并操作它们的结构。

使用解析树操作的另一个方法是修改解析树以执行一些有用的操作，例子之一是修改针对特定对象的所有方法调用，使之重定向到另外一个对象。

### 43.3 由C#条件生成IMAP查询（C#）

<!-- TODO：待补充-->

#### 语义模型

#### 以C#构建

#### 退后一步

## 第44章 类符号表

使用一个类及其字段实现符号表，以便在静态类型语言中支持类型感知的自动补全。

```java
public class SimpleSwitchMachine extends StateMachineBuilder {
    Events switchUp, switchDown;
    States on, off;
    protected void defineStateMachine() {
        on.transition(switchDown).to(off);
        off.transition(switchUp).to(on);
    }
}
```

当代IDE提供很多强大的功能可以让编程变得更简单，其中类型感知的自动补全功能是非常有用的一个。在Java和C#的IDE中，可以输入变量的名字然后输入句号，IDE将会提供一个列表，其中包含该对象上定义的所有方法。

### 44.1 工作原理

实现类符号表的基本方法是，将DSL脚本编写在**表达式生成器**的类中。通常这个生成器会是某个生成器的子类，在这个父类中可以放置一些对所有脚本都可用的行为。脚本对应的表达式生成器将会包含一个表示脚本自身的方法以及每个符号对应的不同字段。因此，如果在DSL中有任务这个概念，并且需要在脚本中定义三个任务，那么可以通过如下字段声明来表示：

```java
Tasks drinkCoffee, makeCoffee, wash;
```

如同DSL处理中的很多情况一样，Tasks是非传统的类的命名方式，然而，由于这个命名给这段DSL带来的可读性又要远胜过常规的命名方法。这样定义字段，使得可以在DSL脚本里作为字段引用它们，同时IDE也会为它们提供自动补全功能，编译器也会提供相应的检查。

然而，仅仅这样定义字段是不够的。当在DSL脚本里引用这些字段时，实际上引用的是字段的内容而不是字段的定义。当在IDE里编写代码的时候，IDE同时掌握定义和内容信息，但是当执行这段程序的时候，字段定义的链接就丢失了，只剩下字段的内容。对于其他代码，这不是什么问题，但是如果想要实现类符号表的话，需要在运行期获得字段定义的链接。

可以在脚本执行之前为每个字段都提供包含定义信息的恰当对象。使用类实例作为激活脚本是个不错的方式----在构造函数中为字段提供内容，然后在实例方法中实现DSL脚本。通常字段的内容是小型的表达式生成器，通过它们可以关联到低层的**语义模型**对象。为了更好地实现交叉引用，这些对象通常会包含字段的名字。从**符号表**的角度来说，字段的名字就是键，而这些生成器对象就是其所对应的值。在生成器中保存字段名称是很好的做法，因为偶尔可能会需要用到不同的键访问方式。

通常DSL脚本通过字段的字面量引用字段----这是类符号表的重点。比如，为了引用wash任务，可以在DSL脚本中输入wash的字段名。但是在处理DSL脚本的过程中，可能需要字段的构造器彼此引用。为此，可能需要通过名称查找字段的能力，或者遍历某种类型字段的能力。实现这些功能的代码不太好编写，通常会用到反射机制。不过幸运的是，通常这部分代码不会太多，而且如果很好地封装的话，也不会给语言处理带来太多的困难。

### 44.2 使用场景

使用类符号表的结果就是为了DSL中所有的语言元素提供全面的静态类型支持。这么做最大的好处就是，使得IDE可以根据静态类型信息为DSL提供强大的工具支持----比如，类型感知的自动补全。也为DSL脚本提供了编译器类型检查。

这种技术的一个不足之处在于必须根据类型系统来对DSL进行大量调整。最终的生成器类可能会看起来很奇怪，此外必须考虑在何处放置DSL脚本才能最好地利用这些机制，比如，都放在一个类里。这些限制可能会使DSL难于阅读和使用。

### 44.3 在静态类型中实现类符号表（Java）

<!-- TODO：待补充-->

## 第45章 本文润色

在进一步处理之前对文本进行简单文本替换：

```
3 hours ago => 3.hours.ago
```

内部DSL通常比较容易开发----尤其是不习惯于语法解析的时候。但是所得到的DSL通常会包含一些宿主语言的特性，而非程序员很难阅读它们。

文本润色通过一些简单的正则表达式替换，把这些东西从DSL中去除掉。

### 45.1 工作原理

文本润色是简单的技巧，它在DSL脚本解析之前，进行一系列的本文替换工作。一个简单的例子是，如果读者不喜欢使用点`(.)`来表示方法调用，那么可以使用空格来替换它。

实现润色是非常容易的，只须编写一系列正则表达式来进行文本替换----绝大多数语言都支持这么做。而复杂的是，如何正确地编写正则表达式，以保证它们不会进行不恰当的替换。引用字符串中的空格就不应该替换为点，这使得正则表达式的编写变得更加困难。

文本润色常见于动态语言，因为可以在运行时来判断文本。因此这类语言可以读入DSL表达式，然后润色它们，最后再判断最终的内部DSL脚本。然而，也可以在静态语言中使用它。当然需要在编译之前对DSL脚本进行润色----这需要在构建的过程中引入额外的步骤。

虽然文本润色主要用在内部DSL上，但是在某些情况下它也可以用在外部DSL上。当使用常规的词法分析器和文法分析器链难以处理的时候----比如，具有语义的缩进和换行----可以通过文本润色对源文件进行预处理。

### 45.2 使用场景

如果仅仅在小范围使用文本润色，那么它不会给你太多的帮助；而如果在大范围内使用它，它会变得非常复杂，这时候还不如直接使用外部DSL。虽然替换重复部分的基本概念看起来很简单，但却容易在正则表达式上犯错。

文本润色不能修改输入的语法结构，因此仍然需要使用宿主语言的基本语法结构。就是要保持未润色的DSL和最终产生的内部DSL表达式的相似性。

如果内部DSL的文本噪音很严重，那么除了文本润色之外，还有一种选择：就是在编辑器里调整语法高亮的设置，让那些噪音字符的颜色尽可能地接近背景色。这样就不容易注意到它们，从而更容易地关注到DSL的内容。如果将这些字符的颜色与背景设置为一样的颜色，那么这些字符就完全不见了。

### 45.3 使用润色的折扣规则（Ruby）

<!-- TODO：待补充-->

## 第46章 为字面量提供扩展

### 46.1 工作原理

当考虑DSL表达式时，从字面量----比如，数字和字符串---开始是个不错的选择。不过，从传统意义上讲，这些对象都是语言的内置类型，有固定的接口，而无法对它们进行扩展。而如今很多语言都提供了向第三方类增加方法的能力，比如C#扩展方法和Ruby的开放类。这种能力对于DSL格外有用，它允许从字面量开始方法链。

当使用方法链时，需要决定是否使用**表达式生成器**。如果不使用表达式生成器，那么必须保证方法链中每次调用的返回类型上，都没有适当的连贯方法：而使用表达式生成器则可以避免这个麻烦，但仍然需要确定可以从生成器快速到达底层对象。

比如`42.s`，`32.km`和`12.kg`分别表示42秒，32公里和12千克。

### 46.2 使用场景

为**字面量提供扩展**是个非常热门的例子，特别是那些支持这种做法的语言在进行自我宣传时。

为字面量提供扩展仅在某些情况下需要，而在另一些情况下需要，而在另一些情况下，则会让人担心这么做会使得这些字面量的类变得很臃肿。所以需要权衡为字面量提供扩展带来的好处和它为字面量类的接口带来的复杂度。还有一些语言环境允许为这些扩展提供独立的命名空间，这会避免由字面量提供扩展所带来的接口臃肿问题。

### 46.3 食谱配料（C#）

<!-- TODO：待补充-->

# 第五部分 其他计算模型

## 第47章 适应性模型

通过某种数据结构组织代码块来实现其他计算模型。编程语言通常都是根据某种计算模型而设计的。对于主流编程语言来说，它们通常采用命令式模型，并以面向对象方式组织代码。这种方法来表达能力和可理解性上达成了一种妥协，因此广泛地采用。但对于某些特定的问题，这个模型不见得是最好的。因而，使用DSL通常也意味着希望使用一种不同的计算模型。

适应性模型可以在命令式语言中实现其他计算模型。可以通过定义一种模型来实现它，在定义的模型中，元素之间的关联代表了计算模型中行为的关联，这个模型通常高需要引用很多命令式的代码段。而后，可以通过执行代码运行这个模型（过程风格）或者在直接执行模型中的代码（面向对象风格）

### 47.1 工作原理

当模型对于系统行为扮演首要角色时，称它们为适应性模型。虽然适应性模型模糊了软件中的很多界限，但是这样的分类是很有帮助的。使用适应性模型从实际上模糊了代码和数据的界限。

适应性模型存在在关系数据库中的情况，通常发现它们都会与模型投射编辑器一起使用----通过表单和字段来编辑适应性模型。虽然这么做也可以，但是使用DSL有更多优势。DSL通常可以更好地展现全局行为，尽管可视化技术也能做到这点，可能文本DSL最大的好处就是可以通过**版本控制**来管理适应性模型。

适应性模型通常使用图数据结构来表达，因此，数据结构和算法教科书对于使用适应性模型会很有帮助。

#### 在适应性模型中使用命令式代码

通常情况下，适应性模型需要与命令式代码有更紧密的结合。比如，可能希望更复杂的行为，或者在状态迁移中加入条件限制。为了做到这些，需要让这个适应性模型支持一些命令式表达式----而它们通常已经在宿主编程语言中存在。因此，通常将常规编程语言的代码内嵌在适应性模型的数据结构中。  

比如**产生式规则系统**中的一条规则，它由两部分组成：布尔条件和行为。通常使用宿主语言表示它们更好。

使用闭包是最自然的方式：

```
rule.Condition = j => j.Start == "BOS";
rule.Action = j => j.Passenger.PostBonusMiles(2000);
```

闭包可以很容易地将代码块内嵌在数据结构中，所以它是最直接的表达方式。当然这种做法有一个不足是，很多语言不支持闭包。

最简单的应对方法就是使用**命令模式\[GOF\]**。创建包装单个方法的小型对象。大多数情况下，可以使用参数化命令方式来减少子类的数量。

另一个选择是使用方法名并通过反射来调用方法。

从适应性模型的角度来看，命令模式是一种对应方法。但如果考虑使用DSL来填充适应性模型，命令模式则更具有吸引力。在绝大多数情况下，DSL将会通过参数包装常见情况，这很容易通过参数化命令来实现。为了在DSL中最大化闭包的表现力，它将用在一种内部DSL或者外部DSL的**外加代码**。

#### 工具

对于适应性模型DSL是一种重要的工具，它允许通过编程语言来配置模型的实例，这让整体行为变得更加明显。但当模型变得更加复杂的时候，DSL可能会显得不够用。

追踪模型的执行过程：模型如何处理其输入，它进行了什么处理，为什么要这么做都应该有清晰的日志来记录。

还可以借助可视化处理和语言工作台等工具。

### 47.2 使用场景

适应性模型是使用其他计算模型的关键。使用适应性模型允许构建其他计算模型的一个处理引擎，然后可以通过这个模型来为特定的行为编程。比如，一旦为**产生式规则系统**创建了一个适应性模型，就可以通过将规则读入模型来执行它们。

适应性模型有一个很大的缺点：它们可能很难理解，有时必须通过阅读配置文件来理解系统的行为。

## 第48章 决策表

当一段代码里面有好多条件分支时，条件组合产生的结果种类变得复杂。

可以使用决策表用表格的形式来表述一组输入条件，表格里面的每一列表示一个由特定条件组合所产生的输出。

### 48.1 工作原理

决策表由两个部分组成：输入条件和输出结果。每行输入条件表示该条件的状态：对于一个简单的二值布尔条件来说，该行中的每个但愿格要么是true，要么是false。为了捕获所有条件的组合，就需要很多列，比如，对于$n$个二值布尔条件来说，就需要有$2^n$列。

每一个输出结果行表示表格中的一个单值输出。每个单元格表示匹配相同列的输入条件的输出值。

决策表的一个有用属性是可以发现是不是所有输入条件的置换都可以在列中体现，从而把没出现的那些置换报告给用户。最好有一些组合是不可能发生的。这些组合可以在错误列中捕获。或者从表的语义上来讲，可以允许有丢失的列，把它们当做错误来对待。

如果想要引入任意的枚举，数字范围或者字符串匹配的话，表格可以变得很复杂。可以把每个这样的情况当做布尔值来捕获，但需要让表格知道用户的意图。

通常建议构建一个独立的决策表**语义模型**和解析器。有了这两个，下一步需要决定它们有多通用。可以为单个决策表例子构建模型和解析器。这样的表格会在代码中固定那些条件列，同样输出结果的类型和数量也是确定的，也可能希望列里的值是可配置的，这样就可以轻易为每个输入条件组合列更改输出结果。

一个更通用的决策表允许配置输入条件和输出结果的类型。程序会通过不同的方式来处理每个输入条件（一个方法名或者一个闭包）。对于强类型语言来说，输入和每个输出结果的类型应该是编译期就配置好的。

解析器也需要相似的决策。解析器可以是一个固定的表格，尽管它配置了一个通用的语义模型。为了得到更好的灵活性，需要一些和表格结构使用的简单语法类似的东西，这样解析器就可以正确地理解输入数据。

最原始但是最有效的方法是把决策表保存成文本格式，比如CSV。另一种方法是直接和电子表格程序交互。

### 48.2 使用场景

决策表是一种捕获一组交互条件的输出结果的有效方法。程序员和领域专家都可以很容易地理解它。表格的特性允许领域专家使用熟悉的电子表格工具来编辑它们。最大的不足是需要一些代价来构建一些基础设施，以便更方便地编辑和显示，

决策表可以处理一定程度的复杂度，就是能够在单个（如果复杂的话）条件表达式中可以得到的复杂度。如果需要把多种条件组合在一起的话，考虑**产生式规则系统**。

### 48.3 为一个订单计算费用（C#）

<!-- TODO：待补充-->

#### 模型

#### 解析器

## 第49章 依赖网络

依赖关系链接一系列任务。为了运行一个任务，调用所依赖的任务，把它们当做前提条件来执行。

```
测试 -|-> 编译     -|-> 生成代码
     |-> 加载数据  -|
```

依赖网络使用一个**有向无环图(DAG)**来组织功能，这个图包含了任务和它们之间的依赖关系。当想要申请一个任务时，首先找到它所依赖的所有任务，并且保证它们都先执行（如果需要的话）。可以遍历依赖网络来保证所有需要的前提任务都执行了。还可以保证，某个任务通过不同的依赖路径出现了多次，它也只会执行一次。

### 49.1 工作原理

一个面向任务的依赖网络，它由任务和它们之间的依赖关系组成。与之不同的是面向产出的风格，这种风格的关注点在于想要生成的产生出和它们之间的依赖关系。执行构建的时候需要做一些代码生成和编译工作，而编译依赖于代码生成。

在面向产品的风格中，会有一个编译过程产生的可执行文件和一些通过代码生成产生的源文件，这些源文件是生成可执行文件的前提。

依赖网络的运行方式：要么运行一个任务（面向过程的），要么生成一个产品（面向产品的）。通常以目标来代表这个产品或者任务。然后系统找到目标的所有前提条件，然后继续寻找前提条件的前提条件。直到得到需要的过渡性前提条件的完整列表。它调用每个任务，使用依赖关系来保证不会有任务先于它的前提条件执行。重要的是，不会有任何一个任务多次执行。

在依赖网络中，主要会出现两种错误。最严重的错误是一个焦作前提条件缺失----有些东西需要构建，但是没有构建。另一个错误是不必要的构建。在大多数情况下，它只会导致执行变慢，因为任务通常是幂等的。如果它不是的话，会导致更严重的错误。

依赖网络的一个很普遍的特性，尤其在面向产品的例子中，是每个产品记录了自己最后一次更新的时间。这个可以帮助进一步减少不必要的构建。当请求构建一个产品时，它事实上只执行那些产品最后修改时间比前提条件的最后修改时间早的那些过程。为了使这个正常工作，前提条件需要首先调用，这样才能保证在需要的时候进行重新构建。

这里给出了调用一个任务和执行该任务的差别。每个过度的前提条件都会调用，但是只有有必要的时候它才会执行。

在一个面向任务的网络中，通常不使用最后修改时间。相反，每个任务只关心自己在某一次目标请求中是否已经执行过了，并且只在第一次调用的时候执行。

选择面向产品而不是面向任务的理由是：面向产品更容易使用持久化的最后修改日期。可以在面向任务的系统中使用最后修改时间的信息，但是为了这么做，每个任务都需要自己承担这个指责。在面向产品中使用最后修改时间可以让网络在运行时来决定是否执行。这种能力并不是免费获得的：它只适用于这种情况：如果前提条件都没有改变，那么输出不会变化。因此，所有可能让输出产生变化的都应该在前提条件中声明。

### 49.2 使用场景

如果一个问题可以很好地分解成一些任务，并且每个任务都能很好地定义输入和输出，那么依赖网络就很适合这种情况。这种只执行必要任务的能力，使得依赖网络很适合那种资源密集型任务或者代价很大的任务，比如远程操作。

相比其他模型来说，依赖网络通常调试起来很费劲。所以把调用和执行都记录下来，这样就可以看到发生了什么。结合只执行需要的任务这个愿望，对于网络相对来说粗粒度的任务划分。

### 49.3 分析饮料（C#）

<!-- TODO：待补充-->

#### 语义模型

#### 解析器

## 第50章 产生式规则系统

通过一组产生式规则组织逻辑，每个规则都有一个条件和一个动作。

许多情况都很容易看做一组条件测试。当校验数据时，每个校验都可以看做一个条件，当条件为假时，抛出错误。对一组位置的资格验证也可以看做一个条件链，如果通过了链上的所有验证，则符合资格。错误诊断可以看做一系列问题并最终找到错误根源的过程。

产生式规则系统计算模型实现一组规则的概念，其中每个规则都有一个条件和一个随之产生的动作。通过一系列循环，系统基于其所有的数据运行规则，每个循环都会识别出其条件匹配的规则，然后执行规则的动作。产生式规则系统通常是**专家系统(expert system)**的核心。

### 50.1 工作原理

产生式规则系统里规则的基本结构相当简单。有一组规则，每个规则都有一个条件和一个动作。条件是一个布尔表达式。动作可是任何东西，但限于依赖产生式规则系统的上下文。比如，如果产生式规则系统只做校验，动作可能只是抛出异常，因此每个动作就指定了抛出怎样的错误，为错误提供怎样的数据。

产生式规则系统中比较复杂的部分是决定如何执行规则。对于通用的专家系统而言，做这件事可能是复杂的，这就是为什么发展出整个专家系统社区以及工具市场。通常就是这样，不过，通用的产生式规则系统非常复杂并不表示就无法针对有限的情况构建出一个简单的产生式规则系统。

产生式规则系统通常会把所有规则执行的控制放到单个组件里，通常称为**规则引擎(rule engine)**，**推理引擎(inference engine)**，**调度器(scheduler)**。简单的规则引擎操作一系列推理循环。循环开始于运行所有可用规则的条件。其条件返回真的规则处于**激活(activated)**状态。引擎会保存一个激活规则列表，称为**议程(agenda)**。当引擎检查完规则的条件时，然后会查看议程中的规则，其目的是要执行这些规则的动作。执行规则的动作称为**触发(firing)**规则。

规则触发的顺序可以由很多不同的方式决定。最简单的方式是按照任意顺序触发规则。在这种情况下，规则编写的方式并不决定其触发方式----这样保证了计算的简单。另一种方式是，总是按照其在系统内定义的顺序触发规则。email系统的过滤规则是一个很好的例子。

另一种排序方式是定义规则时给予其优先级，在专家系统循环里，这通常称为**显著性(salience)**。在这种情况下，规则引擎会先选择议程中权限最高的规则激发。通常会认为使用优先级是一种坏味道；如果发现大量地使用了优先级，就要重新考虑一下，对于问题而言，产生式规则系统是否是一个合适的计算模型。

在规则引擎里，另一个变体是，在每个规则触发之后，检查规则是否处于激活状态，或者，是否要在重新检查之前，触发议程里的所有规则。根据规则如何组织，这会影响到系统的行为。

查看一个规则库，会发现不同的规则组，每组都是整个问题的一个逻辑部分。在这种情况下，把规则分成不同的**规则集(rule set)**并按照特定顺序判断它们是有意义的。因此，给定一些规则，部分完成基本的数据校验，其他的进行资格验证，可能会先运行校验规则集，只有在无错的情况下，才运行资格验证规则集。

#### 链式操作

校验规则中的一种常见情况是最简单的产生式规则系统。在这种情况下，扫描所有的规则，然后触发那些规则，以某种日志或者“通知”的形式添加错误或警告。激活和触发循环一次就够了，因为规则的动作并不会改变产生式规则系统所处理数据的状态。

然而，通常情况下，规则动作会改变所有的状态。在这种情况下，需要重新判断规则条件，查看其中哪些变成了真，在这种情况下，要加到议程里。规则之间的交互称为**前向链式操作(forward chaining)**：从一些事实起步，使用规则推导更多的事实，这些事实激活了更多的规则，这些规则创造了更多的事实，以此类推。只有当议程中不再有更多的规则时，引擎才会停下来。

另一种方式是，用其他方式绕过去。采用这种风格，会从一个目标出发，检查规则集，查看那个规则拥有动作，可以让这个目标为真。然后，取出这些规则，以它们创建子目标，进一步发现支撑它们的规则。这种方式成为**后向链式操作(backward chaining)**。在简单的产生式规则系统中，它不那么常见，因为对于简单情况，后向链式操作过于复杂。

#### 矛盾推导

规则的优势之一在于，每个规则可以独立表示，让产生式规则系统找出结果。但是这种优势也会带来问题。如果得到的推导链彼此矛盾该怎么做？

有两种明显的方式处理矛盾规则。一是设计规则结构避免矛盾。这括包，确保规则运行的方式可以避免矛盾，这可以通过规则更新数据的方式，组织规则集的方式，或者采用有限级的方式来实现。在这个例子里，先将所有适任条件设置为假，并只允许它们变为真。

另一种方式是按照容忍矛盾的方式记录所有推导，允许人们指出矛盾。

通常来说，需要小心处理规则结构中的循环，其可以组织多个规则，以便一个可以触发下一个，永不停止。

#### 规则结构里的模式

一个通用、简单的情况是校验。这很简单，因为所有的规则通常都会有一个简单的后果：抛出某种形式的校验错误。如果有的话，还有一些链式操作。

### 50.2 使用场景

如果有一些想要表达成一组if-then语句的行为时，产生式规则系统是一个自然选择。

产生式规则系统一个很大的危险在于，它们很吸引人。对于非程序员而言，一个小例子容易理解，很好演示。当问题变大时，推导出产生式规则系统在做什么可能是非常困难的，尤其是使用链式操作时，调试更加困难。

规则引擎工具通常会让这个问题恶化。扩展一个工具很容易----可以在很多场合使用它，直到扩展够大时，才会意识到修改很困难。

### 50.3 俱乐部会员校验（C#）

<!-- TODO：待补充-->

#### 模型

#### 解析器

#### 演进DSL

### 50.4 适任资格的规则：扩展俱乐部成员（C#）

<!-- TODO：待补充-->

#### 模型

#### 解析器

## 第51章 状态机

很多系统各根据其内部属性不同的状态对于外界刺激有不同的响应方式。可以利用状态机来澄清系统的内部状态，并描述不同状态的响应以及是什么引起了系统这些状态之间的迁移。除此之外，还可以使用状态机来描述和控制这些行为。

### 51.1 工作原理

状态机在软件和关于软件的讨论中都是常见的话题----根据不同的使用场景，状态机的应用成都和使用形式都会有所不同。

状态机和其他计算模型一样，有很多不同的种类，这些不同种类的状态机虽然很有多共通之处，但是也有一些显著的差别。从常见的元素开始，从本质上说状态机可以处于的一组状态。可以在每个状态上定义多个状态的迁移，其中每个迁移都可由事件触发，之后状态机将会迁移到目标状态。目标状态可能是不个不同的状态，也可能不是。状态机的最终行为由这些状态和触发状态迁移的事件来定义。

一个常见的问题是，当状态机遇到未定义事件时应该如何处理。这取决于是什么样的应用，也许是个错误，也许可以放心地忽略掉。

### 51.2 使用场景

当感觉到行为被事件触发，从一个状态迁移到另一个状态----那么应该使用状态机。由于状态机只能分析正则文法----也就是它无法分析任意嵌套的圆括号，因此如果需要表达类似的行为，那么将无法使用状态机来描述系统行为。

### 51.3 安全面板控制器（Java）

<!-- TODO：待补充-->

# 第六部分

## 第52章 基于转换器的代码生成

### 52.1 工作原理

<!-- DSL看到了第452页-->

### 52.2 使用场景

### 52.3 安全面板控制器

## 第53章 模版化的生成器

### 53.1 工作原理

### 53.2 使用场景

### 53.3 生成带有嵌套条件的安全控制面板状态机

## 第54章 嵌入助手

### 54.1 工作原理

### 54.2 使用场景

### 54.3 安全控制面板的状态

### 54.4 助手类应该生成HTML吗

## 第55章 基于模型的代码生成

### 55.1 工作原理

### 55.2 使用场景

### 55.3 安全控制面板的状态机

### 55.4 动态载入状态机

## 第56章 无视类型的代码生成

### 56.1 工作原理

### 56.2 使用场景

### 56.3 使用嵌套条件的安全面板状态机

## 第57章 代沟

### 57.1 工作原理

### 57.2 使用场景

### 57.3 根据数据结构生成类
