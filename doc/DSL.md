
# 前言

**DSL 领域特定语言**

领域特定语言（英语：domain-specific language、DSL）指的是专注于某个应用程序领域的计算机语言。又译作领域专用语言。

在定义DSL是什么的问题上，Fowler 认为业界经常使用的一些特征，例如“关注于领域”、“有限的表现”和“语言本质”是非常模糊的。因此，唯一能够确定DSL边界的方法是考虑“一门语言的一种特定用法”和“该语言的设计者或使用者的意图”：
如果XSLT的设计者将其设计为XML的转换工具，那么认为XSLT是一个DSL。如果一个用户使用DSL的目的是该DSL所要达到的目的，那么它是一个DSL，但是如果有人以通用的方式来使用一个DSL，那么它（在这种用法下）就不再是一个DSL了

域特定语言（英语：domain-specific language、DSL）指的是专注于某个应用程序领域的计算机语言。又译作领域专用语言。不同于普通的跨领域通用计算机语言(GPL)，领域特定语言只用在某些特定的领域。 比如用来显示网页的HTML，以及Emacs所使用的Emac LISP语言。

DSL可以简化复杂的代码，促进与客户沟通的效率，提高工作效率，清除发展瓶颈。

**编译相关的程序**

* **解释程序 (interpreter)**-
* **汇编程序（assembler）**-
* **连接程序（linker）**-
* **装入程序（loader）**-
* **预处理器（preprocessor）**-
* **编辑器（editor）**-
* **调试程序（debugger）**-
* **描述器（profiler）**-
* **项目管理程序（project manager）**-

**编译相关的步骤**

* **扫描程序（scanner）**-
* **语法分析（parser）**-
* **语义分析（semantic analyzer）**-
* **优化程序（source code optimizer）**-
* **代码生成（code generator）**-
* **目标代码（target code optimizer）**-

**编译相关的记号**

* **记号（token）**-
* **语法树（syntax tree）**-
* **符号表（symbol table）**-
* **常数表（literal table）**-
* **中间代码（intermediate code）**-
* **临时文件（temporary file）**-

# 第一部分

## 第1章 入门例子

### 1.1 哥特式建筑安全系统

想要构建一套这样的安全系统，公司的人进入之后，设置某种无线网络，安装一些小的设备。如果发生某些有趣的事情，这些设备会发出一条四字符的消息。比如，打开抽屉，抽屉上的感应器就会发出一条消息：D2OP。还有一些小的控制设备，响应这样的四字符命令消息。比如，某个设备收到D1UL消息，就会打开一扇门。

假设有这样一系列系统，它们共享着大多数组件和行为，却彼此间差异巨大。在这个例子中，对所有的客户来说，控制器发送和接收消息的方式是相同的。但是产生的事件序列和发送的命令却不尽相同。

把控制器看做是**状态机(state machine)**，每个感应器都可以发送**事件(event)**，改变控制器的**状态(state)**。当控制器进入某种状态时，就会在网络上发出一条命令消息。

### 1.2 状态机模型

对于指定控制器如何运作而言，状态机是一个恰当的抽象，下一步就是确保这个抽象能够运用到软件自身。

<!-- DSL看到了第30页-->

### 1.3 为格兰特小姐的控制器编写程序

### 1.4 语言和语义模型

### 1.5 使用代码生成

### 1.6 使用语言工作台

### 1.7 可视化

## 第2章 使用DSL

### 2.1 定义DSL

### 2.2 为何需要DSL

### 2.3 DSL的问题

### 2.4 广义的语言处理

### 2.5 DSL的生命周期

### 2.6 设计优良的DSL从何而来

## 第3章 实现DSL

### 3.1 DSL处理之架构

### 3.2 解析器的工作方式

### 3.3 文法，语法和语义

### 3.4 解析中的数据

### 3.5 宏

### 3.6 测试DSL

### 3.7 错误处理

### 3.8 DSL迁移

## 第4章 实现内部DSL

### 4.1 连贯API与命令 - 查询API

### 4.2 解析层的需求

### 4.3 使用函数

### 4.4 字面量集合

### 4.5 基于文法选择内部元素

### 4.6 闭包

### 4.7 解析树操作

### 4.8 标注

### 4.9 为字面量提供扩展

### 4.10 消除语法噪音

### 4.11 动态接收

### 4.12 提供类型检查

## 第5章 实现外部DSL

### 5.1 语法分析策略

### 5.2 输出生成策略

### 5.3 解析中的概念

### 5.4 混入另一种语言

### 5.5 XML DSL

## 第6章 内部DSL vs 外部DSL

### 6.1 学习曲线

### 6.2 创建成本

### 6.3 程序员的熟悉度

### 6.4 与领域专家沟通

### 6.5 与宿主语言混合

### 6.6 强边界

### 6.7 运行时配置

### 6.8 趋于平庸

### 6.9 组合多种DSL

### 6.10 总结

## 第7章 其他计算模型概述

### 7.1 几种计算模型

#### 7.1.1 决策表

#### 7.1.2 产生式规则系统

#### 7.1.3 状态机

#### 7.1.4 依赖网络

#### 7.1.5 选择模型

## 第8章 代码生成

### 8.1 选择生成什么

### 8.2 如何生成

### 8.3 混合生成代码和手写代码

### 8.4 生成可读的代码

### 8.5 解析之前的代码生成

### 8.6 延伸阅读

## 第9章 语言工作台

### 9.1 语言工作台之要素

### 9.2 模式定义语言和元模型

### 9.3 源码编辑和投射编辑

### 9.4 说明性编程

### 9.5 工具之旅

### 9.6 语言工作台和CASE工具

### 9.7 该使用语言工作台嘛

# 第二部分

## 第10章 各种DSL

### 10.1 Graphviz

### 10.2 JMock

### 10.3 CSS

### 10.4 HQL

### 10.5 XAML

### 10.6 FIT

### 10.7 Make

## 第11章 语义模型

### 11.1 工作模型

### 11.2 使用场景

### 11.3 入门例子（Java）

## 第12章 符号表

### 12.1 工作原理

### 12.2 使用场景

### 12.3 参考文献

### 12.4 以外部DSL实现的依赖网络（Java和ANTLR）

### 12.5 在一个内部DSL中使用符号键（Ruby）

### 12.6 用枚举作为静态类型符号（Java）

## 第13章 语境变量

### 13.1 工作原理

### 13.2 使用场景

### 13.3 读取INI文件（C#）

## 第14章 构造器生成器

### 14.1 工作原理

### 14.2 使用场景

### 14.3 构建简单的航班信息(C#)

## 第15章 宏

### 15.1 工作原理

### 文本宏

### 语法宏

### 15.2 使用场景

## 第16章 通知

### 16.1 工作原理

### 16.2 使用场景

### 16.3 一个非常简单的通知（C#）

### 16.4 解析中的通知（Java）

## 第17章 分隔符指导翻译

### 17.1 工作原理

### 17.2 使用场景
 
### 17.3 常客记分（C#）

### 17.4 

# 第三部分

## 第18章 语法指导翻译

### 18.1 工作原理

#### 词法分析器

#### 语法分析器

#### 产生输出

#### 语义预测

### 18.2 使用场景

## 第19章 BNF

### 19.1 工作原理

### 19.2 使用场景

## 第20章 基于正则表达式表的词法分析器

### 20.1 工作原理

### 20.2 使用场景

## 第21章 递归下降法语法解析器

### 21.1 工作原理

### 21.2 使用场景

### 21.3 递归下降

## 第22章 解析器组合子

### 22.1 工作原理

### 22.2 使用场景

## 第23章 解析器生成器

### 23.1 工作原理

### 23.2 使用场景

### 23.3 Hello World（Java和ANTLR）

#### 编写基本的文法

#### 构建语法分析器

#### 为文法添加代码动作

#### 使用代沟

## 第24章 树的构建

### 24.1 工作原理

### 24.2 使用场景

### 24.3 使用ANTLR的树构建语法（Java和ANTLR）

#### 标记解释

#### 解析

#### 组装语义模型

### 24.4 使用代码动作进行树的构建

## 第25章 嵌入式语法翻译

