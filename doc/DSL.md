
# 前言

**DSL 领域特定语言**

领域特定语言（英语：domain-specific language、DSL）指的是专注于某个应用程序领域的计算机语言。又译作领域专用语言。

在定义DSL是什么的问题上，Fowler 认为业界经常使用的一些特征，例如“关注于领域”、“有限的表现”和“语言本质”是非常模糊的。因此，唯一能够确定DSL边界的方法是考虑“一门语言的一种特定用法”和“该语言的设计者或使用者的意图”：
如果XSLT的设计者将其设计为XML的转换工具，那么认为XSLT是一个DSL。如果一个用户使用DSL的目的是该DSL所要达到的目的，那么它是一个DSL，但是如果有人以通用的方式来使用一个DSL，那么它（在这种用法下）就不再是一个DSL了

域特定语言（英语：domain-specific language、DSL）指的是专注于某个应用程序领域的计算机语言。又译作领域专用语言。不同于普通的跨领域通用计算机语言(GPL)，领域特定语言只用在某些特定的领域。 比如用来显示网页的HTML，以及Emacs所使用的Emac LISP语言。

DSL可以简化复杂的代码，促进与客户沟通的效率，提高工作效率，清除发展瓶颈。

**编译相关的程序**

* **解释程序 (interpreter)**-
* **汇编程序（assembler）**-
* **连接程序（linker）**-
* **装入程序（loader）**-
* **预处理器（preprocessor）**-
* **编辑器（editor）**-
* **调试程序（debugger）**-
* **描述器（profiler）**-
* **项目管理程序（project manager）**-

**编译相关的步骤**

* **扫描程序（scanner）**-
* **语法分析（parser）**-
* **语义分析（semantic analyzer）**-
* **优化程序（source code optimizer）**-
* **代码生成（code generator）**-
* **目标代码（target code optimizer）**-

**编译相关的记号**

* **记号（token）**-
* **语法树（syntax tree）**-
* **符号表（symbol table）**-
* **常数表（literal table）**-
* **中间代码（intermediate code）**-
* **临时文件（temporary file）**-

# 第一部分

## 第1章 入门例子

### 1.1 哥特式建筑安全系统

想要构建一套这样的安全系统，公司的人进入之后，设置某种无线网络，安装一些小的设备。如果发生某些有趣的事情，这些设备会发出一条四字符的消息。比如，打开抽屉，抽屉上的感应器就会发出一条消息：D2OP。还有一些小的控制设备，响应这样的四字符命令消息。比如，某个设备收到D1UL消息，就会打开一扇门。

假设有这样一系列系统，它们共享着大多数组件和行为，却彼此间差异巨大。在这个例子中，对所有的客户来说，控制器发送和接收消息的方式是相同的。但是产生的事件序列和发送的命令却不尽相同。

把控制器看做是**状态机(state machine)**，每个感应器都可以发送**事件(event)**，改变控制器的**状态(state)**。当控制器进入某种状态时，就会在网络上发出一条命令消息。

### 1.2 状态机模型

对于指定控制器如何运作而言，状态机是一个恰当的抽象，下一步就是确保这个抽象能够运用到软件自身。如果人们在考虑控制器行为时，也要考虑事件，状态和转换，那么，希望这些词汇也可以出现在软件代码里。从本质上说，这就是**领域驱动设计(Domain-Driven Design)**中的**DDD原则**。也就是说在领域人员和程序员之间构建的一种共享语言。

对于Java程序来说，自然的方式就是以状态机为Domain Model。通过接收事件消息和发送命令消息，控制器得以同设备通信。这些消息都是四字母编码，可以通过通信通道进行发送。在控制器代码里面，想用**符号名(symbolic name)**引用这些消息。创建了事件类和命令类，它们都有代码(code)和名字(name)。把它们放到单独的类里面(有一个超类)，因为在控制器的代码里，它们扮演者不同的角色。

```java
class AbstractEvent {
    private String name, code;
    public AbstractEvent(String name, String code) {
        this.name = name;
        this.code = code;
    } 
    public String getCode() {
        return code;
    }

    public String getName() {
        return name;
    }
}
public class Command extends AbstractEvent {}
public class Event extends AbstractEvent {}
```

状态类记录了它会发送的命令及其相应的转换

```java
class State {
    private String name;
    private List<Command> actions = new ArrayList<Command>();
    private Map<String, Transition> transitions = new HashMap<String, Transtion>();
}

class State {
    public void addTranstion(Event event, State targetState) {
        assert null != targetState;
        transtitions.put(event.getCode(), new Transition(this, event, targetState));
    }
}

class Transition {
    private final State source, target;
    private final Event trigger;

    public Transtion(State source, Event trigger, State target){
        this.source = source;
        this.target = target;
        this.trigger = trigger;
    }

    public State getSource() {
        return source;
    }

    public State getTarget() {
        return target;
    }

    public Event getTrigger() {
        return trigger;
    }

    public String getEventCode() {
        return trigger.getCode();
    }
}
```

状态机保存了其起始状态。

```java
class StateMachine...
    private State start;

    public StateMachine(State start) {
        this.start = start;
    }
```

这样，从这个状态可以到达状态机里的任何状态

```java
class StateMachine...
    public Collection<State> getStates() {
        List<State> result = new ArrayList<State>();
        collectState(result, start);
        return result;
    }

    private void collectStates(Collection<State> result, State s) {
        if (result.contains(s)) return;
        result.add(s);
        for (State next : s.getAllTargets())
            collectStates(result, next);
    }

class State...
    Collection<State> getAllTargets() {
        List<State> result = new ArrayList<State>();
        for (Transtion t : transitions.values())
            result.add(t.getTarget());
        return result;
    }
```

为了重置事件，在状态机上保存了一个列表。

```java
class StateMachine...
    private List<Event> resetEvents = new ArrayList<Event>();

    public void addResetEvents(Event... events) {
        for (Event e : events) 
            resetEvents.add(e);
    }
```

像这样用一个单独结构处理重置事并不是必需的。简单🉐地在状态机上声明一些额外的转换，也可以处理这种情况，如下所示：

```java
class StateMachine...
    private void addResetEvent_byAddingTransitions(Event e) {
        for (State s : getStates()) 
            if (!s.hasTransition(e.getCode(), s.addTransition(e,start)));
    }
```

倾向于在状态机上设置显式的重置事件，这样可以更好地表现意图。虽然这样做确实使状态机有点复杂，但它也更加清晰地表现出通用状态机该如何运作，要定义特定状态机也会更加清晰。

处理完结构，再来看看行为。事实证明，这真的相当简单。控制器有个handle方法，它以从设备接收到的事件代码为参数。

```java
class Controller...{
    private State currentState;
    private StateMachine machine;

    public CommandChannel getCommandChannel() {
        return commandsChannel;
    }

    private CommandChannel commandsChannel;

    public void handle(String eventCode) {
        if (currentState.hasTransition(eventCode))
            transitionTo(currentState.targetState(eventCode));
        else if (machine.isResetEvent(eventCode))
            transitionTo(machine.getStart());
        // ignore unknown events
    }

    private void trasitionTo(State target) {
        currentState = target;
        currentState.executeActions(commandsChannel);
    }
}
class State {
    public boolean hasTransition(String eventCode) {
        return transtions.containsKey(eventCode);
    }

    public State targetState(String eventCode) {
        return transtions.get(eventCode).getTarget();
    }

    public void executeActions(CommandChannel commandsChannel) {
        for (Command c : actions) commandChannel.send(c.getCode());
    }
}
class StateMachine... {
    public boolean isResetEvent(String eventCode) {
        return resetEventCode().contains(eventCode);
    }
}
```

对于未在状态上注册的事件，它会直接忽略。对于可识别的任何事件，它就会转换为目标状态，并执行这个目标状态上定义的命令。

### 1.3 控制器编写程序

除了构建状态机模型的代码，还需要其他代码。一般是按照如下划分：

* 程序库，框架或者组件的代码
* 配置代码，组件组装代码。

这种做法分开了公共代码和可变代码。用公共代码构建一套组件，然后根据不同的目的进行配置。如配置代码可以为XML，json，yaml等文件，但是代价是配置上的语法错误只能在运行时检测出来。

DSL只有同其他语言配合起来，才能完成整个工作，DSL的简单性意味着，它是容易编辑和处理的。本文DSL有两种，称为外部DSL和内部DSL。外部DSL是指，在主程序设计语言之外，用一种单独的语言表示领域专用语言。这种语言用的可能是定制语法，或者遵循另一种表现的语法，比如XML。内部DSL是指用通用语言的语法表示的DSL。

### 1.4 语言和语义模型

状态机与DSL的关系是至关重要的。在上面的例子中，DSL的角色就是组装状态机模型。

一个例子:

```dsl
events
  doorClosed D1CL
```

上述DSL会创建一个新的事件对象

```java
new Event("doorClosed", "D1CL")
```

并且把它保存在一边，这样，遇到`doorClosed => active`时，就可以将它包含在一个转换里(使用addTransition)。这个模型就是个引擎，提供了状态机的行为。事实上，可以说，这个设计的能力大多源自这样一个模型。DSL所做的一切就是提供一种更可读的方式来组装这个模型，这就是与开始的命令查询API不同的地方。

涉及到编程语言时，常常会提到**语法(syntax)**和**语义(semantics)**。语法描述程序的合法表达式，而在DSL中所能描述的一切都是由**文法(grammer)**决定的。程序的语义是指，它代表着什么。也就是说，它能做什么。

对于一个设计良好的DSL而言，语义模型至关重要。语义模型可以是对象模型，还可以是其他形式。即便它只是一个纯粹的数据结构，所有的行为都在单独的函数里，依然愿意称之为语义模型，因为在那些函数的上下文里，数据结构表现出了DSL脚本特定的含义。

DSL只是扮演着展示模型配置机制的角色。使用这种方式的益处大多源自模型，而非DSL。为客户配置新的状态很容易，这是模型的属性，而非DSL。控制器可以在运行时改变，无须编译，这是模型的属性，而非DSL。

DSL所带来的益处与状态机紧密相关，其所组成的某个特定模型就扮演了系统程序的角色。要改变状态机的行为，就需要修改模型中的对象及其相互关系。这种风格的模型通常称为“适应性模型”。这样得到的是一个模糊代码和数据之间差异的系统，只看代码，是无法理解状态机行为的，还必须了解对象实例的连接方式。当然，从某种程度上说，这总是对的，任何程序对不同的数据都会给出不同的结果，但在此有个极大的差异，因为状态对象的存在会在很大程度上改变系统的行为。

适应性模型非常强大，但是通常也很难用，因为人们看不到任何定义特定行为的代码。DSL是有价值的，它提供了一种显式的方式表现代码，这种形式让人们对状态机编程有了感觉。

### 1.5 使用代码生成

要处理DSL，组装“语义模型”，然后执行语义模型，提供希望从控制器得到的行为，在语言圈子里，这种方式称为**解释(interpretation)**。在解释文本时，会解析文本，然后程序立刻产生结果。

在语言领域里，与解释相对的是编译。在编译时，先解析程序文本，产生中间输出，然后单独处理输出，提供预期行为。在DSL的上下文里，编译方式通常指的是**代码生成(code generation)**

代码生成通常很笨拙，因为它常常需要进行额外的编译步骤。为了构建程序，首先需要编译状态框架和解析器，其次运行解析器，为控制器生成源代码，然后编译生成的代码。这样做，构建过程就变得复杂许多。然而，代码生成的一个优势在于，编写解析器和生成代码可以用不同的语言。在这个情况下，如果生成的代码用的是动态语言(如JS),第二哥编译步骤就可以省略。

### 1.6 使用语言工作台

语言工具台是一个环境，设计初衷就是帮助人们构建新的DSL，以及有效地运用这些DSL所需的高质量工具。甚至设计对图形语言的支持，但是还存在一些问题和发展前途。

### 1.7 可视化

语言工作台的一大优势在于它们给了DSL更为多样的表现形式，特别是图形化表示。然而，即使是文本化的DSL也可以有图形化的表示。

对于许多DSL来说，使用类似于Graphviz这样的工具非常有用，因为它给了另一种表现形式。类似于DSL本身，这种**可视化(visualization)**表现形式可以让人更好地理解模型。可视化不同于对应的源代码，其本身无法编辑。

## 第2章 使用DSL

### 2.1 定义DSL

领域特定语言：针对某一特定领域，具有受限表达性的一种计算机程序设计语言。这一定义包含4个关键元素：

* **计算机程序设计语言**-用DSL指挥计算机做一些事情。同大多数现代程序设计语言一样，其结构设计成便于人们理解的样子，但它应该还是可以由计算机执行的语言。
* **语言性**-DSL是一种程序设计语言，因此必须具备连贯的表达能力----不管是一个表达式还是多个表达式组合在一起
* **受限的表达性**-通用程序设计语言提供广泛的能力：支持各种数据，控制，以及抽象结构。这些能力很有用，但也会让语言难于学习和使用。DSL只支持特定领域所需要特性的最小集。使用DSL，无法构建一个完整的系统，相反，却可以解决系统某一方面的问题。
* **针对领域**-只有在一个明确的小领域下，这种能力有限的语言才会有用。这个领域才使得这种语言值得使用。

DSL主要分为三类：

* **外部DSL**-是一种“不同于应用系统主要使用语言”的语言。外部DSL通常采用自定义语法，不过选择其他语言的语法也很常见(XML就是一个常见的选择)。宿主应用的代码会采用文本解析技术对使用外部DSL编写的脚本进行解析。一些小语言的传统UNIX就符合这种风格。可能经常会遇到的外部DSL的例子包括：正则表达式、SQL、Awk，以及像Struts和Hibernate这样的系统所使用的XML配置文件。
* **内部DSL**-是一种通用语言的特定语法。用内部DSL写成的脚本是一段合法的程序，但是它具有特定的风格，而且只用到了语言的一部分特性，用于处理整个系统一个小方面的问题。用这种DSL写出的程序有一种自定义语言的风格，与其所使用的宿主语言有所区别。这方面最经典的例子是Lisp。Lisp程序员写程序就是创建和使用DSL。Ruby最著名的框架Rails，经常被认为是一套DSL。
* **语言工作台**-是一个专用的IDE，用于定义和构建DSL。具体来说，语言工作台不仅用来确定DSL的语言结构，而且是编写DSL脚本的编辑环境。最终的脚本将编辑环境和语言本身紧密结合在一起。

#### DSL的边界

DSL边界问题其实就是内部DSL与命令/查询式API之间的差异。从许多方面来说，内部DSl不过是一种特殊的API，核心差异在于语言性。

给具有命令/查询式API的类编写文档，一种常见的方式是列出其所拥有的所有方法，意味着每个方法自身都有独立含义，一组“词汇”，每一个都有自己的完备语义。而内部DSL的方法名只在一个更大表达式的上下文中才有明确的含义。

内部DSL给人的感觉是一个整句，而非一个无关命令的序列。这正是这种API称为连贯接口的基础。对内部DSL来说，受限表达式显然不是语言的一项核心属性，因为内部DSL植根于一个通用语言。在这种情况下，受限表达性表现在如何使用它。当构造DSL表达式时，会限制自己只使用通用语言的一部分特性，通常不会使用条件判断、循环结构和变量。

对外部DSL来说，其边界就是它与通用语言之间的边界。语言可以针对某领域，但仍然是通用语言。R语言就是一个很好的例子，它是一种用于统计的语言和平台，主要用于解决统计方面的问题，它也具备通用语言所有的表达性。因此，尽管它针对某一领域，但是依然不会称其为一种DSL。

一种更为明显的DSL是正则表达式。它所针对的领域(文本匹配)与其有限的特性紧密相关----那些特性刚刚好能做到易于匹配文本。DSL的一个普遍特征是，它们不是图灵完备的。一般来说，DSL不支持常见的命令式控制结构(条件和循环)，也不能定义变量和子例程。

#### 片段DSL和独立DSL

之前用的状态机的例子是一种独立的DSL。DSL出现的另外一种方式是**片段形式**。对于这种形式，DSL片段用于宿主语言的代码中。可以将其看作采用额外特性对宿主语言进行增强。

片段的一个典型例子是正则表达式，可以见到在一个程序中点缀着正则表达式片段，另外一个典型例子是SQL，在大型程序的上下文中，常常会用到SQL语句。

### 2.2 为何需要DSL

DSL是在特定条件下有专门用途的一种工具。DSL只是模型的一个薄壳，这个模型可能是程序库，也可能是框架。

#### 提高开发效率

DSL提供了一种手段，可以更加清晰地就系统某部分的意图进行沟通，DSL相比于采用命令-查询API，DSL形式更容易理解。DSL提供了一种“对阅读和操作抽象”更具表达性的形式，从而增强了这种抽象。DSL还可以帮助人们更好地学习使用API。

#### 与领域专家的沟通

让领域专家能够阅读懂代码，就可以直接指出问题所在，还可以同编写业务规则的程序员更好地交流，还可以编写一些草稿使程序员可以将其细化为适当的DSL规则。

#### 执行环境的改变

状态机可以在运行时解析，而非编译时。因此可以将代码运行于不同的环境，这类理由也是使用DSL一个常见的驱动力。对于XML配置文件而言，将逻辑从编译时移到运行时就是一个这样的理由。

用DSL常常可以弥补宿主语言的局限性，将事物以适宜的DSL形式表现出来，生成可用于实际执行环境的代码。模型的存在有助于这种迁移。

#### 其他计算模型

几乎所有主流的编程语言都采用命令式的计算模型。把非命令式方式称为声明式编程。之所以叫做声明式，是因为这个种风格让人定义做什么，而不是用一堆命令语句来描述怎么做。

### 2.3 DSL的问题

不使用DSL的唯一原因就是，使用DSL得不到任何好处，或者，至少是DSL的好处不足以抵消构建它的成本。

许多DSL的问题只是与某种特定DSL风格相关，要理解这些问题，需要深入理解这些DSL是如何实现的。

#### 语言噪音

虽然了解多种语言会让工作更加困难，但是DSL远比一门通用语言容易，因此，学习起来也要容易的多。

#### 构建成本

DSL的可维护性是一项重要的考量因素。DSL的成本大雨构建模型的成本。一个好的DSL可以封装一个糟糕的程序库，把它变得容易用。但是糟糕的DSL对于构建和维护而言，就是浪费资源，但这种说法对任何代码都适用。

#### 集中营语言

**集中营语言(ghetto language)**问题与语言噪音问题正好相反。一种DSL总是存在着无意中演化成一种通用语言的危险，有一种DSL，然后逐步为它添加新功能：今天添加条件表达式，明天又添加循环，最终图灵完备了。不是自己的业务，不要自己写，随着开源工具的崛起，基于已有开源工作量进行扩展，比从头打造更有意义。

#### “一叶障目”的抽象

任何DSL抽象总是伴随着风险，只知抽象，不知道具体实现。

### 2.4 广义的语言处理

也涉及语言处理技术，90%都是为了DSL，DSL中的语言处理技术也可以用在其他文字处理上。

### 2.5 DSL的生命周期

对于内部DSL，要符合宿主语言的语言；对外部DSL，语句要能够解析。其他DSL开始时比较非正式，然后再对照DSL进行修改，以得到一种合理的语法。对于每个例子，尝试用DSL的形式把它们写下来，随着处理到不同的情况，就要修改DSL，支持新的能力。最后，就会得到一套合理的用例，以及对这些用例的伪DSL描述。如果用的是语言工作台，就要在工作台之外完成这一阶段，用一个纯文本编辑器，或者一个普通的绘图软件，也可以是纸和笔。

一旦有了一套典型的伪DSL，就可以着手实现它了。这里的实现包括以宿主语言设计的状态机模型，模型的命令-查询API，DSL的具体语法以及DSL和命令-查询API之间的转换。

DSL分为测试驱动开发和基于模型发展两种方法。基于模型发展DSL发展DSL的方法有两种。对于“语言生长”的方式，要慢慢地在模型之上构建DSL，把模型几乎看作黑盒。首先看看目前所有的控制器，然后草拟出每个控制器的伪DSL。然后，一个场景一个场景地实现DSL，通常，不会对模型做任何深入的修改，尽管给模型添加一些方法能够更好的支持DSL。

### 2.6 设计优良的DSL从何而来

DSL的总体目标就是对读者要清晰，进行迭代设计，从目标受众那里获得反馈，准备多种方案，看看其他人的反应。DSL是一种程序设计语言，使用它应该像编程。

## 第3章 实现DSL

### 3.1 DSL处理之架构

DSL实现的大体架构：**DSL脚本 解析->语义模型 生成->目标代码**。所有重要的语义行为都可以在模型中铺货，而DSL的任务就是通过解析来填充模型。所以，语义模型在DSL中扮演着核心角色。

DSL语义模型通常是一个系统的Domain Model的子集，因为并不是Domain Model的所有部分都适合用DSL处理。语义模型完全就是一个普通的对象模型，可以像操作其他所有对象模型一样操作它。用状态模型的命令-查询API组装一个状态机，然后运行它，获取状态对象的行为。从某种意义上说，它与DSL是相互独立的，但是在现实中，它们又相互依赖。

分离语义模型和DSL有几个好处。首先，可以暂时不纠结于DSL的语法和解析器，而专注于当前领域的语义。如果用上DSL，就说明所表达的东西已经非常复杂，复杂到要拥有自己的模型来表示。可以直接创建语义模型中的对象，操作它们进行测试。比如，，可以创建一堆状态和迁移(transition)，测试事件(event)和命令(command)是否运行良好。

拥有一个独立的语义模型，模型和语言就可以独立演化。如果要改变模型，无须修改DSL就可以探索做法，模型能够工作后，给DSL添加必要的语言构造即可。同样，如果需要尝试不同的DSL语言，只要验证它们是否可以创建相同的模型对象即可。比较它们组装语义模型方式的不同，就可以知道两种语法之间的区别。

内部DSL和外部DSL的不同就在于解析这一步，既包括解析的目标，也包括解析的方式。两种风格的DSL都会产生同样的语义模型，没有理由不使用单独的语义模型。

当使用外部DSL时，DSL脚本，解析器和语义模型之间有条清晰的界限。DSL脚本由一种独立的语言编写，解析器读取这些脚本，然后组装语义模型。而使用内部DSL时，它们之间更容易混杂在一起。

代码生成是指生成单独编译和运行的代码，它是DSL中的一个可选项。使用语义模型生成代码的一个好处，它解耦了代码生成器和解析器。

### 3.2 解析器的工作方式

解析是一个很强的层级操作。当解析文本时，把数据块组织成一个树结构。考虑一个简单结构，状态机中的事件列表:

```dsl
events
  doorClosed D1CL
  drawOpened D2OP
end
```

这个复合结构是一个事件列表，包含一系列事件，每个事件都有名字和代码。对于真个列表，这里没有显式的标记，但是每一个事件本身仍然是一个层级：每个事件都有表示名字的符号和表示代码的字符串。

无论何时看到这样的脚本，都可以把它想象为一个层级，这样的层级称为语法树或解析树。任何脚本都可以转化为许多潜在的语法树----这取决于如何分解它。相当于单词，语法树是一种更高效的脚本表现形式，因为可以遍历语法树，使用各种不同的方式来对它进行操作。

可以把一个语法树翻译成语义模型。人们通常直接执行语法树，或者基于语法树生成代码。更有效的做法是，语法树可以直接当作语义模型来使用。

很多时候，语法树在调用栈中形成，在遍历的过程中得到处理。所以一般看不到整个树，而只能看到当前处理的分支。语法树的形成有赖于方法调用的实参和嵌套对象。使用外部DSL会产生一个更加显式的语法树。但即使是外部DSL，通常在处理过程中，也是在调用栈中不断形成和修剪着语法树。

### 3.3 文法，语法和语义

**文法**是一种规则，用以描述如何将文本流转化为语法树。文法由一系列**产生式规则**组成，每个产生规则都有一个名字(term)以及一个描述如何分解它的语句(statemant)。所以，一个加法语句可能就是:`addtionStatement:=number + number`。如果遇到语句`5+3`，解析器能够将其识别为加法语句。因为规则是相互引用的，所以也会有一条针对数字的规则，告诉如何识别合法数字。通过这些规则，可以得到一种语言的文法。

一种语言可以由多种不同的文法来定义，认识到这点很重要。世界上不存在某种语言的唯一文法。一种文法就定义了语言所生成的语法树的一种结构，对于一段特定的文本，可能会识别出许多不同的语法树结构。一种文法只定义一种形式的语法树：选择何种文法和语法树取决于很多因素，包括语言的文法特性以及处理语法树的方式等。

文法只定义一种语言的语法----它在语法树中如何表现。而这与语义无关。根据上下文不同，`5+3`可能等于`8`，也可能等于`53`，语法相同，但语义可能截然不同。语义的定义浓缩为如何根据语法树组装语义模型，以及如何处理语义模型。特别是，如果两个表达式产生相同结构的语义模型，即使语法不同，它们的语义其实也是相同的。

如果在使用外部DSL，用到了“语法制导翻译”，很可能会显式地使用文法来构建解析器。如果用的是内部DSL，可能没有显式的文法，但是从文法的角度思考DSL仍然是有用的，文法有助于在众多内部DSL模式中进行选择。

对于内部DSL，谈论文法显得有些奇怪，原因之一是，这里解析了两遍，所以包含了两种文法。第一种是宿主语言本身的解析，这显然要依赖于宿主语言的文法。这一遍解析创建宿主语言的执行指令。当宿主语言所构建的DSL执行时，语法树就会在调用栈中创建。只有在第二遍解析时，才会出现这个名义上的DSL语法。

### 3.4 解析中的数据

当解析器执行时，需要存储解析过程中的数据。这些数据可能是一个完整的语法树，但大多数情况下不是这样的。即使这种情况出现了，还是需要存储其他的一些数据，以便解析工作可以正常进行。

解析本质上是一种树遍历，当处理某一部分DSL脚本时，对于正在处理的语法树分支，可以得到其上下文的一些相关信息。然而，通常还会用到这个分支以外的信息。

命令定义在语言的某个地方，然后在其他地方引用。当命令在语句的行为中引用时，所在的语法树分支不同于命令定义的分支。如果语法树的表示只存在于调用栈中，那么到这里。命令定义就已经消失了。因此，要把命令对象保存下来以备后用。

为了做到这一点，需要使用**符号表**，它本质上是一个字典，其键是标识符`unlockDoor`，值是在解析中表示命令的对象。当处理文本`unlockDoor D1UL`时，创建一个对象持有数据，然后，把它存放在符号表里，键为`unlockDoor`。存放的对象可能是命令的语义对象，也可能针对局部语法树的中间对象。符号表对于交叉引用非常重要。如果在解析中创建一棵完整的语法树，理论上，可以省略符号表，但是它依赖是一个有用的结构。

### 3.5 宏

宏有两种风格，文本宏和语法宏。文本宏最容易理解，简单说就是文本替换。使用文本宏会带来便利，一个很好的例子就是在CSS文件中指定颜色。更复杂的宏例子是C的预处理器，比如，定义一个宏sqr(x)，它可以替换为`x*x`。

通过宏创建DSL有很多方式，可以使用宿主语言本身，也可以提供单独的一个文件，将其转换为宿主语言。语法宏也是通过替换实现的，但是它处理的是宿主语言中有效的元素，将一种表达式转换为另一种。

### 3.6 测试DSL

* 语义模型的测试
* 解析器的测试
* 脚本的测试

#### 语义模型的测试

```java
@Test
public void eventCausesTranstion() {
    State idle = new State("idle");
    StateMachine machine = new StateMachine(idle);
    Event cause = new Event("cause", "EV01");
    State target = new State("target");
    idle.addTransition(cause, target);
    Controller controller = new Controller(machine, new CommandChannel());
    controller.handle("EV01");
    assertEquals(target, controller.getCurrentState());
}
```

上面的代码演示了如何独立测试语义模型。然而，需要说明的是，这个例子的真是测试代码会更加复杂，也应该更好地分解。

有两种方法来分解这类代码。首先，创建一堆小的状态机，提供最小的测试夹具，以便测试语义模型的各种特性。比如，要测试“事件触发转换”(event triggers a transition)，只要创建一个简单状态机，它处于空闲态，并且可以转换(transition)为另外两个状态。

#### 解析器的测试

当使用语义模型时，解析器的工作就是组装语义模型。所以，解析器的工作就是组装语义模型。所以，解析器的测试就是，编写一小段DSL，确保它们生成结构正确的语义模型。

#### 无效输入的测试

刚才讨论的是正向测试，保证有效的DSL输入可以生成结构正确的“语义模型”。测试的另一种类型是负向测试，用于检测在无效输入的情况下会发生什么。无效输入的测试的基本想法，就是把各式各样的无效输入抛给解析器，经常会看到一些不起眼却很极端的错误。得到这样的结果可能已经足够了，除非要对错误诊断提供更多的支持。

#### 脚本的测试

语义模型和解析器的测试就是对普通对待进行单元测试。然而，DSL脚本也是代码，也应该考虑对它们进行测试。把测试看作double-check机制。当编写代码和测试时，其实是用两种非常不同的方式确定同一行为，一种用抽象的方式，另一种是用样例的方式。对任何有持久价值的东西，都应该进行双重确认。

脚本测试的细节很大程度上取决于要测试的东西。基本的方法是，提供一个测试环境，在其中创建文本夹具，运行DSL，比较结果。脚本测试也扮演着集成测试的角色，因为解析器或者语义模型的任何错误都会让它失败。

### 3.7 错误处理

解析器和生成输出是编写编译器中较为容易的部分，难点之一是给出更好的错误消息，DSL的注释支持。存在两个地方可以放置错误处理：模型或者解析器。对于语法错误，处理它最明显的地方就是解析器。

在处理语义错误时，要从解析器和模型中进行选择，两者都有其优点。如果要检查语义规则是否结构良好，模型是一个正确的地方。

* 把错误检测规则放在解析器中
* 把语义信息放入语义模型
* 使用语义模型检测错误

### 3.8 DSL迁移

DSL应该警惕的一个风险是“先编写，后使用”的想法。DSL的诸多属性同程序库完全一样，会不断发展变化并修改。

解决DSL修改问题的一种方式是，提供工具，自动把DSL从一个版本迁移到另一个版本。这些工具可以在升级时运行，也可以在尝试运行旧版脚本时自动运行。有两种方式实现迁移：

* 增量迁移的策略，这种方式本质上同人们处理数据库设计的演化所采用的想法是一致的。
* 基于模型的迁移，这种策略是可以与“语义模型”配合使用。语言就可以支持多个解析器，每个发布版对应一个解析器。每个解析器都会组装语义模型。当采用语义模型时，解析器的行为相当简单。*问题：很容易丢掉一些与语义无关但脚本编写者希望保留的东西：注释*

## 第4章 实现内部DSL

当使用内部DSL时，宿主语言很大程度上会造成限制，因为所用的任何表达式在宿主语言中都必须是合法的，内部DSL使用的很多思想都受限于语言特性。

**连贯接口**-用它描述接近语言风格的API，它是内部DSL的同义词。它揭示了API与DSL之间的核心区别----语言性。

### 4.1 连贯API与命令 - 查询API

连贯接口的核心模式是**方法级联**

```dsl
computer()
    .processor()
    .cores(2)
    .speed(2500)
    .i386()
.disk()
    .size(150)
.disk()
    .size(75)
    .speed(7200)
    .sata()
.end();
```

方法级联用了一连串的方法调用，每个调用都是在前一个的结果上继续调用，方法都是由一个叠一个的调用组成的。在常规的OO代码中，方法由点号隔开，还可以使用函数序列。

```dsl
computer();
    processor();
        cores(2);
        speed(2500);
        i386();
    disk();
        size(150);
    disk();
        size(75);
        speed(7200);
        sata();
```

只要以适当的方式对函数序列进行组织和代码布局，它读上去就可以像方法级联一样清晰明了。连贯性与所用的语法风格无关，而与方法本身的命名和分解方式相关。

连贯接口的本质是以不同的思路来思考如何使用组件，站在语言的角度，思考如何将“组装这些对象”的子句组装成句子。这种思想上的提升，正式内部DSL同调用API之间的核心差别。

命令-查询分离传递出一个信号：对象上的各种方法应该分为命令类方法与查询类方法。查询类方法有返回值，但不会改变系统的可观察状态。命令类方法可能会修改系统的可观察状态，但是不应该有返回值。这个原则非常重要，它可以帮助识别出查询类方法。由于查询类方法没有副作用，因此可以以任意顺序多次调用，而不改变调用结果。使用命令类方法，则要更谨慎一些，因为它们确实存在副作用。

在程序设计中，命令-查询分离是一条极具价值的原则。在内部DSL中使用方法级联，结果却常常破坏该原则----每个方法都要修改状态后返回一个对象，以继续链式操作。

命令-查询分离与连贯接口之间的另一重要区别是方法的命名。为命令-查询查询方法命名时，希望那些名字在独立的上下文中也有一定含义。对于连贯接口，方法命名则非常不同。因此往往会拥有一些方法，它们的名字在一个开放的上下文中并没有什么意义，但放在DSL句子的上下文中，读起来却很连贯。DSL中的方法命名，首先要考虑的是句子，元素的命名都应适应其上下文。DSL的命名都是基于脑海中特定DSL的上下文来编写的，而命令-查询的命名则是按照不需要上下文来撰写的。

### 4.2 解析层的需求

连贯接口与命令-查询接口的不同可能会产生复杂性。如果两种接口共存于一个类，则会让人产生迷惑。因此，建议构建一层“表达式生成器”，从而DSL中的语言处理元素与普通的命令-查询对象分隔开。表达式生成器对象的唯一任务就是，使用连贯接口构建普通对象的模型，从而将连贯的语句有效地翻译为一串命令-查询API调用。

使用表达式生成器的原因之一自然是两种接口的本质不同，但是更主要的原因是经典的“关注分离点”的观点。只要引入某种语言，即使是内部语言，也需要写出符合该语言的代码。这些代码往往需要保持对数据的跟踪，这些数据只有当处理该语言的时候才会有用。理解内部DSL的工作机制需要一定的时间，而一旦填充了底层模型，内部DSL如何工作就不再需要了。因此将语言处理的代码放在单独的层中是值得的，这个结构遵循DSL处理的一般过程。命令-查询接口对象的底层模型就是“语义模型”。表达式生成器就是解析器的一部分。

通常“解析器”用在解析文本的上下文中。在这种情况下，对文本的操作是由宿主语言解析器完成的。但是表达式生成器所做与解析器所谓的确有很多的共同之处。关键的差异在于，传统的解析器将标记流整理为语法树，而表达式生成器的输入则是函数调用流。同解析器的相同之处在于，将其理解为“将函数调用组织为解析树上节点”是有益的，使用了类似的解析数据结构，仍然会组装语义模型。

将语义模型同表达式生成器分离，带来的是使用语义模型一贯的优势。表达式生成器和语义模型可以独立测试，可以有多个解析器，既支持内部DSL，也支持外部DSL，或者用多个表达式生成器支持多种内部DSL。表达式生成器和语义模型也可以独立演化。如同其他软件一样，DSL很少一成不变。软件需要能够演进，能够在不改变DSL脚本的前提下，修改底层框架是很有用的，反之亦然。

有一种论调是反对使用表达式生成器的，但它只适用于语义模型自身使用了连贯接口的情形。在有些情况下，连贯接口是人们与模型交互的主要方式，这时模型类使用连贯接口是有意义饿的。然而，大多数情况下，倾向于模型累使用命令-查询接口。命令-查询接口在不同上下文中的使用方式更为灵活。连贯接口则往往需要存储临时的解析数据。

### 4.3 使用函数

命令-查询API往往表现为函数的形式，而通常，DSL结构也主要构建于函数基础之上。命令-查询API与DSL的主要区别在于函数组合的方式。既然存在组合函数的不同模式，选择哪种模式涉及不同的因素。第一个因素是函数作用域。如果用的是方法级联，DSL中的函数就是对象的方法，这些方法只能定义在链中的对象里，通常也就是“表达式生成器”里。如果在序列里使用裸函数，就要确保这些函数可以恰当地解决作用域问题。最显而易见的方式是使用全局函数，但是这么做会带来两个问题：让全局命名空间变得复杂，并为解析数据引入了全局变量。

全局的东西会让局部的修改变得困难，全局函数在程序的每个部分都可见，但理想情况下，函数应该只出现在DSL处理的部分。很多语言特性的存在都是为了消除对于全局化的需要。比如命名空间，只有导如一个特定的命名空间，其中的函数看起来才会像全局的一样。比如Java中的`static import`。

全局的解析数据是一个更严重的问题。无论以何种方式实现函数序列，都需要操作“语境变量”，以了解表达式解析进行到何种程度。

方法级联在很大程度上避免了全局性问题，虽然仍然需要从某种裸函数开始级联调用，不过，一旦开始，所有的解析数据都就可以保存在定义级联方法的表达式生成器对象里了。

在函数序列中使用“对象范围”，就可以避免上述全局情况。在大多数情形下，DSL脚本都放在表达式生成器的子类里面，这样，裸函数调用都是基于表达式生成器父类中的方法，从而解决了全局性的问题。DSL中的所有函数只定义在生成器类中，所以，都是局部化的。而且，因为它们都是实例方法，所以它们可以直接访问生成器实例的数据，保存解析数据。相对于将DSL脚本置于生成器子类所花的成本，这种做法有极具吸引力的优势，因此它是默认之选。

使用对象范围更进一步的好处是，对扩展性的支持。如果在DSL框架中很容易用范围类的子类，那么DSL用户就可以向DSL语言添加自己的方法。

函数序列与方法级联都需要使用语境变量跟踪解析状态。“嵌套函数”是第三种函数组合技术，使用它往往可以回避语境变量。如果使用嵌套函数，计算机配置的例子看上去应该是这样子的：

```dsl
computer(
    processor(
        cores(2),
        speed(2500),
        i386
    ),
    disk(
        size(150)
    ),
    disk(
        size(75),
        speed(7200),
        SATA
    )
);
```

嵌套函数组合函数的方式是，将函数调用作为更高层次函数调用的实参。结果就是函数调用嵌套起来。在解析技术中，层次结构随处可见，嵌套函数有着同任何类型的层次结构一样的强大优势。很直观的一点就是，在例子中，语言构造本身就反应出配置的层次结构----disk函数嵌套在computer函数里，这同框架对象最终嵌套得完全一致。因此，函数嵌套反映了DSL的逻辑语法树。使用函数序列与方法级联，只能以奇怪的缩进约定表现语法树，而嵌套函数则允许用语言反映语法树。

另一个结果是执行顺序的改变。使用嵌套函数，会在函数本身执行之前得到函数的实参。这样，即便没有语境变量，亦然可以构建框架对象。在computer函数执行之前，processor函数会先执行，返回一个完整的处理器(processor)对象。对后，根据完整的参数，computer函数就可以直接创建计算机(computer)对象。

在构建更高层次结构时，嵌套函数运作良好。然而，它也不尽完美。圆括号和逗号显得格外扎眼，同单纯的缩进约定相比，它们犹如噪音一般。因为嵌套函数同样要用裸函数，所以它与函数序列一样，也会存在全局性问题，而仍然可以通过对象范围加以完善。

如果只是将嵌套函数理解为一组命令，而非构建一个层次结构，其执行顺序会造成混淆。一个简单的嵌套函数序列最终的执行顺序与其编写顺序是相反的。

嵌套函数还客服了“函数实数参数由位置而非名字决定”的问题。考虑一个指定磁盘大小与转速的例子。如果所需全部内容只是两个整数，那么真正需要的就是`disk(75,7200)`。为了解决这个问题，可以使用嵌套函数，其仅仅返回整数值，这样写:`disk(size(75), speed(7200))`.这样的代码更为可读，却无法阻止写出这样的代码：`disk(speed(7200),size(75))`。

大多数程序员都会将大量使用嵌套函数看作一种与众不同，但只是反映了在日常(非DSL)编程中如何运用函数组合模式而已。

还可以进行模式混合，例子的各个部分分别展现出各个模式的长处。当定义列表中的元素时，函数序列运作良好。它很好地将每台计算机(computer)的定义划分到不同的语句里。实现起来也很容易，因为每条语句只是向结果列表中添加了一个配置完整的计算机对象。

对于每台计算机而言，嵌套函数消除了当前计算机对于语境变量的需求，因为所有的实参在computer函数调用之前就得到了。假设一台计算机由一个处理器以及数量可变的磁盘组成，那么该函数的实参列表就应该用其类型更好地反映这一点。一般来说，嵌套函数会让全局函数的使用更为安全，因为这么做会更容易将全局函数组织为“只返回对象而不改变解析状态”。

如果每个处理器和磁盘都有多个可选参数，那么方法级联会很适合。可以设置任意想要的值，以构建出所需元素。

然而，混合使用也会带来问题，特别是标点符号困惑：有些元素以逗号分隔，有些是点，有些则是分号，作为程序员，即使能够将它们分清楚，也很难记得住。对于一个非程序员而言，即使只是读这些表达式，他们都很可能会觉得困惑。标点符号差异是实现的产物，并不是DSL本身所需。

### 4.4 字面量集合

程序编写，无论以通用语言还是DSL，都事关将元素组合在一起。通常程序的组合方式是，将语句组合为序列，还有使用函数。组织元素还有另外一种方式，就是使用“列表的字面构造”和"Literal Map".

列表的字面构造包括一组元素，这些元素可以是相同类型，也可以是不同类型，而且数目不限。

类C风格的语言也有字面量数组的语法，比如`{1,2,3}`,它们可以当作更灵活的列表的字面构造来用，但是，就其使用场景以所能接受的元素而言，确实相当受限。也可以使用哈希或者字典表示脚本语言的字面量集合。

**符号(symbol数据类型)**-这种类型在大括号风格的语言中并不存在。符号数据类型主要用于在映射表中查找，尤其是在“符号表”中。符号都是不可变的，所以出于性能考虑，在实现上，相同符号值表示相同的对象。符号的字面形式不支持空格，它们也不支持大部分的字符串操作，因为其角色是符号查找，而非持有文本。

### 4.5 基于文法选择内部元素

内部DSL的元素有很多种不同的选择。选择的技巧之一是，考虑DSL的逻辑文法。当使用“语法指导翻译”时，创建的文法规则对于思考内部DSL也大有帮助。确定种类的表达式，加上其“BNF”规则，往往对应确定种类的内部DSL结构。

对于必选元素的子句`(parent ::= first second)`,嵌套函数是很好的选择。嵌套函数的实参可以直接匹配规则中的元素。如果是强类型语言，那么基于**类型感知(type aware)**的自动补全可以为每个参数提示正确的选项。

如果用嵌套函数处理可选元素列表`(parent ::= first maybeSecond ? maybeThird?)`,那就要困难的多，因为很可能最终得到的是，各种组合可能性的爆炸。在这种情况下，方法级联通常更适合，因为方法调用只要指明要用的元素即可。方法级联的棘手部分是，需要做一些额外的工作，确保规则中的每一项都只出现一次。

结构|BNF|考虑
-|-|-
必选列表|`parent::=first second third`|嵌套函数
可选列表|`parent::=first maebeSecond?maybeThird?`|方法级联
同构集合|`parent::=child*`|列表的字面构造、函数序列
异构集合|`parent::=(this|that|theOther)*`|方法级联
set|`n/a`|Literal Map

对于由多个相同类型的子元素组成的子句`(parent::=child*)`,采用列表的字面构造会比较合适。如果这个表达式定义的语句在语言的最顶层，那这就是会考虑函数序列的少量地方之一。

若是多个不同类型的子元素`(parent::=(this|that|theOther)*)`,会回到方法级联上，方法名很好地提示了所处理的元素。

子元素集合(set)往往不能与BNF很好地契合，有多个子元素，但每个子元素都最多只出现一次。也将其看作一个比选元素列表，其中的子元素可以按任意顺序排列。Literal Map在逻辑上很符合，但常常会遇到的问题是，必须使用正确的键(key)进行沟通，否则则不行。

对于‘最少一次’格式`(parent::=child+)`的文法规则来说，它并不能很好地与内部DSL契合。最好的方式是，使用一般的多元素格式，在解析过程中，检查至少有一个子元素。

### 4.6 闭包

**闭包(closure)**是程序涉及语言的一种能力，它们有很多的名字(**lambda**, **block**, **匿名函数**等)。闭包的作用是可以把某些内里联代码打包成一个对象，到处传递，在适当的时候执行。

对于内部DSL而言，会把闭包用作DSL脚本里的“嵌套闭包”。嵌套闭包有三个特点，使其很容易用于DSL：内联嵌套，延迟执行以及受限作用域的变量。

“嵌套函数”最好的特性之一是允许以一种对于宿主语言有意义的方式保留DSL的层次特征，而不像在“函数序列”和“方法级联”里，不得不以缩进表示层次关系。嵌套闭包同样具有这样的特点。

可以将任意的内联代码进行嵌套----这也是术语内联嵌套的由来。关于在函数实参里可以放什么，大多数语言都有一些限制，这也限制了在嵌套函数里编写的内容。但是，嵌套闭包可以突破这些界限。通过这个方式，可以嵌套非常复杂的结构，诸如，将函数序列嵌入嵌套闭包里，这在嵌套函数之中是不可能的。还有一个优势，在很多语言里面，从语法上说，嵌套闭包比嵌套函数更容易嵌入多条语句。

延迟执行可能是嵌套闭包带来的最重要的能力。使用嵌套函数，函数实参会在函数本身调用之前执行。使用嵌套闭包，则可以完全控制闭包执行的时机。可以改变执行的顺序，或者根本不执行某些闭包，或将所有的闭包存储起来以备后用。语义模型要完全控制程序执行的方式。这种做法尤为方便，这种模型称为“适应性模型”。DSL会包括一段宿主语言代码，这些代码会放入语义模型。这样，DSL与宿主语言代码就可以天衣无缝地融合了。

最后一个特点是，嵌套闭包允许引入作用域仅限于闭包内部的变量。通过使用作用域受限的变量，查看方法到底在操作那些数据就更容易了。

一个例子:

```ruby
#ruby
    ComputerBuilder.build do |c|
        c.processor do |p|
            p.cores 2
            p.i386
            p.speed 2.2
        end
        c.disk do |d|
            d.size 150
        end
        c.disk do |d|
            d.size 75
            d.speed 7200
            d.sata
        end
    end
```

对processor和disk的调用都包括一些代码，就是几条Ruby语句。这段代码还演示了作用域受限变量的用法，包括computer, processor, disks。这些变量虽然增加了一些噪音，但是也更容易看清楚，哪些对象在何处使用。从这段代码还可以看出，全局函数或者“对象范围”也不再是必需的了，比如，speed函数是定义在作用域受限变量上的“表达式生成器”

另一个例子：要到一组**验证(validate)**规则。通常，在面向对象的环境中，需要考虑对象是否合法，并且在某处有一些代码检查合法性。如果验证是上下文相关的，可能会更加复杂，比如为了做某事而验证对象。如果可以查看某人的数据，对于某人是否符合某项保险政策，一项政策的校验规则可能与另一项是不同的。在DSL里指定规则可能会这么做：

```cs
class ExampleValidation : ValidationEngineBuilder {
    protected override void build() {
        Validate("Annual Incomde is present")
            .With(p => p.AnnualIncome != null);
        Validate("positive Annual Income")
            .With(p => p.AnnualIncome > 0);
    }
}
```

函数调用`With`的内容是一个闭包，这个闭包以一个“人”为实参，并包含一些任意的C#代码。这些代码存储在语义模型上，当模型运行时再执行。
嵌套闭包是一项非常有用的DSL模式，即使对于支持闭包的语言，其闭包的语法也往往比较别扭。

### 4.7 解析树操作

解析树操作的基本思想是，当遇到一个使用宿主编程语言的表达式时，并不执行它，获取其结果，而是将其解析数看作数据。比如`aPerson.Age > 18`表达式的解析树如下：

```json
{
    "node" : "BinaryExpr",
    "childs" : [
        {
            "node" : "MemberExpr",
            "childs" : [
                {
                    "node" : "Member",
                    "value" : "Age"
                },
                {
                    "node" : "op",
                    "value" : "."
                },
                {
                    "node" : "Expr",
                    "value" : "aPerson"
                }
            ]
        },
        {
            "node" : "op",
            "value" : ">"
        },
        {
            "node" : "ConstantExpr",
            "value" : "18"
        }
    ]
}
```

解析树操作的强大之处在于，除了存储闭包本身外，还可以用于宿主语言编写表达式，然后可以把这些表达式转换为不同的表达式，以组装“语义模型”。

### 4.8 标注

Java的**标注annotation**和C#的**特性attribute**等。

标注允许程序员向程序构造(如类和方法)里面附加元数据。这些标注可以在编译期或者运行期进行读取。

```java
class PatientVisit {
    @ValidRange(lower = 1, upper = 1000, units = Units.LB)
    private Quantity weight;
    @ValidRange(lower = 1, upper = 120, units = Units.IN)
    private Quantity height;    
}
```

另一种显而易见的替代方案是，将范围检查代码放到字段的setter里面。不过采用标注会有诸多优势。字段边界读起来更清晰，范围检查也更容易，或者当给属性赋值时，或者稍后的对象校验阶段，这种方式指定的校验规则可以读到，并由GUI组件进行配置。

**标注可以看作一种扩展语言的方式，有了它语言就可以支持新的关键字(keyword功能)**。的确，即便是一些既有关键字，如果用标注实现，也可能会做的更好。比如，从一个新的角度来看，访问修饰符----private，public等以这种方式实现就会更好。

标注同宿主语言的绑定非常之紧密，所以它们很适合片段DSL，而非独立DSL。它们尤其擅长提供非常同一的思路来给宿主语言添加领域专用的增强特性。

### 4.9 为字面量提供扩展

为字面量提供扩展的危险之一是它在全局上增加了方法，但这些方法应该只用在DSL的受限上下文中。为字面量提供扩展虽然不是需要频繁使用的技巧，但用到的时候却非常方便----它非常适合针对特定领域定制语言的场合。

### 4.10 消除语法噪音

内部DSL的关键在于它们只是基于宿主语言的表达式，其编写格式使之读起来如同语言一样。这种做法的影响之一是，它们与宿主语言的语法结构交织在一起。从某些方面这样很好，因为其提供的语法是很多程序员都熟悉的，但有些人会觉得某些语法令人恼火。

消除这些语法负担的方式之一是，以尽可能接近宿主语言的语法编写DSL代码，但也不一定要完全一致，然后用简单的文本替换，将其转换为宿主语言。比如将`3 % if value at least $30000`转换为`percent(3).when.minimum(30000)`。

另一种方法是使用语法着色。大多数文本编辑器都提供了可定制的文本着色方案。

### 4.11 动态接收

动态语言的特点之一是，它们在运行时处理方法**调用(invoation)**。所以，如果写下`aPerson.name`，而person对象又没有定义name函数时，代码将会顺利通过编译，只在运行时抛出错误。

这些语言所采用的非统寻常的机制是这样的，将这个预期之外的调用路由到一个特殊方法进行处理。这个特殊方法的默认行为是抛出一个错误，但是，程序员可以重写该方法，进行其他处理，这种重写为“动态接收”，因为接收到的消息是否合法，是动态判断的。动态接收可能会带来一些有用的编程术语，尤其是使用代理时。有了代理，可以将对象包起来，无须准确知道哪个方法得到调用，就可以利用这些方法调用做一些事情。

在DSL中，动态接收的常见做法是，将信息从方法实参转移到方法名称上。动态接收的关键在于给了一个选择，将信息从参数转移到方法名上面，在某些情形下，这会让表达式更易于阅读和理解。

### 4.12 提供类型检查

静态类型的理由是，现代IDE通常提供了一些针对静态类型的优秀支持。然而，DSL中的大多数类似符号却没有得到这样的支持，因为需要将它们表示为字符串或者符号数据类型，并将其保存在自己的符号表。

## 第5章 实现外部DSL

虽然单靠内部DSL已经足以定义出连贯的语言，但最终还是会受限于宿主语言的语法结构。外部DSL则提供了更大的语法自由度----可以使用自己喜欢的语法。

相比于内部DSL，实现外部DSL的不同之处就在于解析过程，需要解析纯文本输入，这些输入不受任何现有语言的约束。创造DSL所需的背景知识要少于开发通用语言。

### 5.1 语法分析策略

当解析外部DSL时，要将一串文本分解成某种结构，通过这种结构来理解文本的含义。这个“结构化”的过程称为**语法分析(syntactic analysis)**。

一个简单的方法是分隔符指导翻译，受限找出能把输入分解成语句的分隔符（通常是换行符），根据这些分隔符把输入拆分成语句，然后逐个语句进行处理，找出其中的含义。通常，每行文本都包含一些明显的标识。

分隔符指导翻译很容易使用，涉及的工具也是大多数程序员都熟悉的字符串操作和正则表达式。其局限性在于，它不适用于处理层次结构的输入上下文。

更合适的办法是“语法指导翻译”。首先为输入语言定义一个形式化的文法，一般使用生成式表达。绝大多数文法都是以某种形式的**BNF**编写的，其中每行代表一条规则：首先是规则的名称，然后是满足该规则的合法元素。文法对于语法指导翻译特别有用，因为根据文法就可以机械地生成解析器。由语法指导翻译生成的解析器非常适合于处理这样的层次结构。

三种将BNF转换成某种解析算法的方式：

* **递归下降语法解析器**-是经典的转换方法。递归下降算法是一种易于处理理解的解析算法：用函数内部的控制流来展现文法规则。每条文法规则会转换成解析器中的一个函数，每个BNF运算符到控制流的转换过程都有清晰的模式可循。
* **解析器组合子**-将每条规则转换成一个对象，再把对象组合成一个与文法对应的结构。仍然需要递归下降语法解析器的元素，但这些元素会包装成组合子对象，只要将它们组合起来就可以了。
* **解析器生成器**-可以把BNF当作DSL来操作：用这种DSL来编写文法，解析器生成器负责生成解析器。

解析器生成器是最精密的途径：以BNF作为DSL，会让语言更容易理解和维护，因为其语法已经清晰地定义出来，并且能够自动地绑到解析器上。不过这些工具的缺点是需要花时间学习。

ANTLR解析器生成器是一个成熟的，广泛适用的开源工具，它是一个强大的递归下降语法解析器。

### 5.2 输出生成策略

当想要解析某些输入时，必须知道：要使用解析的结果干什么----输出应该是什么样子的？大部分时候，解析过程的输出应该是一个“语义模型”，随后就可以直接解释它或者将其用作代码生成的输入。

* **嵌入式语法翻译**-一个步骤，直接把方法调用放入解析器，从而在解析过程中生成语义模型
* **树的构建**-两个步骤，首先解析输入文本，构造出一棵包含文本结构的语法树，同时用符号表处理语法树各个部分之间的交叉引用；然后执行第二阶段，遍历语法树，生成语义模型。
* **内嵌解释器**-在解析过程中执行解释，并直接输出最终结果。内嵌解释器的一个经典例子就是计算器：它接受算术表达式作为输入，将计算的结果作为输出。也就是说，内嵌解释器并不生成语义模型。

使用树的构建有一个很大的好处：它把整个解析任务分解成两个更简单的任务。当识别输入文本时，只需要关注如何构建语法树----实际上，很多解析器生成器提供了用于树构建的DSL。可以让这部分工作变得更加简单。遍历语法树组装语义模型则是一个常规的编程练习，随时检查整棵树来判断应该做什么。比如XML代码，嵌入式语言翻译类似于SAX，而树的构建则类似于DOM。

即使不生成语义模型，也可以使用嵌入式语法翻译和树的构建----其实在使用代码生成时，这种情况相当常见，大部分解析器生成器的例子都会这样做。

### 5.3 解析中的概念

“语法指导翻译”通常分为两个阶段：**词法分析**(扫描或标记/词素解释)和**语法分析**。词法分析阶段将输入文本转化为一串**标记(token)**，这是一种数据类型，包含两个主要属性：类型和内容。语法分析器随后会根据文法规则把这一串标记组织成一棵语法树。

一般的词法分析会将空白符去掉，解析器根本不会看见它们，当然有时空白字符会用作语法的一部分，例如用换行符作为语句分隔符，或者像Python那样用缩进来标识语法结构。

通常某种结构的文法不只一种，多种文法能够识别同一语言的情况很常见。又很多原因得到不同的文法：不同的**解析器生成器**使用不同的文法，这些文法的语法和语义都不同。即便对于同一个解析器生成器，当采用不同的方式构建文法规则时，也会得到不同的文法。和其他任何代码一样，也要重构文法，使其更容易理解。最终的产出代码也会影响构建文法的方式。

#### 正则文法、上下文无关文法、上下文相关文法

所有正则文法都是上下文无关的，所有上下文无关文法都是上下文相关的。正则文法很重要，因为可以用一个有限状态机来处理，因为正则表达式就是有限状态机，所以正则语言可以用正则表达式来解析。

就计算机语言而论，正则文法有一个大问题：其无法处理嵌套元素。正则语言可以解析`1+2*3+4`这样的表达式，但不能解析`1+(2*(3+4))`。正则文法“不能计数”----对解析器而言，不能用有限状态机解析带有嵌套块的语言。

要处理起嵌套块，就得向上走一步：上下文无关文法。因为一个上下文无关的文法却会给文法添加层级上下文，使其能够“计数”。上下文无关文法可以用**下推机(push-down machine)**----带有栈的有限状态机来实现。大部分语言额解析器都使用上下文无关文法，大部分“解析器生成器”也使用它。“递归下降语法解析器”和“解析器组合子”都会生成下推机。于是，大部分现代编程语言都是用上下文无关文法来解析的。

但是上下文无关文法并不能处理想要的所有语法规则。一个常见异常情况是这样一条规则：变量务必先声明再使用。问题在于，当使用变量时，变量声明常出现在当前所在程序分支所在层次结构之外。尽管上下文无关文法可以保存层次结构上下文，但也没有足够的上下文来处理这种情况----因此还需要**符号表**。

**解析式表达文法(Parsing Expression Grammer, PEG)**-使用一种新的文法格式，可以处理大部分上下文无关的情景和一些上下文相关的情景。PEG解释器不倾向于使用单独的词法分析，并且大部分情况下，PEG似乎比上下文无关文法更好用。

#### 自顶向下解析和自底向上解析

编写解析器的办法有很多种，所以出现了“解析器生成器”。其中最大的一个区别是：解析器是自顶向下的还是自底向上的。

自顶向下解析器首先处理文法中最高级别的规则，根据它确定如何尝试以及匹配，自底向上正好相反。自顶向下解析器也称为LL解析器，自底向上解析器称为LR解析器。自底向上解析有时还称为“移进-规约解析”，因为移进-规约方法是最常见的自底向上解析实现方式。

自底向上解析器比自顶向下解析器要难以编写和理解。Yacc系列可能是最有名的解析器生成器系列，它就是一个自底向上(LALR)解析器。

递归下降算法是一个自顶向下的解析算法，自然“递归下降语法解析器”也是一个自顶向下的解析器，解析器组合子也是。ANTLR解析器生成器也是基于递归下降算法的。

自顶向下解析器的缺点是，无法处理**左递归(left recursion)**。下列规则：

```bnf
expr : expr '+' expr
```

类似这样的规则会导致解析器在尝试匹配`expr`时陷入无穷递归。通过提取左因子就可以消除左递归，做法比较简单，但最终得到的文法就会比较难懂。

### 5.4 混入另一种语言

面对一种外部DSL，一个最大的风险是：它可能在不经意间演变成了一种通用语言。即便没有那么极端，一种DSL也很容易变得过于复杂，尤其是在其中考虑很多特殊情况时，这些情况很少出现，但往往需要特别处理。

使用外加代码的一个问题是：需要不同的方式对外加代码进行标记划分，因此需要某种“可变分词方式”。最简单的可变分词方式方法是，用某种清晰的分隔符将嵌入代码引用起来，使其能够识别为单个标记从而以单一字符串的形式经过解析。

可变分词方式不仅可以处理外加代码。在不同的解析上下文中，也许希望把语言的关键字解释为一个名称的一个部分，可以用圆括号来完成这个技巧，但可变分词方式的其他实现方式引入的语法噪音更少。

### 5.5 XML DSL

很多常见的XML配置文件实际上就是DSL。当然并非所有的配置文件都是DSL。“属性列表”和DSL是不同的。属性列表只是一份简单的“键-值对”列表，可能再加上分类。属性列表没有多少语法结构----完全不具备DSL那些神奇的语言性。另一方面，很多配置文件确实具有像DSL一样的语言性。如果是用XML来实现，就把它们看作外部DSL。XML不是编程语言：它是一种没有语义的语法结构。因此，需要首先把XML代码解读成标记，然后再处理，而不能直接解释、执行它。DOM处理本质上就是“树的构建”，SAX则是“嵌入式语法翻译”。XML就是DSL的承载语法，跟内部DSL的宿主语言提供的承载语法是一样的。

以XML作为承载语法，它引入了太多的语法噪音----太多的尖括号，引号和斜线，每个嵌套元素都必须有开始标签和结束标签。结果有太多的字符是在为语法结构----而非真正的内容----服务，代码变得难以理解----而“容易理解”正是DSL的全部意义所在。

自定义的外部DSL也带来了一个烦恼：它们处理引用，字符转义之类的事情的方式总是难以统一。

除了生成树或者事件的解析器之外，还有一些XML绑定接口，可以很轻松地将XML数据翻译成对象和字段。如果使用解析器生成器，就可以在文法中定义XML结构所能提供的很多检查功能。但很少有工具能使用文法输入。

JSON和YAML相比于XML语法噪音小的多，但是这些语言很大程度上是针对结构化数据的，因此缺乏真正连贯的语言所需的灵活性。DSL与数据序列化不同，连贯性对于DSL的易读性至关重要，而数据序列化格式为了它自己的主要用途做了太多的妥协。

## 第6章 内部DSL vs 外部DSL

### 6.1 学习曲线

内部DSL的学习成本更低，它们看起来只是一些更加好用时髦的API，并且是建立在一种熟悉的语言之上。而学习外部DSL，则需要学习解析器，文法和“解析器”生成器等。

### 6.2 创建成本

构建DSL的成本重要的是区分模型构建的成本和基于模型构建DSL层的成本。在许多情况下，模型与DSL是相关联的，但模型有其自身的考量。

就内部DSL而言，于模型之上构建一层“表达式生成器”就需要额外的付出。在外部DSL中，相应的成本在于解析器的创建，一旦掌握了“语法指导翻译”，编写文法和翻译代码实际上是相当快的。开发解析器的成本同构建表达式生成器层是相似的。

### 6.3 程序员的熟悉度

外部DSL其实相当简单，如果能够遵循常用编程语言的语法规范，那么会让它的接受读更高。

有时，会用到一些更复杂的技术，比如“类符号表”，它需要工具的支持，但采用这种方式，可以继续享受IDE的优势。然而，使用外部DSL，除了最基本的文本编辑功能外，可能什么都没有。支持语法高亮的功能并不困难，大多数编辑器都配置了这样的功能，但是像类型感知的自动补全这类功能就有些困难。

### 6.4 与领域专家沟通

内部DSL通常会和宿主语言的语法绑定在一起，导致其在表达自由度上有限受限，并且会有一些语法噪音。但领域专家不一样，表达受限的程度以及语法噪音同语言相关，有些语言会比其他语言更加适合作为DSL。就算最好的内部DSL，也无法提供和外部DSL一样的语法灵活度。

### 6.5 与宿主语言混合

内部DSL本质上只是一些连贯方法的使用约定，DSL与宿主语言之间边界很模糊，存在利弊，取决于如何使用。

好处在于，当内部DSL缺乏某种构造时，可以很方便地使用宿主语言。这样一来，如果要在DSL中使用算数表达式，无须在DSL里面为此创建专门的构造，使用宿主语言的特性即可。如果要在DSL基础上构建抽象，直接使用宿主语言的抽象功能就好了。

外部DSL无法和宿主语言混合使用，但可以把宿主语言作为“外加代码”嵌入DSL脚本。同样，DSL也可以作为字符串嵌入通用语言，就像嵌入正则表达式和SQL一样。

### 6.6 强边界

宿主语言代码和DSL代码进行混合并不总是带来好处，只有当DSL的用户非常熟悉宿主语言时，这才行的通。DSL的好处就是其能力范围是有限的。这种限制使其易于理解，屏蔽bug。如果DSL有很强的边界，就会限制要测试的东西。DSL中的定价规则不会给集成服务器发送任意的消息，也无法改变订单处理流程。

### 6.7 运行时配置

XML DSL之所以流行，是因为改变代码执行上下文的时间从编译时到运行时。外部DSL可以帮助做到不重新编译就可改变系统行为，在运行时解析，翻译成“语义模型”，然后执行模型。

一种方式是将解释型语言和编译型语言结合使用，然后，用解释型语言编写内部DSL。

### 6.8 趋于平庸

Ant是一种描述Java构建的语言：它是一种使用XML语法的外部结构。相比于扩展一门语言，可以引入另一种语言处理特殊以及复杂的情况。可以在基础的DSL之上再设计另一种语言，其输出就是基础的DSL。这种技术非常有用，有了它，就能用那种缺乏抽象构建能力的语言构建抽象。

### 6.9 组合多种DSL

DSL应该是小巧的，能力受限的。所以，要完成实际工作，就要将DSL同一种或多种通用语言集成起来。也可以将多种DSL组合起来。

对于内部DSL而言，组合DSL就像通宿主语言混合一样容易。还可以用宿主语言的抽象特性帮助完成组合的工作。对于外部DSL来说，这种组合要困难一些。用“语法指导翻译”进行组合，要为不同的语言编写独立的文法，还要能把这些文法组合在一起。大多数“解析器生成器”都不具备这样的能力，这也是只关注通用语言的另一个后果。

### 6.10 总结

无论是内部DSL还是外部DSL，其各有利弊，同时在两个方向进行尝试，所需的投入并不如想象的高。如果使用“语义模型”，在其上构建多种DSL并不困难，无论是内部还是外部。

## 第7章 其他计算模型概述

主流的编程语言大都遵循命令式计算模型。命令式模型把整个计算过程定义为一系列的步骤，如果条件成立再做其他的事情。条件和循环会改变步骤的执行顺序，多个步骤可以组合成为函数。面向对象语言提供了数据与操作之间的绑定，以及多态----但基础仍然是命令式模型。

命令式的展现方式有一个潜在的严重缺陷，它会丢掉一些有用的机会。决策表就有这样一个好处，可以检查它，确保没有遗漏或者重复某些排列项。使用命令式代码还有一种实现方式，创建决策表抽象，然后根据这里的特定情况进行配置。

### 7.1 几种计算模型

#### 7.1.1 决策表

决策表是一种很简单的计算模型，也很适合DSL表达。由于决策表就是一张表格，因此也很适合在电子表格中编辑。

#### 7.1.2 产生式规则系统

**产生式规则系统**是一种对逻辑进行建模的常用概念：它将逻辑分解成多条规则，每条规则由条件和由此引发的行为两部分组成。如果是采用命令式代码，每条规则都可以用类似于if-then语句的风格表述:

```dsl
if
    passenger.frequentFlier
then
    passenger.priorityHandling = true;
if
    mileage > 25000
then
    passenger.frequentFilter = true;
```

有了产生式规则系统，就可以用“条件+行为”的形式定义规则，至于规则的执行和规则之间的关联则交给背后的系统。

这种性质(触发某些规则会改变另一些规则是否被触发)称为**级联(chaining)**，这是产生式规则系统的一个重要性质。有了级联，就可以单独编写规则，无须考虑在更大范围内造成的影响，让系统自己找到结果。

产生式规则系统依赖大量隐式的逻辑，经常会做出意想不到的事情。对于其他计算模型而言，隐式行为造成的问题相当常见。当实现其他计算模型时，有必要加入某种跟踪机制，以便看出模型执行过程中到底发生了什么。对于产生式规则系统而言，就意味着需要记录触发了哪些规则，必要时可以很容易提供这些记录。

级联无疑是产生式规则系统的重要组成部分，但它并非不可或缺。不支持级联的产生式规则系统有时也很有用，例如，一个很好的例子是一组校验规则。当校验时，通常只提供一组校验条件，其中校验未通过的行为就是“报错”。尽管不需要级联，不过把整个校验行为看做一组彼此独立的规则仍然有有助于理清思路。

当使用产生式规则系统时，每次只关注一条规则的行为；而使用决策表时，则要同时关注整张表。这种视角的变化使这两个模型成为不同的思维工具。

#### 7.1.3 状态机

状态机把对象的行为划分成一组状态，用事件触发行为，根据对象所处的状态，事件会使对象从当前状态转换到另一个状态。

状态机的核心元素包括状态、事件和转换，但在这个基本结构之上还有很多变化。特别是，状态机初始化的行为有着诸多变化。状态机很常用，因为很多系统都可以看做“以变动的状态响应各种事件”。

#### 7.1.4 依赖网络

如果有一系列耗费大量计算资源并且彼此依赖的任务需要管理，依赖网络就是很好的选择。

#### 7.1.5 选择模型

所有的模型选择最终都归结于一种感觉：这种计算模型是否符合思考这个问题的方式。而判断“是否符合”的最好办法就是“试一下”：先在纸上尝试用简单的文字和图表来描述行为；如果某个模型似乎能通过这个简单的纸上测试，那就值得把它构建出来。

## 第8章 代码生成

通常来说，直接执行语义模型是最容易做的事，然而还有很多情况，无法这样做。比如，DSL的逻辑只能在有很大差异的环境中执行，在那种环境里，语义模型或解析器都极难构建，甚至无法构建。通过代码生成，几乎可以在任何环境下运行DSL指定的行为。

使用代码生成，要考虑两种不同的环境：DSL处理器和目标环境。DSL处理器都是解析器、语义模型和代码生成器之所在，应该是便于开发的。目标环境则是为生成代码及其周边准备的。使用代码生成的意义在于，将目标环境通DSL处理器分离开来，因为在目标环境下，可能无法构建DSL处理器。

### 8.1 选择生成什么

可用的代码生成风格有两种：“基于模型的代码生成”和“无视模型的代码生成”。二者的差别在于，在目标环境里，“语义模型”是否显式地表现出来。实现状态机有两种经典方案，分别是嵌套条件和状态表。看一个非常简单的状态模型。

这里有两个条件测试，一个嵌套在另一个里面。外部条件查看状态机的当前状态，内部条件根据接收到的事件进行切换。这就是无视模型的代码生成，因为状态机的逻辑嵌套在语言的控制流中----语义模型没有显式地表现出来。

如果用基于模型的代码生成，就要在生成代码中表现出语义模型。这个模型不必与DSL处理器使用的完全吻合，但它会表现出某种形式的数据。

通过将语义模型表现在生成代码中，通用框架代码和专用配置代码分离开来，这通开篇中谈及的划分是一样的。基于模型的代码生成保留了通用/专用的区分，而无视模型的代码生成规则把语义模型放入控制流中，将二者混在一起。

如果采用基于模型的代码生成，唯一要生成的就是专用的配置代码。完全可以在目标环境中构建出基本的状态机，在那里进行测试。而采用无视模型的代码生成，就不得不生成更多的代码。固然可以将一些代码提取出来放到程序库函数里面，省去生成的过程，但大多数关键行为依然要生成。

采用基于模型的代码生成会容易许多，生成的代码也会很简单。虽然依然要构建通用的部分，但是，鉴于这个部分可以独立于代码生成系统运行和测试，实现起来通常容易。因此，尽可能采用基于模型的代码生成。

### 8.2 如何生成

有两种文本输出的风格可以遵循

* 基于转换器的代码生成
* 模版化的生成器

采用基于转换器的代码生成的话，要编写代码，读取“语义模型”，生成目标源码的语句。如果用的是模版化的生成器，会写出一个示例的输出文件。输出文件会有特定状态机专有的一些东西，这样就可以调用语义模型生成相应的代码。

模版化的生成器是由输出的结构驱动的，而基于转换器的代码则是由输入、输出或者二者共同驱动的。两种代码生成方式用起来都不错，要在二者中选择，最好每个都试一下，选择最适合自己的那个。模版化的生成器适用于输出里有大量静态代码，只有少量静态部分呢的情况----而且，可以查看模版文件，了解生成代码会是什么样子。如果用到**无视模型的代码生成**，很可能采用模版化的生成器。否则更倾向于基于转换器的代码生成。

### 8.3 混合生成代码和手写代码

有时，在目标环境下执行的所有代码都可以生成，但更常见的情况是，需要混合生成代码和手写代码。有一些需要遵循的通用规则：

* 不要修改生成代码
* 将生成代码和手写代码严格分开

根据DSL生成代码，其重点在于DSL应该成为行为的权威来源。将文件清楚地分为“全生成”或是“全手写”。生成代码是不会提交到源码库里面的，因为这些代码都是可以在构建过程中重新生成的。

在一个过程式系统中，代码是以函数的方式组织在文件里面的，因此做到这点很容易。而面向对象则不然，类混合了数据和行为，分开二者要相对复杂一些。处理这种情况最简单的方法是，把这个类分成多个文件。根据需要，分成生成代码和手写代码。

这个问题有一个好的解决方案，就是**代沟**，用继承分离生成代码和手写代码。按照其基本形式，生成一个超类，然后手写一个子类，在子类里增强或者重写生成的行为。这样就用文件生成代码和手写代码分开了，在一个类里结合了两种风格，具有极大的灵活性。

### 8.4 生成可读的代码

可以让生成代码如手写代码那样好----拥有清晰的变量名，良好的结构，以及遵循大多数的良好习惯。

### 8.5 解析之前的代码生成

在某些情况下，DSL脚本要集成一些外部信息。确保DSL脚本里用的符号与企业数据库中的一致。可以用**代码生成**生成脚本编写所需的信息。这样，在组装**语义模型**时，就可以利用这些信息进行检查，有时，这些信息在源码中也很有用，对于代码导航以及静态类型尤其如此。

## 第9章 语言工作台

**语言工作台**是这样一种工具，可以帮助打造DSL，并为这种DSL提供现代IDE风格的工具支持。其基本想法就是，这类工具不仅要提供一个创建DSL的IDE，还要为编辑这些DSL构建新的IDE。

### 9.1 语言工作台之要素

各种语言工作台都可以从以下三个方面定义DSL环境：

* **语义模型**模式一般用模型定义出语义模型的数据结构以及静态语意
* DSL编辑环境为人们编写DSL脚本定义丰富的编辑体验，可能是直接编辑源码，也可能是惊醒投射编辑。
* 语义模型行为定义出构建好语义模型后，DSL脚本能够做些什么，通常采用的技术是代码生成。

语言工作台以语义模型为系统核心，提供工具辅助模型定义。语言工作台并不使用程序设计语言定义语义模型，而采用一种特殊的元模型建模结构，这种结构要用到运行时工具处理模型。正是利用了元模型建模结构，语言工作台才能够提供更高级的工具支持。

这样一来，模式和行为得以分离。语义模型模式本质上是一种数据模型，没有任何行为。语义模型行为来自数据结构之外，大部分源自代码生成。有些工具提供语义模型，就可以根据此构造解释器，不过代码生成依旧是运行语义模型最常用的方式。

语言工作台最有趣也是最重要的一个特征是它们的编辑环境。这也是语言工作台给软件开发带来的最重要的改变，为组装和操作语义模型提供了广泛的工具支持。

### 9.2 模式定义语言和元模型

语言工作台所用的模型文本和语义模型有着显著的差异。语言工作台提供了一个环境，用于定义模型的模式，也就是数据结构，通常会用到一种专用的DSL----模式定义语言。至于行为语义，则是要单独定义的，一般用代码生成来做。

**元模型**只是另一种语义模型，容易定义一个DSL组装这个模型，就像为基本模型所做的一样----这样的DSL，称为模式定义语言。模式定义语言其实仅仅是某种形式的数据模型，能够定义实体及相互关系而已。

当手动构建DSL时，创建元模型的意义不大。在大多数情况下，使用熟悉的宿主语言的结构定义能力是最好的选择。因为所用的是熟悉的语言构造，所以用起来会比较容易。

元模型也只是一种模型而已。同其他的模型一样，它也要有自己的模式定义其结构。用语言工作台自身的建模工具处理模式定义系统自身，而创建模型的工具就是编写DSL脚本的工具。

这种方式称为**自举工作台**，许多语言工作台采用的都是这种方式。通常来说，自举工作台更值得信赖，既然这个建模工具都能定义自己，对工作而言足够。

模式定义语言和文法的差别：文法定义某种（文本）语言的具体语法，而模式定义语言定义语义模型模式的结构。所以，文法包含需要用于描述输入语言的东西，而模式定义语言则独立于任何“用于组装语义模型”的DSL。文法还隐含解析树的结构，以及树的构建规则，可以定义语法树的结构。

当定义模式时，要考虑的数据结构：类和字段。模式定义大部分考虑的是，用于存储语义模型元素的逻辑数据结构。还有一个要素需要考虑：模式的结构性约束。这些约束用于定义什么是最有效的语义模型，其等价于契约式设计中的**不变式(invariant)**。

结构性约束通常指的是不是那些由数据结构带来的约束----可以保存数据，但也不管用。数据结构可能会有些附加的约束。约束的复杂度是任意的，甚至会牵扯到多个字段和对象。

模式定义语言都有一些表现结构性约束的方式，也许简单到仅仅允许设定属性的取值范围，也许复杂到用一种通用语言表现任何约束。结构性约束往往存在一个限制，它无法改变语义模型，只能查询。按照这种方式，这些约束就是一个没有级联的“产生式规则系统”

### 9.3 源码编辑和投射编辑

基于源码的编辑系统用一种可编辑的表现形式定义程序，通过工具将其带入运行时系统，然而，这种表现形式与工具无关。在实际中，这种表现形式是基于文本的，这意味着，程序可以由任何文本编辑工具读取和编辑。这个文本就是程序的源码，将它交给编辑器或者解释器，就可以转为可执行的格式，但是对于程序员来说，源码才是编辑和保存的主要表现形式。

采用投射编辑系统，程序的核心表现形式则是一种与所用工具相关的格式。这个格式就是工具使用的“语义模型”的一种持久化表现形式。当编辑程序时，要先启动工具的编辑环境，然后，工作将语义模型投射为一个可编辑的形式。

相比于基于文本的方式，投射编辑带来的好处是可以通过不同的表现形式进行编辑。状态机最好用图形化的方式展现，采用投射编辑器，状态机就可以将状态机渲染成一张图，直接以图的方式编辑。而采用源码，只能编辑文本。

这样的投射可以使得更好地控制编辑体验，输入正确信息，避免犯错。调用一个对象的方法，文本投射只显示这个类合法的方法，也只能输入有效的方法名。编辑器与程序之间就有了一个更紧密的反馈，编辑器也可以给予程序员更多的帮助。

还可以使用多个投射，可以同时作为主要投射的备选方案。可以根据喜好选择最适合于查看信息的投射方式。比如一个类的超类可以显示为表格的一个字段，在编辑环境的另一个面板中，则显示为类层次结构中的节点。编辑其中的任何一个都会更新核心模型，随即也会更新所有的投射。

这些表现形式不过是底层模型的投射而已，所以，鼓励对模型进行语义转换。如果重命名方法，最好体现在模型上，而非其文本表现形式上。从语义层面上看，许多变化都可以看做是对语义模型的操作，而非文本操作。这一点对于安全和有效的重构格外有帮助。

源文件还有一些实用上的优势，在某些场景下通过投射和截屏来解释则要麻烦得多。使用一些文本处理工具，某些转换可以很好地自动化，如果投射系统不支持所需的转换，这一点就显得特别有用。投射系统只接收有效输入，这一点固然很好，但有时当思考解决方案时，可能要键入一些无法立即起作用的东西作为临时

源码扮演两种角色：编辑形式和存储形式。编译器会将这种表现形式转换为可执行的形式。可以在机器上运行的形式。对于解释器语言来说，源码也就是可执行形式。

在某个时刻，比如编译期间，会生成某种抽象的表现形式，这纯粹是一种面向计算机的构造，只是为了使程序处理起来更加容易。现代IDE也会生成一种抽象的表现形式来辅助编辑。也许会有多种抽象的表现形式：IDE用于编辑的表现形式可能不同于编译器所用的语法树。现代编译器也会为不同的目的创建多种抽象表现形式，比如，为了某些目的的创建的是语法树，而为其他目的创建的是调用图。

使用投射性编辑，表现形式可以有不同的安排。核心表现形式是工具所用的**语义模型**。这种表现形式可以投射为多种编辑形式。模型通过一个单独的存储表现形式进行保存。存储表现形式也许在某个层面上是可读的，比如，以XML进行序列化。

### 9.4 说明性编程

投射编辑最引人入胜的一个发展就是，它堆成为说明性编程的支持。在常规程序设计中，最关注的是程序，是对增养的东西应该工作的一般性描述。说它是一般性，因为它只是一段文本，描述一般性的情况，对于不同的输入产生不同的结果。

相比于在解释器里运行代码片段的能力，说明性编程是一个更宽泛的概念。解释代码片段可以探索执行过程，但它并不会把示例置于重要的位置。说明性编程技术将说明推到了编辑体验的前台，程序则退居幕后，只在探讨说明的某个部分时，才会出现。

### 9.5 工具之旅

* **Intenional Workbench**
* **Meta-Programming System(MPS)**
* **Xtext**
* **SQL Server Modeling**

### 9.6 语言工作台和CASE工具

**CASE(Computer-Aided Software Engineering)**计算机辅助软件工程鞠躬可以使用各种图形符号表现软件设计，然后生成软件。特征：以模型为核心，使用元模型定义，图形投射编辑。

语言工作台和CASE工具的差异：CASE工具无法定义自己的语言。

# 第二部分

## 第10章 各种DSL

### 10.1 Graphviz

Graphviz可以生成一个图表，使用DOT语言编写，图表中有`节点`和`弧线`。节点用node关键字声明，但不一定要声明出来。弧用`->`操作符声明。在方括号里列出的是，节点和弧的属性。

### 10.2 JMock

JMock是Mock Object的一个Java程序库。其作者曾经写过多个mock对象程序库，关于如何用内部DSL定义mock上的预期。

Mock对象是用来做测试的。测试从声明预期开始，预期就是测试过程中会调用的对象方法。然后，把mock对象插入要测试的实际对象里，与之交互。随后，mock对象会汇报它是否接收到了正确的方法调用。

JMock使用了渐进式接口。采用这种方式，with只能出现在method之后，这样的，IDE的自动补全就可以帮助按照正确的方式写出预期。JMock采用**表达式生成器**处理DSL调用，并将其翻译称mock和预期的**语义模型**

### 10.3 CSS

CSS在声明式计算模型方面是一个好例子，这种计算模型不同于命令式模型。只要声明HTML元素的匹配规则即可。
 
SASS是另一种类似于CSS的DSL，生成CSS作为输出。SASS提供了数学运算和变量。在CSS块结构上加入语法上的换行和缩进。在一种DSL之上构建另外一种DSL，提供底层DSL缺失的抽象。上层的DSL应该类似于底层的DSL，上层DSL的用户也都能够理解底层的DSL。

### 10.4 HQL

Hibernate是一个广泛应用的对象-关系映射系统，可以将Java类映射到关系数据库的表上。HQL(Hibernate查询语言)提供了这样一种能力，在Java类上以类似于SQL的方式编写查询语句，映射到真实数据库的SQL查询上。

```hql
select person from Person person, Calendar calendar
where calander.holidays['national day'] = person.birthday
    and person.nationality.calendar = calendar
```

HQL处理的本质是，将HQL查询翻译成SQL查询：

* 用**语法指导翻译**和**树的构建**将HQL输入文本转换为HQL的抽象语法树
* 把HQL的AST转换为SQL的AST
* 代码生成器根据SQL的AST生成SQL

所有这些情况都用到了ANTLR。除了可以用标记流作为ANTLR语法分析器的输入，还可以用AST作为ANTLR的输入。ANTLR的树构建语法HQL和SQL的AST时都有用到。

这个转换的路径`输入文本-输入AST->输出AST->输出文本->输出文本`，对于源码到源码转换很常用。

### 10.5 XAML

XAML是C# WPF等UI布局的一种DSL，XAML就是XML文件，用来布局对象结构：使用WPF，可以布局屏幕。

```xaml
<?xml version="1.0" encoding="UTF-8"?>
<ContentView xmlns="http://xamarin.com/schemas/2014/forms"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml" 
    xmlns:binders="clr-namespace:DuGu.XFLib.Binders"
    xmlns:duguctrls="clr-namespace:DuGu.XFLib.Controls"
    xmlns:carView="clr-namespace:CarouselView.FormsPlugin.Abstractions;assembly=CarouselView.FormsPlugin.Abstractions"
    xmlns:ffimg="clr-namespace:FFImageLoading.Forms;assembly=FFImageLoading.Forms"
    xmlns:fftrans="clr-namespace:FFImageLoading.Transformations;assembly=FFImageLoading.Transformations"
    x:Class="QZhiHuFind.Views.DailyView"
    BackgroundColor="#E2DFED">
    <ContentView.Resources>
        <ResourceDictionary>
            <Style TargetType="ffimg:CachedImage">
                <Setter Property="DownsampleToViewSize" Value="true"/>
                <Setter Property="CacheDuration" Value="7" />
                <Setter Property="DownsampleUseDipUnits" Value="true" />
                <Setter Property="ErrorPlaceholder" Value="ic_placeholder.jpg" />
                <Setter Property="LoadingPlaceholder" Value="ic_placeholder.jpg" />
            </Style>
        </ResourceDictionary>
    </ContentView.Resources>
	<ListView
        x:Name="ItemsListView"
        binders:ListViewBinder.ItemTappedCommand="{Binding ItemSelectedCommand}"
        binders:ListViewBinder.LoadMoreCmd="{Binding LoadMoreCommand}"
        BackgroundColor="#E2DFED"
        CachingStrategy="RecycleElement"
        HasUnevenRows="True"
        IsPullToRefreshEnabled="True"
        IsRefreshing="{Binding IsBusy, Mode=TwoWay}"
        ItemsSource="{Binding Items}"
        RefreshCommand="{Binding RefreshCommand}"
        SeparatorVisibility="None"
        VerticalOptions="FillAndExpand">
        <ListView.Header>
...
...
```

在屏幕布局方面，这种做法HTML非常类似。

从逻辑上说，XAML文档定义了一个C#类，这里确实会用到代码生成。生成的代码是**部分类(C#语言特性)**。

### 10.6 FIT

FIT是测试框架，其目标是，以领域专家可以理解的方式，描述测试场景。随后的许多工具扩展了这个基本的想法，尤其是Fitnesse。

如果把FIT当作一种DSL，它的很多方面都很有趣：FIT的核心是提供一种记法，让非程序员也能够很容易地用表格形式指定示例值。所以，FIT程序就是一堆表格，典型的做法是嵌套在HTML页面里。表格之间可以放置其他HTML元素，这些元素都会当做注释。这样，领域专家就可以用平实的叙述方式描述他们想要的东西，表格就提供了可处理的部分。

FIT表格可以采用不同的形式，其本质就是一种简单的命令式语言。它简单到没有条件，没有循环，只有一堆动词。

每个表格同一个夹具相关联，将动词翻译成系统行为。check这个动词比较特殊，只是用来执行比较的。当运行表格时，会产生一个HTML输出，同输入页面完全一样，只会根据比较匹配与否，将check行标上颜色，或绿或红。

### 10.7 Make等

构建软件是需要若干步的。所以，在UNIX早期，Make工具提供了一个组织构建的平台。Make程序由若干目标组成，这些目标通过依赖联系在一起。

Make这样的构建语言不在于其计算模型，因为它们需要将DSL同常规的程序设计语言混合在一起。除了指定目标及其依赖关系外，还需要关心每个目标如何构建----这通常会采用命令式的方式。使用Make，这就意味着要用到shell脚本命令。

而标准的Java构建语言是Ant，它也是一种外部DSL，使用XML作为承载语法。能够避免Make由制表符和空格在语法缩进带来的大麻烦。由通用脚本或其他系统(Maven)生成Ant脚本。

## 第11章 语义模型

### 11.1 工作原理

在DSL的上下文中，语义模型是指一种表现形式，比如，内存对象模型，以表示DSL所描述的对象。如果DSL描述的是状态机，那么语义模型可能就是由状态、事件等类组成的对象模型。定义了特定状态和事件的DSL脚本，对应组装了一个模型，这个模型是一个符合其模式的特定实例，其事件就是DSL脚本里声明的事件。所以，语义模型就是由DSL组装的程序库或框架。

**之前提到的语义模型都是内存中的对象模型**，但并不是它们的唯一表现形式。可以用数据结构，用函数操作数据，表现一些状态机的行为。模型也不必存在于内存中：DSL也可以组装保存在关系数据库中的模型。

语义模型应该根据DSL的意图设计。对状态机而言，使用“状态机”模型就是要控制系统的行为。事实上，语义模型应该能够脱离DSL单独使用，应该能够通过命令-查询接口构建出来，这就可以保证语义模型完整地描述了主题领域的所有语义，可以独立地测试它和解析器。

语义模型同语法树有所不同，因为它们的目的不同。语法树对应DSL脚本的结构。虽然抽象语法树可能经过简化，或者重新组织输入数据，但是，其基本上遵循相同的形式。语义模型则更多的是用DSL脚本信息能够做些什么，因此会采用不同的结构，一般不是树结构。在某些场合下，对于DSL来说，AST也是一种有效的语义模型，但是只是特例，而非通则。

DSL和通用语言的一个差别：通用语言一般不涉及语义模型，语法树就够了，可以根据它进行代码生成，所以，再有个不同的语义模型也没什么必要。有时也会用到语义模型；比如，如果要做优化，调用图的表现形式很有用。这样的模型称为中间形式----代码生成之前的中间步骤。

语义模型经常先于DSL产生。另一种情况是DSL和语义模型要一起构建。语义模型可以包含执行自身的代码（解释风格），也可以作为代码生成的基础（编译风格）。即便用的是代码生成，提供解释方式也有助于DSL的测试和调试。

将验证逻辑放入语义模型中是最合适的，因为它包含验证所需的所有信息和结构。在解释执行或代码生成前，执行验证尤其有帮助。

组合型DSL以文本形式描述某种组合结构，一个例子是用XAML描述UI布局----语义模型的主要形式是各种元素如何组合在一起。状态机的例子更多的是一个计算型DSL，其产生的语义模型更像代码，而不是数据。

计算型DSL的语义模型用于驱动计算，通常用的是其他计算模型----而不是常见的命令式模型。这样的语义模型通常都是“适应性模型”。采用计算型DSL可以做很多事情，但是用起来没那么容易。

可以将语义模型想象称具有两组不同接口：**操作接口(operational intreface)**----客户端操作时使用组装好的模型所用的接口：**组装接口(population interface)**----DSL用来创建模型中类实例的接口。

* 操作接口应该假设语义模型已经创建好，系统的其他部分都可以很好地利用它了。
* 组装接口只用于创建模型实例，可能只是由解析器使用，虽然尽可能将语义模型通解析器解耦，但为了组装语义模型，解析器显然会依赖它。尽管如此，通过构建清晰的接口，降低因修改语义模型的实现而修改解析器的几率。

### 11.2 使用场景

语义模型的优点：

* DSL的语义和解析可以分开测试
* 测试语义：可以直接组装语义模型，基于模型执行测试；
* 测试解析器：可以看其组装的语义模型是否正确。如果有多个解析器，比较组装出的语义模型，就可以知道产生的输出在语义上是否相等。
* 语义模型同时提高了解析和执行的灵活性。可以直接执行语义模型，也可以进行代码生成。
* 分离了对语义和解析的关注

对于算术表达式而言，即便是不立即解析，其生成的抽象语法树AST同语义模型的内容几乎一致。那么如果模型不比AST更丰富，就不值得创建单独的语义模型。

当执行代码生成时，一般不需要语义模型。解析器生成AST，代码生成使用AST。

在函数式编程中，语义模型并不属于DSL文化的一部分。

### 11.3 入门例子（Java）

大多数情况下，并不需要为同一个语义模型提供多个DSL，但是这却是这个例子的一个需求，语义模型让这个需求变得相对简单。

语义模型让这个需求变得相对简单。用到多个解析器，既有内部DSL的，也有外部DSL的。一种测试的方式是，确保它们组装出等价的语义模型。无须复制其他解析器的代码，也无须修改语义模型，可以很容易添加新的DSL和解析器。

除了用做执行和输出的基础外，语义模型还是做校验的好地方。比如，检查是否有状态是不可达的，或者无法推出的。再比如，状态和转换定义中的所有事件和命令都用到了。

## 第12章 符号表

很多语言都需要在代码的不同地方引用对象。如果有一种语言，可以定义任务的配置及其依赖关系，就需要一种方式，在一个任务定义中，引用其依赖的任务。

为了达到这个目的，要对每个任务都定义某种形式的符号；当处理DSL脚本时，这些符号都放到符号表中，通过这张表，可以由符号关联到持有完整信息的底层对象。

### 12.1 工作原理

符号表的根本目的，建立DSL脚本中表示对象的符号与符号所🈯指对象之间的映射关系。这样的映射关系非常适合用map这种数据结构表示，因此用map实现符号表是最常见的做法，符号作为键，“语义模型”对象作为值。

需要考虑的问题是，在符号表里，用做键的对象应该是何种类型。对于很多语言来说，字符串是最显而易见的选择，因为DSL文本就是字符串。

有些语言不实用字符串，因为它们支持“符号”(symbol)数据类型，从结构上说，符号和字符串很像----基本上看，符号就是字符序列----但通常来说，二者在行为有所不同。符号主要用来查找，符号类型一般就是这样设计的。所以，两个字符串“foo”和“foo”可能不是同一个对象，需要比较其内容才能断定其相等性。

性能是一个好的理由，让符号数据类型优于字符串。但对于小型DSL而言，差别就没多大了，首选符号数据类型还有个更大的理由，使用它能够更好地表达意图。通过将某些东西声明为符号，可以清晰地表示出用它做什么，这会让代码就更容易理解。

支持符号的语言都会为符号准备一种特殊的字面量语法。Ruby用`:aSymbol`，而Lisp把所有的纯标识符看做符号。这样做的话，符号会从内部DSL中凸显出来----这也是使用符号的又一重要理由。

符号表中的值可以是最终的模型对象，也可以是处于中间状态的**生成器(builder)**，使用模型对象，符号表就可以作为结果数据，在简单情况下，这种做法很好；而把生成器对象当做值放进去，则可以提供更大的灵活性，代价是要多做一些工作。

有些语言要引入不同类型的对象。在开篇的状态模型里，要识别状态、命令和事件。有多种对象要引用，意味着需要在一个map、多个map以及特殊类等方法之间进行抉择。

在符号表中采用一个map，意味着所有的查找都要在同一个map上完成。这么做的直接后果是，对于不同类型的对象，不能用相同的符号名，也就是说，事件不能与状态同名。也许，这个约束是有用的，可以降低DSL中的混淆。

使用一个map，每一类对象都有一个单独的map。比如，状态模型有三个表，分别对应事件、命令和状态。可以将其看作一张逻辑符号表，或者三张符号表。

使用特殊类，意味着用一个对象表示符号表，以不同的方法引用存储其中的不同类型的对象。有时，这种方式很有用，任何特定的符号处理行为都有一个合适的地方。

在某些情况下，对象在定义好之前就引用了----这称为前向引用。DSL并不会严格使用限制标识符之前一定要声明它，所以，前向引用是有意义的。要支持前向引用的话，当引用一个符号时，如果符号表里面没有对应的项。要这么做的话，除非模型对象异常灵活，否则，应该用生成器作为符号表中的值。

如果符号无须显式声明，需要非常小心拼写错误的符号，这是诸多令人泄气的错误之根源。有一些地方可以检测到拼错的符号，加入这种检查可以减少麻烦。正是由于这种问题的存在，因此最好所有的符号都以某种方式声明出来。

一些复杂的语言还支持嵌套作用域，符号可以只定义在整个程序的某个子集里。在通用语言里，这种做法很普遍，但在简单的DSL里却很少见。

**静态类型符号**-如果用C#或Java这样的静态类型语言实现内部DSL，可以用**哈希表(hashmap)**作为符号表，以字符串为键。这种DSL的语句可能是这样的：

```dsl
task("drinkCoffee").dependsOn("make_coffee", "wash");
```

这样使用字符串肯定能起作用，但是还有以下一些问题：

* 字符串引入了语法噪音，因为它们要加引号
* 编译器不能做类型检查。如果拼错任务名，只有到运行时才能发现。此外，如果要识别不同类型的对象，编译器无法分辨是否引用了错误的类型----只有到运行时才能发现。
* 即便用的是现代IDE，也无法给字符串提供自动补全。
* 自动重构无法很好地支持字符串。

### 12.2 使用场景

对于任何的语言处理而言，符号表都是通用的，预期是尽可能能用它。也有时候不见得要用。当使用**树的构建**时，从语法树上找到所需的东西。有时，搜索构建出的**语义模型**也可以达成一点。但是要用一些中间存储，就算并不真的需要。

### 12.3 以外部DSL实现的依赖网络（Java和ANTLR）

```
go_to_work -> drink_coffee dress
drink_coffee -> make_coffee wash
dress -> wash
```

`->`左边的任务依赖于右边的任务。“->”左边的任务依赖于右边的任务，用“嵌入式语法翻译”解析这段脚本。希望这些依赖可以按任意顺序编写，返回一个头列表，就是不为其他任务所依赖的任务。这是一个很好的例子，可以说明用符号表跟踪任务是值得的。

例子：一个loader类封装ANTLR解析器：它会从reader中获取输入：

```java
class TaskLoader...
    private Reader input;
    public TaskLoader(Reader input) {
        this.input = input;
    }
    public void run() {
        try {
            TaskersLexer lexer = new TaskLexer(new ANTLRReaderStream(input));
            TasksParser parser = new TasksParser(new CommonTokenStream(lexer));
            parser.helper = this;
            parser.network();
        }
        catch (IOException e) {
            throw new RuntimeException(e);
        }
        catch (RecognitionException e) {
            throw new RuntimeException(e);
        }
    }
```

loader类把自己作为“嵌入助手”插入生成的解析器中。其所做的一件事就是提供符号表，也就是一个任务名和任务的简单map：

```java
class TaskLoader {
    private Map<String, Task> tasks = new HashMap<>();
} 
```

这个DSL的文法极其简单，如下所示：

```dsl
grammer file...
    network : SEP ? dependency (SEP dependency) * SEP ?;
    dependenfy
        : lhs = ID '->' rhs += ID+
          {helper.recognizedDependenc($lhs, $rhs);}
        ;
```

这个助手还有一段处理可识别依赖关系的代码。为了将任务连接在一起，它会组装和使用符号表：

```java
class TaskLoader {
    public void recognizedDependency(Token consequent, List dependencies) {
        registerTask(consequent.getText());
        Task consequentTask = tasks.get(consequent.getText());
        for (Object o : dependencies) {
            String taskName = ((Token)o).getText();
            registerTask(taskName);
            consequentTask.addPrerequisite(tasks.get(taskName));
        }
    }

    private void registerTask(String name) {
        if (!tasks.containsKey(name)) {
            tasks.put(name, new Task(name));
        }
    }
}
```

一旦运行完loader，就可以通过它通过得到图的所有头。

```java
class TaskLoader {
    public List<Task> getResult() {
        for (Task t : tasks.values())
            if (!taskUsedAsPrerequisites().contains(t))
                result.add(t);
        return result;
    }

    public Set<Task> tasksUsedAsPrerequisites() {
        Set<Task> result = new HashSet<Task>();
        for (Task t : tasks.values())
            for (Task preReq : t.getPrerequisites())
                result.add(preReg);
        return result;
    }
}
```

### 12.4 在一个内部DSL中使用符号键（Ruby）

符号表来自解析领域，但对内部DSL同样有用。下面是一个简单的DSL脚本，描述了早餐任务及其前置条件：

```dsl
task :go_to_work => [:drink_coffee, :dress]
task :drink_coffee => [:make_coffee, :wash]
task :dress => [:wash]
```

在DSL中，每个任务都可以通过Ruby的符号数据类型引用。任务列表用“函数序列”声明，每个任务的细节用**Literal Map**来展示。

**语义模型**描述起来很简单，就是一个任务类。

```ruby
class Task
    attr_reader : name
    attr_accessor : prerequisites

    def initialize name, *prereqs
        @name = name
        @prerequisites = prereqs
    end

    def to_s    
        name
    end
end
```

DSL脚本由**表达式生成器**负责读取，用到了**对象范围**和instance_eval

```ruby
class TaskBuilder
    def load aStream
        instance_eval aStream
        return self
    end
```

符号表就是个简单的字典

```ruby
class TaskBuilder
    def initialize
        @task = {}
    end
```

任务子句以一个哈希表作为实参，用于组装任务信息。

```ruby
class TaskBuilder...
    def task argMap
        raise "syntax error" if argMap.keys.size != 1
        key = argMap.keys[0]
        newTask = obtain_task(key)
        prereqs = argMap[key].map{|s| obtain_task(s)}
        newTask.prerequistes = prereqs
    end
    def obtain_task aSymbol
        @task[aSymbol] = Task.new(aSymbol.to_s) unless @task[aSymbol]
        return @task[aSymbol]
    end
end
```

用符号实现的符号表和使用字符串作为标志符是一样的。然而，如果支持的话，请使用符号。

### 12.5 用枚举作为静态类型符号（Java）

```java
public enum TaskName {
    wash, dress, make_coffee, drink_coffee, go_to_work
}
```

任务依赖可以这样定义：

```dsl
builder = new TaskBuilder() {{
    task(wash);
    task(dress).needs(wash);
    task(make_coffee);
    task(drink_coffee).needs(make_coffee, wash);
    task(go_to_work).needs(drink_coffee, dress);
}};
```

借助枚举的方式很简单，而且不会强迫使用继承，或者在编写DSL脚本代码时有所限制，并且时优于“类符号表”的地方。

使用这种方法，如果这些符号对应于一些外部数据源，那么应该有一个步骤，读取外部数据源，用代码生成枚举声明，这样没所有一切就可以保持同步。

这样实现的后果时，所有的符号都在一个命名空间。对于多个脚本需要共享同一套符号的情况，这没什么问题，但有时候，希望不同的脚本可以使用不同的符号。

假设有两套任务，一套用于早晨的任务，另一套用于铲雪。当完成早晨的任务时，希望IDE只把它们提供给我；对于铲雪任务，也是一样的道理。实现的方法是：根据接口来定义任务生成器，然后，让枚举实现这个接口。

```java
public interface TaskName {}

class TaskBuilder {
    PrerequisiteClause task(TaskName name) {
        registerTask(name);
        return new PrerequisiteClause(this, tasks.get(name));
    }
    private void registerTask(TaskName name) {
        if (!task.containsKey(name)) {
            tasks.put(name, new Task(name.toString()));
        }
    }
    private Map<TaskName, Task> tasks = new HashMap<TaskName, Task>();
}
```

然后，定义一些枚举，根据特定的任务使用特定的枚举，选择性地导入所需的枚举即可。

```java
import static path.io.ShovelTasks.*;

enum ShoveTasks implements TaskName {
    shobel_path, shobel_drive, shovel_sidewalk, make_out_chocolate
}

builder = new TaskBuilder() {{
    task(shovel_path);
    task(shovel_drive).needs(shovel_path);
    task(shovel_sidewalk);
    task(make_hot_chocolate).needs(shovel_drive, shovel_sidewalk);
}}
```

如果要进行更多的静态类型控制，可以创建一个通用版本的任务生成器，检查其是否使用了正确的TaskName子类型。但是，如果主要感兴趣的是良好的IDE可用性，那么选择导入恰当的枚举，这就够了。

## 第13章 语境变量

### 13.1 工作原理

在解析过程中，如果使用一个命名类似于currentItem的变量，在处理输入脚本时，随着从一个对象移到下一个对象，就要定期更新这个变量，那就是在使用语境变量。

**语境变量**可能是一个**语义模型**，也可能是一个生成器对象。语义模型是一个非常直白的选择，但是有这个前提，所有的属性都要是可变的，这样在需要的时候，解析器才能修改。如果不是这样，通常来说，最好使用某种形式的生成器，用来搜集信息，当完成时创建语义模型，比如“构造器生成器”(第14章)。

### 13.2 使用场景

在解析过程中，有很多地方要保存语境，这时候语境变量就是一个显而易见的选择了，易于创建也易于使用。

然而，如果需要很多语境变量，那也是有问题的。因为从其本性来说，它们是可变状态的，而这些状态是必须跟踪的。

## 第14章 构造器生成器

### 14.1 工作原理

构造型生成器的基本做法很简单。假设要逐步创建一个不可变对象，称为产品。找出产品构造函数的实参，为每一个实参创建一个字段。对于要搜集产品的其他属性，也添加一些字段。最后，添加一个创建方法，返回一个由构造型生成器中所有数据组成的产品对象。

或许，还要在构造型生成器中添加一些生命周期控制，这种控制可能检查是否信息已足够创建产品。可能要设置一个标记，保证已返回的产品不会再返回，或者把已创建的产品放到一个字段里。可能是在创建了产品后，如果尝试给构造型生成器添加属性，就抛出异常。

多个构造型生成器可以深度组合在一起。可以产生一组相关联的对象，而不只是一个对象。

### 14.2 使用场景

有时，要创建一个对象，其中有多个不变字段，而且这些字段的值只能逐渐搜集，这时，构造型生成器就大显身手了。在实际创建这个产品之前，构造型生成器提供了一个存放所有数据的地方。

构造型生成器最简单的一个做法，把信息存放在局部变量，或者没有什么目的的字段中。如果只有一两个产品，这种做法还能运转良好，但如果要一次创建一堆对象，就像解析这种情况，那很快就会带来困惑。

还有一种做法，创建一个实际的模型对象，但是在搜集一项不可变属性的数据之后，就创建模型对象的一个副本，其中的属性已经更改了，替换掉了旧值。这样，避免了编写构造型生成器，但是，通常来说，这并不是很好的做法。尤其是，如果有多个对象引用，这种做法就不起作用了，或者，至少在必须替换每个引用时，这种做法就很麻烦。

要处理此类问题，最佳方式当属构造型生成器，但请记住，只有在处理不可变字段时才会用到它。如果不是这样，那就直接创建产品对象。

## 第15章 宏

### 15.1 工作原理

在程序设计语言构建抽象方面，宏是最古老的技术之一。宏主要分为文本宏和语法宏。文本宏就是把文本当做文本。语法宏理解宿主语言和语法结构，这样，保证其操作的文本单元在语法上是正确的，产生的结果也是语法有效的，就会容易一些。文本宏处理器可以操作任何语言，只要是文本形式的。语法宏处理器只是为一种语言设计的，通常，它就是为这种语言打造的工具，甚至本省就在语言规范中。

#### 文本宏

多数现代语言不支持文本宏，宏处理最简单的形式是，用一个字符串替换另外一个。宏和函数调用的区别是，宏是在预编译期执行的，可以省去函数调用的开销。

#### 语法宏

在C++中语法宏就是模版。对于C++来说，比较复杂，不鼓励内部DSL的使用。语法宏确实有一些强大的能力，在Lisp中，多数甚至绝大多数宏，都是在处理“闭包”时打磨语法的。

### 15.2 使用场景

文本宏的问题很多，错误展开，变量捕获，多次执行诡异bug等，并且难以跟踪和调试。除了非常简单的场景，不推荐使用文本宏。而是否使用语法宏，主要取决于语言环境。

## 第16章 通知

通知是收集错误信息的对象。当校验失败时，会添加一条错误信息到通知中：当校验完成后，返回通知。通过通知，可以知道是否一切正常，如果有错误，还可以深入到错误中。

### 16.1 工作原理

通知的基本形式是一个由错误组成的集合。当执行具体任务时，要能够把错误信息加入通知中。简单的形式是一个错误消息的字符串；复杂的形式是一个错误对象。当任务完成时，返回给调用者。调用者通过简单的布尔查询了解是否一切正常。如果有错误，查询通知获取进一步的信息。

虽然通知的主要目的是收集错误信息，但它也可以用来捕捉警告和其他信息。错误表示执行的命令中有错误，警告则表示，虽未失败，但调用者仍可能会担心的问题。在很多方面，通知和日志文件的行为非常相似，所以日志系统中许多常见的特性在这里一样有用。

### 16.2 使用场景

有时候，复杂的操作可能会触发多个错误，而不希望程序在第一个错误发生时就失败，通知就是一种很管用的做法。一个通知可以保存多个异常，给调用者以更加完整的错误反馈。

通知在一种情况下特别有用，就是UI触发某个底层操作的时候。因为底层最好不要直接与UI交互，所以，通知变成了UI和底层之前的信使。

### 16.3 一个非常简单的通知（C#）

```cs
class Notification {
    List<string> errors = new List<string>();
    public void AddError(string s, params object[] args) {
        errors.Add(string.Format(s, args));
    }

    public bool IsOK {
        get {
            return 0 == errors.Count;
        }
    }

    public bool HasErrors {
        get {
            return IsOK;
        }
    }

    public void AssertOK() {
        if (HasErrors) 
            throw new ValidationException(this);
    }
}
```

# 第三部分

## 第17章 分隔符指导翻译

### 17.1 工作原理

分隔符指导翻译的工作原理是在获取输入后，基于分隔符将其分解成小块。可以使用任何字符作为分隔字符，但是最常用的分隔符是行尾符。

把脚本分解成行通常相当简单，因为多数编程环境都有程序类库，一次一行地读取输入流。还可以使用续行符，表示不同行之间是同一行。

```
score 300 for 3 nights at Bree
score 200 for 2 nights at Dol
score 150 for 2 nights at Orthanc
```

每一行都是称作是自洽的，因为任何一行都不会影响其他行。可以重新排列甚至删除任何行而不会影响解释其他行。它们形式相同,因为每一行编码同种类的消息。所以处理起来相当简单，对每一行执行相同的行处理函数，函数会找到需要的信息，并转换为需要的表达方式。如果使用**嵌入式语法翻译**，意味着把它放入**语义模型**。如果使用**树的构建**，意味着创建一个抽象的语法树。很少见到在分隔符指导翻译时使用树的构建。

如何找出需要的信息依赖于语言中字符串处理的能力，以及需要处理的行的复杂度。在可能的情况下，最简单的方式是使用字符串分隔函数。大多数字符串类库都有这样的函数，可以通过分隔字符把字符串分隔成多个元素。

有时字符串的分解方式不会很清晰，最好的方式是使用**正则表达式**，可以在正则表达式中使用分组来提取需要的字符。正则表达式比分隔符字符串强大的多，

使用分隔符指导翻译处理飞自洽的语句会更加复杂，因为必须保留解析的一些状态信息。一个例子就是状态机，解决这个问题的好办法是，对解析的每种状态有一组不同的解析器。于是状态机解析器有一个顶层的行解析器，并对命令块，事件块，重置事件块和状态块有进一步的行解析器。

### 17.2 使用场景
 
分隔符指导翻译的最大优点是非常简单易用。它的主要替代方案，“语法指导翻译”，需要客服一定的学习曲线才能理解如何使用语法。

这种方法的缺点是难以处理更复杂的语言。因此，只有当面对简单的自洽语句，或者只有一个嵌套上下文时，建议选择分隔符指导翻译。

### 17.3 常客记分（C#）

#### 语义模型

DSL如下：

```dsl
300 for stay 3 nights at Bree
150 per day for stay 2 nights at Bree
50 for spa treatment at Dol Amroth
60 for stay 1 night at Otthanc or Helm's Deep or Dunharrow
1 per dollar for dinner at Bree
```

脚本的每一行代表一行奖励。奖励的主要职责是记录常客活动的基本。活动用来简单地描述数据：

```cs
class Activity {
    public string Type {get;set;}
    public int Amount {get;set;}
    public int Revenue {get;set;}
    public string Location {get;set;}
}
```

奖励包括三个组件，`LocationSpecification`查看活动发生的地方是否合适；活动规范查看活动是否值得奖励；如果这两个规范都满足，Reward对象计算分数。

这三个组件中最简单的是位置规范。只需要检查酒店的名称是否包含在已有的酒店列表中：

```cs
class LocationSpecification {
    private readonly IList<Hotel> hotels = new List<Hotel>();

    public LocationSpecification(params String[] names) {
        foreach (string n in names) {
            hotels.Add(Repository.HotelNamed(n));
        }
    }

    public bool IsSatisfiedBy(Activity a) {
        Hotel hotel = Repository.HotelNamed(a.Location);
        return hotels.Contains(hotel);
    }
}
```

这里需要两种类型的活动规范。一个活动规范肩擦好保持的事件不能少于规定的时间。

```cs
abstract class ActivitySpecification {
    public abstract bool isStatisfiedBy(Activity a);
}

class MinimumNightStayActivitySpec : ActivitySpecification {
    private readonly int minimumNumberOfNights;

    public MinimumNightStayActivitySpec(int numberOfNights) {
        this.minimumNumberOfNights = numberOfNights;
    }
    
    public override bool isStatisfiedBy(Activity a) {
        return a.Type == "stay" 
            ? a.Amount >= minimumNumberOfNights
            : false;
    } 
}
```

第二个活动规范检查活动的类型必须正确

```cs
class TypeActivitySpec : ActivitySpecification {
    private readonly string type;

    public TypeActivitySpec(string type) {
        type = type;
    }

    public override bool isStatisfiedBy(Activity a) {
        return a.Type == type;
    } 
}
```

Reward类根据不同的基准保存积分

```cs
class Reward {
    protected int points;
    public Reward(int points) {
        this.points = points
    }
    virtual public int Score (Activity activity) {
        return points;
    }
}

class RewardPerDay : Reward {
    public RewardPerDay(int points) : base(points) {}

    public override int Score (Activity activity) {
        if (activity.TYpe != "stay")
            throw new ArgumentException("can only use per day scores on stays");
        return activity.Amount * points;
    }
}

class RewardPerDollar : Reward {
    public RewardPerDollar(int points) : base(points) {}

    public override int Score (Activity activity) {
        return activity.Revenue * points;
    }
}
```

#### 解析器

解析器的基本结构是读取每一行输入并处理。这个例子，支持使用`&`作为续航符。一个简单的递归函数就可以工作。当解析行时，首先去除注释，忽略空行。完成以后，开始正确解析，把解析工作委托给一个新的对象：

```cs
class OffsetScriptParser {
    readonly TextReader input;
    readonly List<Offer> result = new List<Offer>();
    public OffsetScriptParser(TextReader input) {
        this.input = input;
    }
    public List<Offer> Run() {
        string line;
        while ((line = input.ReadLine()) != null) {
            line = appendCoutinuingLine(line);
            parseLine(line);
        }
        return result;
    }
    string appendCoutinuingLine(string line) {
        if (IsContinueLine(line)) {
            var first = Regex.Replace(line, @"&\s*$", "");
            var next = input.ReadLine();
            if (null == next) 
                throw;
            return first.Trim() + " " + appendCoutinuingLine(next);
        }
        return line.Trim();
    }
    bool IsContinueLine(string line) {
        return Regex.IsMatch(line, @"&\s*$");
    }
    void ParseLine(string line) {
        line = removeComment(line);
        if (IsEmpty(line))
            return;
        result.Add(new OffsetLineParser().Parse(line.Trim()))
    }
    bool IsEmpty(string line) {
        return Regex.IsMatch(line, @"^\s*$");
    }
    string removeComment(string line) {
        return Regex.IsMatch(line, @"#.*", "");
    }
}
```

基本的解析方法把行分解成子句，并对每个子句调用不同的解析函数。这个方法的核心行为是把正则表达式分解成组，然后分组解析后映射到结果中。在组的定义和使用上有很强的语义关联。

```cs
class OffsetLineParser {
    public Offer Parse(string line) {
        var result = new Offer();

        const string rewardRegexp = @"?<reward>.*";
        const string activityRegexp = @"?<activity>.*";
        const string locationRegexp = @"?<location>.*";

        var source = rewardRegexp + keywordToken("for") + 
            activityRegexp + keywordToken("at") + locationRegexp;

        var m = new Regex(source).Match(line);

        result.Reward = parseReward(m.Groups["reward"].Value);
        result.Location = parseLocation(m.Groups["location"].Value);
        result.Activity = parseActivity(m.Groups["activity"].Value);
    }
    string keywordToken(string keyword) {
        return @"\s+" + keyword + @"\s+";
    }
    LocationSpecification parseLocation(string input) {
        if (Regex.IsMatch(input, @"\bor\b"))
            return parseMultipleHotels(input);
        return new LocationSpecification(input);
    }
    ActivitySpecification parseActivity(string input) {
        if (input.StartWith("stay"))
            return parseStayActivity(input);
        return new TypeActivitySpec(input);
    }
    LocationSpecification parseMultipleHotels(string input) {
        string[] hotelNames = Regex.Split(input, @"\s+or+\s+");
        return new LocationSpecification(hotelNames);
    }
    ActivitySpecification parseStayActivity(input) {
        const string stayKeyword = @"^stay\s+";
        const string nightsKeyword = @"\s+nights?$";
        const string amount = @"(?<amount>\d+)";
        const string source = stayKeyword + amount + nightsKeyword;

        var m = Regex.Match(input, source);
        if (!m.Success) 
            throw;
        return new MinimumNightStayActivitySpec(Int32.Parse(m.Groups["amount"].Value));
    }
    Reward parseReward(string input) {
        if (Regex.IsMatch(input, @"^\d+$"))
            return new Reward(int.Parse(input));
        else if (Regex.IsMatch(input, @"^\d+ per day$"))
            return new RewardPerDay(int.Parse(extractDigits(input)));
        else if (Regex.IsMatch(input, @"^\d+ per dollar$"))
            return new RewardPerDollar(int.Parse(extractDigits(input)));
        throw;
    }
    string extractDigits(string input) {
        return Regex.Match(input, @"^\d+").Value;
    }
}
```

## 第18章 语法指导翻译

计算机语言天生倾向于遵循一种层次化的结构，具有多层的上下文，编写一种文法，描述如何将语言的元素分解为子元素，就可以为这种语言定义合法的语法。

语法指导翻译使用这个文法定义如何创建解析器，解析器可以将输入文本转换成**语法分析树(parse tree)**，语法分析树具有类似于文法规则的结构。

### 18.1 工作原理

文法通常都是以BNF编写的。有了文法，可以更容易理解语言的合法语法是什么样的。使用语法指导翻译，可以让文法更进一步，以此为基础，设计处理这门语言的程序。

几种根据文法进行处理的方式：一种方式是把语言当做规范和实现指南，手写解析器。常见的做法有**递归下降语法解析器**和**解析器组合子**两种。还有一种方式是把语法当做DSL，然后用**解析器生成器**根据文法文件自动构建解析器。对于这个情况，自己无须编写任何解析器的核心代码，所有的代码都是根据文法生成的。

语法固然有用，但是只处理了一部分问题：如何将输入文本转换为语法分析树这个数据结构。但是，几乎总是需要对输入做更多的处理。因此解析器生成器也提供了一些方式，以便在解析器里嵌入进一步的行为，完成诸如组装**语义模型**之类的工作。所以，虽然解析器生成器已经做了很多的事情，但依然可以写一些程序，去做一些很有用的东西。从各个角度来看，解析器生成器都是一个非常精彩的DSL实践的例子。

#### 词法分析器

**词法分析器(lexer)**也叫做**标记解释器(tokenizer)**或**扫描器(scanner)**，它是处理输入文本的第一阶段。词法分析器将输入字符分解成**标记(token)**,标记对输入进行了一个合理的划分。

标记的定义通常采用正则表达式：

```
event-keyword: 'events';
command-keyword: 'commands';
end-keyword: 'end';
identifier: [a-z A-Z 0-9]*
```

比如下面的DSL：

```dsl
events
    dorrClosed D1CL
    drawOpened D2OP
end
```

词法规则将输入转换成一系列标记。

```
[Event-keyword: "events"]
[Identifier: "doorClosed"]
[Identifier: "D1CL"]
[Identifier: "drawOpened"]
[Identifier: "D2OP"]
[End-keyword: "end"]
```

每个标记都是一个有两个根本属性的对象：类型和承载内容(payload)。类型是标记的种类。承载内容是词法分析器匹配出的文本。对于关键字而言，承载内容无所谓，重要的是类型。对于标识符而言，承载内容就很重要了，因为它是数据，在后续的解析中很重要。将词法分析分离出来是有原因的。首先，这会让解析器更简单，因为这样一来，解析器就可以按照标记来编写，而非原始字符。其次，在于效率：将字符归为标记，这种实现不同于直接在解析器中使用字符。

在自动机理论中，词法分析器通常是一个状态机，而解析器是一个下推栈机。因此，这种划分算是一种传统的方式。对词法规则的检查是按顺序进行的，先匹配先算。所以，不能用字符串events做标识符。因为词法分析器会把它识别为关键字。
有些情况下，可以用“可变分词方式”绕过这种做法。

词法分析时，会遇到空白，空格，制表符和换行符。在很多语言里，词法分析器会去掉空白，解析器也就不必处理了，这是同**分隔符指导翻译**的一个巨大差别，而后者把空白是构成结构的关键角色。

如果空白在语义上有作用----比如，换行符表示语句分隔符，或者缩进表示块结构----词法分析器就不能简单地忽略了。相反，必须生成某种标记，表示发生的事情，比如，用换行符表示“以换行作为分隔符”。然而，有些语言采用语法指导翻译进行处理，却故意尝试忽略空白。确实，DSL可以采用任何形式的分隔符，例如状态机就在词法分析器中丢弃所有空白。

词法分析器也常常丢掉注释。即便对于最小的DSL而言，注释也总是有用的，词法分析器可以轻松地去掉这些注释。

标记有`类型`和`承载内容`两个属性。在实践中，会有更多的信息，比如行号、字符位置等。当确定标记时，有时会有一种微调匹配过程的诱惑。比如当上述例子中的事件代码必须是4个字符的序列时，包括大写字母和数字。可以考虑一个特定的标记类型:

```
code: [A-Z 0-9]{4}
```

这个问题在于，会把以4个字母或数字组成的关键字也识别为标识符。

词法分析器处理的三种标记:

* **标点符号**-关键字、运算符或者其他用做组织的构造(括号，语句分隔符;等)。对于标点符号来说，类型是重要的，内容不重要，比如运算符。
* **领域文本**-事物的名字，字面值。比如“数字”或“标识符”或“字符串”
* **可忽略的标记**-空白，换行，注释等。

词法分析器的生成器一般用正则表达式，手写词法分析器会有更大的灵活性，解析器和词法分析器之间的交互也可以更复杂。

有一种特别的“解析器-词法分析器”交互方式可能很有用，就是对词法分析器多模式的支持，允许解析器在模式之间显式切换。通过这种做法，解析器可以在语言某个特定的点上改变标记解释的方式。对于可变分词方式来说很有用。

#### 语法分析器

<!-- DSL看到了第205页-->

#### 产生输出

#### 语义预测

### 18.2 使用场景

## 第19章 BNF

### 19.1 工作原理

### 19.2 使用场景

## 第20章 基于正则表达式表的词法分析器

### 20.1 工作原理

### 20.2 使用场景

## 第21章 递归下降法语法解析器

### 21.1 工作原理

### 21.2 使用场景

### 21.3 递归下降

## 第22章 解析器组合子

### 22.1 工作原理

### 22.2 使用场景

## 第23章 解析器生成器

### 23.1 工作原理

### 23.2 使用场景

### 23.3 Hello World（Java和ANTLR）

#### 编写基本的文法

#### 构建语法分析器

#### 为文法添加代码动作

#### 使用代沟

## 第24章 树的构建

### 24.1 工作原理

### 24.2 使用场景

### 24.3 使用ANTLR的树构建语法（Java和ANTLR）

#### 标记解释

#### 解析

#### 组装语义模型

### 24.4 使用代码动作进行树的构建

## 第25章 嵌入式语法翻译

### 25.1 工作原理

### 25.2 使用场景

## 第26章 内嵌解释器

### 26.1 工作原理

### 26.2 使用场景

### 26.3 计算器

## 第27章 外加代码

### 27.1 工作原理

### 27.2 使用场景

### 27.3 嵌入动态代码

#### 语义模型

#### 语法分析器

## 第28章 可变分词方式

### 28.1 工作原理

#### 字符引用

#### 词法状态

#### 修改标记类型

#### 忽略标记类型

### 28.2 使用场景

## 第29章 嵌套的运算符表达式

### 29.1 工作原理

#### 使用自底向上的语法分析器

#### 自顶向下的语法分析器

### 29.2 使用场景

## 第30章 以换行符作为分隔符

### 30.1 工作原理

### 30.2 使用场景

## 第31章 外部DSL

### 31.1 语法缩进

### 31.2 模块化文法

# 第四部分

## 第32章 表达式生成器

### 32.1 工作原理

### 32.2 使用场景

### 32.3 具有和没有生成器的连贯日历

### 32.4 对于日历使用多个生成器

## 第33章 函数序列

### 33.1 工作序列

### 33.2 使用场景

### 33.3 简单的计算机配置

## 第34章 嵌套函数

### 34.1 工作原理

### 34.2 使用场景

### 34.3 简单计算机配置范例

### 34.4 用标记处理多个不同的参数

### 34.5 针对IDE支持使用子类型标记

### 34.6 使用对象初始化器

### 34.7 周期性事件

## 第35章 方法级联

### 35.1 工作原理

#### 生成器还是值

#### 收尾问题

#### 分层结构

#### 渐进式接口

### 35.2 使用场景

### 35.3 简单的计算机配置范例

### 35.4 带有属性的方法级联

### 35.5 渐进式接口

## 第36章 对象范围

### 36.1 工作原理

### 36.2 使用场景

### 36.3 安全代码

#### 语义模型

#### DSL

### 36.4 使用实例求值

### 36.5 使用实例初始化器

## 第37章 闭包

### 37.1 工作原理

### 37.2 使用场景

## 第38章 嵌套闭包

### 38.1 工作原理

### 38.2 使用场景

### 38.3 用嵌套闭包来包装函数序列

### 38.4 简单的C#示例

### 38.5 使用方法级联

### 38.6 带显式闭包参数的函数序列

### 38.7 采用实例级求值

## 第39章 列表的字面构造

### 39.1 工作原理

### 39.2 使用场景

## 第40章 Literal Map

### 40.1 工作原理

### 40.2 使用场景

### 40.3 使用List和Map表达式计算机的配置信息

### 40.4 演化为Greenspun式

## 第41章 动态接收

### 41.1 工作原理

### 41.2 使用场景

### 41.3 积分-使用方法名解析

#### 模型

#### 生成器

### 41.4 积分-使用方法级联

#### 模型

#### 生成器

## 第42章 标注

### 42.1 工作原理

#### 定义标注

#### 处理标注

### 42.2 使用场景

### 42.3 用于运行时处理的特定语法

### 42.4 使用类方法

### 42.5 动态代码生成

## 第43章 解析树操作

### 43.1 工作原理

### 43.2 使用场景

### 43.3 由C#条件生成IMAP查询

#### 语义模型

#### 以C#构建

#### 退后一步

## 第44章 类符号表

### 44.1 工作原理

### 44.2 使用场景

### 44.3 在静态类型中实现类符号表

## 第45章 本文润色

### 45.1 工作原理

### 45.2 使用场景

### 45.3 使用润色的折扣规则

## 第46章 为字面量提供扩展

### 46.1 工作原理

### 46.2 使用场景

### 46.3 食谱配料

# 第五部分 其他计算模型

## 第47章 适应性模型

### 47.1 工作原理

#### 在适应性模型中使用命令式代码

#### 工具

### 使用场景

## 第48章 决策表

### 48.1 工作原理

### 48.2 使用场景

### 48.3 为一个订单计算费用

#### 模型

#### 解析器

## 第49章 依赖网络

### 49.1 工作原理

### 49.2 使用场景

### 49.3 分析饮料

## 第50章 产生式规则系统

### 50.1 工作原理

#### 链式操作

#### 矛盾推导

#### 规则结构里的模式

### 50.2 使用场景

### 50.3 俱乐部会员校验

#### 模型

#### 解析器

#### 演进DSL

### 50.4 适任资格的规则：扩展俱乐部成员

#### 模型

#### 解析器

## 第51章 状态机

### 51.1 工作原理

### 51.2 使用场景

### 51.3 安全面板控制器

## 第52章 基于转换器的代码生成

### 52.1 工作原理

### 52.2 使用场景

### 52.3 安全面板控制器

## 第53章 模版化的生成器

### 53.1 工作原理

### 53.2 使用场景

### 53.3 生成带有嵌套条件的安全控制面板状态机

## 第54章 嵌入助手

### 54.1 工作原理

### 54.2 使用场景

### 54.3 安全控制面板的状态

### 54.4 助手类应该生成HTML吗

## 第55章 基于模型的代码生成

### 55.1 工作原理

### 55.2 使用场景

### 55.3 安全控制面板的状态机

### 55.4 动态载入状态机

## 第56章 无视类型的代码生成

### 56.1 工作原理

### 56.2 使用场景

### 56.3 使用嵌套条件的安全面板状态机

## 第57章 代沟

### 57.1 工作原理

### 57.2 使用场景

### 57.3 根据数据结构生成类
